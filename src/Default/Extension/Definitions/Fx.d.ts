// Compiled with TypeScript 5.0

// FILE: Fx.d.ts
declare module "Fx" {
    export = Main;
    module Main {
        /**
         * Deferred for native promises.
         * Deferred does not exist in the native promise spec but this is a universially accepted
         * and widely used definition.
         */
        interface Deferred<T> {
            promise: Promise<T>;
            resolve(value?: T | Promise<T>): void;
            reject(reason?: any): void;
        }
        /**
         * Creates a new deferred that uses a native promise.
         *
         * @returns a new instance of Deferred
         */
        const defer: <T>() => Deferred<T>;
        export import forEachKey = MsPortalFx.forEachKey;
        export import getEnvironmentValue = MsPortalFx.getEnvironmentValue;
        export import getUniqueId = MsPortalFx.getUniqueId;
        export import isDevelopmentMode = MsPortalFx.isDevelopmentMode;
        export import isFeatureEnabled = MsPortalFx.isFeatureEnabled;
        export import getFeatureValue = MsPortalFx.getFeatureValue;
        export import require = MsPortalFx.require;
        export import startTimer = MsPortalFx.startTimer;
        interface ToPromiseInterface {
            /**
             * Returns a native promise
             *
             * @param obj Native Promise
             * @returns returns never to force a compile error
             */
            <T>(obj: Promise<T>): never;
            /**
             * Returns a native promise
             *
             * @param obj Q, JQuery or anything that is promise like
             * @returns A native promise that is a proxy of the promise like object
             */
            <T>(obj: PromiseLike<T>): Promise<T>;
        }
        const toPromise: ToPromiseInterface;
        /**
         * Converts a promise factory into a memoized promise.
         * The factory method will be called until a promise is fulfilled.
         * Once a fulfilled promise is available it will be re-used for subsequent callers.
         * While a promise is pending, it will be returned to all concurrent callers.
         * As an example, if the factory method generates a promise that rejects after 5 seconds on the
         * first call, and a fulfilled promise on the second call, callers might observe rejections for
         * the first 5 seconds and will get the fulfilled promise after that.
         *
         * @param callback The function to memoize that return a Q promise
         * @param options Options for memoization that includes a cache factory and error handler.
         * @returns The memoized function call.
         */
        export import memoizePromise = FxImpl.memoizePromise;
    }
}

// FILE: Fx\Ajax.d.ts
declare module "Fx/Ajax" {
    import FxBase = MsPortalFx.Base;
    import Net2 = FxBase.Net2;
    export import HttpStatusCode = Net2.HttpStatusCode;
    interface HttpMethods extends Common.Ajax.BatchHttpMethods {
        TRACE: void;
        OPTIONS: void;
    }
    /**
     * Http methods for ajax calls
     */
    export type HttpMethod = keyof HttpMethods;
    /**
     * Http methods for batch ajax calls
     */
    export type BatchHttpMethod = Common.Ajax.BatchHttpMethod;
    /**
     * The contract of settings input into ajax calls.
     */
    export type NetAjaxSettings<T> = Net2.NetAjaxSettings<T>;
    /**
     * Endpoints used by most extensions.
     */
    export type Endpoints = Common.Ajax.Endpoints;
    /**
     * The settings for the batch call.
     */
    export type BatchSettings = Common.Ajax.BatchSettings;
    /**
     * The contract for the batch settings.
     */
    export type BatchMultipleSettings = Common.Ajax.BatchMultipleSettings;
    /**
     * Response for a request within a batch.
     */
    export type BatchResponseItem<T> = Common.Ajax.BatchResponseItem<T>;
    /**
     * The contract for extended information provided by responses of succeeded ajax calls.
     */
    export type Response<T> = Net2.Response<T>;
    /**
     * Batch response.
     */
    export type BatchResponse = Common.Ajax.BatchResponse;
    /**
     * Individual batch request.
     */
    export type BatchRequest = Common.Ajax.BatchRequest;
    /**
     * The request options.
     */
    export const enum RequestOptions {
        /**
         * Default behavior.
         *    - Defaults to foreground request
         *    - Calls are sent directly to ARM without waiting for other requests
         *    - Any ServerTimeout (503) failures for foreground GET requests
         *      are automatically retried by calling the API directly without batch
         *    - Responses are not cached
         *    - Sending requests without delaying has been observed to improve performance,
         *      so requests no longer wait for other requests before executing
         */
        None = 0,
        /**
         * Make the batch call on the next tick.
         * DebounceNextTick takes precedence over Debounce100Ms.
         */
        DebounceNextTick = 1,
        /**
         * Include the request in a batch call that is made after a 100ms delay.
         * Debounce100Ms takes precedence over DebounceOneMinute
         */
        Debounce100ms = 2,
        /**
         * Sets this request to run in the background.
         * Background requests are batched every 60 seconds.
         */
        DebounceOneMinute = 4,
        /**
         * Forces a retry for any failure returned (statusCode >= 400) regardless of the HTTP method.
         */
        RetryForce = 8,
        /**
         * Skips the default retry.
         * SkipRetry takes precedence over ForceRetry if both are set.
         */
        RetrySkip = 16,
        /**
         * Caches the response for GET requests for 10 seconds.
         */
        ResponseCacheEnabled = 32,
        /**
         * Skips caching the response for GET requests.
         */
        ResponseCacheSkip = 64,
        /**
         * Skips retry when a forbidden gateway error is received.
         */
        RetrySkipOnForbidden = 128,
        /**
         * Sends the request directly to ARM without delaying.
         * DebounceImmediately takes precedence over DebounceNextTick
         */
        DebounceImmediately = 256
    }
    /**
     * Performs an ajax request with the appropriate headers set.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @returns A promise for the ajax call.
     */
    export function postJSON<T>(settings: NetAjaxSettings<T>, data: any): Promise<T>;
    /**
     * Performs an ajax request using caching with the appropriate headers set.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @returns A promise for the ajax call.
     */
    export function ajax<T>(settings: NetAjaxSettings<T>): Promise<T>;
    /**
     * Performs an ajax request using caching with the appropriate headers set and returns the XML Http response.
     *
     * @param settings The settings that are to be passed to the ajax call.
     * @returns A promise for the ajax call.
     */
    export function ajaxExtended<T>(settings: NetAjaxSettings<T>): Promise<Net2.Response<T>>;
    /**
     * Sets the default options that will be used for all requests unless other settings are specified.
     *
     * @param options Request option flags.
     */
    export function initialize(options: {
        requestOptions: RequestOptions.ResponseCacheEnabled | RequestOptions.RetrySkip;
    }): void;
    /**
     * Retrieves commonly-used endpoints.
     *
     * @returns The collection of commonly-used endpoints.
     */
    export const getEndpoints: () => Endpoints;
    /**
     * Calls the API to send a single AJAX request, defaulting to send individuals requests.
     * Setting the batch settings to debounce later will batch this request with other requests.
     *
     * There are a couple of limitations when using this:
     *   - Requests can use absolute or relative ARM endpoint
     *   - Supports tenant level operations (/subscriptions, /resources, /locations, /providers, /tenants)
     *
     * @param settings The settings to use to call batch.
     * @returns A promise for the batch call.
     */
    export function batch<T>(settings: BatchSettings): Promise<BatchResponseItem<T>>;
    /**
     * Performs a batch ajax request using the given set of URIs.
     * This API is recommended if you have a set of URIs that can be called concurrently using batch.
     *
     * @param settings The settings that are to be passed to the batch call.
     * @returns A promise for the batch call.
     */
    export function batchMultiple(settings: BatchMultipleSettings): Promise<BatchResponse>;
    export const DEV: {
        resetAsyncBatchEnabled: () => void;
        resetArmEndpointLower: () => void;
        setArmEndpointLower: (endpoint: string) => void;
    };
    export {};
}

// FILE: Fx\Assets\AssetTypes.d.ts
declare module "Fx/Assets/AssetTypes" {
    import { GetAllAssetTypesOptions } from "Fx/Assets";
    /**
     * The asset type metadata including the resource type metadata.
     */
    export type AssetType = MsPortalFx.Assets.ResourceTypeAssetTypeInformation;
    /**
     * The asset type metadata with optional browse manifest data.
     */
    export type AssetTypeWithBrowseManifest = AssetType & {
        browseManifest?: Common.Assets.BrowseManifest;
    };
    /**
     * Gets all the asset types defined across all portal extension.
     * Official exported function to retrieve the metadata for all the asset types.
     *
     * @param options Optional options for the call.
     * @returns A promise that resolves to an array with metadata for each asset type.
     */
    export function getAllAssetTypes(options?: GetAllAssetTypesOptions): Promise<AssetTypeWithBrowseManifest[]>;
}

// FILE: Fx\Assets\Assets.d.ts
declare module "Fx/Assets/Assets" {
    import FxAssets = MsPortalFx.Assets;
    /**
     * Finds the asset type information for the given resource type from the collection of asset types.
     * NOTE: The asset types must come from the API MsPortalFx.Assets.getResourceTypeAssetTypeInformation().
     *
     * @deprecated Fx.Assets.findAssetTypeInformation 04/30/2020 - No longer supported. This is being removed, use the following code in your
     * code (limited use).
     * @param resourceType The resource type to find.
     * @param assetTypes The array of asset type information from the getResourceTypeAssetTypeInformation API.
     * @returns The result asset type information if found, otherwise undefined.
     */
    export function findAssetTypeInformation<T extends FxAssets.ResourceTypeAssetTypeInformation>(resourceType: string, assetTypes: T[]): Obsolete;
    /**
     * Finds the asset type information for the given resource ID from the collection of asset types.
     * NOTE: The asset types must come from the API MsPortalFx.Assets.getResourceTypeAssetTypeInformation().
     *
     * @deprecated Fx.Assets.findAssetTypeInformationFromResourceId 04/30/2020 - No longer supported. This is being removed, use the following code in your
     * code (limited use).
     * @param resourceID The resource ID for the resource type to find.
     * @param assetTypes The array of asset type information from the getResourceTypeAssetTypeInformation API.
     * @returns The result asset type information if found, otherwise undefined.
     */
    export function findAssetTypeInformationFromResourceId<T extends FxAssets.ResourceTypeAssetTypeInformation>(resourceId: string, assetTypes: T[]): Obsolete;
}

// FILE: Fx\Assets\Decorators.d.ts
declare module "Fx/Assets/Decorators" {
    import { SvgType } from "Fx/Images";
    export = MsPortalFxForAsset;
    module MsPortalFxForAsset {
        module ForAsset {
            module Commands {
                /**
                 * Command kinds.
                 */
                const enum CommandKind {
                    /**
                     * Kind for the open blade commands.
                     */
                    OpenBladeCommand = 0,
                    /**
                     * Kind for the menu command.
                     */
                    MenuCommand = 1
                }
                /**
                 * Selection Command kinds.
                 */
                const enum SelectionCommandKind {
                    /**
                     * Kind for the open blade commands that require selection.
                     */
                    OpenBladeSelectionCommand = 0,
                    /**
                     * Kind for the ARM commands.
                     */
                    ArmCommand = 1,
                    /**
                     * Kind for the selection based menu command.
                     */
                    MenuSelectionCommand = 2
                }
                /**
                 * Visibility options for selection menu commands.
                 */
                const enum SelectionMenuCommandVisibility {
                    /**
                     * Allows a command to be hidden by default.
                     *
                     * NOTE: This is useful if you are experimenting with command bar layout and wish to only show a command via experimentation.
                     */
                    HiddenByDefault = 16,
                    /**
                     * Allows a command to appear on browse toolbar.
                     */
                    BrowseToolbar = 1,
                    /**
                     * Allows a command to appear on resource hover card.
                     */
                    ResourceHoverCard = 8
                }
                /**
                 * Visibility options for selection commands.
                 */
                const enum SelectionCommandVisibility {
                    /**
                     * Allows a command to be hidden by default.
                     *
                     * NOTE: This is useful if you are experimenting with command bar layout and wish to only show a command via experimentation.
                     */
                    HiddenByDefault = 16,
                    /**
                     * Allows a command to appear on browse toolbar.
                     */
                    BrowseToolbar = 1,
                    /**
                     * Allows a command to appear in browse context menu.
                     *
                     * NOTE: Only selection based commands with minSelection === 1 support this option.
                     *       Menu commands do not support this option.
                     */
                    BrowseContextMenu = 2,
                    /**
                     * Allows a command to appear on resource hover card.
                     */
                    ResourceHoverCard = 8
                }
                /**
                 * Visibility options for non selection commands.
                 */
                const enum NonSelectionCommandVisibility {
                    /**
                     * Allows a command to be hidden by default.
                     *
                     * NOTE: This is useful if you are experimenting with command bar layout and wish to only show a command via experimentation.
                     */
                    HiddenByDefault = 16,
                    /**
                     * Allows a command to appear on browse toolbar.
                     */
                    BrowseToolbar = 1,
                    /**
                     * Allows a command to appear on empty browse view.
                     */
                    BrowseEmptyView = 4,
                    /**
                     * Allows a command to replace default "create" button on a service hover card.
                     *
                     * NOTE: Only one command with this flag is supported per asset type.
                     */
                    ServiceHoverCard = 32
                }
                /**
                 * Defines the options that are passed to the command decorator.
                 */
                interface CommandOptions {
                    /**
                     * The asset type that the commands are associated with.
                     */
                    readonly assetType: string;
                    /**
                     * The list of commands which do no require resource selection.
                     */
                    readonly commands?: ReadonlyArray<Command>;
                    /**
                     * The list of commands which require selection.
                     */
                    readonly selectionCommands?: ReadonlyArray<SelectionCommand>;
                }
                /**
                 * Constrains the @ForAsset.Commands decorator so that it can be applied only to classes implementing 'Contract'.
                 */
                interface Contract {
                }
                /**
                 * Constrains the @Commands decorator so that it can be applied only to classes implementing 'Contract'.
                 */
                interface CommandsClass {
                    new (...args: any[]): Contract;
                }
                /**
                 * Decorator for Asset commands
                 *
                 * @param options command options
                 */
                function Decorator(options?: CommandOptions): (commandsClass: CommandsClass) => void;
                /**
                 * The blade reference options for open blade command.
                 */
                interface BladeReference {
                    /**
                     * The blade name.
                     */
                    readonly blade: string;
                    /**
                     * The flag indicating whether blade supports provisioning or not.
                     * Defaults to false.
                     */
                    readonly doesProvisioning?: boolean;
                    /**
                     * The extension name for the blade
                     */
                    readonly extension?: string;
                    /**
                     * The flag indicating whether blade needs to be opened as a context pane.
                     * Defaults to false.
                     */
                    readonly inContextPane?: boolean;
                    /**
                     * The blade parameters.
                     *
                     * NOTE: Blades that require list of resourceIds in the parameters, should specify {resourceIds} as the parameter value.
                     * Fx will replace the {resourceIds} value with currently selected resource Ids at runtime.
                     */
                    readonly parameters?: ReadonlyStringMap<any>;
                }
                /**
                 * The marketplace blade reference
                 */
                interface MarketplaceBladeReference {
                    /**
                     * The marketplaceItemId to open a create flow.
                     */
                    readonly marketplaceItemId?: string;
                }
                /**
                 * Interface for Open blade commands.
                 */
                interface OpenBladeCommand extends CommonCommandBase<CommandKind.OpenBladeCommand> {
                    /**
                     * The blade reference.
                     * Either a reference to the blade or the marketpkace item id which opens the create flow needs to be specified.
                     */
                    readonly bladeReference: BladeReference | MarketplaceBladeReference;
                }
                /**
                 * The interface for resource selection for commands.
                 */
                interface RequiresSelection {
                    /**
                     * The resource selection for commands.
                     * Default selection is max allowed selection supported by browse grid.
                     */
                    readonly selection?: Selection;
                }
                /**
                 * The interface for command execution confirmation options.
                 */
                interface ConfirmationOptions {
                    /**
                     * The confirmation dialog title to show before execution of the command.
                     */
                    readonly title: string;
                    /**
                     * The confirmation dialog message to show before execution of the bulk command.
                     */
                    readonly message: string;
                    /**
                     * The confirmation text input.
                     * User needs to enter this text in order to confirm command execution.
                     */
                    readonly explicitConfirmationText?: string;
                }
                /**
                 * The interface for commands that require user confirmation.
                 */
                interface ConfirmationCommandBase {
                    /**
                     * The command execution confirmation options.
                     */
                    readonly confirmation: ConfirmationOptions;
                }
                /**
                 * The interface for ARM command definition.
                 */
                interface ArmCommandDefinition {
                    /**
                     * Http method POST/DELETE/PATCH etc. By default POST will be used.
                     */
                    readonly httpMethodType?: string;
                    /**
                     * ARM uri for the command operation.
                     * Uri should be a relative uri with the fixed format - {resourceid}/optionalOperationName?api-version.
                     * Example: "{resourceid}?api-version=2018-09-01-preview
                     */
                    readonly uri: string;
                    /**
                     * ARM command operation can be long running operation. asyncOperation property specifies how to poll the status for completion of long running operation.
                     */
                    readonly asyncOperation?: AsyncOperationOptions;
                    /**
                     * Optional list of resource-specific ARM error codes that should be retried for HttpStatusCode.BadRequest(400).
                     *
                     * By default, Fx retries below codes:
                     *     Retry for transient errors with Http status codes: HttpStatusCode.InternalServerError(500), HttpStatusCode.BadGateway(502), HttpStatusCode.ServiceUnavailable(503), HttpStatusCode.GatewayTimeout(504)
                     *     Retry for ARM conflict/throttle errors with status codes: HttpStatusCode.TooManyRequests(409), HttpStatusCode.Conflict(429)
                     * In addition to these, there could be resource-specific errors that need to be retried for HttpStatusCode.BadRequest(400).
                     * If this list is specified, Fx will parse ARM error codes for HttpStatusCode.BadRequest(400) requests and retry in addition to above retries.
                     *
                     * Example: ["PublicIpAddressCannotBeDeleted", "InuseNetworkSecurityGroupCannotBeDeleted"]
                     */
                    readonly retryableArmCodes?: ReadonlyArray<string>;
                    /**
                     * Optional list of resource-specific ARM error codes that shouldn't be retried.
                     * This helps optimize network calls and improve bulk operation performance.
                     *
                     * By default, Fx won't issue retry for below code regardless of HTTP status code:
                     *    "ScopeLocked"
                     * In addition to this Arm error code, there could be resource-specific error codes that shouldn't be retried.
                     * If this list is specified, Fx will ignore the above mentioned list and only honor this list of Arm codes that shouldn't be retried.
                     *
                     * Example: ["ScopeLocked"]
                     */
                    readonly nonRetryableArmCodes?: ReadonlyArray<string>;
                }
                /**
                 * Optional Arm command configs to describe how long running ARM operations needs to be polled and results processed.
                 */
                interface AsyncOperationOptions {
                    /**
                     * By default when http Accepted (202) status code is received, the Location header will be looked up for polling uri to get the status of long running operation.
                     * A different response header can be specified with the pollingHeaderOverride value.
                     */
                    readonly pollingHeaderOverride?: string;
                    /**
                     * A property path to look for status in the response body.
                     * By default 'status' property will be looked up to see if it has "Succeeded", "Failed", "InProgress" or "Canceled".
                     */
                    readonly statusPath?: string;
                }
                /**
                 * The interface for ARM commands.
                 * These commands honor default selection which is FullPage.
                 */
                interface ArmCommand extends CommonCommandBase<SelectionCommandKind.ArmCommand>, ConfirmationCommandBase {
                    /**
                     * The map of ARM bulk command definitions per resource type.
                     *
                     * NOTE: A command may delete multiple types of resources e.g. browse for merged resource types.
                     * In such cases, ARM command definition can be specified for each resource type.
                     */
                    readonly definitions: ReadonlyStringMap<ArmCommandDefinition>;
                    /**
                     * The flag indicating whether to launch Fx bulk delete confirmation blade for delete operations.
                     */
                    readonly isDelete?: boolean;
                }
                /**
                 * The interface for open blade commands that require resource selection.
                 */
                interface OpenBladeSelectionCommand extends CommonCommandBase<SelectionCommandKind.OpenBladeSelectionCommand>, RequiresSelection {
                    /**
                     * The blade reference.
                     */
                    readonly bladeReference: BladeReference;
                }
                /**
                 * The interface for menu command item display customizations.
                 */
                interface MenuItemCustomCommandOptions {
                    /**
                     * The command content.
                     *
                     * Customizes rendering of menu command item @see `Toolbar.ToolbarItems.MenuItemCustomButtonOptions` for more details.
                     */
                    readonly content?: string;
                }
                /**
                 * The interface for commands to specify visibility options.
                 *
                 * NOTE: Only applies to top level commands. i.e. Individual items in menu commands can't specify visibility options.
                 */
                interface SelectionCommandVisibilityOptions {
                    /**
                     * The command visibility options.
                     * Specify one or more options in the format: `SelectionCommandVisibility.BrowseToolbar | SelectionCommandVisibility.BrowseContextMenu`.
                     */
                    readonly visibility?: SelectionCommandVisibility;
                }
                /**
                 * The interface for commands to specify visibility options.
                 *
                 * NOTE: Only applies to top level commands. i.e. Individual items in menu commands can't specify visibility options.
                 */
                interface NonSelectionCommandVisibilityOptions {
                    /**
                     * The command visibility options.
                     * Specify one or more options in the format: `NonSelectionCommandVisibility.BrowseToolbar | NonSelectionCommandVisibility.BrowseEmptyView`.
                     */
                    readonly visibility?: NonSelectionCommandVisibility;
                }
                /**
                 * The interface for commands to specify visibility options.
                 *
                 * NOTE: Only applies to top level commands. i.e. Individual items in menu commands can't specify visibility options.
                 */
                interface SelectionMenuCommandVisibilityOptions {
                    /**
                     * The command visibility options.
                     */
                    readonly visibility?: SelectionMenuCommandVisibility;
                }
                /**
                 * The interface for selection based menu command.
                 */
                interface MenuSelectionCommand extends CommonCommandBase<SelectionCommandKind.MenuSelectionCommand>, RequiresSelection {
                    /**
                     * The list of commands.
                     */
                    readonly commands: ReadonlyArray<OpenBladeSelectionCommand & MenuItemCustomCommandOptions | ArmCommand>;
                }
                /**
                 * The interface for menu command.
                 */
                interface MenuCommand extends CommonCommandBase<CommandKind.MenuCommand> {
                    /**
                     * The list of commands.
                     */
                    readonly commands: ReadonlyArray<OpenBladeCommand & MenuItemCustomCommandOptions>;
                }
                /**
                 * The interface for commands that require resource selection.
                 */
                type SelectionCommand = OpenBladeSelectionCommand & SelectionCommandVisibilityOptions | ArmCommand & SelectionCommandVisibilityOptions | MenuSelectionCommand & SelectionMenuCommandVisibilityOptions;
                /**
                 * The interface for command.
                 */
                type Command = OpenBladeCommand & NonSelectionCommandVisibilityOptions | MenuCommand & NonSelectionCommandVisibilityOptions;
                /**
                 * The interface for command selection.
                 */
                interface Selection {
                    /**
                     * The maximum number of selected resources supported by the command operation.
                     */
                    readonly maxSelectedItems?: number;
                    /**
                     * The minimum number of selected resources supported by the command operation.
                     */
                    readonly minSelectedItems?: number;
                    /**
                     * The message shown when user tries to select more than supported items by the command operation.
                     */
                    readonly disabledMessage: string;
                }
                /**
                 * The interface for common command properties.
                 */
                interface CommonCommandBase<TKind extends CommandKind | SelectionCommandKind> {
                    /**
                     * The command kind.
                     */
                    readonly kind: TKind;
                    /**
                     * The command Id.
                     */
                    readonly id: string;
                    /**
                     * The command label.
                     */
                    readonly label: string;
                    /**
                     * The command icon.
                     */
                    readonly icon: ({
                        /**
                         * URI to the image element.
                         */
                        path: string;
                    } | {
                        /**
                         * References a built-in SVG element.
                         */
                        image: SvgType;
                    });
                    /**
                     * The command tooltip.
                     */
                    readonly tooltip?: string;
                    /**
                     * The command aria label.
                     */
                    readonly ariaLabel?: string;
                }
            }
        }
    }
}

// FILE: Fx\ClientIp.d.ts
declare module "Fx/ClientIp" {
    /**
     * Gets the IPv4 address of the client.
     *
     * @returns The promise for the IP address.
     */
    const _default: () => Promise<string>;
    export = _default;
}

// FILE: Fx\Composition.d.ts
declare module "Fx/Composition" {
    import FxSelectable2 = FxImpl.Composition.Selectable;
    export import PdlBladeCallbacks = FxSelectable2.PdlBladeCallbacks;
    export import BladeReference = FxSelectable2.BladeReference;
    export import PartReference = MsPortalFx.Composition.PartReference;
    export import BladeClosedReason = FxImpl.CompositionCore.BladeClosedReason;
    export import BladeClosedHandler = FxImpl.CompositionCore.BladeClosedHandler;
    export import BladeClosedWithDataHandler = FxImpl.CompositionCore.BladeClosedWithDataHandler;
    export import OperationOptions = FxImpl.CompositionCore.OperationOptions;
    export import ShieldType = FxImpl.CompositionCore.ShieldType;
    export import OperationList = FxImpl.CompositionCore.OperationList;
    /**
     * A view model used by fxclick and controls to display a URI link.
     * Supports right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     */
    export import ClickableLink = FxImpl.CompositionCore.ClickableLink;
    /**
     * A view model used by fxclick and controls to display a link to a blade.
     * Supports right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     */
    export import BladeLink = FxImpl.CompositionCore.BladeLink;
    /**
     * A view model used by fxclick and controls to display a link to a resource.
     * Supports right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     */
    export import ResourceLink = FxImpl.CompositionCore.ResourceLink;
    /**
     * A reference to a DOM element in the portal
     */
    export interface FxElement {
        _fxSignature: void;
    }
    /**
     * Information describing a event generated by a mouse action
     */
    export interface FxMouseEvent {
        /**
         * A reference to the DOM element that was clicked
         */
        readonly target: FxElement;
    }
    /**
     * A callback used by fxclick and controls to display a custom link.
     * Only use for exceptional cases where you do not require browser behaviors like
     * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     * Use BladeLink, ClickableLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
     * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
     */
    export type OnClickHandler = (evt: FxMouseEvent) => void;
    /**
     * Provides access to all the Blade reference factories that are exported by a given extension.
     */
    export interface ImportedBladeReferenceFactoriesRegistry<TExtensionName extends keyof ImportedBladeReferenceFactories> {
        /**
         * Gets the Blade reference factory for a blade in the specified extension.
         */
        forBlade<TBladeName extends keyof ImportedBladeReferenceFactories[TExtensionName]["Blades"]>(bladeName: TBladeName): ImportedBladeReferenceFactories[TExtensionName]["Blades"][TBladeName];
        /**
         * Gets the menu blade reference factory for a menu blade in the current extension
         */
        forMenuBlade<TMenuBladeName extends keyof ImportedBladeReferenceFactories[TExtensionName]["MenuBlades"]>(blade: TMenuBladeName, menuId: string, contentMenuBladeReference?: BladeReference<any>): ImportedBladeReferenceFactories[TExtensionName]["MenuBlades"][TMenuBladeName];
    }
    /**
     * Provides access to all the Blade reference factories that are exported by a given resource type.
     */
    export interface ResourceTypeBladeKindReferenceFactoriesRegistry {
        /**
         * Gets the Blade reference factory for a blade representing the specified resource type and blade kind.
         *
         * @param bladeKind Blade kind: Properties, etc...
         * @returns Blade reference factory for the specified blade kind
         */
        forBlade(bladeKind: ResourceTypeBladeKind): ResourceTypeBladeKindReferenceFactory;
    }
    /**
     * Provides access to all blade reference factories.
     */
    export interface BladeReferenceFactoriesRegistry {
        /**
         * Gets the Blade reference factory for a blade in the current extension.
         *
         * @param blade Name of the blade
         * @returns Blade reference factory for the current extension and specified blade
         */
        forBlade<TBladeName extends keyof BladeReferenceFactories>(blade: TBladeName): BladeReferenceFactories[TBladeName];
        /**
         * Gets the Blade reference factory for a nopdl blade referenced by a marketplace package.
         *
         * @returns Blade reference factory
         */
        forMarketplace(): MarketplaceBladeReferenceFactory;
        /**
         * Gets all the Blade reference factories that are exported by a given extension.
         * The list of available extensions is enhanced by referencing the different definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         * Importing definition files just extends the list of types available for TypeScript compiler (and hence available in the IntelliSense).
         *
         * @param extensionName Name of the extension which this contains the blade
         * @returns Blade reference factories for the specified extension
         */
        forExtension<TExtensionName extends keyof ImportedBladeReferenceFactories>(extensionName: TExtensionName): ImportedBladeReferenceFactoriesRegistry<TExtensionName>;
        /**
         * Gets the menu blade reference factory for a menu blade in the current extension
         *
         * @param blade Name of the menu blade
         * @param menuId Menu item id
         * @param contentMenuBladeReference Alternate blade reference for menu blade content
         * @returns Menu blade reference factory for the current extension and specified blade
         */
        forMenuBlade<TMenuBladeName extends keyof MenuBladeReferenceFactories>(blade: TMenuBladeName, menuId: string, contentMenuBladeReference?: BladeReference<any>): MenuBladeReferenceFactories[TMenuBladeName];
        /**
         * Gets the blade reference factory for a blade representing the specified resource type.
         *
         * @param resourceType The full resource type name (resource provider + resource type)
         * @returns Blade reference factories for the specified resource type
         */
        forResourceType(resourceType: string): ResourceTypeBladeKindReferenceFactoriesRegistry;
    }
    /**
     * Represents a factory for a resource type blade kind reference.
     */
    interface ResourceTypeBladeKindReferenceFactory {
        /**
         * Creates a reference to a Blade.
         *
         * @param options Options for configuring the blade reference.
         * @returns A reference to a Blade.
         */
        createReference(options: {
            /**
             * Parameters to pass to the child blade.
             */
            readonly parameters: ResourceTypeBladeParameters[ResourceTypeBladeKind];
            /**
             * Callback that is invoked when the blade is closed.
             */
            readonly onClosed?: BladeClosedWithDataHandler<any>;
            /**
             * Optional flag to indicate the blade reference should be for an in-menu blade.
             */
            readonly inMenu?: boolean;
        }): BladeReference<any>;
    }
    /**
     * Represents a factory for a blade reference.
     */
    interface MarketplaceBladeReferenceFactory {
        /**
         * Creates a reference to a Blade.
         *
         * @param options Options for configuring the blade reference.
         * @returns A reference to a Blade.
         */
        createReference(options: {
            /**
             * Parameters to pass to the child blade.
             */
            parameters?: any;
            /**
             * Callback that is invoked when the blade is closed.
             */
            onClosed?: BladeClosedWithDataHandler<any>;
            /**
             * The marketplace options to launch the provisioning Blade.
             */
            marketplaceOptions: Common.Marketplace.MarketplaceOptions;
        }): BladeReference<any>;
        /**
         * Creates a reference to a Blade.
         *
         * @param options Options for configuring the blade reference.
         * @returns A reference to a Blade.
         */
        createReference(options: {
            /**
             * Parameters to pass to the child blade.
             */
            parameters?: any;
            /**
             * Callback that is invoked when the blade is closed.
             */
            onClosed?: BladeClosedWithDataHandler<any>;
            /**
             * The marketplace id of the provisioning Blade.
             */
            marketplaceId: string;
        }): BladeReference<any>;
    }
    /**
     * Represents the resource type blade parameters for given blade reference kinds.
     */
    export import ResourceTypeBladeParameters = Common.ResourceManagement.ResourceTypeBladeParameters;
    /**
     * The resource type blade reference kind
     */
    export import ResourceTypeBladeKind = Common.ResourceManagement.ResourceTypeBladeKind;
    /**
     * Provides access to all blade reference factories.
     */
    export const BladeReferences: BladeReferenceFactoriesRegistry;
    /**
     * Provides access to all the Part reference factories that are exported by a given extension.
     */
    export interface ImportedPartReferenceFactoriesRegistry<TExtensionName extends keyof ImportedPartReferenceFactories> {
        /**
         * Gets the Part reference factory for a part in the specified extension.
         */
        forPart<TPartName extends keyof ImportedPartReferenceFactories[TExtensionName]>(partName: TPartName): ImportedPartReferenceFactories[TExtensionName][TPartName];
    }
    /**
     * Provides access to all part reference factories.
     */
    export interface PartReferenceFactoriesRegistry {
        /**
         * Gets the Part reference factory for a part in the current extension.
         */
        forPart<TPartName extends keyof PartReferenceFactories>(part: TPartName): PartReferenceFactories[TPartName];
        /**
         * Gets all the Part reference factories that are exported by a given extension.
         * The list of available extensions is enhanced by referencing the different definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         * Importing definition files just extends the list of types available for TypeScript compiler (and hence available in the IntelliSense).
         */
        forExtension<TExtensionName extends keyof ImportedPartReferenceFactories>(extensionName: TExtensionName): ImportedPartReferenceFactoriesRegistry<TExtensionName>;
    }
    /**
     * Provides access to all part reference factories.
     */
    export const PartReferences: PartReferenceFactoriesRegistry;
    global {
        /**
         * Describes the list of blades that exist in the current extension.
         */
        interface BladeReferenceFactories {
        }
        /**
         * Describes the list of menu blades taht exist in the current extension
         */
        interface MenuBladeReferenceFactories {
        }
        /**
         * Describes the list of blades that are exported by the different extensions.
         * This list is enhanced by referencing the definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         */
        interface ImportedBladeReferenceFactories {
        }
        /**
         * Describes the list of parts that exist in the current extension.
         */
        interface PartReferenceFactories {
        }
        /**
         * Describes the list of parts that are exported by the different extensions.
         * This list is enhanced by referencing the definition files shared by other extensions.
         * An extension can include as many of these definition files as fits their development workflow,
         * as they add zero overhead to the runtime size of the importing extension.
         */
        interface ImportedPartReferenceFactories {
        }
    }
    export {};
}

// FILE: Fx\Composition\Blade.d.ts
declare module "Fx/Composition/Blade" {
    import * as FxComposition from "Fx/Composition";
    import { DialogManagement } from "Fx/Composition/Dialog";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    export = MsPortalFxBlade;
    module MsPortalFxBlade {
        import PartReference = MsPortalFx.Composition.PartReference;
        /**
         * The @Blade decorator.  Identifies a class within the extension as a Blade view model class.
         *
         * @param options Metadata describing the Blade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: BladeClass) => void;
        /**
         * Constrains the @Blade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface BladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @Blade decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this Blade.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: any;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' method.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a Blade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the Blade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a Blade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' method.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the Blade.
             */
            container: Container;
        }
        /**
         * Describes if/when to display an alert when the blade closes.
         */
        export import AlertLevel = FxBladeBase.AlertLevel;
        /**
         * Options supplied to the @Blade decorator.  Includes metadata describing the Blade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxViewModelBase.AcceptsStyleSheetsOptions, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, FxBladeBase.SupportsPrint, DialogManagement {
            /**
             * The location where the Blade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the Blade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * container.helpContentUri is obsolete.
             *
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            helpContentUri: Obsolete;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the Blade view model such that it implements an 'onRebind' method that will be
             * called when the Blade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the Blade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Blade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Blade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Blade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Blade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the Blade's configuration
                 * API) as well as 'settings' (the Blade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Blade's configuration API),
             * the 'parameters' of the Blade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The Blade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * Blade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the Blade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the Blade implement an 'onPin' method that determines what Part
             * to pin when the user pins the Blade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the Blade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 *
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 */
                supportsPostProvisioning?: true;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for Blades, like defining an explicit Blade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this Blade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the Blade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the Blade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the Blade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * A decorator used to specify a Blade that will be replaced by this Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: BladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a Blade class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Blade's view."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
    }
}

// FILE: Fx\Composition\BladeBase.d.ts
declare module "Fx/Composition/BladeBase" {
    import { ClickableLink } from "Fx/Composition";
    import { ItemType } from "Fx/Composition/ItemType";
    import { Container as PdlBladeContainer } from "Fx/Composition/Pdl/Blade";
    import { Context as MarketplaceContext } from "Fx/ResourceManagement/Marketplace";
    import { InitialValues, DeployTemplateOptions, AllDeployTemplateOptions, DeployCustomOptions, DeployTemplateResults } from "Fx/ResourceManagement/Provisioning";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import { PdlBladeReference } from "Fx/Composition/Selectable";
    import * as Toolbar from "Fx/Controls/Toolbar";
    import { PolicyValidationFactory } from "Fx/ResourceManagement/Policies";
    import { ReadonlyComputation } from "Weave";
    import FxConfiguration = MsPortalFx.Composition.Configuration;
    import FxToolbars = MsPortalFx.ViewModels.Toolbars;
    /**
     * The class type to which the various Blade decorators can be applied.
     */
    export interface BladeClass extends FxViewModelBase.ViewModelClass<any> {
        _fx?: {
            itemType?: ItemType;
            options?: Options;
            ownsEditScope?: boolean;
            rebindable?: boolean;
            parameterProvider?: boolean;
            doesProvisioning?: boolean;
            configurableOptions?: FxViewModelBase.Configurable.Options;
            isWeaveBlade?: boolean;
            isWeaveFlighted?: boolean;
        };
    }
    /**
     * A common interface type for various Blade view model classes.
     *
     * @template TParameters The type of input parameters for the blade.
     * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
     */
    export interface Contract<TParameters, TModel = void> extends FxViewModelBase.Contract<TParameters, TModel> {
        /**
         * The displayed title of the Blade.
         * Supply 'null' if no title is desired for the Blade.
         */
        title: string | KnockoutObservableBase<string> | ReadonlyComputation<string>;
        /**
         * The displayed subtitle of the Blade.
         * Supply 'null' if no subtitle is desired for the Blade.
         */
        subtitle: string | KnockoutObservableBase<string> | ReadonlyComputation<string>;
    }
    /**
     * Status bar for a Blade.
     */
    export interface StatusBar {
        /**
         * The text to display in the Blade's status bar.
         */
        text: string;
        /**
         * Optional callback called by the FX when the status bar is clicked.
         */
        onClick?: (() => void) | ClickableLink;
    }
    /**
     * Specifies which content state decoration should be applied to a Blade.
     */
    export import ContentState = MsPortalFx.ViewModels.ContentState;
    /**
     * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
     * 'onRebind' methods.
     *
     * @template TParameters The type of input parameters for the blade.
     * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
     */
    export interface Context<TParameters, TModel = void> extends FxViewModelBase.Context<TParameters, TModel> {
        /**
         * An API a Blade can use to interact with its host MenuBlade (if applicable).
         */
        menu: MenuBladeManagement;
        /**
         * An API a Blade can use to interact with the Form Fields on the Blade.
         */
        form: FormManagement;
    }
    /**
     * Represents a container object that can be used to control the chrome of the Blade.
     */
    export interface Container extends FxViewModelBase.Container {
        /**
         * Supplies the Blade's icon.
         * Any non-null value supplied here will override the image inferred from this Blade's 'forAsset' option (if supplied).
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * Opens CloudShell if not opened and executes provided command.
         *
         * @param cliType shell type to open, "bash" or "powershell"
         * @param commands One or a series of commands to execute in the CloudShell, see https://aka.ms/CloudShell/CmdInjection/allowlist for allow listed commands
         * @returns A boolean indicating whether the commands were initiated in CloudShell
         */
        executeInCloudShell(cliType: "bash" | "powershell", ...commands: CloudShellCommand[]): Promise<boolean>;
        /**
         * Toggles between full screen on/off.
         */
        toggleFullScreen(): Promise<void>;
    }
    /**
     * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
     */
    export import Location = MsPortalFx.ViewModels.BladeLocation;
    /**
     * Represents a container object that can be used to specify the CommandBar of the Blade.
     */
    export interface CanHaveCommandBarContainer {
        /**
         * The command bar of the Blade.  If required, must be set before 'container.revealContent' is called and before the
         * Promise returned from 'onInitialized' is resolved.
         */
        commandBar: FxToolbars.Toolbar | Toolbar.Contract;
    }
    /**
     * Represents a container object that exposes an observable size of the content area.
     */
    export interface ExposesContentSize {
        /**
         * The width and height of the content area of the blade, in pixels.
         */
        contentSize: KnockoutObservable<{
            height: number;
            width: number;
        }>;
    }
    /**
     * Options passed to the various Blade decorators.
     */
    export interface Options extends FxViewModelBase.Options {
        /**
         * Specifies whether the Blade is pinnable.  Defaults to 'true'.
         */
        isPinnable?: boolean;
    }
    /**
     * Shared by decorator options of @Blade/@TemplateBlade/@FrameBlade
     */
    export interface ShrinkOnOpenChildBladeOptions {
        /**
         * Specifies whether the Blade shrinks to the small width on open child blade.
         */
        shrinkOnOpenChildBlade?: boolean;
    }
    export interface ReflowReadyOption {
        /**
         * Specifies whether the content is compliant with {@link https://www.w3.org/WAI/WCAG21/Understanding/reflow.html WCAG2.1 criterion 1.4.10 Reflow}
         * Compliant content is designed to be responsive and can be rendered in a resolution as low as 320px width by 256px height in the portal.
         */
        reflowReady?: boolean;
    }
    /**
     * Represents a container object that can requests to print the content of the page.
     */
    export interface SupportsPrint {
        /**
         * Request to print the nearest page content related to this container.
         *
         * @returns A promise to confirm the request was sent to the Shell.
         */
        print(): Promise<void>;
    }
    export module Rebindable {
        /**
         * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
         */
        type Changes = FxViewModelBase.Rebindable.Changes;
    }
    export module Configurable {
        /**
         * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade's settings.
         */
        type Options = FxViewModelBase.Configurable.Options;
        /**
         * Metadata describing one setting of the Blade's persisted settings.
         */
        type SettingMetadata = FxViewModelBase.Configurable.SettingMetadata;
        /**
         * The scope at which the Blade's settings are persisted.
         */
        export import SettingsScope = FxViewModelBase.Configurable.SettingsScope;
        /**
         * Context injected by the FX into the view model.  This context will include 'configuration' (the Blades's
         * configuration API) as well as 'settings' (the Blade's persisted settings values).
         */
        type Context<TSettings> = FxViewModelBase.Configurable.Context<TSettings>;
        /**
         * The Blade's configuration API returned from 'context.configuration'.
         */
        type Configuration<TSettings> = FxConfiguration.Blade.Contract<TSettings>;
    }
    export module ReturnsData {
        /**
         * Represents a container object that can be used to control the chrome of the Blade.
         */
        interface Container<TData> {
            /**
             * Closes the Blade, returning 'data' to the parent Blade/Part.
             *
             * @param data The data to return to the parent Blade/Part.
             * @returns A promise indicating if the Blade was successfully closed.
             */
            closeCurrentBlade(data: TData): Promise<boolean>;
        }
    }
    export module DoesProvisioning {
        /**
         * Troubleshooting links for the arm errors blade
         */
        export import TroubleshootingLinks = Common.TroubleshootingLinks;
        /**
         * The input parameters for the arm errors blade.
         */
        export import ArmErrorsBladeParameters = Common.ArmErrorsBladeParameters;
        /**
         * The view model's provisioning API, with which the view model can provision async
         * operations, such as creates and deployments, (and logs the necessary telemetry).
         */
        interface Provisioning<TUIMetadata> extends MarketplaceContext<TUIMetadata> {
            /**
             * Initial values for form initialization. Use those values to initialize the subscription,
             * resource group, and location drop down controls.
             */
            readonly initialValues: InitialValues;
            /**
             * A factory for validating form values against policies
             */
            readonly policyValidationFactory: PolicyValidationFactory;
            /**
             * Validates an ARM template and returns a promise for the validation result.
             *
             * @param options Template deployment options
             */
            validateTemplate<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): Promise<TOptions>;
            /**
             * Deploy a template to ARM and receive a promise for a deployment result
             *
             * @param options Template deployment options
             */
            deployTemplate<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): Promise<DeployTemplateResults<TOptions>>;
            /**
             * Deploy a template to ARM and receive a promise for a deployment result
             *
             * @param options Template deployment options
             */
            deployStack(options: Common.DeployStackOptions): Promise<Common.DeployStackResults<Common.DeployStackOptions>>;
            /**
             * Get a blade reference to the template viewer blade
             *
             * @param options Template deployment options
             */
            getAutomationBladeReference<TOptions extends AllDeployTemplateOptions = DeployTemplateOptions>(options: TOptions): PdlBladeReference<any, void>;
            /**
             * Get a blade reference to the Arm Errors blade
             *
             * @param bladeParameters Parameters passed to the arm errors blade
             */
            getArmErrorsBladeReference(bladeParameters: ArmErrorsBladeParameters): PdlBladeReference<any, void>;
            /**
             * Set the marketplace item for the create
             *
             * @param id marketplace item id to replace current marketplace item in provisioning
             * @returns a promise that resolves to the requested marketplace item
             */
            setMarketplaceId(id: string): Promise<Common.Marketplace.Item<TUIMetadata>>;
            /**
             * Deploy a template to ARM and receive a promise for a deployment result
             *
             * @param options Custom deployment options
             */
            deployCustom<TResult>(options: DeployCustomOptions<TResult>): Promise<TResult>;
        }
    }
    /**
     * An API available as 'context.form' that a Blade can use to interact with the Form Fields on the Blade.
     */
    export type FormManagement = MsPortalFx.ViewModels.FormProperties;
    /**
     * Describes if/when to display an alert when the blade closes.
     */
    export import AlertLevel = MsPortalFx.ViewModels.AlertLevel;
    /**
     * An API available as 'context.menu' that a Blade can use to interact with its host MenuBlade (if applicable).
     */
    export interface MenuBladeManagement extends MsPortalFx.ViewModels.MenuBladeManagement {
        /**
         * A suffix applied to the title of the MenuBlade.
         */
        readonly titleSuffix: KnockoutObservable<string>;
        /**
         * A suffix applied to the subtitle of the MenuBlade.
         */
        readonly subtitleSuffix: KnockoutObservable<string>;
    }
    /**.
     * The blade 'Container' API for all variations of blades. It's through this API that extensions
     * can interact with the blade's chrome UI.
     */
    export type AnyBladeContainer = Container | PdlBladeContainer;
    export module ReplacesOldBlade {
        /**
         * Options that are supplied to the @ReplacesOldBlade decorator
         */
        interface Options {
            /**
             * The old blade that is to be replaced
             */
            replacedBlade: string;
            /**
             * The extension which the old blade belongs to
             */
            extension?: string;
            /**
             * Specifies that an ExP feature gate of the form "RedirectBlade-{sourceExtensionName}-{sourceBladeName}" is to be used to control whether this redirect is honored for a customer session.
             * {@link https://aka.ms/IbizaExperimentation Ibiza Experimentation }
             */
            useFlighting?: boolean;
        }
    }
    export import CloudShellCommand = Common.CloudShellCommand;
}

// FILE: Fx\Composition\ButtonPart.d.ts
declare module "Fx/Composition/ButtonPart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    export = MsPortalFxButtonPart;
    module MsPortalFxButtonPart {
        /**
         * The @ButtonPart decorator.  Identifies a class within the extension as a ButtonPart view model class.
         *
         * @param options Metadata describing the ButtonPart and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: ButtonPartClass) => void;
        /**
         * Constrains the @ButtonPart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface ButtonPartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @ButtonPart decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> {
            /**
             * The title of the part.
             */
            title: string | KnockoutObservableBase<string>;
            /**
             * A shorter title of the part (for size: mini).
             */
            shortTitle: string | KnockoutObservableBase<string>;
            /**
             * The displayed subtitle for this Part, typically the Asset name for the asset/resource associated with this Part.
             * Supply 'null' if no subtitle is desired for the Part.
             */
            subtitle: string | KnockoutObservableBase<string>;
            /**
             * A description for the part.
             */
            description: string | KnockoutObservableBase<string>;
            /**
             * An icon for the the part.
             */
            icon: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
            /**
             * Called by the FX to initialize this ButtonPart.
             *
             * @returns A promise that should be resolved by the ButtonPart when: (1) all the data is loaded for this view model and (2) the
             * ButtonPart state is updated to reflect the loaded data.
             */
            onInitialize(): Promise<any>;
            /**
             * Describes the behavior of the ButtonPart when it is clicked by the user.
             * Supply 'null' if the Part is not clickable.
             */
            onClick: (() => void) | FxComposition.ClickableLink;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the ButtonPart.
             */
            container: Container;
            /**
             * Interface for managing part updatable header
             */
            updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
        }
        /**
         * Represents a container object that can be used to control the chrome of the ButtonPart.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the ButtonPart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed ButtonPart size information.
             * The ButtonPart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this ButtonPart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed ButtonPart size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined ButtonPart sizes, including 'Custom' if the ButtonPart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this ButtonPart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @ButtonPart decorator.  Includes metadata describing the ButtonPart and how it will be treated by
         * the FX.
         */
        interface Options extends FxViewModelBase.Options {
            /**
             * The initial size with which the ButtonPart will be rendered.
             */
            initialSize?: Size.Mini | Size.Small | Size.Normal | Size.Wide;
            /**
             * Metadata describing the parameters passed to this Part.
             */
            parameterMetadata?: {
                [key: string]: ParameterMetadata;
            };
            /**
             * Metadata that describes this Part in the Part Gallery.
             */
            galleryMetadata?: FxPartBase.GalleryMetadata;
            /**
             * Ensure the Part's 'onClick' method is always called when such a Part is clicked.
             * This overrides intrinsic FX behavior for Parts pinned from MenuBlades, where 'onClick' is not called and, rather,
             * a deep link is utilized to open the MenuBlade.
             */
            ignorePinnedDeepLink?: boolean;
        }
        /**
         * The available sizes for the ButtonPart.
         */
        export import Size = FxPartBase.Size;
        /**
         * Metadata describing a parameter passed to this ButtonPart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the ButtonPart view model such that it implements an 'onRebind' method that will be
             * called when the ButtonPart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the ButtonPart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the ButtonPart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * ButtonPart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: ButtonPartClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        module UpdatableHeader {
            /**
             * The part's displayed title and optional subtitle.
             */
            export import PartHeader = FxPartBase.UpdatableHeader.PartHeader;
            /**
             * Options supplied for enableForExtensionRenderedHeader method
             */
            export import Options = FxPartBase.UpdatableHeader.Options;
            /**
             * Interface for managing part updatable header
             */
            export import UpdatableHeaderContext = FxPartBase.UpdatableHeader.UpdatableHeaderContext;
        }
    }
}

// FILE: Fx\Composition\DashboardFilters.d.ts
declare module "Fx/Composition/DashboardFilters" {
    export = MsPortalFxDashboardFilters;
    module MsPortalFxDashboardFilters {
        namespace TimeRangeFilter {
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             */
            interface FilterModel {
                /**
                 * An absolute time range.
                 */
                absolute?: {
                    /**
                     * The start of the time range.
                     */
                    fromDate: Date;
                    /**
                     * The end of the time range.
                     */
                    toDate: Date;
                };
                /**
                 * A relative time range.
                 */
                relative?: {
                    /**
                     * The duration for the relative time range.
                     */
                    duration: number;
                    /**
                     * The time unit for the duration of the relative time range.
                     */
                    timeUnit: TimeUnit;
                };
                /**
                 * The time standard for the provided time range.
                 */
                format?: DateTimeKind;
                /**
                 * The time granularity for the provided time range.
                 */
                granularity?: TimeGranularity;
            }
            /**
             * Values represent units of time.  Used in FilterModel above.
             */
            const enum TimeUnit {
                Minute = 0,
                Hour = 1,
                Day = 2,
                Week = 3
            }
            /**
             * Values represent time zone formats.  Used in FilterModel above.
             */
            const enum DateTimeKind {
                UTC = 0,
                Local = 1
            }
            /**
             * Values represent time granularity units.  Used in FilterModel above.
             */
            const enum TimeGranularity {
                Automatic = 0,
                OneMinute = 1,
                FiveMinutes = 2,
                FifteenMinutes = 3,
                ThirtyMinutes = 4,
                OneHour = 5,
                SixHours = 6,
                TwelveHours = 7,
                OneDay = 8,
                OneWeek = 9,
                OneMonth = 10
            }
            /**
             * The filter id of the TimeRange filter.
             */
            const filterId = "MsPortalFx_TimeRange";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_TimeRange: FilterModel;
            }
        }
        /**
         * An abstract class representing an extension-defined filter, one supported by a particular Part.
         * Each supported FX filter variant will have a 'createDefinition' factory function that returns a FilterDefinition.
         * A Part returns FilterDefinitions covering its supported filters from its 'getFilterDefinitions' and 'getDynamicFilterDefinitions'
         * methods.
         */
        class FilterDefinition {
        }
        /**
         * Identifies a specific localizable filter value.
         */
        interface LocalizableFilterValue {
            /**
             * Identifies a specific localizable filter value.  Part's return localized display text for such a value by implementing
             * a 'getLocalizedFilterValues' method.
             */
            valueId: string;
        }
        /**
         * A discrete value the user can pick in the filter UI.
         */
        type FilterValue = string | LocalizableFilterValue;
        namespace EqualityFilter {
            /**
             * Operators supported by the equality filter.
             */
            const enum Operator {
                Equals = 0,
                NotEquals = 1,
                Contains = 2,
                NotContains = 3,
                StartsWith = 4,
                NotStartsWith = 5,
                EndsWith = 6,
                NotEndsWith = 7
            }
            /**
             * Type alias for equality operators.
             */
            type EqualityOperator = Operator.Equals | Operator.NotEquals;
            /**
             * Type alias for substring operators.
             */
            type SubstringOperator = Operator.Contains | Operator.NotContains | Operator.StartsWith | Operator.NotStartsWith | Operator.EndsWith | Operator.NotEndsWith;
            /**
             * A discrete value the user can pick in the equality filter UI.
             */
            type FilterValue = MsPortalFxDashboardFilters.FilterValue;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of filter values selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                values?: FilterValue[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             *
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityOperator;
                values: FilterValue[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             *
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), identifying and configuring an extension-declared equality filter.
             */
            interface Options {
                /**
                 * The id of the extension-declared filter.  For extensions to jointly participate in a filter (for instance, to each supply
                 * distinct filter values), this id must be the same across the extensions.
                 */
                filterId: string;
                /**
                 * Display text for this filter.
                 */
                displayText: string;
                /**
                 * A callback called when the user changes the filter text in the equality filter UI.  In response, the Part should
                 * return a set of filter values, where each value matches 'filterText'.
                 *
                 * @param filterText User input from the equality filter text box.
                 * @returns An array or Promise resolving with an array of filter values, where each value matches 'filterText'.
                 */
                getFilterValues(filterText: string): FilterValue[] | Promise<FilterValue[]>;
                /**
                 * The filter's supported operators.
                 * If not provided, Equals and NotEquals operators will be supported by default.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates an equality filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @returns The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
        }
        /**
         * A type describing any filter model.  The filter's kind or id should be used to choose a corresponding filter model type to which to cast.
         */
        type AnyFilterModel = EqualityFilter.FilterModel | TimeRangeFilter.FilterModel | SubscriptionFilter.FilterModel | LocationFilter.FilterModel | ResourceGroupFilter.FilterModel | ResourceTypeFilter.FilterModel;
        /**
         * Part 'TFilterModels' interface types will inherit this interface type when they support dynamic filters (those filters not known at
         * compile-time).  In the Part's 'onInitialize' and 'onRebind' methods, it will reason over filter models for dynamic filters
         * according to this interface type.
         */
        interface DynamicFilterModels {
            /**
             * The filter {id, model}-pairs for dynamic filters.
             */
            [dynamicFilterId: string]: AnyFilterModel;
        }
        /**
         * A localized filter value returned from a Part's 'getLocalizedFilterValues' method.
         */
        interface LocalizedFilterValue {
            /**
             * The value id.
             */
            valueId: string;
            /**
             * The localized filter value.
             */
            value: string;
        }
        /**
         * A dynamic filter definition returned from a Part's 'getDynamicFilterDefinitions'.
         */
        interface DynamicFilterDefinition {
            /**
             * The filter definition.
             */
            definition: FilterDefinition;
            /**
             * Specifies whether telemetry should be logged for this filter.  Defaults to 'false' if not supplied.
             * Telemetry should only be logged if the filter (its filter id, for instance) doesn't include any sensitive user information.
             */
            logTelemetry?: boolean;
        }
        namespace SubscriptionFilter {
            /**
             * Operators supported by the subscription filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of subscription ids selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                subscriptionIds?: string[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             *
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                subscriptionIds: string[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             *
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard subscription filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of subscriptions from which the user can pick, reflecting those subscriptions supported
                 * by the associated Part.
                 *
                 * @returns An array or Promise resolving with an array of supported subscription ids.
                 */
                getSubscriptionIds(): string[] | Promise<string[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a subscription filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @returns The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the subscription filter.
             */
            const filterId = "MsPortalFx_Subscription";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_Subscription: FilterModel;
            }
        }
        namespace LocationFilter {
            /**
             * Operators supported by the location filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * A location known to the Portal/ARM for which locale-specific text can be mapped to by the FX.
             */
            interface KnownLocation {
                /**
                 * The non-localized location name.
                 */
                name: string;
            }
            /**
             * A discrete location value the user can pick in the location filter UI.
             */
            type Location = KnownLocation | MsPortalFxDashboardFilters.FilterValue;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of locations selected by the user from a list.  Supplied only when 'operator' is Operator.Equals and Operator.NotEquals.
                 */
                locations?: Location[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             *
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                locations: Location[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             *
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard location filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of locations from which the user can pick, reflecting those locations supported
                 * by the associated Part.
                 *
                 * @param filterText User input from the location filter text box.
                 * @returns An array or Promise resolving with an array of supported locations ids.
                 */
                getLocations(filterText: string): Location[] | Promise<Location[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a location filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @returns The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the location filter.
             */
            const filterId = "MsPortalFx_Location";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_Location: FilterModel;
            }
        }
        namespace ResourceGroupFilter {
            /**
             * Operators supported by the resource groups filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of resource group ids selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                resourceGroupIds?: string[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             *
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                resourceGroupIds: string[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             *
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard resource groups filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of resource groups from which the user can pick, reflecting those resource groups supported
                 * by the associated Part.
                 *
                 * @returns An array or Promise resolving with an array of supported resource group ids.
                 */
                getResourceGroupIds(): string[] | Promise<string[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a resource groups filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @returns The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the resource groups filter.
             */
            const filterId = "MsPortalFx_ResourceGroup";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_ResourceGroup: FilterModel;
            }
        }
        namespace ResourceTypeFilter {
            /**
             * Operators supported by the resource types filter.
             */
            export import Operator = EqualityFilter.Operator;
            /**
             * A discrete resource type value the user can pick in the resource types filter UI.
             */
            interface ResourceType {
                /**
                 * The name of the resource type, used to locate <ResourceType> metadata defined on some <AssetType>.
                 */
                resourceType: string;
                /**
                 * An optional resource kind, used to locate <ResourceKind> metadata around the <ResourceType> named by 'resourceType'.
                 */
                resourceKind?: string;
            }
            /**
             * The filter model supplied to a Part's 'onInitialize' and 'onRebind' methods.
             * A Part will load/reload its data by constructing an AJAX query based on this filter model.
             *
             * Re: "Select all":
             * - "User clicks 'select all'" is normalized to { operator: NotEquals, values: [] }
             * - "User clicks 'select all' then unchecks specific values" is normalized to { operator: NotEquals, value: [ <UNCHECKED_VALUES> ]}
             */
            interface FilterModel {
                /**
                 * The active filter operator.
                 */
                operator: Operator;
                /**
                 * A set of resource types selected by the user from a list.  Supplied only when 'operator' is Operator.Equals or Operator.NotEquals.
                 */
                resourceTypes?: ResourceType[];
                /**
                 * A user-entered substring, supplied only when 'operator' is Operator.Contains, Operator.NotContains, et al.
                 */
                substring?: string;
            }
            /**
             * Determines if the given filterModel is equality filter model (when 'operator' is EqualityOperator).
             *
             * @param filterModel The filter model.
             */
            function isEqualityFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.EqualityOperator;
                resourceTypes: ResourceType[];
            };
            /**
             * Determines if the given filterModel is substring filter model (when 'operator' is SubstringOperator).
             *
             * @param filterModel The filter model.
             */
            function isSubstringFilterModel(filterModel: FilterModel): filterModel is {
                operator: EqualityFilter.SubstringOperator;
                substring: string;
            };
            /**
             * Options supplied to 'createDefinition' (below), configuring the Part's support for the Dashboard resource types filter.
             */
            interface Options {
                /**
                 * A callback called to populate the list of resource types from which the user can pick, reflecting those resource types supported
                 * by the associated Part.
                 *
                 * @returns An array or Promise resolving with an array of supported resource types.
                 */
                getResourceTypes(): ResourceType[] | Promise<ResourceType[]>;
                /**
                 * The filter's supported operators.
                 */
                operators?: EqualityFilter.Operator[];
            }
            /**
             * Creates a resource types filter definition. Returned from a Part's 'getFilterDefinitions' or 'getDynamicFilterDefinitions'.
             *
             * @param options Options from which to create the filter definition.
             * @returns The filter definition.
             */
            function createDefinition(options: Options): MsPortalFxDashboardFilters.FilterDefinition;
            /**
             * The filter id of the resource types filter.
             */
            const filterId = "MsPortalFx_ResourceType";
            /**
             * Used to compose a Part's 'TFilterModels' type (see the 'Filterable.Context<TFilterModels>'-typing for its 'context' member).
             */
            interface FilterIdAndModel {
                MsPortalFx_ResourceType: FilterModel;
            }
        }
    }
}

// FILE: Fx\Composition\DataContext.d.ts
declare module "Fx/Composition/DataContext" {
    export = MsPortalFxDataContext;
    module MsPortalFxDataContext {
        /**
         * The @DataContext decorator.  Identifies a class within the extension as the DataContext class for a certain extension area.
         * The DataContext class loads and caches data for the area's contained Blades and Parts.
         *
         * @param options Options supplied to the decorator, including the area for which the DataContext loads/caches data.
         */
        function Decorator(options?: Options): (dataContextClass: Function) => void;
        /**
         * Options supplied to the @DataContext decorator.
         */
        interface Options {
            /**
             * The extension area for which the DataContext loads and caches data for the area's contained Blades and Parts.
             */
            area: string;
        }
    }
}

// FILE: Fx\Composition\Dialog.d.ts
declare module "Fx/Composition/Dialog" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { FxElement } from "Fx/Composition";
    /**
     * Standard button sets that can be displayed in a dialog.
     */
    export const enum DialogButtons {
        /**
         * The message box contains Abort, Retry and Ignore buttons.
         */
        AbortRetryIgnore = 0,
        /**
         * The message box contains an OK button.
         */
        OK = 1,
        Ok = 1,
        /**
         * The message box contains OK and Cancel buttons.
         */
        OKCancel = 2,
        /**
         * The message box contains Retry and Cancel buttons.
         */
        RetryCancel = 3,
        /**
         * The message box contains Yes and No buttons.
         */
        YesNo = 4,
        /**
         * The message box contains Yes, No and Cancel buttons.
         */
        YesNoCancel = 5,
        /**
         * The message box contains Delete and Cancel buttons.
         */
        DeleteCancel = 6,
        /**
         * The message box contains Delete and Go back buttons.
         */
        DeleteGoBack = 7
    }
    /**
     * Button identifiers.
     */
    export const enum DialogButton {
        /**
         * The abort button.
         */
        Abort = 0,
        /**
         * The cancel button.
         */
        Cancel = 1,
        /**
         * The ignore button.
         */
        Ignore = 2,
        /**
         * The no button.
         */
        No = 3,
        /**
         * The ok button.
         */
        Ok = 4,
        /**
         * The retry button.
         */
        Retry = 5,
        /**
         * The yes button.
         */
        Yes = 6,
        /**
         * The delete button.
         */
        Delete = 7,
        /**
         * The Go back button.
         */
        GoBack = 8
    }
    /**
     * Describes a custom button in a dialog.
     */
    export interface CustomDialogButton {
        /**
         * Optional display text of the button
         * If not specified, a default display text value will be used.
         */
        displayText?: string;
        /**
         * Button identifier that is programatically passed back.
         */
        button: DialogButton;
        /**
         * If set to the true the button is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    /**
     * The result returned after a dialog was closed.
     */
    export interface DialogResult {
        /**
         * The result returned from the dialog.
         */
        button: DialogButton;
    }
    /**
     * Describes preferred strategies to position a dialog.
     */
    export const enum DialogPosition {
        /**
         * The dialog will open above the reference element, aligned to its left edge.
         * The dialog pointer will be located at the bottom left pointing downwards.
         */
        TopLeftEdge = 1,
        /**
         * The dialog will open to the right of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top left pointing leftwards.
         */
        RightTopEdge = 2,
        /**
         * The dialog will open below the reference element, aligned to its left edge.
         * The dialog pointer will be located at the top left pointing upwards.
         */
        BottomLeftEdge = 3,
        /**
         * The dialog will open to the left of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top right pointing rightwards.
         */
        LeftTopEdge = 4,
        /**
         * The dialog will open above the reference element, aligned to its right edge.
         * The dialog pointer will be located at the bottom right pointing downwards.
         */
        TopRightEdge = 5,
        /**
         * The dialog will open below the reference element, aligned to its right edge.
         * The dialog pointer will be located at the top right pointing upwards.
         */
        BottomRightEdge = 6,
        /**
         * The dialog will open above the reference element, center aligned.
         * The dialog pointer will be located center-bottom pointing downwards.
         */
        TopEdge = 7,
        /**
         * The dialog will open below the reference element, center aligned.
         * The dialog pointer will be located center-top pointing upwards.
         */
        BottomEdge = 8
    }
    /**
     * Options supplied when opening a dialog
     */
    export interface BaseDialogOptions {
        /**
         * Name used in telemetry
         */
        telemetryName: string;
        /**
         * Dialog title
         *
         * If hideTitle is set the title value will still be used for the dialog's accessible name.
         */
        title: string;
        /**
         * Dialog content
         *
         * The dialog content can be a string message to display or an HTML template / view model pair.
         */
        content: string | HtmlContent;
        /**
         * Buttons can be either standard buttons provided by the framework or
         * this can be custom buttons with labels provided by the extension
         */
        buttons: DialogButtons | CustomDialogButton[];
        /**
         * Default button is the button which has focus if custom buttons was specified.
         * This property is not applicable when standard buttons are specified.
         */
        defaultButton?: DialogButton;
        /**
         * Optional callback that is invoked when the dialog is closed.
         * Dialogs are closed when the user clicks on one of the buttons or
         * clicks anywhere on the screen outside of the dialog. If the user clicks
         * somewhere else in the portal the cancel button or equivalent is passed to this callback.
         */
        onClosed?: (result: DialogResult) => void;
        /**
         * Indicator to hide dialog title.
         */
        hideTitle?: boolean;
        /**
         * Makes the dialog render as modal within its context. When modal, user input is required for dismissal and user interaction is suppressed within the context of the dialog.
         *
         * Only the blade dialog context supports a modal rendering. Modal rendering isn't compatible with DialogOptions target parameter.
         */
        modal?: boolean;
        /**
         * Dialog reference populated by the runtime that offers fine control of the lifetime of the dialog.
         * This is useful for very specific scenarios, mostly where an asynchronous operation is needed before closing the dialog.
         * Doing so requires to build a fully custom dialog content.
         */
        dialogRef?: DialogRef;
    }
    /**
     * Options supplied when opening a dialog that supports targeting
     */
    export interface DialogOptions extends BaseDialogOptions {
        /**
         * The target which is used to position the dialog.
         * This is a class name or a reference to a DOM element.
         */
        target?: string | FxElement;
        /**
         * Hint where to position the dialog relative to the target.
         * Defaults to BottomLeftEdge.
         */
        positionHint?: DialogPosition;
    }
    /**
     * Methods for managing dialogs which don't support targeting
     */
    export interface BaseDialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is to be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: BaseDialogOptions): Promise<boolean>;
    }
    /**
     * Methods for managing dialogs
     */
    export interface DialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is to be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: DialogOptions): Promise<boolean>;
    }
    /**
     * Provides an interface to control a dialog reference.
     */
    export interface DialogRef {
        /**
         * The dialog instance.
         */
        value: {
            /**
             * Close the dialog with the provided result.
             *
             * @param result The DialogResult that is passed to the onClosed callback and logged to telemetry.
             */
            close: (result: DialogResult) => void;
        };
    }
    /**
     * Creates a DialogRef instance to be used as a value for the dialogRef parameter in DialogOptions.
     *
     * @returns A DialogRef instance.
     */
    export function createDialogRef(): DialogRef;
}

// FILE: Fx\Composition\FrameBlade.d.ts
declare module "Fx/Composition/FrameBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import { BaseDialogManagement } from "Fx/Composition/Dialog";
    import * as FxFramePart from "Fx/Composition/FramePart";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    export = MsPortalFxFrameBlade;
    module MsPortalFxFrameBlade {
        import PartReference = MsPortalFx.Composition.PartReference;
        /**
         * The @FrameBlade decorator.  Identifies a class within the extension as a FrameBlade view model class.
         *
         * @param options Metadata describing the FrameBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: FrameBladeClass) => void;
        /**
         * Constrains the @FrameBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface FrameBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @FrameBlade decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The FrameBlade view model.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             *
             * ViewModelV2Contract is preferred since this API is consistent across FrameBlade, FramePart and FrameControl.
             */
            viewModel: ViewModel | ViewModelV2Contract;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a FrameBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the FrameBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a FrameBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the FrameBlade.
             */
            container: Container;
        }
        /**
         * Options supplied to the @FrameBlade decorator.  Includes metadata describing the FrameBlade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the FrameBlade.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the FrameBlade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, BaseDialogManagement {
            /**
             * The location where the FrameBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the FrameBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the FrameBlade view model such that it implements an 'onRebind' method that will be
             * called when the FrameBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the FrameBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the FrameBlade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the FrameBlade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the FrameBlade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FrameBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FrameBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the FrameBlade's configuration
                 * API) as well as 'settings' (the FrameBlade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the FrameBlade's configuration API),
             * the 'parameters' of the FrameBlade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The FrameBlade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * FrameBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the FrameBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the FrameBlade implement an 'onPin' method that determines what Part
             * to pin when the user pins the FrameBlade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the FrameBlade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 *
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 */
                supportsPostProvisioning?: true;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for FrameBlades, like defining an explicit FrameBlade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this FrameBlade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the FrameBlade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the FrameBlade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the FrameBlade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * Options used to configure the FrameBlade view model.
         */
        export import ViewModelOptions = FxFramePart.ViewModelOptions;
        /**
         * V2 options used to configure the FrameBlade view model.
         */
        export import ViewModelV2Options = FxFramePart.ViewModelV2Options;
        /**
         * ViewModelV2Contract is the latest frame API where messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         */
        export import ViewModelV2Contract = FxFramePart.ViewModelV2Contract;
        /**
         * Defines the signature for a message handler.
         */
        export import MessageHandler = FxFramePart.MessageHandler;
        /**
         * The view model of the FrameBlade.
         */
        class ViewModel extends FxFramePart.ViewModel {
            /**
             * Creates the view model for a FrameBlade
             *
             * @param container The container for this FrameBlade.
             * @param options Options for the FrameBlade view model.
             */
            constructor(container: Container, options: ViewModelOptions);
        }
        /**
         * Creates the V2 view model for a FrameBlade.
         * With V2 view model, messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         *
         * @param container The container for this FrameBlade.
         * @param options V2 options for the FrameBlade view model.
         */
        function createViewModel(container: Container, options: ViewModelV2Options): ViewModelV2Contract;
        /**
         * A decorator used to specify a Blade that will be replaced by this Frame Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: FrameBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\FramePart.d.ts
declare module "Fx/Composition/FramePart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    import * as FxPartBase from "Fx/Composition/PartBase";
    export = MsPortalFxFramePart;
    module MsPortalFxFramePart {
        /**
         * The @FramePart decorator.  Identifies a class within the extension as a FramePart view model class.
         *
         * @param options Metadata describing the FramePart and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: FramePartClass) => void;
        /**
         * Constrains the @FramePart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface FramePartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @FramePart decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this FramePart.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             *
             * ViewModelV2Contract is preferred since this API is consistent across FrameBlade, FramePart and FrameControl.
             */
            viewModel: ViewModel | ViewModelV2Contract;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the FramePart.
             */
            container: Container;
            /**
             * Interface for managing part updatable header
             */
            updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
        }
        /**
         * Represents a container object that can be used to control the chrome of the FramePart.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the FramePart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed Part size information.
             * The FramePart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this FramePart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed Part size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined Part sizes, including 'Custom' if the FramePart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this FramePart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @FramePart decorator.  Includes metadata describing the FramePart and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options {
            /**
             * The sizes supported by this FramePart.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the FramePart will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the FramePart.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the FramePart.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the FramePart.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this FramePart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the FramePart view model such that it implements an 'onRebind' method that will be
             * called when the FramePart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the FramePart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the FramePart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the FramePart's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the FramePart's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the FramePart's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FramePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the FramePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> extends FxPartBase.Configurable.Contract {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the FramePart's
                 * configuration API), as well as 'parameters' and 'settings' (the FramePart's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the FramePart's configuration
             * API), the 'parameters' of the FramePart, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The FramePart's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * FramePart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: FramePartClass) => void;
        }
        /**
         * The signature of messages used by the FramePart.
         */
        const signature = "FxFramePart";
        /**
         * The kind of message indicating that content can be revealed.
         */
        const revealContentMessageKind = "revealcontent";
        /**
         * The kind of message indicating that initialization has completed.
         */
        const initializationCompleteMessageKind = "initializationcomplete";
        /**
         * The kind of message that indicates that the frame has gone idle.
         */
        const frameIsIdleMessageKind = "frameidle";
        /**
         * The kind of message that indicates that the frame has gone active/busy.
         */
        const frameIsBusyMessageKind = "framebusy";
        module Internal {
            interface Data<T> {
                /**
                 * Data passed from the shell to the control.
                 */
                postMessage: KnockoutObservable<Message<T>>;
                /**
                 * Data passed from the control to the shell.
                 */
                receiveMessage: KnockoutObservable<Message<T>>;
                /**
                 * Indicates whether the iframe control has initialized.
                 */
                isFrameReady: KnockoutObservable<boolean>;
                /**
                 * The signature to be used for messages routed to/from the IFrame.
                 */
                signature: string;
                /**
                 * isV2Options flag indicates if iframe messages are exchanged via the latest V2 frame APIs.
                 * With V2 frame APIs, messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
                 */
                isV2Options: boolean;
            }
            interface ViewModelOptions extends MsPortalFxFramePart.ViewModelOptions {
                /**
                 * The signature of messages used by the FramePart.
                 */
                signature: string;
            }
        }
        /**
         * Defines the signature for a message handler.
         */
        type MessageHandler = (data: any) => void;
        /**
         * Defines a message sent between a frame part's view model and the frame.
         */
        interface Message<T> {
            /**
             * The message signature.
             */
            signature: string;
            /**
             * The message kind.
             */
            kind: string;
            /**
             * The message data.
             */
            data: T;
        }
        interface ViewModelOptions {
            /**
             * The URL of the page to load in the frame.
             */
            src: string;
        }
        interface ViewModelV2Options {
            /**
             * The URL of the page to embed in an iframe.
             */
            readonly src: string;
            /**
             * Callback to handle messages posted from iframe to the FramePart.
             * FramePart defines the shape of the message received from iframe.
             *
             * @param message Message received from iframe.
             */
            readonly onReceiveMessage: (message: unknown) => void;
        }
        interface ViewModelV2Contract {
            /**
             * Method to post message from FramePart to iframe.
             * FramePart defines the shape for the message posted to iframe.
             *
             * @param message Message posted from FramePart to iframe.
             */
            readonly postMessage: (message: unknown) => void;
        }
        /**
         * Creates an instance of iframe viewmodel with V2 contract.
         * V2 view model is the latest frame API where messages passed to/from the IFrame aren't required to follow any FX-specified format (no required 'kind' property)".
         *
         * @param container Container of the part.
         * @param options Options for creating V2 view model.
         * @returns a V2 iframe viewmodel
         */
        function createViewModel(container: Container, options: ViewModelV2Options): ViewModelV2Contract;
        class ViewModelBase {
            private readonly _handlers;
            private readonly _readyPromise;
            /**
             * Data passed to/from the shell and the control.
             */
            private readonly _msPortalFxData;
            /**
             * Posts a message to the frame.
             *
             * @param kind The message kind.
             * @param data The data associated to the message.
             */
            protected _postMessage: <T>(kind: string, data?: T) => void;
            /**
             * The URL of the page to embed.
             */
            readonly src: string;
            /**
             * Creates the view model for a frame part.
             *
             * @param container Container of the part.
             * @param options Options for this view model.
             */
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelOptions);
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelV2Options);
            /**
             * Helper method to wait till frame initialization is complete.
             *
             * @returns A promise when resolved will indicate iframe has been fully initialized.
             */
            waitForFrameReady(): Promise<void>;
            /**
             * Attaches an event handler function for message events of the specified kind.
             *
             * @param kind The kind of message to listen to.
             * @param handler A function to execute when a message of the specified kind is received.
             */
            on(kind: string, handler: MessageHandler): void;
            /**
             * Removes an event handler.
             *
             * @param kind The kind of message.
             * @param handler A function previously attached to message events of the specified kind.
             */
            off(kind: string, handler: MessageHandler): void;
        }
        class ViewModel extends ViewModelBase {
            /**
             * Creates the view model for a frame part.
             *
             * @param container Container of the part.
             * @param options Options for this view model.
             */
            constructor(container: MsPortalFx.ViewModels.PartContainerContract | Container, options: ViewModelOptions);
            /**
             * Posts a message to the frame.
             *
             * @param kind The message kind.
             * @param data The data associated to the message.
             */
            postMessage<T>(kind: string, data?: T): void;
        }
        namespace Filterable {
            /**
             * The @Filterable decorator.  FrameParts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the FramePart supports.
             * (see the 'FramePart.Filterable.Context' type and its 'filterModels' property, injected into the FramePart as its 'context' member).
             * FrameParts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the FramePart
             * - in their 'onRebind' method, to update the rendered FramePart to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@FramePart.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the FramePart class.  This context should be used within the FramePart's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @FramePart.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @returns A Promise reflecting the time spent loading updated FramePart data and making corresponding
                 * changes to the FramePart's view.
                 */
                onRebind(changes: Changes): Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the FramePart's
                 * 'TFilterModels' type included in 'public context: FramePart.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this FramePart's 'onInitialize' (to not compete
                 * with the initiation of FramePart data-loading).  When called, this method should not assume that the FramePart is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter declared on the FramePart's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this FramePart's 'onInitialize' (to not compete
                 * with the initiation of FramePart data-loading).  When called, this method should not assume that the FramePart is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @returns A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the FramePart's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the FramePart class, including extra APIs supporting the
             * '@FramePart.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this FramePart, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this FramePart's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this FramePart includes UX to update filters that apply to the Part, the FramePart can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @returns A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Promise<void>;
                        /**
                         * If this FramePart includes UX to update filters that apply to the Part, the FramePart can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @returns A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        module UpdatableHeader {
            /**
             * The part's displayed title and optional subtitle.
             */
            export import PartHeader = FxPartBase.UpdatableHeader.PartHeader;
            /**
             * Options supplied for enableForExtensionRenderedHeader method
             */
            export import Options = FxPartBase.UpdatableHeader.Options;
            /**
             * Interface for managing part updatable header
             */
            export import UpdatableHeaderContext = FxPartBase.UpdatableHeader.UpdatableHeaderContext;
        }
    }
}

// FILE: Fx\Composition\ItemType.d.ts
declare module "Fx/Composition/ItemType" {
    /**
     * These are the composition items that have TypeScript decorator support.
     */
    export const enum ItemType {
        Blade = 0,
        FrameBlade = 1,
        MenuBlade = 2,
        TemplateBlade = 3,
        ButtonPart = 4,
        FramePart = 5,
        Part = 6,
        TemplatePart = 7,
        ReactView = 10,
        AssetCommands = 11,
        TemplateBlade2 = 12,
        ReactTile = 13,
        TabMenuBlade = 14
    }
}

// FILE: Fx\Composition\MenuBlade.d.ts
declare module "Fx/Composition/MenuBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import * as Menu from "Fx/Controls/Menu";
    export = MsPortalFxMenuBlade;
    module MsPortalFxMenuBlade {
        /**
         * The @MenuBlade decorator.  Identifies a class within the extension as a MenuBlade view model class.
         *
         * @param options Metadata describing the MenuBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: MenuBladeClass) => void;
        /**
         * Constrains the @MenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface MenuBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @MenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this MenuBlade.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: ViewModel2;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a MenuBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the MenuBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a MenuBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the MenuBlade.
             */
            container: Container;
        }
        /**
         * Options supplied to the @MenuBlade decorator.  Includes metadata describing the MenuBlade and how it will be treated by
         * the FX.
         */
        type Options = FxBladeBase.Options;
        /**
         * Represents a container object that can be used to control the chrome of the MenuBlade.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the MenuBlade.
         */
        interface Container extends FxBladeBase.Container {
            /**
             * The location where the MenuBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the MenuBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the MenuBlade view model such that it implements an 'onRebind' method that will be
             * called when the MenuBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the MenuBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * MenuBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the MenuBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        /**
         * The sort order used for groups in the menu.
         */
        export import SortOrder = Menu.SortOrder;
        /**
         * The sort function used to order groups in the menu.
         */
        export import SortFunction = Menu.SortFunction;
        namespace Internal {
            /**
             * Options supplied to the ViewModel constructor.
             */
            interface ViewModelOptions extends Menu.Options {
                /**
                 * The groups of menu items.
                 */
                groups: MenuGroup[] | KnockoutReadOnlyObservableBase<MenuGroup[]>;
                /**
                 * Specifies the sort order used for groups in the menu.
                 */
                groupSortOrder?: SortOrder;
                /**
                 * Specifies the sort function used to order groups in the menu.
                 */
                groupSortFunction?: SortFunction;
                /**
                 * A value indicating whether or not to show the search box.
                 */
                showSearch?: boolean;
            }
        }
        /**
         * Defines the view model for a menu blade.
         */
        class ViewModel2 {
            private _msPortalFxMenu;
            /**
             * Creates the view model for a menu blade.
             *
             * @param container The container for the view model.
             * @param options Options for the view model.
             * @returns The view model.
             */
            static create<T extends Internal.ViewModelOptions>(container: Container, options: T): ViewModel2 & T;
            private _initialize;
        }
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends Menu.MenuItem {
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends Menu.MenuGroup {
        }
        /**
         * A decorator used to specify a Blade that will be replaced by this Menu Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: MenuBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\Part.d.ts
declare module "Fx/Composition/Part" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = MsPortalFxPart;
    module MsPortalFxPart {
        /**
         * The @Part decorator.  Identifies a class within the extension as a Part view model class.
         *
         * @param options Metadata describing the Part and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (partClass: PartClass) => void;
        /**
         * Constrains the @Part decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface PartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @Part decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this Part.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: any;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the Part.
             */
            container: Container;
            /**
             * Header information updated by user
             */
            updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
        }
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed Part size information.
             * The Part class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed Part size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined Part sizes, including 'Custom' if the Part is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @Part decorator.  Includes metadata describing the Part and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options, FxViewModelBase.AcceptsStyleSheetsOptions {
            /**
             * The sizes supported by this Part.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the Part will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the Part.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the Part.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the Part.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this Part.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the Part view model such that it implements an 'onRebind' method that will be
             * called when the Part's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the Part is bound.
             *
             * When this decorator is not used, whenever parameters change value, the Part view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Part's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Part's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Part's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Part's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the Part's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> extends FxPartBase.Configurable.Contract {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the Part's
                 * configuration API), as well as 'parameters' and 'settings' (the Part's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Part's configuration
             * API), the 'parameters' of the Part, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The Part's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * Part replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: PartClass) => void;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a Part class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Part's view."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        namespace Filterable {
            /**
             * The @Filterable decorator.  Parts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the Part supports.
             * (see the 'Part.Filterable.Context' type and its 'filterModels' property, injected into the Part as its 'context' member).
             * Parts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the Part
             * - in their 'onRebind' method, to update the rendered Part to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@Part.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the Part class.  This context should be used within the Part's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @Part.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @returns A Promise reflecting the time spent loading updated Part data and making corresponding
                 * changes to the Part's view.
                 */
                onRebind(changes: Changes): Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the Part's
                 * 'TFilterModels' type included in 'public context: Part.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this Part's 'onInitialize' (to not compete
                 * with the initiation of Part data-loading).  When called, this method should not assume that the Part is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter declared on the Part's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this Part's 'onInitialize' (to not compete
                 * with the initiation of Part data-loading).  When called, this method should not assume that the Part is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @returns A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the Part's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the Part class, including extra APIs supporting the
             * '@Part.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this Part, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this Part's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this Part includes UX to update filters that apply to the Part, the Part can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @returns A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Promise<void>;
                        /**
                         * If this Part includes UX to update filters that apply to the Part, the Part can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @returns A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        module UpdatableHeader {
            /**
             * The part's displayed title and optional subtitle.
             */
            export import PartHeader = FxPartBase.UpdatableHeader.PartHeader;
            /**
             * Options supplied for enableForExtensionRenderedHeader method
             */
            export import Options = FxPartBase.UpdatableHeader.Options;
            /**
             * Interface for managing part updatable header
             */
            export import UpdatableHeaderContext = FxPartBase.UpdatableHeader.UpdatableHeaderContext;
        }
    }
}

// FILE: Fx\Composition\PartBase.d.ts
declare module "Fx/Composition/PartBase" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import { ItemType } from "Fx/Composition/ItemType";
    import { ToolbarItems } from "Fx/Controls/Toolbar";
    import { SvgType } from "Fx/Images";
    import { LifetimeManager } from "Fx/Lifetime";
    import { DialogManagement } from "Fx/Composition/Dialog";
    export = Main;
    module Main {
        import FxConfiguration = MsPortalFx.Composition.Configuration;
        import FxParts = MsPortalFx.Parts;
        /**
         * The class type to which the various Part decorators can be applied.
         */
        interface PartClass extends FxViewModelBase.ViewModelClass<any> {
            _fx?: {
                itemType?: ItemType;
                options?: Options;
                ownsEditScope?: boolean;
                rebindable?: boolean;
                parameterProvider?: void;
                configurableOptions?: FxViewModelBase.Configurable.Options;
                filterable?: boolean;
            };
        }
        /**
         * A common interface type for the various Part view model classes.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxViewModelBase.Contract<TParameters, TModel> {
            /**
             * The title text displayed for this part. Typically this specifies what kind of information
             * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
             * type of the asset that the part relates to, e.g., "Website".
             * Supply 'null' if no title is desired for the Part.
             */
            title: string | KnockoutObservableBase<string>;
            /**
             * The displayed subtitle for this Part, typically the Asset name for the asset/resource associated with this Part.
             * Supply 'null' if no subtitle is desired for the Part.
             */
            subtitle: string | KnockoutObservableBase<string>;
            /**
             * Describes the behavior of the Part when it is clicked by the user.
             * Supply 'null' if the Part is not clickable.
             */
            onClick: (() => void) | FxComposition.ClickableLink;
            /**
             * Supplies context menu commands for the Part.
             *
             * @param commandLifetime The lifetime manager for command related allocations.
             * @returns An array of toolbar items for the Part commands.
             */
            supplyCommands?: (commandLifetime: LifetimeManager) => ToolbarItems.ToolbarItemContract[];
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxViewModelBase.Context<TParameters, TModel> {
            /**
             * Interface for managing part updatable header
             */
            updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
        }
        /**
         * Represents a container object that can be used to control the chrome of the Part.
         */
        interface Container extends FxViewModelBase.Container, DialogManagement {
            /**
             * If allowed by ResizeMode, will adjust the size of the part to the size specified, clamped to the grid constraints.
             *
             * @param width The desired width, in grid steps, valid in range from 1 to 25.
             * @param height The desired height, in grid steps, valid in range from 1 to 25.
             */
            resizeTo(width: number, height: number): void;
        }
        /**
         * Detailed Part size information.
         */
        interface SizeInfo {
            /**
             * The width/height of the Part in terms of pixels.
             */
            dimensions: {
                width: number;
                height: number;
            };
        }
        /**
         * The location of a Part.
         */
        export import Location = MsPortalFx.ViewModels.PartLocation;
        /**
         * Options supplied to the specific Part decorator.  Includes metadata describing the Part and how it will be
         * treated by the FX.
         */
        interface Options extends FxViewModelBase.Options {
            /**
             * The initial height with which the Part will be rendered.
             * Is applicable only when the 'initialSize' doesn't include a fixed height.
             */
            initialHeight?: number;
            /**
             * The initial width with which the Part will be rendered.
             * Is applicable only when the 'initialSize' doesn't include a fixed width.
             */
            initialWidth?: number;
            /**
             * Metadata describing the parameters passed to this Part.
             */
            parameterMetadata?: {
                [key: string]: ParameterMetadata;
            };
            /**
             * Metadata that describes this Part in the Part Gallery.
             */
            galleryMetadata?: GalleryMetadata;
            /**
             * Ensure the Part's 'onClick' method is always called when such a Part is clicked.
             * This overrides intrinsic FX behavior for Parts pinned from MenuBlades, where 'onClick' is not called and, rather,
             * a deep link is utilized to open the MenuBlade.
             */
            ignorePinnedDeepLink?: boolean;
        }
        /**
         * The available sizes for the Part.
         */
        export import Size = FxParts.PartSize;
        /**
         * The available resize modes for the Part.
         */
        export import ResizeMode = FxParts.ResizeMode;
        /**
         * Metadata describing a parameter passed to this Part.
         */
        interface ParameterMetadata {
            /**
             * When a Part is added to a Dashboard, this type is used to determine compatible Dashboard values to which the
             * associated parameter can be bound.
             */
            valueType: FxConfiguration.ValueType;
        }
        /**
         * Metadata describing the parameters passed to this Part.
         */
        interface GalleryMetadata {
            /**
             * The title of the Part shown in the Part Gallery.
             */
            title: string;
            /**
             * The description of the Part shown in the Part Gallery.
             */
            description?: string;
            /**
             * The category to which the Part belongs.
             */
            category?: string;
            /**
             * A reference to an SVG element to be used as the the thumbnail that is shown for the Part's entry in the Part Gallery.
             */
            thumbnail?: ({
                /**
                 * URI to the image element.
                 */
                path: string;
            } | {
                /**
                 * References a built-in SVG element.
                 */
                image: SvgType;
            });
            /**
             * The feature name used to hide this Part in the Part Gallery.
             */
            feature?: string;
        }
        module Rebindable {
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxViewModelBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Part's settings.
             */
            type Options = FxViewModelBase.Configurable.Options;
            /**
             * Metadata describing one setting of the Part's persisted settings.
             */
            type SettingMetadata = FxViewModelBase.Configurable.SettingMetadata;
            /**
             * The scope at which the Part's settings are persisted.
             */
            export import SettingsScope = FxViewModelBase.Configurable.SettingsScope;
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the Part's configuration
             * API) as well as 'parameters' and 'settings' (the Part's persisted settings values).
             */
            type Context<TSettings> = FxViewModelBase.Configurable.Context<TSettings>;
            /**
             * The Part's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxConfiguration.Part.Contract<TParameters, TSettings>;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds an optional 'configureOnAddToDashboardSelector'.
             */
            interface Contract {
                /**
                 * CSS selector to automatically open part configuration context pane when the part is added to a dashboard.
                 */
                configureOnAddToDashboardSelector?: string;
            }
        }
        module ReplacesOldPart {
            /**
             * Identifies a part on a blade that is to have its pinned instances replaced
             */
            interface ReplacedPartIdentifer {
                /**
                 * Name of the part that is to be replaced
                 */
                part: string;
                /**
                 * The lens which contains the part that is to be replaced
                 */
                lens: string;
                /**
                 * The blade which contains the part that is to be replaced
                 */
                blade: string;
            }
            /**
             * Options supplied to the ReplacesOldPart decorator.
             */
            interface Options {
                /**
                 * The old part that is to be replaced
                 */
                replacedPart: string | ReplacedPartIdentifer;
                /**
                 * The extension which the old part belongs to
                 */
                extension?: string;
            }
        }
        /**.
         * The Part 'Container' API for all variations of Parts. It's through this API that extensions
         * can interact with the Part's chrome UI.
         */
        type AnyPartContainer = Container | MsPortalFx.ViewModels.PartContainerContract;
        module UpdatableHeader {
            /**
             * The part's displayed title and optional subtitle.
             */
            interface PartHeader {
                /**
                 * The title text displayed for this part.
                 */
                title: string;
                /**
                 * The displayed subtitle for this Part.
                 * Supply 'null' if no subtitle is desired for the Part.
                 */
                subtitle?: string;
            }
            /**
             * Options supplied for enableForExtensionRenderedHeader method
             */
            interface Options {
                /**
                 * Disables subtitle customization in the header customization UI shown to the user.
                 */
                disableSubtitleUpdate?: boolean;
            }
            /**
             * Interface for managing part updatable header
             */
            interface UpdatableHeaderContext {
                /**
                 * For parts that render title/subtitle as part of their HTML template or their IFrame content,
                 *  this API enables user-customization of the part's title/subtitle via standard title/subtitle update UI.
                 *
                 * @param onChange Supplies initial and updated title/subtitle values so the extension can render
                 * @param options Options that customize title/subtitle update UI displayed to the user
                 */
                enableForExtensionRenderedHeader(onChange: (header: PartHeader) => void, options?: Options): void;
            }
        }
    }
}

// FILE: Fx\Composition\PartReferences.d.ts
declare module "Fx/Composition/PartReferences" {
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = PartReferences;
    module PartReferences {
        interface PartReferenceOptions extends MsPortalFx.Composition.PartReferenceOptions {
            /**
             * The part-level filters to use when displaying data, if applicable.
             */
            filters?: StringMap<FxFilters.AnyFilterModel>;
        }
        /**
         * Identifies the part that is referenced. This type is not intended to be used directly, but instead
         * code generation defines sub-classes of this base type to create a strongly typed reference per Part.
         */
        class PartReference<TParameters> extends MsPortalFx.Composition.PartReference<TParameters> {
            /**
             * Options to create the target part
             */
            options: PartReferenceOptions;
            /**
             * PartReference constructor
             *
             * @param partName partName of the referenced part
             * @param parameters parameters that are passed to the target part
             * @param options options that are used to create the target part
             */
            constructor(partName: string, parameters: TParameters, options?: PartReferenceOptions);
        }
    }
}

// FILE: Fx\Composition\Pdl\Blade.d.ts
declare module "Fx/Composition/Pdl/Blade" {
    import * as FxComposition from "Fx/Composition";
    import { ExposesContentSize, SupportsPrint } from "Fx/Composition/BladeBase";
    import FxConfiguration = MsPortalFx.Composition.Configuration;
    import BladeLocation = MsPortalFx.ViewModels.BladeLocation;
    export interface Container extends MsPortalFx.ViewModels.ContainerContract, MsPortalFx.ViewModels.BladeManagement, MsPortalFx.ViewModels.DialogManagement, SupportsPrint, ExposesContentSize {
        /**
         * Activates this Blade's 'Configuration', which is an API that enables the Blade to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @returns The Configuration API for this Part
         */
        activateConfiguration<TSettings>(options?: FxConfiguration.Blade.Options<TSettings>): FxConfiguration.Blade.Contract<TSettings>;
        /**
         * Tracks the list of asynchronous operations being performed by the Blade.
         */
        operations: FxComposition.OperationList;
        /**
         * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        fail(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'error' display mode, allowing for a custom error message.
         *
         * Use this method when encountering an expected error state transition which has been
         * designed as part of the user experience and is not the indication of a product bug.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An custom error message or options customizing the error UI.
         *                As opposed to other error state transition methods, the message is non-optional.
         */
        handledError(message: string | ErrorOptions): void;
        /**
         * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        notFound(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        unauthorized(message?: string | ErrorOptions): void;
        /**
         * Used to put a failed Blade/Part back into an operational state.
         */
        recover(): void;
        /**
         * Causes the blade's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the blade interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @returns a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Promise<boolean>;
        /**
         * Closes the child blade that is currently open
         *
         * @returns a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is successfully closed.
         */
        closeContextBlade(): Promise<boolean>;
        /**
         * Properties to track form validity, dirty state of forms on this blade and methods to trigger validation and modify alert behavior
         */
        form: MsPortalFx.ViewModels.FormProperties;
        /**
         * Interface for managing menu blade.   This property is null if the blade is not a opened by a menu blade.
         */
        menu: MsPortalFx.ViewModels.MenuBladeManagement;
        /**
         * container.helpContentUri is obsolete.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        helpContentUri: Obsolete;
        /**
         * API collection that facilitates dashboard interactions.
         */
        dashboard: MsPortalFx.ViewModels.DashboardManagement;
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        bladeLocation: BladeLocation;
    }
    /**
     * The options for the notice blade.
     */
    export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
    /**
     * The options for the error details.
     */
    export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
    export class Container {
    }
}

// FILE: Fx\Composition\Pdl\MenuBlade.d.ts
declare module "Fx/Composition/Pdl/MenuBlade" {
    import * as Menu from "Fx/Controls/Menu";
    export = Main;
    module Main {
        /**
         * The options for the menu.
         */
        interface Options extends Menu.Options {
        }
        /**
         * The sort functions used to sort groups in the menu.
         */
        const SortFunction: typeof Menu.SortFunction;
        /**
         * Defines the view model for a menu blade.
         */
        class ViewModel extends MsPortalFx.ViewModels.Blade {
            menu: Menu.ViewModel;
            /**
             * Creates the view model for a menu blade.
             *
             * @param container The container for the view model.
             */
            constructor(container: MsPortalFx.ViewModels.ContainerContract);
        }
        /**
         * The sort order used for groups in the menu.
         */
        export import SortOrder = Menu.SortOrder;
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends Menu.MenuItem {
        }
        /**
         * Defines a group in the menu.
         */
        interface MenuGroup extends Menu.MenuGroup {
        }
    }
}

// FILE: Fx\Composition\Permissions.d.ts
declare module "Fx/Composition/Permissions" {
    /**
     * Permissions that will be evaluated before rendering a Blade/Part.
     */
    export type Permissions = (Permission | PermissionSet)[];
    /**
     * A permission that will be evaluated for a resource before the associated Blade/Part UI will be shown/enabled.
     */
    export interface Permission {
        /**
         * The 'action' name for this permission ('read', 'write', etc.).
         */
        action: string;
        /**
         * An optional target of the permissions check.  If this is not supplied, then the target resource of this
         * permissions check is the asset associated with this Blade/Part.  To associate a Blade/Part with an asset,
         * use the 'Options.forAsset' property supplied to the Blade/Part decorator.
         */
        targetResource?: ResourceIdSource;
    }
    /**
     * A set of permissions that will be evaluated for a resource before the associated Blade/Part UI will be
     * shown/enabled.
     */
    export interface PermissionSet {
        /**
         * The set of permissions and/or permission references.
         */
        permissions: Permission[];
        /**
         * Indicates how the result from each of the N permission checks will be considered before allowing the
         * associated Blade/Part UI to be shown/enabled.
         */
        requirement: SetRequirement;
    }
    /**
     * Specifies the target asset for a permission or permission reference.
     */
    export interface ResourceIdSource {
        /**
         * A reference to an asset type definition that defines the resource that is the target of some permission or
         * permission reference.
         * If not supplied, then the asset type definition used here is that which is associated with the Blade/Part
         * (using the 'Options.forAsset' property supplied to the Blade/Part decorator).
         */
        assetType?: {
            /**
             * The name of the asset type definition.
             */
            assetType: string;
            /**
             * The name of the extension in which the asset type is defined.  When this is not supplied, this defaults
             * to the current extension.
             */
            extensionName?: string;
        };
        /**
         * If supplied, this indicates that a "property provider service" associated with the asset type definition is
         * to be used to determine the resource id that is the target of a permission / permission reference.
         * When supplied, this value contains the 'key' and 'property' parameters passed to the "property provider
         * service".
         *
         * If this is not supplied, then it is assumed that the associated permission or permission reference will be
         * evaluated against the resource associated with the Blade/Part via the 'Options.forAsset' property passed to
         * the Blade/Part decorator.
         */
        providerParameters?: {
            /**
             * The 'key' parameter passed to the "property provider service".
             */
            key: string;
            /**
             * The 'property' parameter passed to the "property provider service".  This is the view model property
             * where the resource id is to be published.
             */
            property: string;
        };
    }
    /**
     * Indicates how the result from each of the N permission checks will be considered before allowing the associated
     * Blade/Part UI to be shown/enabled.
     */
    export type SetRequirement = MsPortalFx.Extension.SetRequirement;
}

// FILE: Fx\Composition\TabMenuBlade.d.ts
declare module "Fx/Composition/TabMenuBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import * as TabMenu from "Fx/Controls/TabMenu";
    export = MsPortalFxTabMenuBlade;
    module MsPortalFxTabMenuBlade {
        /**
         * The @TabMenuBlade decorator.  Identifies a class within the extension as a TabMenuBlade view model class.
         *
         * @param options Metadata describing the TabMenuBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (bladeClass: TabMenuBladeClass) => void;
        /**
         * Constrains the @TabMenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface TabMenuBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @TabMenuBlade decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * The view model that the FX will bind into the view for this TabMenuBlade.  This property must be set before 'container.revealContent()'
             * is called (if it is) and before the promise returned from 'onInitialize' is resolved.
             */
            viewModel: ViewModel2;
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Specifies which content state decoration should be applied to a TabMenuBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the TabMenuBlade.
             */
            container: Container;
        }
        /**
         * Options supplied to the @TabMenuBlade decorator.  Includes metadata describing the TabMenuBlade and how it will be treated by
         * the FX.
         */
        type Options = FxBladeBase.Options;
        /**
         * Represents a container object that can be used to control the chrome of the TabMenuBlade.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the TabMenuBlade.
         */
        interface Container extends FxBladeBase.Container {
            /**
             * The location where the TabMenuBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a TabMenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * TabMenuBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the TabMenuBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        /**
         * A decorator used to specify a Blade that will be replaced by this Menu Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: TabMenuBladeClass) => void;
        }
        /**
         * Options supplied to the ViewModel constructor.
         */
        interface ViewModelOptions extends TabMenu.Options {
            /**
             * The groups of menu items.
             */
            items: TabMenu.MenuItem[] | KnockoutReadOnlyObservableBase<TabMenu.MenuItem[]>;
            /**
             * The main menu management driving the tab menu.
             */
            mainMenu?: FxBladeBase.MenuBladeManagement;
        }
        /**
         * Defines the view model for a tab menu blade.
         */
        class ViewModel2 {
            private _msPortalFxTabMenu;
            /**
             * Creates the view model for a tab menu blade.
             *
             * @param container The container for the view model.
             * @param options Options for the view model.
             * @returns The view model.
             */
            static create<T extends ViewModelOptions>(container: Container, options: T): ViewModel2 & T;
            private _initialize;
        }
        /**
         * Defines an item in a group of the menu.
         */
        interface MenuItem extends TabMenu.MenuItem {
        }
    }
}

// FILE: Fx\Composition\TemplateBlade.d.ts
declare module "Fx/Composition/TemplateBlade" {
    import * as FxComposition from "Fx/Composition";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import { DialogManagement } from "Fx/Composition/Dialog";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as Provisioning from "Fx/ResourceManagement/Provisioning";
    import { PostProvisioningOptions, PostProvisioningContent } from "Fx/ResourceManagement/Deployments";
    import PartReference = MsPortalFx.Composition.PartReference;
    export = MsPortalFxTemplateBlade;
    module MsPortalFxTemplateBlade {
        /**
         * The @TemplateBlade decorator.  Identifies a class within the extension as a TemplateBlade view model class.
         *
         * @param options Metadata describing the TemplateBlade and how it will be treated by the FX.
         */
        function Decorator(options?: Options): (templateBladeClass: TemplateBladeClass) => void;
        /**
         * Constrains the @TemplateBlade decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface TemplateBladeClass extends FxBladeBase.BladeClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @TemplateBlade decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxBladeBase.Contract<TParameters, TModel> {
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Status bar for a TemplateBlade.
         */
        interface StatusBar extends FxBladeBase.StatusBar {
            /**
             * The state of the TemplateBlade.
             */
            state: ContentState;
        }
        /**
         * Specifies which content state decoration should be applied to a TemplateBlade.
         */
        export import ContentState = FxBladeBase.ContentState;
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the blade.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxBladeBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the TemplateBlade.
             */
            container: Container;
        }
        /**
         * Describes if/when to display an alert when the blade closes.
         */
        export import AlertLevel = FxBladeBase.AlertLevel;
        /**
         * Options supplied to the @TemplateBlade decorator.  Includes metadata describing the TemplateBlade and how it will be treated by
         * the FX.
         */
        interface Options extends FxBladeBase.Options, FxViewModelBase.RequiresHtmlTemplateOptions, FxViewModelBase.AcceptsStyleSheetsOptions, FxBladeBase.ShrinkOnOpenChildBladeOptions, FxBladeBase.ReflowReadyOption {
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplateBlade.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplateBlade.
         */
        interface Container extends FxBladeBase.Container, FxBladeBase.CanHaveCommandBarContainer, FxBladeBase.ExposesContentSize, FxBladeBase.SupportsPrint, DialogManagement {
            /**
             * The location where the TempleteBlade is opened/rendered.
             */
            bladeLocation: Location;
            /**
             * The status bar of the TemplateBlade.
             */
            statusBar: KnockoutObservable<StatusBar>;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | NoticeOptions | ErrorOptions): void;
        }
        /**
         * The location where a Blade is opened/rendered (in the content area of a MenuBlade, in the Context Pane, etc.)
         */
        export import Location = FxBladeBase.Location;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * The options for the notice blade.
         */
        export import NoticeOptions = MsPortalFx.ViewModels.NoticeOptions;
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the TemplateBlade view model such that it implements an 'onRebind' method that will be
             * called when the TemplateBlade's parameters are changed.  Parameter changes are caused by, for example, the parent Blade/Part making
             * a call to a 'container.openBlade()'-related API or by the user updating browser's address bar.
             *
             * When this decorator is not used, whenever parameters change value, the TemplateBlade view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxBladeBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its persisted 'settings' values.  The 'settings'
             * values are made available in the view model's 'context', for use in the view model's 'onInitialize' and optional 'onRebind'
             * methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the TemplateBlade's settings.
             */
            type Options = FxBladeBase.Configurable.Options;
            /**
             * Metadata describing one setting of the TemplateBlade's persisted settings.
             */
            type SettingMetadata = FxBladeBase.Configurable.SettingMetadata;
            /**
             * The scope at which the TemplateBlade's settings are persisted.
             */
            export import SettingsScope = FxBladeBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplateBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplateBlade's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TSettings> {
                /**
                 * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplateBlade's configuration
                 * API) as well as 'settings' (the TemplateBlade's persisted settings values).
                 */
                context: Context<TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplateBlade's configuration API),
             * the 'parameters' of the TemplateBlade, as well as its persisted 'settings' values.
             */
            interface Context<TSettings> extends FxBladeBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its settings.
                 */
                configuration: Configuration<TSettings>;
            }
            /**
             * The TemplateBlade's configuration API returned from 'context.configuration'.
             */
            type Configuration<TSettings> = FxBladeBase.Configurable.Configuration<TSettings>;
        }
        module ReturnsData {
            /**
             * The @ReturnsData decorator.  Adds a strongly-typed 'context.container.closeCurrentBlade(data: TData)' to the
             * TemplateBlade.
             */
            function Decorator(): (returnsDataClass: ReturnsDataClass) => void;
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface ReturnsDataClass {
                new (...args: any[]): Contract<any>;
            }
            /**
             * Constrains the @ReturnsData decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract<TData> {
                /**
                 * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
                 * optional 'onRebind' methods.
                 */
                context: Context<TData>;
            }
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
             * 'onRebind' methods.
             */
            interface Context<TData> {
                /**
                 * A container object that can be used to control the chrome of the TemplateBlade.
                 */
                container: FxBladeBase.ReturnsData.Container<TData>;
            }
        }
        module Pinnable {
            /**
             * The @Pinnable decorator.  Requires that the TemplateBlade implement an 'onPin' method that determines what Part
             * to pin when the user pins the TemplateBlade.
             */
            function Decorator(): (pinnableClass: PinnableClass) => void;
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface PinnableClass {
                new (...args: any[]): Contract;
            }
            /**
             * Constrains the @Pinnable decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface Contract {
                /**
                 * A callback that will be called when the user pins the TemplateBlade.  Returns a PartReference to the Part that will be pinned to the
                 * user's Dashboard.
                 */
                onPin(): PartReference<any>;
            }
        }
        module DoesProvisioning {
            /**
             * The @DoesProvisioning decorator. Adds a strongly-typed 'context.provisioning' to the TemplateBlade.
             * This provisioning API allows the view model to perform provisioning operations, including support
             * for telemetry around provisioning.
             *
             * @param options Options used to configure the @DoesProvisioning decorator.
             */
            function Decorator<TOptions extends Options>(options?: TOptions): (doesProvisioningClass: TOptions["supportsPostProvisioning"] extends true ? DoesProvisioningAndPostProvisioningClass : DoesProvisioningClass) => void;
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningClass {
                new (...args: any[]): Contract;
                _fx?: {
                    doesProvisioning?: boolean;
                };
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes implementing 'Contract'.
             */
            interface DoesProvisioningAndPostProvisioningClass extends DoesProvisioningClass {
                /**
                 * A static function which returns a viewmodel used to customize the content on the blade launched after submitting a provisioning request.
                 *
                 * @param lifetime The lifetime of the content returned.
                 * @param options The options for fetching content relevant to the provisioning request.
                 */
                createPostProvisioningContent(lifetime: MsPortalFx.Base.LifetimeManager, options: PostProvisioningOptions): Promise<PostProvisioningContent>;
            }
            /**
             * Options supplied to the @DoesProvisioning decorator.
             */
            interface Options {
                /**
                 * A flag indicating whether the caller is required to supply a Marketplace item id
                 * when instantiating a BladeReference to this TemplateBlade. Defaults to true.
                 */
                requiresMarketplaceId?: boolean;
                /**
                 * A flag indicating that the create blade's class exposes the createPostProvisioningContent function.
                 * Defaults to false.
                 */
                supportsPostProvisioning?: boolean;
            }
            /**
             * Constrains the @DoesProvisioning decorator so that it can be applied only to classes
             * implementing 'Contract'.
             */
            interface Contract {
                /**
                 * Context injected by the FX into the view model. This context should be used within
                 * the view model's 'onInitialize' and optional 'onRebind' methods.
                 */
                context: Context<any>;
            }
            /**
             * Context injected by the FX into the view model. This context should be used within the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             */
            interface Context<TUIMetadata = void> {
                /**
                 * The view model's provisioning API, with which the view model can
                 * perform provisioning operations, including support for telemetry
                 * around provisioning.
                 */
                provisioning: FxBladeBase.DoesProvisioning.Provisioning<TUIMetadata>;
            }
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTemplateOptions = Provisioning.DeployTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeploySubscriptionLevelTemplateOptions = Provisioning.DeploySubscriptionLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployManagementGroupLevelTemplateOptions = Provisioning.DeployManagementGroupLevelTemplateOptions;
            /**
             * Options for the DeployTemplate method on provisioning context
             */
            export import DeployTenantLevelTemplateOptions = Provisioning.DeployTenantLevelTemplateOptions;
            /**
             * Options for the DeployCustom method on provisioning context
             */
            export import DeployCustomOptions = Provisioning.DeployCustomOptions;
            /**
             * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
             */
            export import TemplateDeploymentMode = Provisioning.TemplateDeploymentMode;
            /**
             * Parameters passed to the arm errors blade. See 'getArmErrorsBladeReference'.
             */
            export import ArmErrorsBladeParameters = FxBladeBase.DoesProvisioning.ArmErrorsBladeParameters;
            /**
             * Troubleshooting links for the arm errors blade
             */
            export import TroubleshootingLinks = FxBladeBase.DoesProvisioning.TroubleshootingLinks;
        }
        module LegacyFeatures {
            /**
             * The @LegacyFeatures decorator.  Used to access legacy features for TemplateBlades, like defining an explicit TemplateBlade width.
             *
             * @param options Options used to configure the @LegacyFeatures decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
            /**
             * Options supplied to the @LegacyFeatures decorator.
             */
            interface Options {
                /**
                 * The width for this TemplateBlade.
                 */
                width?: Width;
            }
            /**
             * The available widths for the TemplateBlade.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        module ForContextPane {
            /**
             * The @ForContextPane decorator.  Used to configure the behavior of the TemplateBlade when it is opened in the ContextPane.
             *
             * @param options Options used to configure the @ForContextPane decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
            /**
             * Options supplied to the @ForContextPane decorator.
             */
            interface Options {
                /**
                 * The width of the TemplateBlade when it is opened in the ContextPane.
                 */
                width?: Width;
            }
            /**
             * The available widths for the ContextPane.
             */
            export import Width = MsPortalFx.Blades.BladeWidth;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a TemplateBlade class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the TemplateBlade's HTML template."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        /**
         * A decorator used to specify a Blade that will be replaced by this Template Blade.
         */
        module ReplacesOldBlade {
            /**
             * Options that are supplied to the @ReplacesOldBlade decorator
             */
            type Options = FxBladeBase.ReplacesOldBlade.Options;
            /**
             * The @ReplacesOldBlade decorator.
             * This decorator specifies that this Blade is to be shown in place of some other, now-retired Blade from this or some other extension.
             * The Blade's API (its 'TParameters' and 'TData' types) must be compatible with that of the replaced Blade (and this is not compiler-validated).
             *
             * @param options Options used to configure the @ReplacesOldBlade decorator.
             */
            function Decorator(options: Options): (bladeClass: TemplateBladeClass) => void;
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Blade class constructor. Use either DI or a DataContext but not both
             * in the same Blade class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (bladeClass: InjectableModelBladeClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelBladeClass<TModel> {
                new (...args: any[]): Contract<any, TModel>;
            }
        }
    }
}

// FILE: Fx\Composition\TemplateBlade2.d.ts
declare module "Fx/Composition/TemplateBlade2" {
    export = MsPortalFxTemplateBlade2;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    module MsPortalFxTemplateBlade2 {
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        const Decorator: Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type TemplateBlade2Class = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type Contract = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type StatusBar = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type ContentState = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type Context = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type AlertLevel = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type Options = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        const Container: Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type Container = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type Location = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type ShieldType = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type NoticeOptions = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        type ErrorOptions = Obsolete;
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        module Configurable {
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const Decorator: Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Options = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type SettingMetadata = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type SettingsScope = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type ConfigurableClass = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Contract = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Context = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Configuration = Obsolete;
        }
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        module ReturnsData {
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const Decorator: Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type ReturnsDataClass = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Contract = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Context = Obsolete;
        }
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        module Pinnable {
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const Decorator: Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type PinnableClass = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Contract = Obsolete;
        }
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        module ForContextPane {
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const Decorator: Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Options = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Width = Obsolete;
        }
        /**
         * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        module ReplacesOldBlade {
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            type Options = Obsolete;
            /**
             * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const Decorator: Obsolete;
        }
    }
}

// FILE: Fx\Composition\TemplatePart.d.ts
declare module "Fx/Composition/TemplatePart" {
    import * as FxComposition from "Fx/Composition";
    import * as FxViewModelBase from "Fx/Composition/ViewModelBase";
    import * as FxPartBase from "Fx/Composition/PartBase";
    import * as FxFilters from "Fx/Composition/DashboardFilters";
    export = MsPortalFxTemplatePart;
    module MsPortalFxTemplatePart {
        /**
         * The @TemplatePart decorator.  Identifies a class within the extension as a TemplatePart view model class.
         *
         * @param options Metadata describing the TemplatePart and how it will be treated by the FX.
         */
        function Decorator(options: Options): (partClass: TemplatePartClass) => void;
        /**
         * Constrains the @TemplatePart decorator so that it can be applied only to classes implementing 'Contract'.
         */
        interface TemplatePartClass extends FxPartBase.PartClass {
            new (...args: any[]): Contract<any, any>;
        }
        /**
         * Constrains the @TemplatePart decorator so that it can be applied only to classes implementing 'Contract'.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Contract<TParameters, TModel = void> extends FxPartBase.Contract<TParameters, TModel> {
            /**
             * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and
             * optional 'onRebind' methods.
             */
            context: Context<TParameters, TModel>;
        }
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         *
         * @template TParameters The type of input parameters for the part.
         * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
         */
        interface Context<TParameters, TModel = void> extends FxPartBase.Context<TParameters, TModel> {
            /**
             * A container object that can be used to control the chrome of the TemplatePart.
             */
            container: Container;
            /**
             * Interface for managing part updatable header
             */
            updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplatePart.
         */
        class Container {
        }
        /**
         * Represents a container object that can be used to control the chrome of the TemplatePart.
         */
        interface Container extends FxPartBase.Container {
            /**
             * Detailed TemplatePart size information.
             * The TemplatePart class should subscribe to this observable to be notified of size changes.
             */
            size: KnockoutReadOnlyObservableBase<SizeInfo>;
            /**
             * Indicates the location of this TemplatePart (on a Dashboard, on a Blade, etc.).
             */
            location: Location;
            /**
             * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            fail(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'error' display mode, allowing for a custom error message.
             *
             * Use this method when encountering an expected error state transition which has been
             * designed as part of the user experience and is not the indication of a product bug.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An custom error message or options customizing the error UI.
             *                As opposed to other error state transition methods, the message is non-optional.
             */
            handledError(message: string | ErrorOptions): void;
            /**
             * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            notFound(message?: string | ErrorOptions): void;
            /**
             * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
             *
             * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
             * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
             * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
             * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
             * @param message An optional custom error message or options customizing the error UI.
             */
            unauthorized(message?: string | ErrorOptions): void;
        }
        /**
         * The options for the error details.
         */
        export import ErrorOptions = MsPortalFx.ViewModels.ErrorOptions;
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = FxComposition.ShieldType;
        /**
         * Detailed TemplatePart size information.
         */
        interface SizeInfo extends FxPartBase.SizeInfo {
            /**
             * One of the defined TemplatePart sizes, including 'Custom' if the TemplatePart is configured to support arbitrary sizing.
             */
            partSize: Size;
        }
        /**
         * Indicates the location of this TemplatePart (on a Dashboard, on a Blade, etc.).
         */
        export import Location = FxPartBase.Location;
        /**
         * Options supplied to the @TemplatePart decorator.  Includes metadata describing the TemplatePart and how it will be treated by
         * the FX.
         */
        interface Options extends FxPartBase.Options, FxViewModelBase.RequiresHtmlTemplateOptions, FxViewModelBase.AcceptsStyleSheetsOptions {
            /**
             * The sizes supported by this TemplatePart.
             */
            supportedSizes?: Size[];
            /**
             * The initial size with which the TemplatePart will be rendered.  Must be one of the 'supportedSizes'.
             */
            initialSize?: Size;
            /**
             * The resize mode for the TemplatePart.  If not supplied, the default value of 'Fixed' will be used.
             */
            resizeMode?: ResizeMode;
        }
        /**
         * The available sizes for the TemplatePart.
         */
        export import Size = FxPartBase.Size;
        /**
         * The available resize modes for the TemplatePart.
         */
        export import ResizeMode = FxPartBase.ResizeMode;
        /**
         * Metadata describing a parameter passed to this TemplatePart.
         */
        type ParameterMetadata = FxPartBase.ParameterMetadata;
        module Rebindable {
            /**
             * The @Rebindable decorator.  This expands the TemplatePart view model such that it implements an 'onRebind' method that will be
             * called when the TemplatePart's parameters are changed.  Parameter changes are caused by, for example, the user modifying a Dashboard
             * value ('timeRange', for instance) to which the TemplatePart is bound.
             *
             * When this decorator is not used, whenever parameters change value, the TemplatePart view model will be disposed and
             * a new one instantiated and initialized.
             */
            function Decorator(): (rebindableClass: RebindableClass) => void;
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface RebindableClass {
                new (...args: any[]): Contract;
                _fx?: {
                    rebindable?: boolean;
                };
            }
            /**
             * Constrains the @Rebindable decorator so that it can be applied only to classes implementing 'Contract', requiring that the class
             * implement an 'onRebind' method.
             */
            interface Contract {
                /**
                 * A method called by the FX whenever the view model's parameters change value.  When called, the view model should
                 * be updated to reflect the new parameter/settings values.
                 *
                 * @param changes A description of the parameters that have changed.
                 * @returns A promise that should be resolved once the view model has been entirely updated to reflect the new values for
                 * parameters/settings.
                 */
                onRebind(changes: Changes): Promise<any>;
            }
            /**
             * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
             */
            type Changes = FxPartBase.Rebindable.Changes;
        }
        module Configurable {
            /**
             * The @Configurable decorator.  View models that use this decorator will make use of 'context.configuration' to
             * obtain the view model's configuration API, with which the view model can update its 'parameters' and persisted 'settings'
             * values.  A new 'settings' property is added to the view model's 'context' which -- along with 'parameters' -- are used in the
             * view model's 'onInitialize' and optional 'onRebind' methods.
             *
             * @param options Options used to configure the @Configurable decorator, supplying additional metadata for the view model's
             * settings.
             */
            function Decorator(options?: Options): (configurableClass: ConfigurableClass) => void;
            /**
             * Options supplied to the @Configurable decorator.  Used to supply metadata describing the TemplatePart's settings.
             */
            type Options = FxPartBase.Configurable.Options;
            /**
             * Metadata describing one setting of the TemplatePart's persisted settings.
             */
            type SettingMetadata = FxPartBase.Configurable.SettingMetadata;
            /**
             * The scope at which the TemplatePart's settings are persisted.
             */
            export import SettingsScope = FxPartBase.Configurable.SettingsScope;
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplatePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface ConfigurableClass {
                new (...args: any[]): Contract<any, any>;
                _fx?: {
                    configurableOptions?: Options;
                };
            }
            /**
             * Constrains the @Configurable decorator so that it can only be applied to a class that implements the 'Contract' interface.
             * This adds to the view model's 'context':
             * - 'configuration', the TemplatePart's configuration API
             * - 'parameters' and persisted 'settings' values, used in the 'onInitialize' and optional 'onRebind' methods to render the view.
             */
            interface Contract<TParameters, TSettings> extends FxPartBase.Configurable.Contract {
                /**
                 * Context injected by the FX into the view model.  This context will include a 'configuration' (the TemplatePart's
                 * configuration API), as well as 'parameters' and 'settings' (the TemplatePart's persisted settings values).
                 */
                context: Context<TParameters, TSettings>;
            }
            /**
             * Context injected by the FX into the view model.  This context will include 'configuration' (the TemplatePart's configuration
             * API), the 'parameters' of the TemplatePart, as well as its persisted 'settings' values.
             */
            interface Context<TParameters, TSettings> extends FxPartBase.Configurable.Context<TSettings> {
                /**
                 * The view model's configuration API, with which the view model can update its parameters and settings.
                 */
                configuration: Configuration<TParameters, TSettings>;
            }
            /**
             * The TemplatePart's configuration API returned from 'context.configuration'.
             */
            type Configuration<TParameters, TSettings> = FxPartBase.Configurable.Configuration<TParameters, TSettings>;
        }
        module ReplacesOldPart {
            /**
             * Options that are supplied to the @ReplacesOldPart decorator
             */
            type Options = FxPartBase.ReplacesOldPart.Options;
            /**
             * The @ReplacesOldPart decorator.  This decorator is used to identify a old part that this
             * TemplatePart replaces.
             *
             * @param options options used to configure the @ReplacesOldPart decorator.
             */
            function Decorator(options: Options): (partClass: TemplatePartClass) => void;
        }
        /**
         * The @ProxiedMember decorator.  Identifies a public member of a TemplatePart class that is to be proxied for use in the view.
         * This decorator is not necessary in most scenarios.
         * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the TemplatePart's HTML template."
         */
        export import ProxiedMember = FxViewModelBase.ProxiedMember;
        namespace Filterable {
            /**
             * The @Filterable decorator.  TemplateParts that carry this decorator will receive the state of the those filters currently
             * applied to the containing Dashboard.  They'll receive a "filter model" for each applied filter that the TemplatePart supports.
             * (see the 'TemplatePart.Filterable.Context' type and its 'filterModels' property, injected into the TemplatePart as its 'context' member).
             * TemplateParts will make use of the current "filter models":
             * - in their 'onInitialize' method, to render the TemplatePart
             * - in their 'onRebind' method, to update the rendered TemplatePart to reflect user changes to Dashboard filters
             */
            function Decorator(): (filterableClass: FilterableClass) => void;
            interface FilterableClass {
                new (...args: any[]): Contract<any>;
                _fx?: {
                    filterable?: boolean;
                };
            }
            /**
             * The interface type implemented by any class that carries the '@TemplatePart.Filterable.Decorator' decorator.
             */
            interface Contract<TFilterModels> {
                /**
                 * Context injected by the FX into the TemplatePart class.  This context should be used within the TemplatePart's 'onInitialize'
                 * and 'onRebind' methods.
                 */
                context: Context<TFilterModels>;
                /**
                 * As with the 'onRebind' method required when using the @TemplatePart.Rebindable.Decorator decorator,
                 * this method will be called by the FX whenever the filters for the current Dashboard are updated by the user.
                 *
                 * @param changes An indication of the filter ids whose corresponding filters have been added/removed/updated.
                 * @returns A Promise reflecting the time spent loading updated TemplatePart data and making corresponding
                 * changes to the TemplatePart's view.
                 */
                onRebind(changes: Changes): Promise<any>;
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known statically.  These static filters are those known
                 * at development time (and not those derived from mutable backend schema, for instance).  Such extension-defined
                 * filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic filters like TimeRangeFilter).
                 * This method should return a filter definition for each extension-defined filters declared on the TemplatePart's
                 * 'TFilterModels' type included in 'public context: TemplatePart.Filterable.Context<TFilterModels>'.
                 *
                 * This method will be called by the FX some time after the FX calls this TemplatePart's 'onInitialize' (to not compete
                 * with the initiation of TemplatePart data-loading).  When called, this method should not assume that the TemplatePart is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter declared on the TemplatePart's 'TFilterModels' type.
                 */
                getFilterDefinitions?(): FxFilters.FilterDefinition[];
                /**
                 * Optional.  Returns filter definitions for extension-defined filters known only dynamically (for instance, derived from
                 * mutable backend schema).  Such extension-defined filters are ones like EqualityFilter.FilterDefinition (and not FX-intrinsic
                 * filters like TimeRangeFilter).
                 *
                 * This method will be called by the FX some time after the FX calls this TemplatePart's 'onInitialize' (to not compete
                 * with the initiation of TemplatePart data-loading).  When called, this method should not assume that the TemplatePart is
                 * fully initialized.
                 *
                 * @returns An array of filter definitions for each extension-defined filter only known dynamically.
                 */
                getDynamicFilterDefinitions?(): Promise<FxFilters.DynamicFilterDefinition[]>;
                /**
                 * Required only if any filter definition 'getValues' callbacks returns a localizable filter value.
                 * In such cases, this method will be called to map one or more such localizable filter values to display text in the Portal
                 * user's locale.
                 *
                 * @param filterId The filter id for the filter definition whose 'getValues' callback returned a localizable value.
                 * @param valueIds One or more ids of localizable values.
                 * @returns A Promise resolving with corresponding display text for each localizable value, according to the user's locale.
                 */
                getLocalizedFilterValues?(filterId: string, valueIds: string[]): Promise<FxFilters.LocalizedFilterValue[]>;
            }
            /**
             * A description of filter changes (adds/removes/updates) that triggered a call to the TemplatePart's 'onRebind' method,
             * to reflect user modification to Dashboard filters.
             */
            interface Changes {
                /**
                 * An array of filter ids covering the added/removed/updated Dashboard filters.
                 */
                filterIds: string[];
            }
            /**
             * Context injected by the FX into the TemplatePart class, including extra APIs supporting the
             * '@TemplatePart.Filterable.Decorator' decorator.
             */
            interface Context<TFilterModels> {
                /**
                 * FX APIs related to Dashboards.
                 */
                dashboard: {
                    /**
                     * FX APIs related to Dashboard filtering.
                     */
                    filtering: {
                        /**
                         * For those filters supported by this TemplatePart, these are the filter models for those filters currently applied
                         * to the active Dashboard and those that are applied locally at the Part level.  The supported filters are those static filters declared in this TemplatePart's
                         * 'TFilterModels' type and those dynamic filters returned from 'getDynamicFilterDefinitions'.
                         */
                        effectiveFilterModels: TFilterModels;
                        /**
                         * A description of all filters applied, broken down into those filters applied to the active Dashboard and those filters applied locally
                         * at the Part level.
                         *
                         * These values do not take precedence into consideration, and should not be used as a source of truth for a filter's final
                         * effective value. For that refer back to the effectiveFilterModels.
                         *
                         */
                        allFilterModels: {
                            /**
                             * All filters applied at the dashboard level.
                             */
                            dashboard: TFilterModels;
                            /**
                             * All filters applied at the part level.
                             */
                            part: TFilterModels;
                        };
                        /**
                         * If this TemplatePart includes UX to update filters that apply to the Part, the TemplatePart can include an option for
                         * the user to update filters at the Dashboard level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'dashboardFilters' here passed here.
                         *
                         * @param dashboardFilters Updated dashboard filter models
                         * @returns A Promise reflecting the updating of the Dashboard filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(dashboardFilters: Partial<TFilterModels>): Promise<void>;
                        /**
                         * If this TemplatePart includes UX to update filters that apply to the Part, the TemplatePart can include an option for
                         * the user to update filters at the Dashboard level and/or part level, using this method.
                         *
                         * The filters accepted here are a subset of those declared to be supported statically via the 'TFilterModels' type and
                         * those filters supported dynamically via 'getDynamicFilterDefinitions'.
                         *
                         * When the returned Promise resolves, the extension can assume that 'context.filtering.effectiveFilterModels' is consistent
                         * with the updated 'filters' here passed here.
                         *
                         * @param filters Updated dashboard and/or part-level filter models
                         * @returns A Promise reflecting the updating of the Dashboard and/or Part-level filter state as well as 'context.dashboard.filtering.effectiveFilterModels'.
                         */
                        updateFilters(filters: {
                            dashboard?: Partial<TFilterModels>;
                            part?: Partial<TFilterModels>;
                        }): Promise<void>;
                    };
                };
            }
        }
        module InjectableModel {
            /**
             * The @InjectableModel decorator. Classes can specify this decorator to indicate the model class
             * that the dependency injection container will supply.
             * NOTE: Using a model (aka DataContext) -and therefore the @InjectableModel decorator- is not compatible
             * with using Dependency Injection in the Part class constructor. Use either DI or a DataContext but not both
             * in the same Part class.
             */
            function Decorator<TModel>(model: new (...args: any[]) => TModel): (partClass: InjectableModelPartClass<TModel>) => void;
            /**
             * Constrains the @InjectableModel decorator so that it can be applied only to classes implementing 'Contract' that defines the right DataContext.
             */
            interface InjectableModelPartClass<TModel> {
                new (): Contract<any, TModel>;
            }
        }
        module UpdatableHeader {
            /**
             * The part's displayed title and optional subtitle.
             */
            export import PartHeader = FxPartBase.UpdatableHeader.PartHeader;
            /**
             * Options supplied for enableForExtensionRenderedHeader method
             */
            export import Options = FxPartBase.UpdatableHeader.Options;
            /**
             * Interface for managing part updatable header
             */
            export import UpdatableHeaderContext = FxPartBase.UpdatableHeader.UpdatableHeaderContext;
        }
    }
}

// FILE: Fx\Composition\ViewModelBase.d.ts
declare module "Fx/Composition/ViewModelBase" {
    import * as BladeBase from "Fx/Composition/BladeBase";
    import * as FxComposition from "Fx/Composition";
    import * as FxPermissions from "Fx/Composition/Permissions";
    import * as PartBase from "Fx/Composition/PartBase";
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Options that are common to various Blade/Part decorators.  Includes metadata describing the Blade/Part and how it will be treated by
     * the FX.
     */
    export interface Options {
        /**
         * Specifies whether this Blade/Part should exported from this extension,
         * so it can be imported/reused by other extensions.  The default is 'false'.
         */
        forExport?: boolean;
        /**
         * Used to associate this Blade/Part with a defined AssetType.  This allows the FX to:
         * - When an asset is deleted, give special UX treatment to associated Parts/Blades (close Blades, disable Parts)
         * - Store per-asset Part/Blade settings
         */
        forAsset?: {
            /**
             * Names a single Blade/Part parameter that the FX will treat as the 'id' of the associated asset.
             */
            assetIdParameter: string;
            /**
             * Names an AssetType definition.  Values here should be one of the string constant generated by the PDL compiler from
             * <AssetType>.
             */
            assetType: string;
        };
        /**
         * Permissions that will be evaluated against the resource associated with this Blade/Part (see 'forAsset' above) before the
         * Blade/Part UI is shown/enabled.
         */
        permissions?: FxPermissions.Permissions;
    }
    /**
     * A common class type for Blade/Part view model classes.
     */
    export interface ViewModelClass<TModel = void> {
        new (...args: any[]): Contract<any, TModel>;
    }
    /**
     * A common interface type for Blade/Part view model classes.
     *
     * @template TParameters The type of input parameters for the blade.
     * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
     */
    export interface Contract<TParameters, TModel = void> {
        /**
         * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
         * 'onRebind' methods.
         */
        context: Context<TParameters, TModel>;
        /**
         * Called by the FX to initialize this view model.
         *
         * @returns A promise that should be resolved by the view model when: (1) all the data is loaded for this view model and (2) the
         * view model is updated to reflect the loaded data.
         */
        onInitialize(): Promise<any>;
    }
    /**
     * Context injected by the FX into the view model.  This context should be used within the view model's 'onInitialize' and optional
     * 'onRebind' methods.
     *
     * @template TParameters The type of input parameters for the blade.
     * @template TModel The type of the model / DataContext that gets injected in the context. Note: TModel is being deprecated in favor of using Dependency Injection directly in the view model's constructor.
     */
    export interface Context<TParameters, TModel = void> {
        /**
         * The container used by this view model.
         */
        container: Container;
        /**
         * The model used by this view model.
         */
        model?: TModel;
        /**
         * Parameters supplied by the caller of this Blade/Part.
         */
        parameters: TParameters;
        /**
         * API collection that facilitates dashboard interactions.
         */
        dashboard: MsPortalFx.ViewModels.DashboardManagement;
    }
    /**
     * Options to pass to the openHelpPane API that provides additional context
     */
    export interface HelpPaneOptions {
        /**
         * Optional problem classifier, used when opening a specific problem context
         */
        readonly problemClassificationId?: string;
        /**
         * Optional solutionId, used when opening a specific solution
         */
        readonly solutionId?: string;
        /**
         * Optional resource Id, providing additional context for the support flow
         */
        readonly resourceId?: string;
        /**
         * Optional workflow identifier, used to connect flows across many experiences
         */
        readonly correlationId?: string;
    }
    /**
     * Represents a container object that can be used to control the chrome of the Blade/Part.
     */
    export interface Container extends FxBase.LifetimeManager, FxViewModels.BladeManagement {
        /**
         * Removes the blocking loading indicator from the Blade/Part.
         */
        revealContent(): void;
        /**
         * The announce API aims to provide screen reader users knowledge of certain UI updates that are otherwise difficult to advertise.
         * Announcements main purpose is to bring attention to these changes and provide feedback that is only visual otherwise.
         *
         * The message will be published at the 'polite' level, letting the screen reader queue the announcement at an appropriate time without interrupting the current read out queues.
         *
         * The API has these notable documented use cases:
         *   UI changes without focus change: If you add new UI elements through user interaction, and without moving the focus, you should announce.
         *   Confirmations: If you do operations that have completed visually, but not audibly, you should announce. Ex: upon deleting item XYZ, announce "item XYZ deleted"
         *   Loading progression: Announce at reasonable interval loading progression of specific thresholds, and the completion of loading.
         *   Custom search results: If you don't use the SearchBox control, you should announce. Ex: "3 items found".
         *
         * Keep these rules in mind when announcing:
         *   Is this something a control you use should be doing or does already? For example, the search control already has a mechanism to publish search results updates.
         *   Keep announcements short and concise as much as possible. Verbose announcements aren't usually helpful as the UI likely has the information, but the user just didn't know to look for it yet.
         *
         * @param message The message that will be read by the screen reader.
         */
        announce(message: string): void;
        /**
         * Asynchronously moves the focus to the first focusable element on or within the specified target if the container currently
         * owns the focus. If multiple target elements are found, only the first one will be inspected. If nothing is focusable,
         * the focus will not move and this method will return false.
         *
         * @param targetSelector Any valid CSS selector to elements owned by this container that identifies a target to focus on or within.
         * @returns An object with a success status and an optional error message explaining rejection.
         */
        setFocus(targetSelector: string): Promise<{
            success: boolean;
            errorMsg?: string;
        }>;
        /**
         * Closes this blade.
         *
         * @param data Use the @ReturnsData<TData> decorator to supply TData-typed 'data' here. This 'data' will be returned to the
         * BladeReference with which this Blade was opened, via the BladeReference's 'onClosed' callback.
         * @returns a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: void): Promise<boolean>;
        /**
         * Closes the child blade that is currently open.
         *
         * @returns a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is sucessfully closed.
         */
        closeContextBlade(): Promise<boolean>;
        /**
         * Tracks the list of asynchronous operations being performed by the Part.
         */
        operations: FxComposition.OperationList;
        /**
         * An observable whose value determines the message displayed when there is no data to be displayed in the
         * Blade/Part.
         * This message will be displayed if it is non-null, non-empty.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Used to put a failed Blade/Part back into an operational state.
         */
        recover(): void;
        /**
         * Opens the portal help pane
         *
         * @param options Additonal parameters that can be passed to the helppane for contextual help
         */
        openHelpPane(options?: HelpPaneOptions): Promise<void>;
    }
    /**
     * Shared by the decorator options of @TemplateBlade/@TemplatePart.  Requires that the extension supply an HTML template to which the
     * view model will be bound.
     */
    export interface RequiresHtmlTemplateOptions {
        /**
         * The HTML template to which the associated view model will be bound.  This can be either an HTML string or an HTML filename.
         */
        htmlTemplate: string;
    }
    /**
     * Shared by decorator options that accept a 'styleSheets' option.
     */
    export interface AcceptsStyleSheetsOptions {
        /**
         * The CSS style sheets containing styles used by HTML templates of this Blade/Part.
         */
        styleSheets?: string[];
    }
    export module Rebindable {
        /**
         * Passed to the view model's 'onRebind' method, reflecting the changes to the view model's parameters.
         */
        interface Changes {
            /**
             * The keys of those view model parameters whose values have changed.
             */
            parameterKeys: string[];
        }
    }
    export module Configurable {
        /**
         * Options supplied to the @Configurable decorator.  Used to supply metadata describing the Blade/Part's settings.
         */
        interface Options {
            /**
             * Metadata describing the settings that will be persisted for this Blade/Part.
             */
            settings?: {
                /**
                 * The scope at which the settings will be persisted.  If not supplied, a default value of 'PerPartOrBladeType' will be
                 * used.
                 */
                scope?: SettingsScope;
                /**
                 * A StringMap of metadata describing individual settings that will be persisted.
                 */
                metadata?: {
                    [key: string]: SettingMetadata;
                };
            };
        }
        /**
         * Metadata describing one setting of the Blade/Part's persisted settings.
         */
        interface SettingMetadata {
            /**
             * Specifies whether this setting is one that can be shared across different Part and Blade types (that is, isn't used by a
             * single Part or Blade type).  If not supplied, a default value of 'false' will be used.
             */
            isSharedAcrossPartAndBladeTypes?: boolean;
            /**
             * When 'isSharedAcrossPartAndBladeTypes' is 'true', this is the key under which the setting will be saved.  This key will
             * be used in the different Parts and Blades that share the setting value.
             */
            sharedKey?: string;
        }
        /**
         * The scope at which the Blade/Part's settings are persisted.
         */
        const enum SettingsScope {
            /**
             * The settings are saved under a single key for all instances of the associated Blade/Part.
             */
            PerPartOrBladeType = 0,
            /**
             * The settings are saved under a discrete key for each 'id' with which the associated Blade/Part
             * is rendered.  For instance, the 'Freezing Fog' website would have different settings values than those of the
             * 'Jasmine Dancer' website on the 'WebsiteDetails' Blade.
             */
            PerId = 1
        }
        /**
         * Context injected by the FX into the view model.  This context will include a 'configuration' (the
         * Blade/Part's configuration API) as well as 'parameters' and 'settings' (the
         * Blade/Part's persisted settings values).
         */
        interface Context<TSettings> {
            /**
             * The persisted settings values.
             */
            settings: TSettings;
        }
    }
    /**
     * The @ProxiedMember decorator.  Identifies a public member of a Blade/Part class that is to be proxied for use in the view.
     * This decorator is not necessary in most scenarios.
     * This decorator suppresses any compile-time errors that state "The '<MEMBER>' member is public and is not bound to the Blade/Part's view."
     */
    export function ProxiedMember(target: Object, key: string): void;
    /**.
     * The Part 'Container' API for all variations of Parts. It's through this API that extensions
     * can interact with the Part's chrome UI.
     */
    export type AnyContainer = BladeBase.AnyBladeContainer | PartBase.AnyPartContainer;
}

// FILE: Fx\Controls\Accordion.d.ts
declare module "Fx/Controls/Accordion" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring an accordion control
     */
    export interface Options {
        /**
         * Specifies whether the user can open multiple sections or not.
         * Set to false by default.
         * If canExpandMultipleSections = false and > 1 sections are initialized with `expanded = true`, only the 1st section will be expanded
         */
        canExpandMultipleSections?: boolean;
        /**
         * Specifies whether the user can make all the sections be closed at once. Allows collapsing the active section.
         * Set to false by default.
         * If canCollapseAllSections = false and no section is initialized with `expanded = true`, will expand the 1st section.
         *
         * 'canExpandMultipleSections' and 'canCollapseAllSections' used together exhibit the following behavior:
         * canExpandMultipleSections = true ; canCollapseAllSections = true ;  =>  Expand / collapse with no limitations.
         * canExpandMultipleSections = true ; canCollapseAllSections = false;  =>  At least one section expanded, can have more than one sections expanded.
         * canExpandMultipleSections = false; canCollapseAllSections = true ;  =>  At most one section expanded, can have all sections collapsed.
         * canExpandMultipleSections = false; canCollapseAllSections = false;  =>  Always have exact one section expanded.
         */
        canCollapseAllSections?: boolean;
        /**
         * Disabled state
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Visibility of the control
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Styling for the control
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * No border style for Accordion. Set to false by default.
         */
        noFxPadding?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sections for your accordion control.
         */
        sections: Section[] | KnockoutObservableArray<Section>;
    }
    /**
     * The interface that defines the viewmodel that respresents an Accordion.
     */
    export interface Contract extends Control {
        /**
         * Disabled state
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Visibility of the control
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Styling for the control
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Aria label for control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * No border style for Accordion. Set to false by default.
         */
        readonly noFxPadding: KnockoutObservableBase<boolean>;
        /**
         * Sections for your accordion control.
         */
        readonly sections: KnockoutObservableArray<Section>;
    }
    /**
     * Creates an Accordion control viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the accordion.
     * @returns an Accordion viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    /**
     * Options for a Section in Accordion control
     */
    export interface SectionOptions {
        /**
         * The open / collapse status of the section, Default is false.
         */
        expanded?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Header title for your section.
         * Can be a HTML template.
         */
        title: string | Control | HtmlContent | KnockoutObservableBase<string | Control | HtmlContent>;
        /**
         * Content for your section.
         * Can also be a HTML template.
         * Can be a Promise.
         */
        content: string | Control | HtmlContent | KnockoutObservableBase<string | Control | HtmlContent> | Promise<string | HtmlContent>;
    }
    /**
     * The interface that defines the viewmodel that respresents a Section.
     */
    export interface Section {
        /**
         * The open / collapse status of the section
         */
        readonly expanded: KnockoutObservableBase<boolean>;
        /**
         * Header title for your section.
         */
        readonly title: KnockoutObservableBase<string | Control | HtmlContent>;
        /**
         * Content for your section.
         */
        readonly content: KnockoutObservableBase<string | Control | HtmlContent>;
    }
    /**
     * Creates a Section viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Section.
     * @returns a Section viewmodel
     */
    export function createSection(lifetime: MsPortalFx.Base.LifetimeManager, options: SectionOptions): Section;
}

// FILE: Fx\Controls\AreaChart.d.ts
declare module "Fx/Controls/AreaChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export import ChartEvents = ChartBase.ChartEvents;
    export import ConditionOperator = ChartBase.ConditionOperator;
    export import Interpolation = ChartBase.Interpolation;
    export import RenderingCondition = ChartBase.RenderingCondition;
    export { FxChartColorClass };
    /**
     * Supported area chart types.
     */
    export const enum AreaChartType {
        /**
         * Overlapping area chart
         */
        Overlapped = 0,
        /**
         * Stacked area chart.
         */
        Stacked = 1
    }
    /**
     * Display options for showing the line and data points for stacked area charts.
     */
    export const enum LineState {
        /**
         * Display stacked area chart line with coordinate points.
         */
        ShowLineWithPoints = 0,
        /**
         * Hide stacked area chart line.
         */
        HideLine = 1,
        /**
         * Display stacked area chart line with the point nearest to x slider only.
         */
        ShowLineWithXHoverPoint = 2
    }
    /**
     * View options to customize how series should be displayed.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Defines the hatching pattern type for the series.
         * Default is solid color without any hatch patterns.
         */
        readonly areaHatchingPattern?: Pattern;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        readonly renderingConditions?: RenderingCondition[];
        /**
         * Indicates if the series is selectable.
         * By default, the area is selectable and selectable styling is shown. To disallow selecting the area, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the area is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Defines the interpolation type for the series.
         * By default the interpolation is Linear and the data points will be connected by straight lines.
         */
        readonly interpolation?: Interpolation;
        /**
         * Indicates if the series is hidden from the legend.
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Options for configuring a AreaChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis properties of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis properties of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specify if area chart should be stacked or overlapped.
         */
        readonly areaChartType?: AreaChartType | KnockoutObservableBase<AreaChartType>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking area charts.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Whether to show lines for the StackedArea charts.
         */
        readonly lineState?: LineState | KnockoutObservableBase<LineState>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the area chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * AreaChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics: KnockoutObservableBase<boolean>;
        /**
         * Specify if area chart should be stacked or overlapped.
         */
        readonly areaChartType: KnockoutObservableBase<AreaChartType>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking area charts.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries: KnockoutObservableBase<boolean>;
        /**
         * Whether to show lines for the StackedArea charts.
         */
        readonly lineState: KnockoutObservableBase<LineState>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the area chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @returns A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Promise<void>;
    }
    /**
     * Creates a AreaChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a AreaChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\ArmErrorList.d.ts
declare module "Fx/Controls/ArmErrorList" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The data contract for errors coming from ARM.
     */
    export interface ArmError {
        /**
         * The error code.
         */
        code?: string;
        /**
         * The error message.
         */
        message?: string;
        /**
         * The target of the error. Typically, this is a ARM resource name.
         */
        target?: string;
        /**
         * The nested ARM errors.
         */
        details?: ArmError[];
        /**
         * The additional information.
         */
        additionalInfo?: ErrorDetails[];
        /**
         * Optional custom HTML view for the error. If supplied, the control will display the view as it is for the error.
         * This is useful when the extension needs to show the error formatted in a custom way.
         */
        customHtml?: HtmlContent;
        /**
         * The recommended action.
         * This property is not defined in ARM error contract, but some errors contain this.
         */
        recommendedAction?: string;
    }
    /**
     * The error type and information.
     */
    export interface ErrorDetails {
        /**
         * The error type.
         */
        type: string;
        /**
         * The details of error type.
         */
        info?: any;
    }
    /**
     * Error specific options.
     */
    export interface ErrorOptions {
        /**
         * Options for policy error.
         */
        readonly policyError: PolicyErrorOptions;
    }
    /**
     * Options for policy error.
     */
    export interface PolicyErrorOptions {
        /**
         * Main error target. Used to deduplicate policy errors when errors have multiple targets.
         */
        readonly mainTarget?: string;
        /**
         * Callback when the link to policy assignment is clicked.
         */
        readonly onViewPolicyAssignmentClick?: (policyAssignmentId: string) => void;
    }
    /**
     * Options for configuring a ArmErrorList control.
     */
    export interface Options {
        /**
         * The ARM error.
         */
        readonly error: ArmError | KnockoutReadOnlyObservable<ArmError>;
        /**
         * Error specific options.
         */
        readonly errorOptions?: ErrorOptions;
        /**
         * The value indicating whether the root error needs to be hidden or not. The root error is the top error in the given error object.
         * The default value is false.
         */
        readonly hideRootError?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the copy button needs to be hidden or not.
         * The default value is false.
         */
        readonly hideCopyButton?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the feedback area needs to be hidden or not.
         * The default value is false.
         */
        readonly hideFeedback?: boolean;
        /**
         * The value indicating whether the error details need to show only leaf errors or not.
         * The default value is false.
         */
        readonly showLeafErrorsOnly?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ArmErrorList control view model.
     */
    export interface Contract extends Control {
        /**
         * The ARM  error.
         * This property is read-only. To mutate, change the value of the error property provided in the ArmErrorList options.
         */
        readonly error: KnockoutReadOnlyObservable<ArmError>;
        /**
         * The value indicating whether the root error needs to be hidden or not. The root error is the top error in the given error object.
         * The default value is false.
         */
        readonly hideRootError: KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the copy button needs to be hidden or not.
         * The default value is false.
         */
        readonly hideCopyButton: KnockoutObservableBase<boolean>;
        /**
         * The value indicating whether the error details need to show only leaf errors or not.
         * The default value is false.
         */
        readonly showLeafErrorsOnly: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a ArmErrorList control.
     *
     * @param lifetime The lifetime manager for the ArmErrorList control.
     * @param options The options for creating the ArmErrorList control.
     * @returns The created ArmErrorList control.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\BarChart.d.ts
declare module "Fx/Controls/BarChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export { FxChartColorClass };
    /**
     * Supported bar chart types.
     */
    export const enum BarChartType {
        /**
         * The data series will be rendered as stacked bars for each x value.
         */
        Stacked = 0,
        /**
         * The data series will be rendered as grouped bars for each x value.
         */
        Grouped = 1
    }
    /**
     * Defines the date span used for spacing the bars.
     */
    export interface DateSpanOptions {
        /**
         * The number of years in the span.
         */
        readonly years?: number;
        /**
         * The number of months in the span.
         */
        readonly months?: number;
        /**
         * The number of days in the span.
         */
        readonly days?: number;
        /**
         * The number of hours in the span.
         */
        readonly hours?: number;
        /**
         * The number of minutes in the span.
         */
        readonly minutes?: number;
        /**
         * The number of seconds in the span.
         */
        readonly seconds?: number;
        /**
         * The number of milliseconds in the span.
         */
        readonly milliseconds?: number;
    }
    /**
     * This base interface defines how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Indicates if the series is selectable.
         * By default, the bar is selectable and selectable styling is shown. To disallow selecting the bar, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the bar is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         *
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         *
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
    }
    /**
     * Options for configuring a BarChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics?: boolean | KnockoutObservableBase<boolean>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A padding ratio which is relative to bar size. The ratio will be used to specify padding between two bars and the bar width.
         */
        readonly barPaddingRatio?: number | KnockoutObservableBase<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        readonly barChartType?: BarChartType | KnockoutObservableBase<BarChartType>;
        /**
         * The span for the x-axis. For bar chart with close data points, bars may over lap. A granular span can be specified to avoid bar overlaps.
         */
        readonly xAxisSpan?: DateSpanOptions | KnockoutObservableBase<DateSpanOptions>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the bar chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * BarChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics: KnockoutObservableBase<boolean>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        readonly enableSparseSeries: KnockoutObservableBase<boolean>;
        /**
         * A padding ratio which is relative to bar size. The ratio will be used to specify padding between two bars and the bar width.
         */
        readonly barPaddingRatio: KnockoutObservableBase<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        readonly barChartType: KnockoutObservableBase<BarChartType>;
        /**
         * The span for the x-axis. For bar chart with close data points, bars may over lap. A granular span can be specified to avoid bar overlaps.
         */
        readonly xAxisSpan: KnockoutObservableBase<DateSpanOptions>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the bar chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @returns A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Promise<void>;
    }
    /**
     * Creates a BarChart control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a BarChart control viewmodel.
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\BaseResourceDropDown.d.ts
declare module "Fx/Controls/BaseResourceDropDown" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { CustomV, Required } from "Fx/Controls/Validations";
    import { Contract as DropDownContract, Options as DropDownOptionsContract } from "Fx/Controls/DropDown";
    import { Item as MarketplaceItem } from "Fx/ResourceManagement/Marketplace";
    import { Location as ArmLocation, ResourceGroup as ArmResourceGroup } from "Fx/ResourceManagement";
    export = Main;
    module Main {
        import FxAzure = MsPortalFx.Azure;
        /**
         * The validations accepted by the resource dropdowns.
         */
        type Validation<TValue> = CustomV<TValue> | Required;
        /**
         * Interface for grouping with text group headers.
         */
        interface Group<TValue, THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> {
            /**
             * A function which takes an item and returns the display name of the group it will belong to.
             *
             * @param item An object of the type for this dropdown.
             * @returns The display name for the group it belongs to. If empty, item will be on top level of the dropdown.
             */
            map: (item: TValue) => THtmlKeyMap extends StringMap<HtmlContent> ? keyof THtmlKeyMap : string;
            /**
             * A comparator to display the groups in the order desired (does not sort values within groups).
             */
            sort?: Comparator<THtmlKeyMap extends StringMap<HtmlContent> ? keyof THtmlKeyMap : string>;
            /**
             * A StringMap used to look up HtmlContent object for each of the groups returned from the map function.
             */
            mapToHtml?: THtmlKeyMap;
        }
        /**
         * The options accepted by all resource dropdowns.
         */
        interface Options<TValue, THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends Pick<DropDownOptionsContract<TValue>, "cssClass" | "label" | "ariaLabel" | "filter" | "filterPlaceholder" | "placeholder" | "suppressDirtyBehavior" | "infoBalloonContent" | "infoBalloonAriaLabel" | "subLabel" | "visible"> {
            /**
             * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
             */
            value?: TValue | KnockoutObservableBase<TValue>;
            /**
             * Validations on the control.
             */
            validations?: Validation<TValue>[] | KnockoutObservableBase<Validation<TValue>[]>;
            /**
             * An object which will hide values.
             */
            hiding?: {
                /**
                 * A callback for to determine if an item is hidden.
                 *
                 * @param item An object of the type for this dropdown.
                 * @returns A flag for if the item should be hidden.
                 */
                hide(item: TValue): boolean;
                /**
                 * A message explaining why values are hidden.
                 */
                reason: string;
            };
            /**
             * An object which will map values to groups and sort the groups.
             */
            grouping?: Group<TValue, THtmlKeyMap>;
            /**
             * A callback which will disable an item if a reason is returned to disable it.
             * Values will be grouped by the reason the item is disabled.
             *
             * @param item An object of the type for this dropdown.
             * @returns The reason this item is disabled. If empty the item will be enabled.
             */
            disable?(item: TValue): string;
            /**
             * A comparator to display the values in the order desired (does not sort groups if you have any, will sort within groups).
             */
            sort?: Comparator<TValue>;
            /**
             * A function called which will be passed a readonly array of values when fetched.
             */
            onFetchedValues?: (fetchedValues: TValue[]) => void;
        }
        /**
         * The contract all resource dropdowns fulfill
         */
        interface Contract<TValue> extends Control, Pick<DropDownContract<TValue>, "cssClass" | "dirty" | "valid" | "label" | "validationResults" | "disabled" | "triggerValidation" | "loading" | "subLabel"> {
            /**
             * the value of the control.
             */
            readonly value: KnockoutObservableBase<TValue>;
            /**
             * validations on the control.
             */
            readonly validations: KnockoutObservableArray<Validation<TValue>>;
            /**
             * The available values for the control.
             */
            readonly fetchedValues: KnockoutReadOnlyObservableArray<TValue>;
        }
        /**
         * Subscription dropdown interfaces.
         */
        module Subscription {
            import FxGalleryItem = MsPortalFx.Services.Gallery.GalleryItem;
            import ResourceManager = FxAzure.ResourceManager;
            import RequiredPermissions = FxAzure.RequiredPermissions;
            import Subscription = FxAzure.Subscription;
            /**
             * Options for the legacy dropdown which doesn't have the property initialSubscriptionId.
             */
            interface BaseOptions<THtmlKeyMap extends StringMap<HtmlContent>> extends Main.Options<Subscription, THtmlKeyMap> {
                /**
                 * The gallery item to validate against.
                 */
                filterByGalleryItem?: FxGalleryItem | ResourceManager.GalleryItemExtract | MarketplaceItem<any> | KnockoutObservableBase<FxGalleryItem | ResourceManager.GalleryItemExtract | MarketplaceItem<any>>;
                /**
                 * The list of required permissions the subscription must have. (If you need to check.
                 * for resource provider registration permissions, use the 'resourceProviders' option.
                 * instead.)
                 */
                requiredPermissions?: RequiredPermissions | KnockoutObservableBase<RequiredPermissions>;
                /**
                 * A list of resource providers that the
                 * subscription needs to be registered with. Providing the list will NOT register
                 * the subscription with the resource provider, but will only check if the user has
                 * the necessary permissions to register them (only if they aren't registered already).
                 */
                resourceProviders?: string[] | KnockoutObservableBase<string[]>;
            }
            /**
             * Options for the subscription dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial subscription id to be set as a default value for the dropdown if it's a member of the values fetched from ARM.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.subscriptionIds`.
                 * If an array is passed here, the first item in the array which is is a member of the values fetched from ARM will be used.
                 */
                initialSubscriptionId: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Promise<Subscription[]>;
            }
            /**
             * This is the contract for the subscription dropdown.
             */
            interface Contract extends Main.Contract<Subscription> {
            }
        }
        /**
         * Location dropdown interfaces module.
         */
        module Location {
            import Subscription = FxAzure.Subscription;
            /**
             * Options for the legacy dropdown which doesn't have properties initialLocationName and subscriptionId
             */
            type BaseOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = Main.Options<ArmLocation, THtmlKeyMap>;
            /**
             * Options for the location dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial location name to be set as a default value for the dropdown if it's a member of the values fetched from ARM.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.locationNames`.
                 * If an array is passed here, the first item in the array which is is a member of the values fetched from ARM will be used.
                 */
                initialLocationName: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * The subscription used to look up available locations if provided.
                 * Otherwise, defaults to locations available to the current tenant.
                 */
                subscriptionId?: KnockoutObservableBase<string | Subscription>;
                /**
                 * The scope used to look up available locations if subscriptionId is not provided.
                 * Defaults to locations available to the current tenant.
                 */
                scope?: KnockoutObservableBase<string>;
                /**
                 * Optional. The observable that holds the list of resource types used to filter locations.
                 */
                resourceTypes?: string[] | KnockoutObservableBase<string[]>;
                /**
                 * Optional. Enable Edge Zone locations.
                 * This adds a link to the Edge Zones in the sublabel of the dropdown.
                 * Edge locations are smaller footprints of Azure closer to the end user for customers
                 * deploy latency sensitive applications. Check with your resource providers to see
                 * if they support Edge Zone locations
                 */
                enableEdgeLocations?: boolean;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Promise<ArmLocation[]>;
            }
            /**
             * Options for the location dropdown with additional locations.
             */
            interface CustomOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends Options<THtmlKeyMap> {
                /**
                 * A callback to customize which locations are in the dropdown.
                 *
                 * @param locs The locations retrieved from ARM.
                 * @returns A list of locations to be displayed in the dropdown.
                 */
                customizeItems?: (locs: ArmLocation[]) => ArmLocation[];
            }
            /**
             * This is the contract for the location dropdown.
             */
            interface Contract extends Main.Contract<ArmLocation> {
            }
        }
        /**
         * ResourceGroup dropdown interfaces module.
         */
        module ResourceGroup {
            import RequiredPermissions = FxAzure.RequiredPermissions;
            import Subscription = FxAzure.Subscription;
            /**
             * The modes possible for the dropdown.
             */
            const enum Mode {
                UseExisting = 0,
                CreateNew = 1,
                Both = 2
            }
            /**
             * The mode of the value returned by the control
             */
            type SelectedMode = Mode.CreateNew | Mode.UseExisting;
            /**
             * The ARM resource group value.
             */
            type ResourceGroup = ArmResourceGroup;
            /**
             * The value of the resource group dropdown.
             */
            interface Value {
                /**
                 * The mode of the dropdown, create new or use existing.
                 */
                mode: SelectedMode;
                /**
                 * The ARM value for the resource group.
                 */
                value: ResourceGroup;
            }
            /**
             * Options for the resource group dropdown.
             */
            interface Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends BaseOptions<THtmlKeyMap> {
                /**
                 * The initial resourceGroupId to be set as a default value for the dropdown if it's an existing resource group in the dropdown.
                 * Create Blades will receive this value on the blades context e.g. `this.context.provisioning.initialValues.resourceGroupNames`.
                 * If an array is passed, will select the first available in the list.
                 */
                initialResourceGroupName?: string | string[] | KnockoutObservableBase<string | string[]>;
                /**
                 * The subscription used to look up available resource groups.
                 */
                subscriptionId: KnockoutObservableBase<string | Subscription>;
                /**
                 * A custom fetch callback to replace the network call for loading items into the dropdown.
                 */
                customFetch?(): Promise<ResourceGroup[]>;
                /**
                 * If true, the control will shift to the right with a line indicating a parent/child relationship with the item above it. Defaults to false.
                 * This option overrides any class provided in the cssClass option.
                 */
                nested?: boolean;
            }
            /**
             * Options for the legacy dropdown (which doesn't have 'initialResourceGroupName' and 'subscriptionId' properties).
             */
            interface BaseOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> extends Main.Options<Value, THtmlKeyMap> {
                /**
                 * The list of required permissions the subscription must have.
                 */
                requiredPermissions?: RequiredPermissions | KnockoutObservableBase<RequiredPermissions>;
                /**
                 * The mode allowed for the resource group dropdown.
                 */
                allowedMode?: Mode | KnockoutObservableBase<Mode>;
                /**
                 * Sets the placeholder.
                 * Default is blank.
                 */
                createNewPlaceholder?: string | KnockoutObservableBase<string>;
            }
            /**
             * This is the contract for the resource group dropdown.
             */
            interface Contract extends Main.Contract<Value> {
                /**
                 * Set which mode the dropdown is in, create or use existing.
                 */
                switchMode(mode?: SelectedMode): void;
            }
        }
    }
}

// FILE: Fx\Controls\Batch\HeatMap.d.ts
declare module "Fx/Controls/Batch/HeatMap" {
    /**
     * Represent an item in the heatMap
     */
    export interface Item {
        /**
         * Id of an item in the heatmap. This NEED to be unique.
         */
        id: string;
        /**
         * State of the item
         */
        state: string;
        /**
         * Optional setting to make the item less opaque on the heatmap.
         * Default: 1
         */
        opacity?: number;
    }
    /**
     * Possible position of the legend relative to the heatmap.
     * i.e. LegendLocation.Left means the legend will be on the left of the heatmap.
     *
     * LegendLocation.None will not show the legend
     */
    export enum LegendLocation {
        None = 0,
        Top = 1,
        Right = 2,
        Bottom = 3,
        Left = 4
    }
    /**
     * Represent a possible state an item can have
     */
    export interface State {
        /**
         * State id, Item added to the Heatmap should have their state match this id
         */
        id: string;
        /**
         * Label for the legend
         */
        label: KnockoutObservableBase<string>;
        /**
         * Color the tile with this state will have
         */
        color: MsPortalFx.ColorUtil.ColorCode;
        /**
         * Color opacity
         *
         * @default 1
         */
        opacity?: number;
    }
    export interface Options {
        /**
         * Message to be displayed in the heatmap if the item list is empty
         */
        noItemsMessage?: KnockoutObservableBase<string>;
        /**
         * List of available states. Every state that might be used in an item later on should be here.
         */
        states?: State[];
        /**
         * When one of the item has a state not defined in the lis_t above it will use this color
         */
        unknownStateColor?: MsPortalFx.ColorUtil.ColorCode;
        /**
         * Enable selection on the heatmap
         *
         * @default true
         */
        isSelectable?: boolean;
        /**
         * If the heatmap control should expand automatically if the number of items don't fit in the initial window
         *
         * @default false
         */
        isExpandable?: boolean;
        /**
         * Minimum number of pixel a tile side can be in the heatmap
         * Cannot be less that 1
         *
         * @default 10
         */
        minTileSize?: number;
        /**
         * Maximum number of pixel a tile side can be in the heatmap
         *
         * @default 100
         */
        maxTileSize?: number;
        /**
         * Legend location relative to the heatmap.
         * None will not show the legend.
         *
         * @default Right
         */
        legendLocation?: KnockoutObservableBase<LegendLocation>;
    }
    export interface ItemListDiff {
        added: Item[];
        updated: Item[];
        removed: Item[];
    }
    export class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel {
        states: State[];
        unknownStateColor: MsPortalFx.ColorUtil.ColorCode;
        noItemsMessage: KnockoutObservableBase<string>;
        errorMessage: string;
        minTileSize: number;
        maxTileSize: number;
        /**
         * Enable selection on the heatmap
         *
         * @default true
         */
        isSelectable: boolean;
        /**
         * If the heatmap control should expand automatically if the number of items don't fit in the initial window
         *
         * @default false
         */
        isExpandable: boolean;
        /**
         * Cache of the items used to compute the edits
         */
        private itemMap;
        /**
         * Legend location relative to the heatmap.
         * None will not show the legend.
         *
         * @default Right
         * @see LegendOptions
         */
        legendLocation: KnockoutObservableBase<LegendLocation>;
        /**
         * Internal mapping of state by ID.
         * Used in the widget.
         */
        stateMap: StringMap<State>;
        /**
         * Internal callback that will pass the difference of items everytime setItems is called
         */
        _msPortalFxUpdateCallback: KnockoutObservable<(diffs: ItemListDiff) => void>;
        /**
         * Internal update to ask for a canvas redraw
         */
        _msPortalFxUpdateCanvas: KnockoutObservableBase<number>;
        /**
         * Observable containing the currently selected item.
         * Seleletable must be set to true in the options for this to be updated
         */
        selectedItem: KnockoutObservable<Item>;
        selectable: MsPortalFx.ViewModels.Selectable<Item>;
        /**
         * Buffer for to keep the last setItems args until the implementation set the callback
         */
        private _lastItemsBuffer;
        private defaultOptions;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        setItems(items: Item[]): void;
        /**
         * Force a render of the heatmap.
         * Use this if you have enableAutoRendering to false.
         */
        render(): void;
        private _createStateMap;
        private _createItemMap;
        private _computeDifference;
    }
}

// FILE: Fx\Controls\Button.d.ts
declare module "Fx/Controls/Button" {
    import { BladeLink, ResourceLink, ClickableLink, OnClickHandler } from "Fx/Composition";
    import * as ControlBase from "Fx/Controls/ControlsBase";
    export import Image = ControlBase.Image;
    export import IconPosition = ControlBase.IconPosition;
    export import IconAndPosition = ControlBase.IconAndPosition;
    /**
     * Styling of the button
     */
    export const enum Style {
        /**
         * Primary button style (default).
         */
        Primary = 0,
        /**
         * Secondary button style.
         */
        Secondary = 1,
        /**
         * Danger button style.
         */
        Danger = 2
    }
    /**
     * Options used to dynamically configure the button.
     */
    export interface Options {
        /**
         * Describes the behavior when the button is clicked.
         *
         * For non-navigation scenarios, a callback can be supplied.
         * For navigation scenarios, a modeled description of the navigation target can be supplied.
         * For navigation scenarios, the callback option should not be used,
         * as it breaks browser 'open in new tab' and 'copy link' support.
         */
        onClick: OnClickHandler | BladeLink | ResourceLink | ClickableLink;
        /**
         * The text shown on the button.
         */
        text: string | KnockoutObservableBase<string>;
        /**
         * The style of the button.
         */
        style?: Style | KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The alternate text for screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Loading text message.
         */
        loadingText?: string | KnockoutObservableBase<string>;
        /**
         * Icon shown in the button.
         */
        icon?: IconAndPosition | KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Button control.
     */
    export interface Contract extends ControlBase.Control {
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The text shown on the button.
         */
        readonly text: KnockoutObservableBase<string>;
        /**
         * The style of the button (Primary / Secondary).
         */
        readonly style: KnockoutObservableBase<Style>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The alternate text for screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Loading status.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Loading text message.
         */
        readonly loadingText: KnockoutObservableBase<string>;
        /**
         * Icon shown in the button.
         */
        readonly icon: KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Creates a button control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a button viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ChartBase.d.ts
declare module "Fx/Controls/ChartBase" {
    import { Contract as InfoBalloonContract } from "Fx/Controls/InfoBalloon";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    /**
     * Defines hatching patterns.
     */
    export const enum HatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is hatched with main diagonal (\) thin lines. Alternate name aligning with new enums - CounterDiagonalThinLine.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched with horizontal think lines. Alternate name aligning with new enums - HorizontalThickLine
         */
        DottedHatching = 3,
        /**
         * The area is hatched with main diagonal (\) thin lines.
         */
        MainDiagonalThinLine = 4,
        /**
         * The area is hatched with horizontal thin lines.
         */
        HorizontalThinLine = 5,
        /**
         * The area is hatched with vertical thin lines.
         */
        VerticalThinLine = 6,
        /**
         * The area is hatched with main diagonal (\) thick lines.
         */
        MainDiagonalThickLine = 7,
        /**
         * The area is hatched with counter diagonal (/) thick lines.
         */
        CounterDiagonalThickLine = 8,
        /**
         * The area is hatched with vertical thick lines.
         */
        VerticalThickLine = 9,
        /**
         * The area is hatched with main diagonal (\) lines in a smoothed out pattern.
         */
        MainDiagonalSmoothLine = 10,
        /**
         * The area is hatched with counter diagonal (/) lines in a smoothed out pattern.
         */
        CounterDiagonalSmoothLine = 11,
        /**
         * The area is hatched with horizontal lines in a smoothed out pattern.
         */
        HorizontalSmoothLine = 12,
        /**
         * The area is hatched with vertical lines in a smoothed out pattern.
         */
        VerticalSmoothLine = 13,
        /**
         * The area has square pattern.
         */
        Square = 14,
        /**
         * The area has diagonal square pattern.
         */
        DiagonalSquare = 15,
        /**
         * The area has circle pattern.
         */
        Circle = 16,
        /**
         * The area has quarter circle(quadrant) pattern.
         */
        Quadrant = 17
    }
    /**
     * Specifies the scale used on the axis.
     */
    export const enum Scale {
        /**
         * Specify this scale for discrete values where the values will be mapped 1:1 on the axis.
         */
        Ordinal = 0,
        /**
         * Specify this scale for continuous values like numeric values in the series which may or may not be sorted.
         */
        Linear = 1,
        /**
         * Specify this scale for date / time values in the series which may or may not be sorted.
         */
        Time = 2,
        /**
         * Logarithmic scale for numeric values
         */
        Log = 3
    }
    /**
     * Specifies conditions checked on rendering a series view.
     */
    export const enum ConditionOperator {
        /**
         * The view should be rendered for series segments exceeding the argument of the condition.
         */
        GreaterThan = 0,
        /**
         * The view should be rendered for series segments not exceeding the argument of the condition.
         */
        LessThan = 1
    }
    /**
     * Defines interpolation of lines of the line chart.
     */
    export const enum Interpolation {
        /**
         * The series interpolation when data points are connected by straight lines.
         */
        Linear = 0,
        /**
         * The series interpolation when data points are connected by smooth curves. The monotone is a mode of D3 interpolation style.
         */
        Monotone = 1,
        /**
         * The series interpolation when series are connected by two lines: the first one (from the left side) is horizontal and the second one is vertical.
         */
        StepAfter = 2
    }
    /**
     * Specifies the aggregation type of a metric rule.
     */
    export const enum MetricRuleAggregationType {
        /**
         * X-value of the point selected.
         */
        CurrentXValue = 0,
        /**
         * Y-value of the point selected.
         */
        CurrentYValue = 1,
        /**
         * Min of y-value of points selected.
         */
        MinY = 2,
        /**
         * Max of y-value of points selected.
         */
        MaxY = 3,
        /**
         * Average of y-value of points selected.
         */
        AverageY = 4,
        /**
         * Sum of y-value of points selected.
         */
        SumY = 5,
        /**
         * Count of points selected.
         */
        Count = 6,
        /**
         * Custom value.
         */
        CustomValue = 7
    }
    /**
     * Specifies the aggregation scope of a metric rule.
     */
    export const enum MetricRuleAggregationScope {
        /**
         * All selected series should be aggregated into a common metric.
         */
        AllTogether = 0,
        /**
         * All selected series should be aggregated with separate metrics.
         */
        AllSeparately = 1,
        /**
         * A metric should be aggregated over a single series.
         */
        SingleSeries = 2
    }
    /**
     * Specifies the scope of metrics rules.
     */
    export const enum MetricRuleScope {
        /**
         * The default scope if other rules are not specified.
         */
        Default = 0,
        /**
         * A single data point is in the scope.
         */
        Point = 2,
        /**
         * Multiple data points from the same series are in the scope.
         */
        MultiplePointsSingleSeries = 3,
        /**
         * Multiple data points from multiple series are in the scope.
         */
        MultiplePointsMultipleSeries = 4
    }
    /**
     * Specifies the display options for a single metric.
     */
    export interface Metric {
        /**
         * Specifies the aggregation scope of the rule.
         */
        readonly aggregationScope: MetricRuleAggregationScope;
        /**
         * Specifies the aggregation of the rule.
         */
        readonly aggregationType: MetricRuleAggregationType;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        readonly aggregationSeriesName?: string;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        readonly showBarColor?: boolean;
        /**
         * Specifies the color css for the metric bar. If nothing is specified, the color css from the current aggregation series will be used.
         */
        readonly colorCode?: string | FxChartColorClass;
        /**
         * Specifies the hatching pattern for the metric bar. If nothing is specified, the hatching pattern from the current aggregation series will be used.
         */
        readonly hatchingPattern?: HatchingPattern;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions;
        /**
         * Specifies the metric title of the rule.
         */
        readonly title?: string;
        /**
         * Specifies the metric unit of the rule.
         */
        readonly unit?: string;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        readonly customValue?: KnockoutObservableBase<string>;
        /**
         * The default info balloon of the metric rule.
         */
        readonly defaultInfoBalloon?: InfoBalloonContract;
    }
    /**
     * Specifies options for defining a metric rule.
     */
    export interface MetricRule {
        /**
         * Specifies the scope of the rule.
         */
        readonly scope: MetricRuleScope;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        readonly scopeSeriesName?: string;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        readonly metrics: KnockoutObservableArray<Metric>;
    }
    export interface AxisOptions<T> {
        /**
         * Defines the type of the axis label.
         */
        readonly scale?: Scale | KnockoutObservableBase<Scale>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        readonly tickMarksCount?: number | KnockoutObservableBase<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        readonly showAxis?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        readonly showAxisLine?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        readonly showTickMarks?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        readonly showGridLines?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        readonly rotateLabel?: number | KnockoutObservableBase<number>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly xSliderFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly displayLabelFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly xSliderCalloutDisplayFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        readonly min?: T | KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        readonly max?: T | KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        readonly unit?: MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        readonly displaySIUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        readonly autoScaleUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        readonly labelPadding?: number | KnockoutObservableBase<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        readonly customAxisPadding?: number | KnockoutObservableBase<number>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        readonly reverseDomain?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        readonly hideAxisLabelsOnXSliderHover?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Axis<T> {
        /**
         * Defines the type of the axis label.
         */
        readonly scale: KnockoutObservableBase<Scale>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        readonly tickMarksCount: KnockoutObservableBase<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        readonly showAxis: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        readonly showAxisLine: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        readonly showTickMarks: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        readonly showGridLines: KnockoutObservableBase<boolean>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        readonly rotateLabel: KnockoutObservableBase<number>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        readonly xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly displayLabelFormatter: KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        readonly xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        readonly min: KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        readonly max: KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        readonly unit: KnockoutObservableBase<MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        readonly displaySIUnit: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        readonly autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        readonly labelPadding: KnockoutObservableBase<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        readonly customAxisPadding: KnockoutObservableBase<number>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        readonly reverseDomain: KnockoutObservableBase<boolean>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        readonly hideAxisLabelsOnXSliderHover: KnockoutObservableBase<boolean>;
    }
    /**
     * This interface defines a single data point for the chart.
     */
    export interface ChartItem<TX, TY> {
        /**
         * The X value for an item.
         */
        readonly xValue: TX;
        /**
         * The Y values for an item.
         */
        readonly yValue: TY;
    }
    /**
     * Specifies the condition used on rendering a series view.
     */
    export interface RenderingCondition {
        /**
         * The name of the series to be compared with.
         */
        readonly seriesName: string;
        /**
         * The condition operator.
         */
        readonly conditionOperator: ConditionOperator;
        /**
         * The interpolation for the series.
         */
        readonly interpolation: Interpolation;
    }
    /**
     * Specifies a array of selected chart items with in a series.
     */
    export interface SeriesSelection<TX, TY> {
        /**
         * Name of the series.
         */
        readonly seriesName: string;
        /**
         * The value of the selected chart item.
         */
        readonly values: ChartItem<TX, TY>[];
    }
    /**
     * Defines the event data associated with chart event notifications.
     */
    export interface EventData<TX, TY> {
        /**
         * Name of the series.
         */
        readonly seriesName: string;
        /**
         * The value of the current target element.
         */
        readonly value: ChartItem<TX, TY>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         *
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         *
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
        /**
         * Event handler for click on a series.
         *
         * Event callback.
         *
         * @param data EventData with clicked seriesName and optionally provides the x, y value if series was clicked on specific point.
         */
        readonly seriesClick?: (data: EventData<TX, TY>) => void;
    }
}

// FILE: Fx\Controls\ChartColor.d.ts
declare module "Fx/Controls/ChartColor" {
    /**
     * Supported chart color classes which represets color sequences with accessible contrast ratios.
     */
    export const enum FxChartColorClass {
        /**
         * DataViz - Color Slot 0
         *      Light theme - #637CEF
         *      Dark theme - #637CEF
         */
        Color0 = "msportalfx-chart-color-0",
        /**
         * DataViz - Color Slot 1
         *      Light theme - #E3008C
         *      Dark theme - #E3008C
         */
        Color1 = "msportalfx-chart-color-1",
        /**
         * DataViz - Color Slot 2
         *      Light theme - #2AA0A4
         *      Dark theme - #2AA0A4
         */
        Color2 = "msportalfx-chart-color-2",
        /**
         * DataViz - Color Slot 3
         *      Light theme - #9373C0
         *      Dark theme - #9373C0
         */
        Color3 = "msportalfx-chart-color-3",
        /**
         * DataViz - Color Slot 4
         *      Light theme - #13A10E
         *      Dark theme - #13A10E
         */
        Color4 = "msportalfx-chart-color-4",
        /**
         * DataViz - Color Slot 5
         *      Light theme - #3A96DD
         *      Dark theme - #3A96DD
         */
        Color5 = "msportalfx-chart-color-5",
        /**
         * DataViz - Color Slot 6
         *      Light theme - #CA5010
         *      Dark theme - #CA5010
         */
        Color6 = "msportalfx-chart-color-6",
        /**
         * DataViz - Color Slot 7
         *      Light theme - #57811B
         *      Dark theme - #57811B
         */
        Color7 = "msportalfx-chart-color-7",
        /**
         * DataViz - Color Slot 8
         *      Light theme - #B146C2
         *      Dark theme - #B146C2
         */
        Color8 = "msportalfx-chart-color-8",
        /**
         * DataViz - Color Slot 9
         *      Light theme - #AE8C00
         *      Dark theme - #AE8C00
         */
        Color9 = "msportalfx-chart-color-9",
        /**
         * DataViz - Color slot 10
         *      Light theme - #3c51b4
         *      Dark theme - #93A4F4
         */
        Color10 = "msportalfx-chart-color-10",
        /**
         * DataViz - Color slot 11
         *      Light theme - #AD006A
         *      Dark theme - #EE5FB7
         */
        Color11 = "msportalfx-chart-color-11",
        /**
         * DataViz - Color slot 12
         *      Light theme - #026467
         *      Dark theme - #4CB4B7
         */
        Color12 = "msportalfx-chart-color-12",
        /**
         * DataViz - Color slot 13
         *      Light theme - #674C8C
         *      Dark theme - #A083C9
         */
        Color13 = "msportalfx-chart-color-13",
        /**
         * DataViz - Color slot 14
         *      Light theme - #0E7A0B
         *      Dark theme - #27AC22
         */
        Color14 = "msportalfx-chart-color-14",
        /**
         * DataViz - Color slot 15
         *      Light theme - #2C72A8
         *      Dark theme - #4FA1E1
         */
        Color15 = "msportalfx-chart-color-15",
        /**
         * DataViz - Color slot 16
         *      Light theme - #9A3D0C
         *      Dark theme - #D77440
         */
        Color16 = "msportalfx-chart-color-16",
        /**
         * DataViz - Color slot 17
         *      Light theme - #405F14
         *      Dark theme - #73AA24
         */
        Color17 = "msportalfx-chart-color-17",
        /**
         * DataViz - Color slot 18
         *      Light theme - #863593
         *      Dark theme - #C36BD1
         */
        Color18 = "msportalfx-chart-color-18",
        /**
         * DataViz - Color slot 19
         *      Light theme - #6D5700
         *      Dark theme - #D0B232
         */
        Color19 = "msportalfx-chart-color-19",
        /**
         * DataViz - Color slot 20
         *      Light theme - #4F6BED
         *      Dark theme - #4F6BED
         */
        Color20 = "msportalfx-chart-color-20",
        /**
         * DataViz - Color slot 21
         *      Light theme - #EA38A6
         *      Dark theme - #EA38A6
         */
        Color21 = "msportalfx-chart-color-21",
        /**
         * DataViz - Color slot 22
         *      Light theme - #038387
         *      Dark theme - #038387
         */
        Color22 = "msportalfx-chart-color-22",
        /**
         * DataViz - Color slot 23
         *      Light theme - #8764B8
         *      Dark theme - #8764B8
         */
        Color23 = "msportalfx-chart-color-23",
        /**
         * DataViz - Color slot 24
         *      Light theme - #11910D
         *      Dark theme - #11910D
         */
        Color24 = "msportalfx-chart-color-24",
        /**
         * DataViz - Color slot 25
         *      Light theme - #3487C7
         *      Dark theme - #3487C7
         */
        Color25 = "msportalfx-chart-color-25",
        /**
         * DataViz - Color slot 26
         *      Light theme - #D06228
         *      Dark theme - #D06228
         */
        Color26 = "msportalfx-chart-color-26",
        /**
         * DataViz - Color slot 27
         * Light theme - #689920
         * Dark theme - #689920
         */
        Color27 = "msportalfx-chart-color-27",
        /**
         * DataViz - Color slot 28
         *      Light theme - #BA58C9
         *      Dark theme - #BA58C9
         */
        Color28 = "msportalfx-chart-color-28",
        /**
         * DataViz - Color slot 29
         *      Light theme - #937700
         *      Dark theme - #C19C00
         */
        Color29 = "msportalfx-chart-color-29",
        /**
         * DataViz - Color slot 30
         *      Light theme - #2C3C85
         *      Dark theme - #C8D1FA
         */
        Color30 = "msportalfx-chart-color-30",
        /**
         * DataViz - Color slot 31
         *      Light theme - #7F004E
         *      Dark theme - #F7ADDA
         */
        Color31 = "msportalfx-chart-color-31",
        /**
         * DataViz - Color slot 32
         *      Light theme - #02494C
         *      Dark theme - #9BD9DB
         */
        Color32 = "msportalfx-chart-color-32",
        /**
         * DataViz - Color slot 33
         *      Light theme - #4C3867
         *      Dark theme - #B29AD4
         */
        Color33 = "msportalfx-chart-color-33",
        /**
         * DataViz - Color slot 34
         *      Light theme - #0B5A08
         *      Dark theme - #A7E3A5
         */
        Color34 = "msportalfx-chart-color-34",
        /**
         * DataViz - Color slot 35
         *      Light theme - #20547C
         *      Dark theme - #83BDEB
         */
        Color35 = "msportalfx-chart-color-35",
        /**
         * DataViz - Color slot 36
         *      Light theme - #712D09
         *      Dark theme - #DF8E64
         */
        Color36 = "msportalfx-chart-color-36",
        /**
         * DataViz - Color slot 37
         *      Light theme - #23330B
         *      Dark theme - #A4CC6C
         */
        Color37 = "msportalfx-chart-color-37",
        /**
         * DataViz - Color slot 38
         *      Light theme - #63276D
         *      Dark theme - #CF87DA
         */
        Color38 = "msportalfx-chart-color-38",
        /**
         * DataViz - Color slot 39
         *      Light theme - #3A2F00
         *      Dark theme - #DAC157
         */
        Color39 = "msportalfx-chart-color-39",
        /** Color index sequence ends: Max chart color count = 40 */
        /** Status Colors */
        /**
         * Light theme - #015cda
         * Dark theme - #015cda
         */
        Info = "msportalfx-chart-color-info",
        /**
         * Light theme - #107c10
         * Dark theme - #54b054
         */
        Success = "msportalfx-chart-color-success",
        /**
         * Light theme - #f7630c
         * Dark theme - #f87528
         */
        Warning = "msportalfx-chart-color-warning",
        /**
         * Light theme - #c50f1f
         * Dark theme - #dc626d
         */
        Error = "msportalfx-chart-color-error",
        /**
         * Light theme - #dbdbdb
         * Dark theme - #4d4d4d
         */
        Disabled = "msportalfx-chart-color-disabled",
        /**
         * Light theme - #094509
         * Dark theme - #218c21
         */
        HighSuccess = "msportalfx-chart-color-highSuccess",
        /**
         * Light theme - #6e0811
         * Dark theme - #cc2635
         */
        HighError = "msportalfx-chart-color-highError"
    }
}

// FILE: Fx\Controls\CheckBox.d.ts
declare module "Fx/Controls/CheckBox" {
    import { HtmlContent, OverflowMode } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Overflow Mode for text overflow
     */
    export { OverflowMode };
    /**
     * Options for configuring a checkbox control.
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * if set to true, the label will be placed to the right of the control
         */
        labelOnRight?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        overflowMode?: OverflowMode | KnockoutObservableBase<OverflowMode>;
    }
    /**
     * CheckBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<boolean>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        readonly overflowMode: KnockoutObservableBase<OverflowMode>;
    }
    /**
     * Creates a checkbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a checkbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\ClipboardButton.d.ts
declare module "Fx/Controls/ClipboardButton" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ControlBase from "Fx/Controls/ControlsBase";
    export import IconAndPosition = ControlBase.IconAndPosition;
    /**
     * Item to be written to or read from the clipboard.
     */
    export interface ClipboardContent {
        /**
         * The type of the data to stored in the clipboard
         */
        typeName: string;
        /**
         * The data to be stored in the clipboard
         */
        data: unknown;
    }
    /**
     * The size of the button
     */
    export const enum ButtonSize {
        /** Normal sized button */
        Normal = 0,
        /** Slightly smaller button */
        Small = 1
    }
    /**
     *
     */
    interface ButtonOptions {
        /**
         * Tooltip for the clipboard button
         */
        readonly tooltip?: string | KnockoutObservable<string>;
        /**
         * The aria label to use instead of the default text label.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown on the button.
         */
        readonly text?: string | KnockoutObservable<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is visible.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Icon shown in the button.
         */
        readonly icon?: IconAndPosition | KnockoutObservableBase<IconAndPosition>;
        /**
         * Size of the button
         */
        readonly size?: ButtonSize;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        readonly telemetryName?: string;
    }
    /**
     * Options for configuring a Clipboard CopyButton control
     */
    export interface CopyButtonOptions extends ButtonOptions {
        /**
         * Called when the copy button is clicked, the value returned is written to the clipboard
         */
        readonly onClick: () => ClipboardContent | string;
    }
    /**
     * Options for configuring a Clipboard PasteButton control
     */
    export interface PasteButtonOptions extends ButtonOptions {
        /**
         * Called when the copy button is clicked, the value passed to this function is what has been read from the clipboard
         */
        readonly onClick: (values: ClipboardContent | string) => void;
    }
    /**
     * The viewmodel for the Clipboard CopyButton control.
     */
    export interface CopyButtonContract extends Control {
        /**
         * Tooltip for the button
         */
        readonly tooltip: KnockoutObservable<string>;
        /**
         * The aria label to use instead of the default text label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The button label
         */
        readonly text: KnockoutObservable<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: KnockoutObservableBase<string>;
    }
    /**
     * The viewmodel for the Clipboard PasteButton control.
     */
    export interface PasteButtonContract extends Control {
        /**
         * Tooltip for the button
         */
        readonly tooltip: KnockoutObservable<string>;
        /**
         * The aria label to use instead of the default text label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The button label
         */
        readonly text: KnockoutObservable<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: KnockoutObservableBase<string>;
    }
    /**
     * Creates an ClipboardButton control viewmodel used to copy to the clipboard.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The options to configure the ClipboardButton to copy to the clipboard.
     * @returns a ClipboardButton viewmodel
     */
    export function createCopyButton(lifetime: MsPortalFx.Base.LifetimeManager, options: CopyButtonOptions): CopyButtonContract;
    /**
     * Creates an ClipboardButton control viewmodel used to paste from the clipboard.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The options to configure the ClipboardButton to paste from the clipboard
     * @returns a ClipboardButton viewmodel
     */
    export function createPasteButton(lifetime: MsPortalFx.Base.LifetimeManager, options: PasteButtonOptions): PasteButtonContract;
    export {};
}

// FILE: Fx\Controls\ComboBox.d.ts
declare module "Fx/Controls/ComboBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { BaseOptions, BaseContract, Item, Group } from "Fx/Controls/DropDown";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Describes an Item used for items in the ComboBox.
     */
    export { Item };
    /**
     * Describes a Group used for items in the ComboBox.
     */
    export { Group };
    /**
     * ComboBox control options.
     */
    export interface Options<TValue> extends BaseOptions<TValue> {
        /**
         * Callback when the user types into the ComboBox.
         * The extension is responsible for populating the ComboBox content based on the user inputted string.
         *
         * While pending we add a loading icon into the ComboBox.
         */
        onFilter?: (value: string) => Promise<void>;
        /**
         * Boolean flag indicating whether to show the temporary, built-in, preview item; defaults to false.
         */
        hidePreviewItem?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ComboBox control view model.
     */
    export interface Contract<TValue> extends BaseContract<TValue> {
        /**
         * Boolean flag indicating whether to show the temporary, built-in, preview item; defaults to false.
         */
        readonly hidePreviewItem: KnockoutObservableBase<boolean>;
        /**
         * @deprecated 'multiItemDisplayText' is obsolete. Any value supplied for the 'multiItemDisplayText' property will be ignored since this control does not support multi-selection.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        readonly multiItemDisplayText: Obsolete;
    }
    /**
     * Creates a ComboBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a ComboBox control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\Console.d.ts
declare module "Fx/Controls/Console" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { LogItem, LogItemType } from "Fx/Controls/LogStream";
    export { LogItem, LogItemType };
    export interface Options {
        /**
         * Alternate text for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        prompt?: string | KnockoutObservableBase<string>;
        /**
         * callback called when the user enters input
         * console is the instance of the console created with these options, userInput is the string entered by the user
         */
        processCommand: (console: Contract, userInput: string) => void;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends Control {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Provides the text used for the CLI prompt.
         */
        readonly prompt: KnockoutObservableBase<string>;
        /**
         * Clears the console.
         */
        reset(): void;
        /**
         * Writes an entry to the console
         *
         * @param entry The text to show in the control.  Passing in a LogItem or array of LogItems allows you to control the level of entry (error, warning, etc.)
         */
        log(entry: string | string[] | LogItem | LogItem[]): void;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a Console control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Console control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ControlsBase.d.ts
declare module "Fx/Controls/ControlsBase" {
    /**
     * Enum that defines the type of the control.
     */
    export import ControlType = MsPortalFx.ViewModels.ControlType;
    /**
     * Contract identifying a control as something that can be created via the pcControl binding.
     */
    export interface Control {
        /**
         * Enum that defines the type of the control.
         */
        readonly controlType: ControlType;
    }
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export interface HtmlContent {
        /**
         * The HTML template to display
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        viewModel?: any;
    }
    /**
     * Overflow Mode for text overflow
     */
    export const enum OverflowMode {
        /**
         * Wrapping the overflow text
         */
        Wrap = 0,
        /**
         * Show Ellipsis for the overflow text
         */
        Ellipsis = 1
    }
    /**
     * Image interface
     */
    export import Image = MsPortalFx.Base.Image;
    /**
     * Icon position inside a button.
     */
    export const enum IconPosition {
        /**
         * The icon is positioned left of the button label.
         */
        Left = 0,
        /**
         * The icon is positioned right of the button label.
         */
        Right = 1
    }
    /**
     * Icon used for buttons
     */
    export interface IconAndPosition {
        /**
         * The image to use as an icon.
         */
        image: Image;
        /**
         * The position of the icon in the button.
         */
        position: IconPosition;
    }
}

// FILE: Fx\Controls\CopyableLabel.d.ts
declare module "Fx/Controls/CopyableLabel" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Styling of the button
     */
    export const enum Style {
        /**
         * Primary button style (default).
         */
        Primary = 0,
        /**
         * Secondary button style.
         */
        Secondary = 1
    }
    export interface Options {
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The readOnly property of the control.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Hides the textbox.  Used in scenarios where the copied text is not shown to the user.
         */
        hideTextbox?: boolean;
        /**
         * Style of the button. Secondary style can be applied only when the textBox is hidden.
         */
        style?: Style;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The number of lines in the textbox.
         */
        rows?: number;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The value of the TextBox.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        telemetryName?: string;
    }
    export interface Contract extends Control {
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The readOnly property of the control.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The label of the control.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The value of the TextBox.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a copyableLabel control viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\CustomHtml.d.ts
declare module "Fx/Controls/CustomHtml" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for creating a custom html form control
     */
    export interface Options {
        /**
         * The html template to display as the body of the form.
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        innerViewModel?: any;
        /**
         * Uses a new binding context for the template such that $root is innerViewModel instead of the blade/part view model.
         * Defaults to true.
         */
        isolated?: boolean;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * Custom html control viewmodel
     */
    export interface Contract extends Control {
        /**
         * The label of the control.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
    }
    /**
     * Creates a custom html control viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\DataGrid.d.ts
declare module "Fx/Controls/DataGrid" {
    import { Control, HtmlContent } from "Fx/Controls/ControlsBase";
    import { SelectionMode, SortDirection } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import { BladeReference, FxElement } from "Fx/Composition";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    export { 
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    HtmlContent, 
    /**
     * DataGrid selection mode.
     */
    SelectionMode, 
    /**
     * DataGrid sort direction.
     */
    SortDirection, };
    /**
     * DataGrid column sort order.
     */
    export interface SortOrder {
        /**
         * The column id.
         */
        id: string;
        /**
         * The sort direction.
         */
        direction: SortDirection;
    }
    /**
     * DataGrid cell definition.
     */
    export interface CellDefinitionBase<TItem> {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
    }
    /**
     * Text cell definition.
     */
    export interface TextCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies the text to display in the cell.
         *
         * @param item The data item,
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A string or a value that is convertible to string or an observable containing the value.
         */
        text: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * Text column definition.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinition<TItem> extends TextColumnDefinitionOptions<TItem> {
        /**
         * Text column definition type.
         * A column that displays text in each cell.
         */
        type: "Text";
    }
    /**
     * Text column definition options.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A Text cell definition.
         */
        cell: TextCellDefinition<TItem>;
    }
    /**
     * Template cell definition.
     */
    export interface TemplateCellDefinition<TItem, TViewModel = any> extends CellDefinitionBase<TItem> {
        /**
         * The template used for all cells in the column.
         */
        template: string;
        /**
         * Supplies a viewmodel to bind with the template.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @param grid The grid.
         * @returns A view model or an observable containing the view model.
         */
        viewModel: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => TViewModel | KnockoutReadOnlyObservableBase<TViewModel>;
    }
    /**
     * Template column definition.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinition<TItem> extends TemplateColumnDefinitionOptions<TItem, any> {
        /**
         * Template column definition type.
         * A column that binds a view model to an HTML template in each cell.
         */
        type: "Template";
    }
    /**
     * Template column definition options.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinitionOptions<TItem, TViewModel = any> extends ColumnDefinitionBase<TItem> {
        /**
         * A Template cell definition.
         */
        cell: TemplateCellDefinition<TItem, TViewModel>;
    }
    /**
     * UriLink definition.
     */
    export interface UriLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the uri.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The link target.
         */
        target?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The link text.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
        /**
         * The URI to navigate to when the link is clicked.
         * A non-null URI will render a clickable link.
         * A null URI will render plain text that is not clickable.
         */
        uri: string | KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * UriLink cell definition.
     */
    export interface UriLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a UriLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A UriLink definition.
         */
        uriLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => UriLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * UriLink column definition.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinition<TItem> extends UriLinkColumnDefinitionOptions<TItem> {
        /**
         * UriLink column definition type.
         * A column that displays a URI link in each cell.
         */
        type: "UriLink";
    }
    /**
     * UriLink column definition options.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A UriLink cell definition.
         */
        cell: UriLinkCellDefinition<TItem>;
    }
    /**
     * BladeLink definition.
     */
    export interface BladeLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the bladeReference.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The blade reference for the link.
         * A non-null blade reference will render a clickable link.
         * A null blade reference will render plain text that is not clickable.
         * A blade reference that uses object-typed blade parameters or is too long will result in an href of "#" instead of a deep link.
         */
        bladeReference: BladeReference<unknown> | KnockoutReadOnlyObservableBase<BladeReference<unknown>>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * Text to display with link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * BladeLink cell definition.
     */
    export interface BladeLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a BladeLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A BladeLink definition.
         */
        bladeLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => BladeLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * BladeLink column definition.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinition<TItem> extends BladeLinkColumnDefinitionOptions<TItem> {
        /**
         * BladeLink column definition type.
         * A column that displays a link that opens a blade in each cell.
         */
        type: "BladeLink";
    }
    /**
     * BladeLink column definition options.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A BladeLink cell definition.
         */
        cell: BladeLinkCellDefinition<TItem>;
    }
    /**
     * ResourceLink definition.
     */
    export interface ResourceLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick instead.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The resource id to link to.
         * A non-null resource id will render a clickable link unless canClick is false.
         * A null resource id will render plain text that is not clickable.
         */
        resourceId: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The resource kind to link to.
         */
        resourceKind?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * Overrides the default text determined from the resource id.
         *
         * You can use the getDisplayName utility function to generate a name that utilizes a hidden-title tag.
         *
         * text: ResourceName.getDisplayName({
         *     id: getResourceId(item),
         *     tags: getResourceTags(item),
         * }),
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * ResourceLink cell definition.
     */
    export interface ResourceLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a resource link definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A resource link definition.
         */
        resourceLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => ResourceLink;
        /**
         * Indicates to display the resource icon in the link.
         * Defaults to true.
         */
        showIcon?: boolean;
        /**
         * Indicates to display the preview badge on the resource icon in the link.
         * Defaults to true.
         * For preview blades you may set this to false if you find it too noisy to show these on every icon.
         * If you do hide the badging for a preview blade make sure the blade itself indicates it is preview.
         */
        showPreview?: boolean;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * ResourceLink column definition.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinition<TItem> extends ResourceLinkColumnDefinitionOptions<TItem> {
        /**
         * ResourceLink column definition type.
         * A column that displays a link that opens a resource in each cell.
         */
        type: "ResourceLink";
    }
    /**
     * ResourceLink column definition options.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A ResourceLink cell definition.
         */
        cell: ResourceLinkCellDefinition<TItem>;
    }
    /**
     * CustomLink definition.
     */
    export interface CustomLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The text to display in the link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * CustomLink cell definition.
     */
    export interface CustomLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Changes the role of the link to "button".
         * By default the role will be a "link" and the user expects the link to navigate using openBlade or openContextPane.
         * If your onClick does not navigate you should change the role of the link to "button".
         * However, you may want to consider alteratives such as supplyButtonCommands which is designed to add command buttons to grid rows.
         */
        buttonRole?: boolean;
        /**
         * Supplies a CustomLink definition to display a custom link in a cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A CustomLink definition.
         */
        customLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => CustomLink;
        /**
         * Callback to provide custom behavior for clicking on the link.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         * If your onClick does not navigate you should set buttonRole to true.
         *
         * @param item The data item.
         * @param row The row containing the data item.
         * @param target The framework element that was clicked on.
         */
        onClick?: (item: TItem, row: Row<TItem>, target: FxElement) => void;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * CustomLink column definition.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinition<TItem> extends CustomLinkColumnDefinitionOptions<TItem> {
        /**
         * CustomLink column definition type.
         * A column that displays a custom link in each cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         */
        type: "CustomLink";
    }
    /**
     * CustomLink column definition options.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A CustomLink cell definition.
         */
        cell: CustomLinkCellDefinition<TItem>;
    }
    /**
     * TagList cell definition.
     */
    export interface TagListCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Notification when an item tag has been clicked.
         *
         * @param item The item being clicked.
         * @param tagIndex The index of the tag being clicked.
         */
        onClick?: (item: TItem, tagIndex: number) => void;
        /**
         * Supplies the tags to display in a cell.
         *
         * @param lifetime The cell lifetime.
         * @param item The item to get tags for.
         * @param row The row containing the cell.
         * @returns The tags or an observable containing the tags.
         */
        tags: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string[] | KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * TagList column definition.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinition<TItem> extends TagListColumnDefinitionOptions<TItem> {
        /**
         * TagList column definition type.
         * A TagList column displays a list of strings as bubbled text in a cell.
         */
        type: "TagList";
    }
    /**
     * TagList column definition options.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A TagList cell definition.
         */
        cell: TagListCellDefinition<TItem>;
    }
    /**
     * DataGrid data node.
     */
    export interface DataNode<TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The unique id.
         * If the object identity of your items is changing this is required to allow
         * the grid to preserve selection and other UI state across refreshes.
         * Can be set to null if you do not have an identifier or do not care about preserving UI state.
         */
        id: TId;
        /**
         * The data item.
         */
        item: TItem;
        /**
         * The child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the child nodes when the children property is not set.
         * Allows for delayed loading of child items.
         *
         * @param parentNode The parent node.
         * @returns The child nodes or a promise for the child nodes.
         */
        getChildren?: (parentNode: DataNode<TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * DataGrid group data node.
     * A group node is a parent node for all the children in the group.
     * A group node creates a group row with a single cell spanning the row to contains the group header.
     */
    export interface GroupNode<TGroup, TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The group unique id.
         */
        id: TId;
        /**
         * The group data item.
         */
        group: TGroup;
        /**
         * The group child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the group child nodes when the children property is not set.
         * Allows for asynchronous loading of group items.
         *
         * @param parentNode The parent node.
         * @returns The group child nodes or a promise for the group child nodes.
         */
        getChildren?: (parentNode: GroupNode<TGroup, TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * Query parameters for the callback data source.
     */
    export interface CallbackDataSourceParams<TParams = any> {
        /**
         * Custom query parameters for the datasource.
         */
        params: TParams;
        /**
         * Indicates if the data source has been reset.
         * The data source may return uncached data in this case.
         */
        reset: boolean;
        /**
         * The requested sort order to return the data in.
         */
        sortOrder: SortOrder[];
    }
    /**
     * Result to return from the callback data source.
     */
    export type CallbackDataSourceResult<TItem, TGroup = any> = DataNode<TItem>[] | GroupNode<TGroup, TItem, any>[];
    /**
     * DataGrid callback data source.
     */
    export interface CallbackDataSource<TItem, TGroup = any, TParams = any> {
        /**
         * Callback to get the data items.
         *
         * @param queryParams Query parameters such as sort order for making the correct query.
         * @returns The data result or a promise for the result.
         */
        (queryParams: CallbackDataSourceParams<TParams>): CallbackDataSourceResult<TItem, TGroup> | Promise<CallbackDataSourceResult<TItem, TGroup>>;
    }
    /**
     * Refresh options.
     */
    export interface RefreshOptions<TParams = any> {
        /**
         * Message to display and announce while refreshing.
         */
        message?: string;
        /**
         * Message to announce when refresh is completed.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
        /**
         * Custom query parameters to pass to the dataSource.
         */
        params?: TParams;
        /**
         * Indicates if the refresh should fully reset the grid data.
         * Typically used with a refresh command in the UI.
         * When reset the grid will clear selection and other UI state that may not apply with new data.
         * The data source should use this option to determine if cached data should be returned or not.
         * The default is false.
         */
        reset?: boolean;
        /**
         * Determines if the message and spinner are shown while the dataSource is called.
         * If true the dataSource will be called asyncronously after the message UI has been displayed.
         * If false the dataSource will be called synchronously and the message UI will not be shown.
         * If undefined (the default) the dataSource will be called synchronously and the message UI will only be shown if
         * the dataSouce implementation is async and yields execution.
         */
        showMessage?: boolean;
        /**
         * The requested sort order to return the data in.
         * This is an array of the column ids and sort directions in order of precedence.
         * When sortOrder is provided as an option it is passed to the dataSource.
         * When sortOrder is not provided the sortOrder is constructed from the column collection using the column id and sortDirection.
         * If sorting is disabled for the grid this option will have no effect.
         * The current sortOrder can also be accessed with grid.sorting.sortOrder.
         */
        sortOrder?: SortOrder[];
    }
    /**
     * DataGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, HTML content, or an observable that returns a string or HTML content.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * DataGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
    }
    /**
     * DataGrid cell definition.
     * The CellDefinition contains properties that are used to create a Cell.
     */
    export type CellDefinition<TItem> = BladeLinkCellDefinition<TItem> | CustomLinkCellDefinition<TItem> | ResourceLinkCellDefinition<TItem> | TagListCellDefinition<TItem> | TemplateCellDefinition<TItem> | TextCellDefinition<TItem> | UriLinkCellDefinition<TItem>;
    /**
     * DataGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export type ColumnDefinition<TItem> = BladeLinkColumnDefinition<TItem> | CustomLinkColumnDefinition<TItem> | ResourceLinkColumnDefinition<TItem> | TagListColumnDefinition<TItem> | TemplateColumnDefinition<TItem> | TextColumnDefinition<TItem> | UriLinkColumnDefinition<TItem>;
    /**
     * DataGrid column definition common properties.
     */
    export interface ColumnDefinitionBase<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         * Defaults to false.
         * When set to true the dataSource must implement sorting for it to work.
         */
        canSort?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * To set additional column header properties provide a column header definition.
         */
        header?: string | ColumnHeaderDefinition;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Sort direction of the column.
         * Defaults to unsorted.
         */
        sortDirection?: SortDirection | KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid column.
     * Part of the DataGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         */
        readonly canSort: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * Sort direction of the column.
         */
        readonly sortDirection: KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         *
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * DataGrid cell.
     * Part of the DataGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
    }
    /**
     * DataGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
    }
    /**
     * DataGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         *
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * DataGrid row.
     * Part of the DataGrid object model.
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is currently hovered.
         */
        readonly hovered: KnockoutReadOnlyObservable<boolean>;
        /**
         * The data id.
         */
        readonly id: any;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * DataGrid row group definition.
     * Used to initialize new row groups.
     */
    export interface RowGroupDefinition<TGroup> {
        /**
         * Supplies the accessibility label for the row group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The accessibility label.
         */
        ariaLabel?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the content for the group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The row group content label.
         */
        content?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | HtmlContent | KnockoutObservableBase<string>;
    }
    /**
     * DataGrid row group.
     * Part of the DataGrid object model.
     */
    export interface RowGroup<TGroup, TItem> {
        /**
         * The row group accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * Indicates if the row group is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row group is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * The group.
         */
        readonly group: TGroup;
        /**
         * The data id.
         */
        readonly id: any;
    }
    /**
     * DataGrid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid header.
     * Part of the DataGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid focus options.
     */
    export interface FocusOptions<TItem, TGroup = any> {
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * DataGrid focus contract.
     */
    export interface FocusContract<TItem, TGroup = any> {
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * The current row group.
         * This row group is the focused row group when the grid has focus.
         * When focus leaves the grid the current row group remains.
         */
        readonly currentRowGroup: KnockoutReadOnlyObservable<RowGroup<TGroup, TItem>>;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
    }
    /**
     * DataGrid selection options.
     */
    export interface SelectionOptions<TItem, TGroup = any> {
        /**
         * Determines if all items can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be selected at once.
         */
        canSelectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @param grid The grid.
         * @returns Indicates if the item can be selected.
         */
        canSelectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if all items can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be unselected at once.
         */
        canUnselectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @param grid The grid.
         * @returns Indicates if the item can be unselected.
         */
        canUnselectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
    }
    /**
     * DataGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Indicates if all items can be selected.
         */
        readonly canSelectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be selected.
         *
         * @param item The item to select.
         * @returns Indicates if an item can be selected.
         */
        canSelectItem(item: TItem): boolean;
        /**
         * Indicates if all items can be unselected.
         */
        readonly canUnselectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be unselected.
         *
         * @param item The item to unselect.
         * @returns Indicates if an item can be unselected.
         */
        canUnselectItem(item: TItem): boolean;
        /**
         * Selects all items.
         *
         * @returns Indicates if all items were selected.
         */
        selectAllItems(): boolean;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Selects an item.
         *
         * @param item The item to select.
         * @returns Indicates if the item was selected.
         */
        selectItem(item: TItem): boolean;
        /**
         * Selects an item by id.
         *
         * @param id The item's id to select.
         * @returns Indicates if the item was selected.
         */
        selectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Unselects all items.
         *
         * @returns Indicates if all items were unselected.
         */
        unselectAllItems(): boolean;
        /**
         * Unselects an item.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItem(item: TItem): boolean;
        /**
         * Unselects an item by id.
         *
         * @param id The item's id to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid activation options.
     */
    interface ActivationOptions {
        /**
         * Hides the selection while a child blade is opened.
         * Leaves the current row highlighting only on the activated row.
         * When the child blade is closed the selection is restored unless the user changed the selection while the child blade was open.
         * There are very few scenarios where you would enable this behavior.
         * Typically the only scenario this is used is when you want to collapse the parent blade to show the child blade next to it.
         * This is disabled by default.
         */
        hideSelectionDuringActivation?: boolean;
    }
    /**
     * DataGrid activation contract.
     * Activation occurs when a child blade is opened from a grid cell using a BladeLinkColumn,
     * CustomLinkColumn, ResourceLinkColumn, or fxclick in an HTML template.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * DataGrid hover contract.
     */
    export interface HoverContract<TItem> {
        /**
         * The currently hovered row.
         * Null when a row is not hovered.
         */
        readonly hoveredRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param row The row.
         * @returns A promise for completion
         */
        hoverRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param id The id.
         * @returns A promise for completion
         */
        hoverRowById<TId extends string | ConvertsToString>(id: TId): Promise<boolean>;
    }
    /**
     * DataGrid context menu options.
     */
    export interface ContextMenuOptions<TItem, TGroup = any> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid hierarchy options.
     */
    export interface HierarchyOptions<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be collapsed.
         */
        canCollapseAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @param grid The grid.
         * @returns Indicates if the row can be collapsed.
         */
        canCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @param grid The grid.
         * @returns Indicates if the row group can be collapsed.
         */
        canCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be expanded.
         */
        canExpandAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @param grid The grid.
         * @returns Indicates if the row can be expanded.
         */
        canExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @param grid The grid.
         * @returns Indicates if the row group can be expanded.
         */
        canExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Notifies when the hierarchy is collapsed.
         *
         * @param grid The grid.
         */
        onCollapseAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is collapsed.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is collapsed.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when the hierarchy is expanded.
         *
         * @param grid The grid.
         */
        onExpandAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is expanded.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is expanded.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Customize the initial expanded state of a hierarchical parent row.
         * The grid will call this when a new row is being created to determine if it should be expanded or not.
         * The grid will only call if the item has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded The default expanded state which is expanded for root items and collapsed for all child item.
         * @param level The item level in the hierarchy 1 is top level.
         * @param item The row item.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForItem?: (cachedExpanded: boolean, defaultExpanded: boolean, level: number, item: TItem) => boolean;
        /**
         * Customize the initial expanded state of a row group.
         * The grid will call this when a new row group is being created to determine if it should be expanded or not.
         * The grid will only call if the group has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded  The default expanded state which is expanded for row groups.
         * @param group The row group.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForGroup?: (cachedExpanded: boolean, defaultExpanded: boolean, group: TGroup) => boolean;
    }
    /**
     * DataGrid hierarchy contract.
     */
    export interface HierarchyContract<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @returns Indicates if the hiearrchy can be collapsed.
         */
        canCollapseAll(): boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @returns Indicates if a row can be collapsed.
         */
        canCollapseRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if a row group can be collapsed.
         */
        canCollapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @returns Indicates if the hiearrchy can be expanded.
         */
        canExpandAll(): boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @returns Indicates if a row can be expanded.
         */
        canExpandRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if a row group can be expanded.
         */
        canExpandRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Collapse the hierarchy.
         *
         * @returns Indicates if the hierarchy was collapsed.
         */
        collapseAll(): Promise<boolean>;
        /**
         * Collapses a row.
         *
         * @param row The row to collapse.
         * @returns Indicates if the row was collapsed.
         */
        collapseRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Collapses a row group.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if the row group was collapsed.
         */
        collapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
        /**
         * Expands the hierarchy.
         *
         * @returns Indicates if the hierarchy was expanded.
         */
        expandAll(): Promise<boolean>;
        /**
         * Expands a row.
         *
         * @param row The row to expand.
         * @returns Indicates if the row was expanded.
         */
        expandRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Expands a row group.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if the row group was expanded.
         */
        expandRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
    }
    /**
     * DataGrid resizing options.
     */
    export interface ResizingOptions<TItem, TGroup = any> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * DataGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is automatically enabled when the grid UI is created and the element
         * the grid is bound into has a height.
         * By default vertical scrolling is automatically disabled when the grid UI is created and the element
         * the grid is bound into does not have a height.
         * When set to true the grid will enable vertical scrolling and skip the auto detection based on height.
         * However, you will still need to ensure the element the grid is bound to has a height.
         * When set to false the grid will disable vertical scrolling and skip the auto detection based on height.
         */
        vertical?: boolean;
    }
    /**
     * DataGrid sorting options.
     */
    export interface SortingOptions<TItem, TGroup = any> {
        /**
         * Determines whether additional sorted columns can be added to the current sort order.
         * This can be used to limit the number of columns that can be sorted at the same time.
         * The default is to allow all the sortable columns to be sorted at the same time.
         *
         * @param sortOrder All columns with their column ids and sort directions.
         * @param grid The grid.
         * @returns A boolean that indicates if additional columns can be added to the current sort order.
         */
        canSortAdditionalColumns?: (sortOrder: SortOrder[], grid: Contract<TItem, TGroup>) => boolean;
    }
    /**
     * DataGrid sorting properties and methods.
     */
    export interface SortingContract<TItem> {
        /**
         * The current sort order.
         * This is an array of the column ids and sort directions in order of precedence.
         */
        readonly sortOrder: KnockoutReadOnlyObservableArray<SortOrder>;
    }
    /**
     * DataGrid options.
     */
    export interface Options<TItem, TGroup = any> {
        /**
         * Activation options.
         * Activation is enabled by default.
         * Activation can not be disabled by omitting the activation options or setting to null.
         */
        activation?: ActivationOptions;
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[];
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem, TGroup>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The data source.
         */
        dataSource: CallbackDataSource<TItem, TGroup>;
        /**
         * Disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem, TGroup>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Hierarchy options.
         * Heirarchy is enabled by default.
         * The hierarchy is determined by the node structure returned from the data source.
         */
        hierarchy?: HierarchyOptions<TItem, TGroup>;
        /**
         * Content to display when the grid has no data.
         */
        noDataMessage?: string | HtmlContent;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem, TGroup>;
        /**
         * Row initialization options.
         */
        row?: RowDefinition<TItem>;
        /**
         * Row group options.
         */
        rowGroup?: RowGroupDefinition<TGroup>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is auto-detected.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is not enabled by default.
         * Selection is enabled by providing selection options.
         */
        selection?: SelectionOptions<TItem, TGroup>;
        /**
         * Sorting options.
         * Sorting is enabled by default.
         * Sorting can be disabled by setting to null.
         * To sort you must set canSort to true on a column and implement sorting in the dataSource.
         */
        sorting?: SortingOptions<TItem, TGroup>;
        /**
         * Hides or shows the grid.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * DataGrid loading message options.
     */
    export interface LoadingMessageOptions {
        /**
         * Message to be displayed/announced while loading.
         */
        message?: string;
        /**
         * Message to be announced on loading completion.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
    }
    /**
     * DataGrid contract.
     */
    export interface Contract<TItem, TGroup = any> extends Control {
        /**
         * DataGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * If called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional messages to display and announce to screen readers.
         * @returns A Promise that is resolved when the message is shown or determined not to be shown.
         */
        displayLoadingMessage(completion: Promise<any>, message?: string | LoadingMessageOptions): Promise<boolean>;
        /**
         * DataGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem, TGroup>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Hierarchy properties and methods.
         */
        readonly hierarchy: HierarchyContract<TItem, TGroup>;
        /**
         * Hover properties and methods.
         */
        readonly hover: HoverContract<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the grid has no data to display.
         */
        readonly noData: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Refreshes the grid data.
         *
         * @param options Refresh options.
         * @returns A promise for completion.
         */
        refresh<TParams>(options?: RefreshOptions<TParams>): Promise<any>;
        /**
         * The grid row groups when the grid is grouped.
         */
        readonly rowGroups: KnockoutReadOnlyObservableArray<RowGroup<TGroup, TItem>>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * DataGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * Sorting properties and methods.
         */
        readonly sorting: SortingContract<TItem>;
        /**
         * Hides or shows the DataGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a DataGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem, TGroup = any>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TGroup>): Contract<TItem, TGroup>;
    /**
     * Creates a BladeLink column definition that displays a link to a blade in each cell.
     *
     * @param options The BladeLink column definition options.
     * @returns A BladeLink column definition.
     */
    export function createBladeLinkColumn<TItem>(options: BladeLinkColumnDefinitionOptions<TItem>): BladeLinkColumnDefinition<TItem>;
    /**
     * Creates a CustomLink column definition that displays a custom link in each cell.
     * Only use for exceptional cases where you do not require browser behaviors like
     * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
     * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
     *
     * @param options The CustomLink column definition options.
     * @returns A CustomLink column definition.
     */
    export function createCustomLinkColumn<TItem>(options: CustomLinkColumnDefinitionOptions<TItem>): CustomLinkColumnDefinition<TItem>;
    /**
     * Creates a ResourceLink column definition that displays a link to a resource in each cell.
     *
     * @param options The ResourceLink column definition options.
     * @returns A ResourceLink column definition.
     */
    export function createResourceLinkColumn<TItem>(options: ResourceLinkColumnDefinitionOptions<TItem>): ResourceLinkColumnDefinition<TItem>;
    /**
     * Creates a TagList column definition that displays a list of tags as bubbled text in each cell.
     *
     * @param options The TagList column definition options.
     * @returns A TagList column definition.
     */
    export function createTagListColumn<TItem>(options: TagListColumnDefinitionOptions<TItem>): TagListColumnDefinition<TItem>;
    /**
     * Creates a template column definition that displays an HTML template bound to a view model in each cell.
     *
     * @param options The template column definition options.
     * @returns A Template column definition.
     */
    export function createTemplateColumn<TItem, TViewModel = any>(options: TemplateColumnDefinitionOptions<TItem, TViewModel>): TemplateColumnDefinition<TItem>;
    /**
     * Creates a text column definition that displays text in each cell.
     *
     * @param options The text column definition options.
     * @returns A Text column definition.
     */
    export function createTextColumn<TItem>(options: TextColumnDefinitionOptions<TItem>): TextColumnDefinition<TItem>;
    /**
     * Creates a UriLink column definition that displays a URI link in each cell.
     *
     * @param options The UriLink column definition options.
     * @returns A UriLink column definition.
     */
    export function createUriLinkColumn<TItem>(options: UriLinkColumnDefinitionOptions<TItem>): UriLinkColumnDefinition<TItem>;
}

// FILE: Fx\Controls\DatePicker.d.ts
declare module "Fx/Controls/DatePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DatePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DatePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a date picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DateTimePicker.d.ts
declare module "Fx/Controls/DateTimePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import * as TimeZones from "Fx/TimeZones";
    export import TimeZoneId = TimeZones.TimeZoneId;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date time picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DateTimePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        timezoneId?: TimeZoneId | KnockoutObservableBase<TimeZoneId>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * Empty value text for date.
         */
        placeHolderTextForDate?: string | KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        placeHolderTextForTime?: string | KnockoutObservableBase<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DateTimePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        readonly showTimezoneDropdown: KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        readonly timezoneId: KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        readonly placeHolderTextForDate: KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        readonly placeHolderTextForTime: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date/time picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a date time picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DateTimeRangePicker.d.ts
declare module "Fx/Controls/DateTimeRangePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import * as TimeZones from "Fx/TimeZones";
    export import TimeZoneId = TimeZones.TimeZoneId;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a date time range picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DateTimeRangePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Enabled range for start date/time
         */
        startDateTimeEnabledRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        endDateTimeEnabledRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        showTimezoneDropdown?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        timezoneId?: TimeZoneId | KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        placeHolderTextForDate?: string | KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        placeHolderTextForTime?: string | KnockoutObservableBase<string>;
        /**
         * Display start/end date/time fields inline (false by default).
         */
        displayFieldsInline?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: DateTimeRange | KnockoutObservableBase<DateTimeRange>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DateTimeRangePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for start date/time
         */
        readonly startDateTimeEnabledRange: KnockoutObservableBase<DateTimeRange>;
        /**
         * Enabled range for end date/time
         */
        readonly endDateTimeEnabledRange: KnockoutObservableBase<DateTimeRange>;
        /**
         * Show time zone dropdown.
         */
        readonly showTimezoneDropdown: KnockoutObservableBase<boolean>;
        /**
         * The ID of the timezone of the value the user sees (which is different from the 'value' of the control that is in the local timezone).
         */
        readonly timezoneId: KnockoutObservableBase<TimeZoneId>;
        /**
         * Empty value text for date.
         */
        readonly placeHolderTextForDate: KnockoutObservableBase<string>;
        /**
         * Empty value text for time.
         */
        readonly placeHolderTextForTime: KnockoutObservableBase<string>;
    }
    /**
     * Creates a date/time range picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a date time range picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DayPicker.d.ts
declare module "Fx/Controls/DayPicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a day picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DayPicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number[] | KnockoutObservableBase<number[]>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DayPicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a day picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a day picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\DiffEditor.d.ts
declare module "Fx/Controls/DiffEditor" {
    import * as Base from "Fx/Controls/ControlsBase";
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    import { ContentType, Marker, Range, CustomConfig, CursorPosition, TypeScriptExtraLib, TypeScriptCompilerOptions, JSONSchema } from "Fx/Controls/Editor";
    export { ContentType, Marker, Range, CustomConfig, CursorPosition, TypeScriptExtraLib, TypeScriptCompilerOptions, JSONSchema, };
    /**
     * Options for creating a diff editor control
     */
    export interface Options {
        /**
         * The original document contents.
         */
        readonly oldContent: string | KnockoutObservableBase<string>;
        /**
         * The new document contents.
         */
        readonly newContent: string | KnockoutObservableBase<string>;
        /**
         * Enables splitter between the content panes
         */
        readonly enableSplitViewResizing?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Render the differences in two side-by-side editors.
         * Defaults to true.
         */
        readonly renderSideBySide?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers?: Marker[] | KnockoutObservableBase<Marker[]>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize?: number | KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn?: number | KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines?: number | KnockoutObservableBase<number>;
        /**
         * Defines an auto save delay in millisenconds when it expires the editor changes are saved.
         * The delay is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled.
         * Defaults to 500 milliseconds.
         */
        readonly autoSaveDelay?: number;
    }
    /**
     * Options for creating an editor control
     */
    export interface EditorOptions extends Options {
        /**
         * The type of editor content.
         */
        readonly contentType?: ContentType | KnockoutObservableBase<ContentType>;
    }
    /**
     * Options for creating an editor control
     */
    export interface JSONEditorOptions extends Options {
        /**
         * JSON schemas.
         */
        readonly schemas: JSONSchema[];
    }
    /**
     * Options for creating an editor control
     */
    export interface TypeScriptEditorOptions extends Options {
        /**
         * Additional source files to the language service. Use this
         * for typescript (definition) files that won't be loaded as editor
         * document, like `jquery.d.ts`.
         */
        readonly extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        readonly compilerOptions: TypeScriptCompilerOptions;
    }
    /**
     * Options for creating a custom editor control
     */
    export interface CustomEditorOptions extends Options {
        /**
         * Custom language configruation.
         */
        readonly customConfig: CustomConfig;
    }
    /**
     * Editor contract.
     */
    export interface EditorContract extends Contract {
        /**
         * The type of the editor content.
         */
        readonly contentType: KnockoutObservableBase<ContentType>;
    }
    /**
     * Custom editor contract.
     */
    export interface CustomEditorContract extends Contract {
        /**
         * Custom language configruation.
         */
        readonly customConfig: KnockoutObservableBase<CustomConfig>;
    }
    /**
     * JSON editor contract.
     */
    export interface JSONEditorContract extends Contract {
    }
    /**
     * TypeScript editor contract.
     */
    export interface TypeScriptEditorContract extends Contract {
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        readonly typescriptOutput: KnockoutObservableBase<string>;
    }
    /**
     * Base DiffEditor contract.
     */
    export interface Contract extends Base.Control {
        /**
         * The original document contents.
         */
        readonly oldContent: KnockoutObservableBase<string>;
        /**
         * The new document contents.
         */
        readonly newContent: KnockoutObservableBase<string>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The currently selected content of the editor content.
         */
        readonly selectedContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * The currently selected range in the editor content.
         */
        readonly selectedRange: KnockoutObservableBase<Range>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers: KnockoutObservableBase<Marker[]>;
        /**
         *  Current position of the cursor in the editor content.
         */
        readonly cursorPosition: KnockoutObservableBase<CursorPosition>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar: KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize: KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn: KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines: KnockoutObservableBase<number>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor is displayed.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Refreshes the editor view.
         */
        refresh(): Promise<void>;
        /**
         * Saves the content of the editor.
         */
        save(): Promise<void>;
    }
    /**
     * Creates an editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createEditor(lifetime: LifetimeManager, options: EditorOptions): EditorContract;
    /**
     * Creates a custom editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createCustomEditor(lifetime: LifetimeManager, options: CustomEditorOptions): CustomEditorContract;
    /**
     * Creates a JSON editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createJSONEditor(lifetime: LifetimeManager, options: JSONEditorOptions): JSONEditorContract;
    /**
     * Creates a TypeScript editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createTypeScriptEditor(lifetime: LifetimeManager, options: TypeScriptEditorOptions): TypeScriptEditorContract;
}

// FILE: Fx\Controls\DocsControl.d.ts
declare module "Fx/Controls/DocsControl" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * DocsControl's supported blade actions.
     *
     * @deprecated DocsControl.ActionType - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export enum ActionType {
        /**
         * Blade action is not supported by DocsControl.
         */
        NotSupported = 0,
        /**
         * Open a blade from #blade deeplink.
         */
        OpenBlade = 1,
        /**
         * Open a create flow from #create deeplink.
         */
        Create = 2,
        /**
         * Open a blade in context pane.
         */
        OpenContextPane = 3
    }
    /**
     * Action completed args to indicate if the blade action was performed successfully by the DocsControl.
     *
     * @deprecated DocsControl.ActionCompletedArgs - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface ActionCompletedArgs {
        /**
         * One of the supported blade action type.
         */
        actionType: ActionType;
        /**
         * Blade action data embeeded in docs.
         */
        data: string;
        /**
         * Azure documentation source uri.
         */
        src: string;
        /**
         * Flag to indicate if blade action succeeded or failed.
         */
        success?: boolean;
        /**
         * Error message if the blade action failed.
         */
        errorMessage?: string;
    }
    /**
     * Options for configuring a DocsControl control.
     *
     * @deprecated DocsControl.Options - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface Options {
        /**
         * Source uri where docs are hosted.
         */
        readonly src: string | KnockoutObservableBase<string>;
        /**
         * Action completion callback for the extension to know if the blade action succeed or not.
         * Extension can add any telemtry related to the blade action in the callback.
         *
         * @param args Action completed args indicating success or failure of the blade action.
         */
        readonly onActionCompleted?: (args: ActionCompletedArgs) => void;
    }
    /**
     * DocsControl view model contract.
     *
     * @deprecated DocsControl.Contract - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     */
    export interface Contract extends Control {
        /**
         * Source uri where docs are hosted.
         */
        readonly src: KnockoutObservableBase<string>;
    }
    /**
     * Creates a DocsControl viewmodel.
     *
     * Chromeless doc service will not be supported going forward.
     * As first step, DocsControl is getting deprecated and DocsControl will be removed from SDK in near future.
     * Extension should find alternate solutions to surface doc content via direct links.
     * The current deprecation will raise tslint errors if extension is using any DocsControl type/APIs.
     * Extension can temporarily add //eslint-disable-next-line deprecation/deprecation to bypass the tslint rule.
     *
     * @deprecated DocsControl.create - DocsControl APIs are getting deprecated since chromeless docs service will not be supported going forward. This API will be removed in a future SDK release.
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a DocsControl viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Donut.d.ts
declare module "Fx/Controls/Donut" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Built-in sizes for Donut control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7
    }
    /**
     * GroupInfo is the ViewModel for a particular <optGroup>
     */
    export interface GroupInfo {
        /**
         * Id for mapping from Item GroupID column to this user friendly GroupInfo.
         */
        key: string;
        /**
         * User friendly label for the grouping.
         */
        text: string | KnockoutObservableBase<string>;
        /**
         * Disable state of this group.
         */
        disable: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ItemSetting defines the properties required to build donut items.
     * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
     */
    export interface ItemSetting {
        /**
         * Data key used to identify the color.  This is optional, if not provided, it will use default color wheel.
         */
        colorKey?: string;
        /**
         * Data key used to identify the donut slice.  Data have to be string, we use it on the object map to quickly identify item's element.
         */
        rowIdKey?: string;
        /**
         * Data key used to label the row for display purpose.  Data have to be string, we use to show center caption for quick indication of the item.
         */
        labelKey?: string;
        /**
         * Property used for display item. If it is not set, it uses items[index] to display.
         */
        textKey?: string;
        /**
         * Property used for Value of an item. If it is not set, it uses items[index] as Value.
         */
        valueKey?: string;
        /**
         * Property used for disable state of an item. If it is not set, default to false.
         */
        disableKey?: string;
        /**
         * Property used for select state of an item. If it is not set, default to false.
         */
        selectedKey?: string;
        /**
         * Property used for grouping of an item. If it is not set, there is no grouping for the items.
         */
        groupIdKey?: string;
        /**
         * Data key of the hatching pattern.
         */
        hatchingKey?: string;
    }
    /**
     * Options for configuring a Donut control.
     */
    export interface Options<T> {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * Group definitions.
         */
        groupInfos?: GroupInfo[] | KnockoutObservableArray<GroupInfo>;
        /**
         * ItemSetting defines the properties required to build donut items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
         */
        itemSetting?: ItemSetting | KnockoutObservableBase<ItemSetting>;
        /**
         * Items displayed in the donut based on the ItemSetting definitions.
         */
        items?: T[] | KnockoutObservableArray<T>;
        /**
         * total value. The total value of all item values.
         */
        total?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}". The following formatter arguments will be substituted with respective values when displaying center text,
         * {0}: current value.
         * {1}: maximum value.
         */
        totalFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        unitFormat?: string | MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space constraints in the center of the Donut.
         */
        numberFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        infoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text. The following formatter arguments will be substituted with respective values when displaying center hover text,
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        hoverInfoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * The following formatter arguments will be substituted with respective values when displaying center selected text,
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        selectedInfoFormat?: string | KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentage.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        hoveredUnit?: string | MsPortalFx.UnitConversion.Unit | KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * RowId of current hovered slice in donut.
         */
        hoveredIndex?: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        disableSelectOnClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        showCenter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Title of the Donut control, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Donut control, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * Donut control view model contract.
     */
    export interface Contract<T> extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Group definitions.
         */
        readonly groupInfos: KnockoutObservableArray<GroupInfo>;
        /**
         * ItemSetting defines the properties required to build donut items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of donut slices.
         */
        readonly itemSetting: KnockoutObservableBase<ItemSetting>;
        /**
         * Items displayed in the donut based on the ItemSetting definitions.
         */
        readonly items: KnockoutObservableArray<T>;
        /**
         * total value. The total value of all item values.
         */
        readonly total: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         * Display Text in the center.
         * By default the format string is "{0}". The following formatter arguments will be substituted with respective values when displaying center text,
         * {0}: current value.
         * {1}: maximum value.
         */
        readonly totalFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit in the center. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * By default the format string is "".
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center will not be auto scaled and the raw total value and specified unit string will be displayed.
         */
        readonly unitFormat: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * Specify the globalized number precision format options for the center and hovered value.
         * By default we will have 1 floating point precision due to space constraints in the center of the Donut.
         */
        readonly numberFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions>;
        /**
         * Display info in the center. (Caption)
         * This is used when there is no selected nor hover on the donut.
         */
        readonly infoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center during the hover. (Caption)
         * This is used when hover on the text. The following formatter arguments will be substituted with respective values when displaying center hover text,
         * {0}: current label ("" if not available).
         * {1}: current value (or percentage).
         * {2}: current unit (or %).
         */
        readonly hoverInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display info in the center when there is a selected and no hover. (Caption)
         * The following formatter arguments will be substituted with respective values when displaying center selected text,
         * {0}: current selected total.
         * {1}: current total().
         * {2}: current unitFormat().
         */
        readonly selectedInfoFormat: KnockoutObservableBase<string>;
        /**
         * Display Unit for Hovered/Selected. This is a union type of string or MsPortalFx.UnitConversion.Unit.
         * If it is "%" or undefined, by default it shows percentage.
         * If MsPortalFx.UnitConversion.Unit is specified, the the center value and caption value will be autoscaled to appropriate unit and it will be shown.
         * If string is specified, the center and hovered values will not be auto scaled and the raw item value and specified unit string will be displayed.
         */
        readonly hoveredUnit: KnockoutObservableBase<string | MsPortalFx.UnitConversion.Unit>;
        /**
         * RowId of current hovered slice in donut.
         */
        readonly hoveredIndex: KnockoutObservableBase<string>;
        /**
         * Disable selected change on click.
         */
        readonly disableSelectOnClick: KnockoutObservableBase<boolean>;
        /**
         * Show center content.
         */
        readonly showCenter: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Title of the Donut control, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Donut control, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        render: () => void;
    }
    /**
     * Creates a Donut control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Donut control viewmodel
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\DropDown.d.ts
declare module "Fx/Controls/DropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Validation } from "Fx/Controls/Validations";
    import { Contract as FormContract } from "Fx/Controls/FormBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * List of preset options for relative drop-down popup widths.
     */
    export const enum PopupWidth {
        /**
         * The expanded drop-down popup width is equivalent to the width of the drop-down itself.
         */
        DropDownWidth = -1
    }
    /**
     * Describes an Item used for items in the DropDown.
     */
    export interface Item<TValue> {
        /**
         * Content to render for the item.
         * If you use HtmlContent, use `ariaLabel` for screen reader support.
         */
        text: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Overrides what is shown in the selected state. Allows you to display different content then what is shown in the DropDown.
         * This is especially useful when using filtering and items with html.
         */
        selectedItemOverride?: string | KnockoutObservableBase<string>;
        /**
         * Value of the item.
         */
        value: TValue;
        /**
         * Disabled state of the item. `selectAll` is not supported with disabled drop-down items.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for item.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Describes an Group used for items in the DropDown.
     */
    export interface Group<TValue> {
        /**
         * Content to render for the item.
         * If you use HtmlContent, use `ariaLabel` for screen reader support.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Items to render under this group.
         */
        children?: Array<Item<TValue> | Group<TValue>> | KnockoutObservableBase<Array<Item<TValue> | Group<TValue>>>;
        /**
         * Disabled state of group. `selectAll` is not supported with disabled drop-down items.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for group.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface BaseOptions<TValue> {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * String/HtmlContent shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Items to render in the DropDown.
         */
        items?: Array<Item<TValue> | Group<TValue>> | KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Indicates that the control is in a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown. Default is false.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The disabled state of the control. Default is false.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | Array<TValue> | KnockoutObservableBase<TValue | Array<TValue>>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Message shown at bottom of dropdown when no items are remain after filtering (by default).
         * You can set an empty string if you don't want to show any message.
         *
         * Optionally, manipulate visibility  with 'showStatusMessage' for use in other applications.
         */
        statusMessage?: HtmlContent | KnockoutObservableBase<HtmlContent>;
        /**
         * Manipulate visibility of 'statusMessage'.
         * Leave as is or set to undefined to have the default filtering behavior.
         */
        showStatusMessage?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show the search icon in the filter textbox. Default is false.
         */
        showSearchIcon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Telemetry identifier.
         */
        telemetryName?: string;
        /**
         * Popup state of the DropDown.
         */
        isPopUpOpen?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Base DropDown control view model.
     */
    export interface BaseContract<TValue> extends FormContract {
        /**
         * Popup state of the DropDown.
         */
        readonly isPopUpOpen: KnockoutObservableBase<boolean>;
        /**
         * Current value of the filter TextBox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         */
        readonly filterPlaceholder: KnockoutObservableBase<string>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        readonly placeholder: KnockoutObservableBase<string>;
        /**
         * Items to render in the DropDown.
         */
        readonly items: KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Indicates that the control is in a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown. Default is false.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Stops the selected item from updating, if items are changed.
         * This is useful while changing items via 'filterString' or a 'customFilter'.
         */
        readonly suppressSelectedUpdate: KnockoutObservableBase<boolean>;
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<TValue> & KnockoutObservableBase<Array<TValue>>;
        /**
         * Message shown at bottom of dropdown when no items are remain after filtering (by default).
         * You can set an empty string if you don't want to show any message.
         *
         * Optionally, manipulate visibility  with 'showStatusMessage' for use in other applications.
         */
        readonly statusMessage: KnockoutObservableBase<HtmlContent>;
        /**
         * Manipulate visibility of 'statusMessage'.
         * Leave as is or set to undefined to have the default filtering behavior.
         */
        readonly showStatusMessage: KnockoutObservableBase<boolean>;
        /**
         * Show the search icon in the filter textbox. Default is false.
         */
        readonly showSearchIcon: KnockoutObservableBase<boolean>;
        /**
         * Telemetry identifier.
         */
        readonly telemetryName: string;
    }
    /**
     * DropDown control options.
     */
    export interface Options<TValue> extends BaseOptions<TValue> {
        /**
         * Enable filtering. Default is false.
         *
         * When filtering, the control does a substring match over the item's text property (if a string).
         * If the text property is HtmlContent, the control does a substring match on the rendered content text.
         *
         * If the HtmlContent content has data-bound content, the control does not consider the item for filtering.
         * For this scenario, the 'customFilter' option should be used.
         */
        filter?: boolean;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Callback which will override the default substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only enabled when filter is set to true.
         */
        customFilter?: (value: string) => Promise<TValue[]>;
        /**
         * Enable multiselect. Default is false.
         */
        multiselect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected".
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * Enables 'select all' for multiselect. Default is false. Not supported with disabled drop-down items.
         */
        selectAll?: boolean;
        /**
         * Callback which will override the default 'select all' functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => Promise<any>;
        /**
         * Maximum width beyond which the expanded drop-down popup will not grow at the expense
         * of displaying ellipsis on drop-down items with content longer than that.
         */
        popupWidthHint?: number | PopupWidth | KnockoutObservableBase<number | PopupWidth>;
    }
    /**
     * DropDown control view model.
     */
    export interface Contract<TValue> extends BaseContract<TValue> {
        /**
         * Current value of the filter TextBox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         */
        readonly filterPlaceholder: KnockoutObservableBase<string>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected".
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
        /**
         * Stops the selected item from updating, if items are changed.
         * This is useful while changing items via 'filterString' or a 'customFilter'.
         */
        readonly suppressSelectedUpdate: KnockoutObservableBase<boolean>;
        /**
         * Maximum width beyond which the expanded drop-down popup will not grow at the expense
         * of displaying ellipsis on drop-down items with content longer than that.
         */
        readonly popupWidthHint: KnockoutObservableBase<number | PopupWidth>;
    }
    /**
     * Creates a DropDown control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a DropDown control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
    /**
     * @deprecated DropDown.ObsoleteOptions - Options used in old construction pattern.  For new controls, please use the new create pattern.
     * No new features or fixes are added here.
     */
    export interface ObsoleteOptions<T> {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Items to render in the DropDown.
         */
        items?: KnockoutObservableArray<Item<T> | Group<T>>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder?: string | KnockoutObservableBase<string>;
        /**
         * Enable filtering. Default is false.
         *
         * When filtering, the control does a substring match over the item's text property (if a string).
         * If the text property is HtmlContent, the control does a substring match on the rendered content text.
         *
         * If the HtmlContent content has data-bound content, the control does not consider the item for filtering.
         * For this scenario, the 'customFilter' option should be used.
         */
        filter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Callback which will override the default simple substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only works when filter is set to true.
         */
        customFilter?: (value: string) => Promise<T[]>;
        /**
         * Toggle multiselect on.
         */
        multiselect?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Enables select all for multiselect. Not supported with disabled drop-down items.
         */
        selectAll?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override the default selectAll functionality.
         * Allows you to select any items you wish, we don't do any selecting when you provide this override.
         */
        selectAllOverride?: () => Promise<any>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl?: boolean;
        /**
         * Aria label for DropDown.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Display text format for multiselect.
         * By default the format string is "{0} selected".
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * Old construction pattern.  Instead of creating instances of this class, please use the create methods in this module instead.
     * No new features or fixes are added here.
     */
    export class ViewModel<TValue> extends MsPortalFx.ViewModels.Forms.Base.Input.ViewModel<TValue> {
        /**
         * Items to render in the DropDown.
         */
        items: KnockoutObservableArray<Item<TValue> | Group<TValue>>;
        /**
         * Turn filtering on/off.
         */
        filter: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sets the filter TextBox placeholder text.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         */
        filterPlaceholder: string | KnockoutObservableBase<string>;
        /**
         * Sets the placeholder text. Shown when the there is no value selected.
         * Default is blank.
         *
         * This is equivalent to the 'placeholder' attribute on an input tag.
         * Multiselect doesn't support placeholder, use multiItemDisplayText.
         */
        placeholder: string | KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Callback which will override the default simple substring filtering.
         * Return list of items (by item value) you wish to show.
         * Only works when filter is set to true.
         */
        customFilter: (value: string) => Promise<TValue[]>;
        /**
         * Turn multiselect on/off.
         */
        multiselect: boolean | KnockoutObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected".
         */
        multiItemDisplayText: string | KnockoutObservableBase<string>;
        /**
         * Turn multiselect on/off. Not supported with disabled drop-down items.
         */
        selectAll: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback which will override the default selectAll functionality.
         */
        selectAllOverride: () => Promise<any>;
        /**
         * Stops the selected from updating, if items are changed.
         */
        suppressSelectedUpdate: KnockoutObservableBase<boolean>;
        /**
         * Value is of type T or Array<TValue> depending on whether multiselect is set;
         */
        value: KnockoutObservableBase<TValue> & KnockoutObservableBase<Array<TValue>>;
        /**
         * Aria label for DropDown.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Popup state of of the DropDown.
         */
        readonly isPopUpOpen: KnockoutObservableBase<boolean>;
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDown is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, observablePath: string, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
        /**
         * This is an old construction pattern.  Please use the create method in this module instead.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the DropDown is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the DropDown control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: MsPortalFx.ViewModels.Forms.Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<any>, options?: ObsoleteOptions<TValue> & MsPortalFx.ViewModels.Forms.Base.Input.Options<TValue>);
    }
}

// FILE: Fx\Controls\DurationPicker.d.ts
declare module "Fx/Controls/DurationPicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a duration picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * Aria label for the DurationPicker. If supplied, the aria label applied to each of the inner controls will be the 'ariaLabel' value prepended to inner control's logical name (like 'days', 'hours', etc).
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * DurationPicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
    }
    /**
     * Creates a duration picker control viewmodel.
     * Note: The only options that you will be able to dynamically update are the ones that are passed in as observables.
     * ie: if you pass in { label: ko.observable("myLabel") }, the label property on your viewmodel will be observable, but the sublabel property will not be.
     * similarly, if you pass in { label: "myLabel" } as your options, and you will not be able to update your label dynamically.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a duration picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\EditableGrid.d.ts
declare module "Fx/Controls/EditableGrid" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { SelectionMode } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    /**
     * EditableGrid selection mode.
     */
    export { SelectionMode };
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * EditableGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, a control, or an observable that returns a string or control.
         */
        content?: string | HtmlContent | Control | KnockoutObservableBase<string | HtmlContent | Control>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * EditableGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent | Control>;
    }
    /**
     * EditableGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export interface ColumnDefinition<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Creates an input control such as TextBox, DropDown, or NumericTextBox that
         * enables the user to edit the cell value.
         *
         *     createCellEditor: (editorLifetime, item) => {
         *         return TextBox.create(editorLifetime, {
         *             value: item.valueProperty // Bind the item property to the text box for editing
         *         });
         *     })
         *
         * @param editorLifetime The lifetime manager for the cell editor control.
         * @param item The data item for the row.
         * @param row The containing row.
         * @returns The input control used for editing the cell value.
         */
        createCellEditor?: (editorLifetime: MsPortalFx.Base.LifetimeManager, item: TItem, row: Row<TItem>) => Control | KnockoutReadOnlyObservableBase<Control>;
        /**
         * Callback to define cell properties.
         *
         * @param cellLifetime The cell lifetime manager.
         * @param item The item to create the cell for.
         * @param row The containing row.
         * @returns The cell definition or the cell display content as a string or control.
         */
        defineCell: (cellLifetime: MsPortalFx.Base.LifetimeManager, item: TItem, row: Row<TItem>) => DefineCellDefinition | string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * If need to set additional column header properties provide a column header definition.
         */
        header?: ColumnHeaderDefinition | string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid column.
     * Part of the EditableGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Editable grid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         *
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * EditableGrid cell definition.
     * The CellDefinition contains properties that are used to initialize a new Cell.
     */
    export interface DefineCellDefinition {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The content to display in the cell.
         * The content will usually be a string representation of a data item value.
         * For numbers and dates this may require NumberFormat and DateTimeFormat from "MsPortalFx/Globalization".
         * If the value can change and you want the cell to update use an observable or computed for the content.
         * To display images or other UI in the cell provide CustomHtml or other control for the content.
         */
        content?: string | HtmlContent | Control | KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
    }
    /**
     * EditableGrid cell.
     * Part of the EditableGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
        /**
         * The content to display in the cell.
         */
        readonly content: KnockoutReadOnlyObservableBase<string | HtmlContent | Control>;
        /**
         * The cell editor control for editing cell content.
         * Will be null if cell has not been edited or is not editable.
         */
        readonly editor: KnockoutReadOnlyObservableBase<Control>;
        /**
         * Indicates if the cell editor control is dirty because the user made a change.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Triggers validation of the cell.
         */
        triggerValidation(): Promise<boolean>;
        /**
         * Extension-defined cell validation errors.
         * Extensions can add custom errors to this array to flag a cell as invalid in the UI.
         * When the error condition is cleared the extension should remove the errors from this array to remove the error UI.
         */
        readonly customValidationErrors: KnockoutObservableArray<string>;
        /**
         * Validation results from the cell editor control.
         * This is a read-only collection of the validation errors extracted from the cell editor control.
         */
        readonly editorValidationErrors: KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * EditableGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Enables the row to expand in height to fit the cell content.
         * When enabled the height property is a minimum row height instead of a fixed height.
         * By default the row height is fixed and cell content may be clipped.
         */
        expandable?: boolean;
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         *
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * EditableGrid row.
     * Part of the EditableGrid object model.
     * Accessed by grid.rows()[index].
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is hovered.
         */
        readonly hovered: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is being edited.
         */
        readonly editing: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is dirty because the user edited the value of one or more of the cells.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Triggers validation of the row.
         */
        triggerValidation(): Promise<boolean>;
        /**
         * All cell and cell editor control validation errors for the row.
         * This is a read-only collection of all the cell validation errors within the row.
         */
        readonly validationErrors: KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * Grid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Grid header.
     * Part of the EditableGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid focus options.
     */
    export interface FocusOptions<TItem> {
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid focus contract.
     */
    export interface FocusContract<TItem> {
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
    }
    /**
     * EditableGrid selection options.
     */
    export interface SelectionOptions<TItem> {
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Determines if a row can be selected.
         *
         * @param row The row to select.
         * @param grid The grid.
         * @returns Indicates if the row can be selected.
         */
        canSelectRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if a row can be unselected.
         *
         * @param row The row to unselect.
         * @param grid The grid.
         * @returns Indicates if the row can be unselected.
         */
        canUnselectRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if all rows can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all rows can be selected at once.
         */
        canSelectAllRows?: (grid: Contract<TItem>) => boolean;
        /**
         * Determines if all rows can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all rows can be unselected at once.
         */
        canUnselectAllRows?: (grid: Contract<TItem>) => boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all rows are selected.
         */
        readonly allRowsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected rows.
         * Commands should use the selectedOrCurrentRows property in most scenarios.
         */
        readonly selectedRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The selected rows or the current row if there are no selected rows.
         * Commands should use this property instead of selectedRows if they
         * must work on the current row when the user has not made a selection yet.
         */
        readonly selectedOrCurrentRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
    }
    /**
     * EditableGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Indicates if all rows are selected.
         */
        readonly allRowsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected rows.
         * Commands should use the selectedOrCurrentRows property in most scenarios.
         */
        readonly selectedRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The selected rows or the current row if there are no selected rows.
         * Commands should use this property instead of selectedRows if they
         * must work on the current row when the user has not made a selection yet.
         */
        readonly selectedOrCurrentRows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * Determines if a row can be selected.
         *
         * @param row The row to select.
         * @returns Indicates if a row can be selected.
         */
        canSelectRow(row: Row<TItem>): boolean;
        /**
         * Selects a row.
         *
         * @param row The row to select.
         * @returns Indicates if the row was selected.
         */
        selectRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row can be unselected.
         *
         * @param row The row to unselect.
         * @returns Indicates if a row can be unselected.
         */
        canUnselectRow(row: Row<TItem>): boolean;
        /**
         * Unselects a row.
         *
         * @param row The row to unselect.
         * @returns Indicates if the row was unselected.
         */
        unselectRow(row: Row<TItem>): boolean;
        /**
         * Indicates if all rows can be selected.
         */
        readonly canSelectAllRows: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Selects all rows.
         *
         * @returns Indicates if all rows were selected.
         */
        selectAllRows(): boolean;
        /**
         * Indicates if all rows can be unselected.
         */
        readonly canUnselectAllRows: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Unselects all rows.
         *
         * @returns Indicates if all rows were unselected.
         */
        unselectAllRows(): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid activation options.
     */
    interface ActivationOptions {
        /**
         * Hides the selection while a child blade is opened.
         * Leaves the current row highlighting only on the activated row.
         * When the child blade is closed the selection is restored unless the user changed the selection while the child blade was open.
         * There are very few scenarios where you would enable this behavior.
         * Typically the only scenario this is used is when you want to collapse the parent blade to show the child blade next to it.
         * This is disabled by default.
         */
        hideSelectionDuringActivation?: boolean;
    }
    /**
     * EditableGrid activation contract.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * EditableGrid hover contract.
     */
    export interface HoverContract<TItem> {
        /**
         * The currently hovered row.
         * Null when a row is not hovered.
         */
        readonly hoveredRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param row The row.
         * @returns A promise for completion
         */
        hoverRow(row: Row<TItem>): Promise<boolean>;
    }
    /**
     * EditableGrid toolbar options.
     */
    export interface ToolbarOptions<TItem> {
        /**
         * Hides or shows the toolbar.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback to create a customized toolbar.
         * If no callback is supplied the EditableGrid will create a default toolbar.
         *
         * @param toolbarLifetime The lifetime manager for the toolbar.
         * @param grid The grid for creating built-in toolbar items like grid.deletion.createDeleteRowsCommand(toolbarLifetime, grid.selection).
         *             (BREAKING: This parameter used to be a ToolbarItems interface and is now a grid contract to be used as described above.)
         * @returns The toolbar view model that will be used within the grid header.
         */
        createToolbar?: (toolbarLifetime: MsPortalFx.Base.LifetimeManager, grid: Contract<TItem>) => ToolbarControl.Contract;
    }
    /**
     * Toolbar button creation options for grid command factory methods.
     */
    export interface ToolbarButtonOptions {
        /**
         * Telemetry identifier of the toolbar item.
         */
        telemetryName?: string;
        /**
         * The aria label to use instead of the default text label.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The regular tooltip of the toolbar item.
         */
        tooltip?: string | KnockoutObservableBase<string>;
        /**
         * The command label.
         */
        label?: string | KnockoutObservableBase<string>;
        /**
         * The icon for the command.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The tooltip shown when the button is disabled.
         */
        disabledMessage?: string | KnockoutObservableBase<string>;
    }
    /**
     * EditableGrid toolbar contract.
     */
    export interface ToolbarContract<TItem> {
        /**
         * The toolbar view model.
         */
        readonly viewModel: ToolbarControl.Contract;
        /**
         * Controls the toolbar visibility in the grid header.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid addition options.
     */
    export interface AdditionOptions<TItem> {
        /**
         * Callback to create a new item.
         * The item will be held in the placeholder row until committed.
         *
         * @returns A newly created item.
         */
        createItem: () => TItem;
        /**
         * Determines if the user can add additional rows.
         *
         * @param grid The grid.
         * @returns Indicates if the user can add additional rows
         */
        canAddRow?: (grid: Contract<TItem>) => boolean;
        /**
         * Callback when row is added.
         *
         * @param row The added row.
         * @param grid The grid.
         */
        onAddRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid addition contract.
     */
    export interface AdditionContract<TItem> {
        /**
         * Determines if rows can be added
         */
        canAddRow: KnockoutReadOnlyObservableBase<boolean>;
    }
    /**
     * EditableGrid deletion options.
     */
    export interface DeletionOptions<TItem> {
        /**
         * Determines if rows can be deleted.
         *
         * @param rows The rows to delete.
         * @param grid The grid.
         * @returns Indicates if the rows can be deleted.
         */
        canDeleteRows?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Notifies when rows have been deleted.
         *
         * @param rows The rows that were deleted.
         * @param grid The grid.
         */
        onDeleteRows?: (rows: Row<TItem>[], grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid deletion contract.
     */
    export interface DeletionContract<TItem> {
        /**
         * Determines if rows can be deleted.
         *
         * @param rows The rows to delete.
         * @returns Indicates if the rows can be deleted.
         */
        canDeleteRows(rows: Row<TItem>[]): boolean;
        /**
         * Deletes the specified rows.
         *
         * @param rows The rows to delete.
         * @returns Indicates if the rows were deleted.
         */
        deleteRows(rows: Row<TItem>[]): boolean;
        /**
         * Creates a toolbar button for deletion using the supplied rows as the command context.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to be deleted.
         * @param options Toolbar button options for overriding defaults.
         */
        createDeleteRowsCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
    }
    /**
     * EditableGrid editing options.
     */
    export interface EditingOptions<TItem> {
        /**
         * Determines if the specified row can be edited.
         *
         * @param row The row to edit.
         * @param grid The grid.
         * @returns Indicates if the row can be edited.
         */
        canEditRow?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if the specified row can stop editing.
         *
         * @param row The row to stop editing.
         * @param grid The grid.
         * @returns Promise that indicates if the row can stop editing.
         */
        canStopEditingRow?: (row: Row<TItem>, grid: Contract<TItem>) => Promise<boolean>;
    }
    /**
     * EditableGrid editing contract.
     */
    export interface EditingContract<TItem> {
        /**
         * Determines if a row can be edited.
         *
         * @param row The row to edit.
         * @returns Indicates if the row can be edited.
         */
        canEditRow(row: Row<TItem>): boolean;
        /**
         * Puts the specified row into editing mode for the user to edit it.
         *
         * @param row The row to edit.
         * @returns Indicates if the row was put into edit mode.
         */
        editRow(row: Row<TItem>): boolean;
        /**
         * Determine if the row can close all cell editors.
         *
         * @param row The row to stop editing.
         * @returns Promise that indicates if the row can stop editing.
         */
        canStopEditingRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Stops editing the row by closing all the cell editors of the row.
         *
         * @param row The row to stop editing.
         * @returns Promise that indicates if the row successfully stopped editing.
         */
        stopEditingRow(row: Row<TItem>): Promise<boolean>;
    }
    /**
     * EditableGrid insertion options.
     */
    export interface InsertionOptions<TItem> {
        /**
         * Callback to create an new item for insertion.
         *
         * @returns A newly created item.
         */
        createItem: () => TItem;
        /**
         * Determines if a new row can be inserted before the specified row.
         *
         * @param rowBefore The row to insert a new row before.
         * @param grid The grid.
         * @returns Indicates if a new row can be inserted before the specified row.
         */
        canInsertRow?: (rowBefore: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Notifies when a row has been inserted.
         *
         * @param row The row that was inserted.
         * @param grid The grid.
         */
        onInsertRow?: (row: Row<TItem>, grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid insertion contract.
     */
    export interface InsertionContract<TItem> {
        /**
         * Determine if a new row can be inserted before the specified row.
         *
         * @param rowBefore The row to insert a new row before.
         * @returns Indicates if a new row can be inserted before the specified row.
         */
        canInsertRow(rowBefore: Row<TItem>): boolean;
        /**
         * Inserts a new row before the specified row.
         * The grid calls the createItem callback to generate the new item that will be inserted.
         *
         * @param rowBefore The row to insert a new row before.
         * @returns Indicates if a new row was inserted.
         */
        insertRow(rowBefore: Row<TItem>): boolean;
        /**
         * Creates a toolbar button for inserting a row before the supplied row context.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The current row or rows to apply the command status to.  Will be disabled if more than one row is present.
         * @param options Toolbar button options for overriding defaults.
         */
        createInsertRowCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
    }
    /**
     * EditableGrid reordering options.
     */
    export interface ReorderingOptions<TItem> {
        /**
         * Determines if the rows can be moved to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the specified row position.
         */
        canMoveRowsToRow?: (rows: Row<TItem>[], to: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved up.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved up.
         */
        canMoveRowsUp?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved down.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved down.
         */
        canMoveRowsDown?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved to top.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the top.
         */
        canMoveRowsTop?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines if the rows can be moved to bottom.
         *
         * @param rows The rows to move.
         * @param grid The grid.
         * @returns Indicates if the rows can be moved to the bottom.
         */
        canMoveRowsBottom?: (rows: Row<TItem>[], grid: Contract<TItem>) => boolean;
        /**
         * Determines it the reordering drag handle UI is visible.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid reordering contract.
     */
    export interface ReorderingContract<TItem> {
        /**
         * Determines if rows can be moved to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @returns Indicates if the rows can be moved to the specified row position.
         */
        canMoveRowsToRow(rows: Row<TItem>[], to: Row<TItem>): boolean;
        /**
         * Moves rows to the specified row position.
         *
         * @param rows The rows to move.
         * @param to The row in the position where the rows are to be moved.
         * @returns Indicates if the rows were moved.
         */
        moveRowsToRow(rows: Row<TItem>[], to: Row<TItem>): boolean;
        /**
         * Determines if rows can be moved up.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved up.
         */
        canMoveRowsUp(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows up.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsUp(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved down.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved down.
         */
        canMoveRowsDown(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows down.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsDown(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved to the top.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved to the top.
         */
        canMoveRowsTop(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows to the top.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsTop(rows: Row<TItem>[]): boolean;
        /**
         * Determines if rows can be moved to the bottom.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows can be moved to the bottom.
         */
        canMoveRowsBottom(rows: Row<TItem>[]): boolean;
        /**
         * Moves rows to the bottom.
         *
         * @param rows The rows to move.
         * @returns Indicates if the rows were moved.
         */
        moveRowsBottom(rows: Row<TItem>[]): boolean;
        /**
         * Creates a toolbar button for moving the supplied context rows up.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @returns The command button.
         */
        createMoveRowsUpCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows down.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @returns The command button.
         */
        createMoveRowsDownCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows to the top.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @returns The command button.
         */
        createMoveRowsTopCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Creates a toolbar button for moving the supplied context rows to the bottom.
         *
         * @param lifetime The lifetime manager for the command.
         * @param context The row or rows to move.
         * @param options Toolbar button options for overriding defaults.
         * @returns The command button.
         */
        createMoveRowsBottomCommand(lifetime: MsPortalFx.Base.LifetimeManager, context: Row<TItem> | KnockoutObservableBase<Row<TItem>> | Row<TItem>[] | KnockoutObservableBase<Row<TItem>[]> | SelectionState<TItem>, options?: ToolbarButtonOptions): ToolbarControl.ToolbarItems.BasicButtonContract;
        /**
         * Determines it the reordering drag handle UI is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid resizing options.
     */
    export interface ResizingOptions<TItem> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem>) => void;
    }
    /**
     * EditableGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is disabled.
         * Vertical scrolling requires that the element the grid is bound to has a height.
         * Having a height allows the grid to display a vertical scrollbar and fix the header at the top.
         */
        vertical?: boolean;
    }
    /**
     * EditableGrid validation options.
     */
    export interface ValidationOptions<TItem> {
        /**
         * Custom validation call back.
         * Called to validate the grid when the form is validated.
         * Errors can be added and removed from particular cells using the cell customValidationErrors array.
         *
         * @param grid The grid.
         * @returns Indicates if the grid is valid.
         */
        validate?: (grid: Contract<TItem>) => boolean;
        /**
         * Custom async validation call back.
         * Called to validate the grid when the form is validated.
         * Errors can be added and removed from particular cells using the cell customValidationErrors array.
         *
         * @param grid The grid.
         * @returns Promise indicating if the grid is valid.
         */
        validateAsync?: (grid: Contract<TItem>) => Promise<boolean>;
        /**
         * Creates a customized display of validation errors.
         *
         * @param lifetime The lifetime manager for the validation footer.
         * @param row The row to contain the footer. The validationErrors property of the row will have the errors to display.
         * @returns The control to present as the row validation footer.
         */
        createRowValidationFooter?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => HtmlContent | Control;
    }
    /**
     * EditableGrid validation contract.
     */
    export interface ValidationContract<TItem> {
        /**
         * Triggers validation of the grid.
         *
         * @returns Promise that indicates if the grid is valid.
         */
        triggerValidation(): Promise<boolean>;
        /**
         * Indicates if the grid is valid.
         * This is the result of the latest validation.
         */
        readonly valid: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * EditableGrid context menu options.
     */
    export interface ContextMenuOptions<TItem> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem>) => boolean;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid options.
     */
    export interface Options<TItem> {
        /**
         * Activation options.
         * Activation is enabled by default.
         * Activation can not be disabled by omitting the activation options or setting to null.
         */
        activation?: ActivationOptions;
        /**
         * Addition options for adding new rows.
         * Addition is disabled by default.
         * Addition can be enabled by specifying addition options.
         */
        addition?: AdditionOptions<TItem>;
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[] | KnockoutObservableArray<ColumnDefinition<TItem>>;
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Deletion options for deleting rows.
         * Deletion is disabled by default.
         * Deletion can be enabled by specifying deletion options.
         */
        deletion?: DeletionOptions<TItem>;
        /**
         * Disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Editing options for editing existing rows.
         * Editing is enabled by default.
         * Editing can not be disabled by omitting editing options or setting to null.
         * Providing a cell editor control on a column will enable editing of cells withing the column.
         * The canEditRow callback can be used to disable editing of particular rows.
         */
        editing?: EditingOptions<TItem>;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Insertion options for inserting a new row.
         * Insertion is disabled by default.
         * Insertion can be enabled by specifying insertion options.
         */
        insertion?: InsertionOptions<TItem>;
        /**
         * The array of items to be edited.
         * Changes will be made directly to this array as the user makes edits.
         * This is required because it is expected that the existing data is obtained before creating the grid.
         * If you do not have existing data you can specify an empty array.
         */
        items: TItem[] | KnockoutObservableArray<TItem>;
        /**
         * Reordering options for reordering rows.
         * Reordering is disabled by default.
         * Reordering can be enabled by specifying reordering options.
         */
        reordering?: ReorderingOptions<TItem>;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem>;
        /**
         * Row initialization options
         */
        row?: RowDefinition<TItem>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is disabled.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is enabled by default.
         * Selection can not be disabled by omitting selection options or setting to null.
         */
        selection?: SelectionOptions<TItem>;
        /**
         * Toolbar options.
         * The toolbar is disabled by default.
         * The toolbar can be enabled by providing toolbar options.
         */
        toolbar?: ToolbarOptions<TItem>;
        /**
         * Validation options.
         * Validation is enabled by default.
         * Validation can not be disabled by omitting validation options or setting to null.
         */
        validation?: ValidationOptions<TItem>;
        /**
         * Hides or shows the EditableGrid.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * EditableGrid loading message options.
     */
    export interface LoadingMessageOptions {
        /**
         * Message to be displayed/announced while loading.
         */
        message?: string;
        /**
         * Message to be announced on loading completion.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
    }
    /**
     * EditableGrid contract.
     */
    export interface Contract<TItem> extends Control {
        /**
         * EditableGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * EditableGrid grid row addition properties and methods.
         */
        readonly addition: AdditionContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Gets or sets the EditableGrid dirty state.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * If called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional messages to display and announce to screen readers.
         * @returns A Promise that is resolved when the message is shown or determined not to be shown.
         */
        displayLoadingMessage(completion: Promise<any>, message?: string | LoadingMessageOptions): Promise<boolean>;
        /**
         * EditableGrid row deletion properties and methods.
         */
        readonly deletion: DeletionContract<TItem>;
        /**
         * EditableGrid row editing properties and methods.
         */
        readonly editing: EditingContract<TItem>;
        /**
         * EditableGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Hover properties and methods.
         */
        readonly hover: HoverContract<TItem>;
        /**
         * Editable grid row insertion properties and methods.
         */
        readonly insertion: InsertionContract<TItem>;
        /**
         * The array of items to be edited.
         * Changes will be made directly to this array as the user makes edits.
         */
        readonly items: KnockoutObservableArray<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() method.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() method.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * EditableGrid row reordering properties and methods.
         */
        readonly reordering: ReorderingContract<TItem>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * EditableGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * EditableGrid toolbar properties and methods.
         */
        readonly toolbar: ToolbarContract<TItem>;
        /**
         * EditableGrid row validation properties and methods.
         */
        readonly validation: ValidationContract<TItem>;
        /**
         * Hides or shows the EditableGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an EditableGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem>): Contract<TItem>;
}

// FILE: Fx\Controls\Editor.d.ts
declare module "Fx/Controls/Editor" {
    import * as Base from "Fx/Controls/ControlsBase";
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * Exposes the second part of a keyboard shortcut allowed to be mapped to the Monaco editor, if there are two keys in the shortcut.
     * Otherwise, exposes the only key bound to the shortcut.
     * The enum values are copied from Monaco Editor API(https://microsoft.github.io/monaco-editor) and should be kept in sync with it.
     */
    export const enum KeyCode {
        /**
         * Placed first to cover the 0 value of the enum.
         */
        Unknown = 0,
        Backspace = 1,
        Tab = 2,
        Enter = 3,
        Shift = 4,
        Ctrl = 5,
        Alt = 6,
        PauseBreak = 7,
        CapsLock = 8,
        Escape = 9,
        Space = 10,
        PageUp = 11,
        PageDown = 12,
        End = 13,
        Home = 14,
        LeftArrow = 15,
        UpArrow = 16,
        RightArrow = 17,
        DownArrow = 18,
        Insert = 19,
        Delete = 20,
        KEY_0 = 21,
        KEY_1 = 22,
        KEY_2 = 23,
        KEY_3 = 24,
        KEY_4 = 25,
        KEY_5 = 26,
        KEY_6 = 27,
        KEY_7 = 28,
        KEY_8 = 29,
        KEY_9 = 30,
        KEY_A = 31,
        KEY_B = 32,
        KEY_C = 33,
        KEY_D = 34,
        KEY_E = 35,
        KEY_F = 36,
        KEY_G = 37,
        KEY_H = 38,
        KEY_I = 39,
        KEY_J = 40,
        KEY_K = 41,
        KEY_L = 42,
        KEY_M = 43,
        KEY_N = 44,
        KEY_O = 45,
        KEY_P = 46,
        KEY_Q = 47,
        KEY_R = 48,
        KEY_S = 49,
        KEY_T = 50,
        KEY_U = 51,
        KEY_V = 52,
        KEY_W = 53,
        KEY_X = 54,
        KEY_Y = 55,
        KEY_Z = 56,
        Meta = 57,
        ContextMenu = 58,
        F1 = 59,
        F2 = 60,
        F3 = 61,
        F4 = 62,
        F5 = 63,
        F6 = 64,
        F7 = 65,
        F8 = 66,
        F9 = 67,
        F10 = 68,
        F11 = 69,
        F12 = 70,
        F13 = 71,
        F14 = 72,
        F15 = 73,
        F16 = 74,
        F17 = 75,
        F18 = 76,
        F19 = 77,
        NumLock = 78,
        ScrollLock = 79,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ';:' key
         */
        US_SEMICOLON = 80,
        /**
         * For any country/region, the '+' key
         * For the US standard keyboard, the '=+' key
         */
        US_EQUAL = 81,
        /**
         * For any country/region, the ',' key
         * For the US standard keyboard, the ',<' key
         */
        US_COMMA = 82,
        /**
         * For any country/region, the '-' key
         * For the US standard keyboard, the '-_' key
         */
        US_MINUS = 83,
        /**
         * For any country/region, the '.' key
         * For the US standard keyboard, the '.>' key
         */
        US_DOT = 84,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '/?' key
         */
        US_SLASH = 85,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '`~' key
         */
        US_BACKTICK = 86,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '[{' key
         */
        US_OPEN_SQUARE_BRACKET = 87,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the '\|' key
         */
        US_BACKSLASH = 88,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ']}' key
         */
        US_CLOSE_SQUARE_BRACKET = 89,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         * For the US standard keyboard, the ''"' key
         */
        US_QUOTE = 90,
        /**
         * Used for miscellaneous characters; it can vary by keyboard.
         */
        OEM_8 = 91,
        /**
         * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
         */
        OEM_102 = 92,
        NUMPAD_0 = 93,
        NUMPAD_1 = 94,
        NUMPAD_2 = 95,
        NUMPAD_3 = 96,
        NUMPAD_4 = 97,
        NUMPAD_5 = 98,
        NUMPAD_6 = 99,
        NUMPAD_7 = 100,
        NUMPAD_8 = 101,
        NUMPAD_9 = 102,
        NUMPAD_MULTIPLY = 103,
        NUMPAD_ADD = 104,
        NUMPAD_SEPARATOR = 105,
        NUMPAD_SUBTRACT = 106,
        NUMPAD_DECIMAL = 107,
        NUMPAD_DIVIDE = 108,
        /**
         * Cover all key codes when IME is processing input.
         */
        KEY_IN_COMPOSITION = 109,
        ABNT_C1 = 110,
        ABNT_C2 = 111,
        /**
         * Placed last to cover the length of the enum.
         * Please do not depend on this value!
         */
        MAX_VALUE = 112
    }
    /**
     * Exposes the first part of a keyboard shortcut allowed to be mapped to the Monaco editor, if the shortcut contains two keys.
     * The enum values are copied from Monaco Editor API(https://microsoft.github.io/monaco-editor) and should be kept in sync with it.
     */
    export const enum KeyModifier {
        CtrlCmd = 2048,
        Shift = 1024,
        Alt = 512
    }
    /**
     * Custom Keyboard shortcuts that can be bound to CallBack functions.
     */
    export interface CustomCommand {
        commandCallback: (keyCode: KeyCode, keyModifier?: KeyModifier) => void;
        keyCode: KeyCode;
        keyModifier?: KeyModifier;
    }
    /**
     * Options for creating an editor control
     */
    export interface Options {
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Custom Keyboard shortcuts that can be bound to CallBack functions.
         */
        readonly customCommands?: CustomCommand[] | KnockoutObservableArray<CustomCommand>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The content of the editor.
         */
        readonly content: string | KnockoutObservableBase<string>;
        /**
         * Content uri is used to infer the content type, if content is not given. Editor does not load the content from the Uri.
         */
        readonly contentUri?: string | KnockoutObservableBase<string>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers?: Marker[] | KnockoutObservableBase<Marker[]>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize?: number | KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn?: number | KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines?: number | KnockoutObservableBase<number>;
        /**
         * Enables highlighting of all words/tokens matching the words/tokens under the cursor position.
         * blockHighlight is not affected by this value.
         * Defaults to true.
         */
        readonly selectionHighlight?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Enables highlighting the block under the cursor position.
         * The block definition can be provided using the defineBlock callback.
         * selectionHighlight is not affected by this value.
         * Defaults to false.
         */
        readonly blockHighlight?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Block highlight definition.
         * If the callback is provided, its logic will be used to identify the block based on cursor position.
         * If the callback is not provided, the default logic is used where blank lines act as the block delimiters.
         */
        readonly defineBlock?: (cursorPosition: CursorPosition, lines: string[]) => Range;
        /**
         * Defines an auto save delay in millisenconds when it expires the editor changes are saved.
         * The delay is set each time the user changes the text and if there where no changes until the time expires the changes are saved
         * Zero -or- null means auto save is disabled.
         * Defaults to 500 milliseconds.
         */
        readonly autoSaveDelay?: number;
    }
    /**
     * Type of editor content.
     * Used to enable language specific editor features like colorization.
     */
    export const enum ContentType {
        /**
         * Text.
         * 'text/plain'
         */
        Text = 0,
        /**
         * Custom Content Type.
         */
        Custom = 1,
        /**
         * Batch Script.
         * 'text/x-bat'
         */
        Bat = 2,
        /**
         * C.
         * 'text/x-c'
         */
        C = 3,
        /**
         * Coffee Script.
         * 'text/x-coffeescript', 'text/coffeescript'
         */
        CoffeeScript = 4,
        /**
         * C++.
         * 'text/x-cpp'
         */
        Cpp = 5,
        /**
         * C#.
         * 'text/x-csharp'
         */
        CSharp = 6,
        /**
         * C# WebPages.
         * 'text/x-cshtml'
         */
        CSHtml = 7,
        /**
         * Cascading Style Sheet.
         * 'text/css'
         */
        Css = 8,
        /**
         * Dockerfile.
         * 'text/x-dockerfile'
         */
        Dockerfile = 9,
        /**
         * F#.
         * 'text/x-fsharp'
         */
        FSharp = 10,
        /**
         * Go.
         * 'text/x-go'
         */
        Go = 11,
        /**
         * Handlebars template.
         * 'text/x-handlebars-template'
         */
        Handlebars = 12,
        /**
         * Html.
         * 'text/html'
         */
        Html = 13,
        /**
         * Initialization file.
         * 'text/x-ini'
         */
        Ini = 14,
        /**
         * Pug.
         * 'pug'
         */
        Pug = 15,
        /**
         * Java.
         * 'text/x-java-source'
         */
        Java = 16,
        /**
         * JavaScript.
         * 'text/javascript'
         */
        JavaScript = 17,
        /**
         * JSHtm.
         * 'text/x-jshtm'
         */
        JSHtm = 18,
        /**
         * JSON.
         * 'application/json'
         */
        Json = 19,
        /**
         * Less.
         * 'text/x-less', 'text/less'
         */
        Less = 20,
        /**
         * Lua.
         * 'text/x-lua'
         */
        Lua = 21,
        /**
         * Mark Down.
         * 'text/x-markdown'
         */
        MarkDown = 22,
        /**
         * Objective-C
         * 'objective-c'
         */
        ObjectiveC = 23,
        /**
         * PHP.
         * 'application/x-php'
         */
        Php = 24,
        /**
         * Power Shell.
         * 'text/x-powershell'
         */
        PowerShell = 25,
        /**
         * Python.
         * 'text/x-python', 'text/python'
         */
        Python = 26,
        /**
         * R.
         * 'text/x-r'
         */
        R = 27,
        /**
         * Ruby.
         * 'text/x-ruby'
         */
        Ruby = 28,
        /**
         * SQL.
         * 'sql'
         */
        Sql = 29,
        /**
         * Swift.
         * 'swift'
         */
        Swift = 30,
        /**
         * TypeScript.
         * 'text/typescript'
         */
        TypeScript = 31,
        /**
         * Visual Basic.
         * 'text/x-vb'
         */
        VisualBasic = 32,
        /**
         * Xaml.
         * 'application/xaml+xml'
         */
        Xaml = 33,
        /**
         * Xml.
         * 'text/xml', 'application/xml'
         */
        Xml = 34,
        /**
         * MySQL.
         * 'mysql'
         */
        MySQL = 35,
        /**
         * PgSQL.
         * 'pgsql'
         */
        PgSQL = 36,
        /**
         * KQL.
         * 'Kql'
         */
        Kql = 37,
        /**
         * YAML.
         * 'Yaml'
         */
        Yaml = 38
    }
    /**
     * Options for creating an editor control
     */
    export interface EditorOptions extends Options {
        /**
         * The type of editor content.
         */
        readonly contentType?: ContentType | KnockoutObservableBase<ContentType>;
    }
    /**
     * Options for creating a Kusto editor control
     */
    export interface KustoEditorOptions extends Options {
        /**
         * The schema of the Kusto database
         */
        readonly contentSchema?: KustoSchema | KnockoutObservableBase<KustoSchema>;
    }
    /**
     * Options for creating a JSON editor control
     */
    export interface JSONEditorOptions extends Options {
        /**
         * JSON schemas.
         */
        readonly schemas: JSONSchema[];
        /**
         * If set, comments are tolerated. If set to false, syntax errors will be emitted for comments.
         */
        readonly allowComments?: boolean;
    }
    /**
     * Options for creating an editor control
     */
    export interface TypeScriptEditorOptions extends Options {
        /**
         * Additional source files to the language service. Use this
         * for typescript (definition) files that won't be loaded as editor
         * document, like `jquery.d.ts`.
         */
        readonly extraLibs?: TypeScriptExtraLib[];
        /**
         * Compiler options for compiling the typescript.
         */
        readonly compilerOptions: TypeScriptCompilerOptions;
    }
    /**
     * Options for creating a custom editor control
     */
    export interface CustomEditorOptions extends Options {
        /**
         * Definition for a custom content type.
         */
        readonly customConfig: CustomConfig;
    }
    /**
     *  A cursor position in the text editor.  Same properties as a Monaco IPosition interface
     */
    export interface CursorPosition {
        /**
         * line number (1-based line number)
         */
        readonly lineNumber: number;
        /**
         * column (the first character in a line is between column 1 and column 2)
         */
        readonly column: number;
    }
    /**
     * JSON schema
     */
    export interface JSONSchema {
        /**
         * A list of filename patterns (including '*' wildcards) for files that should be associated with the schema. For example '*.schema.json', 'package.json'
         */
        readonly fileMatch: string[];
        /**
         * Indicates uri from which schema will be loaded.
         */
        readonly uri?: string;
        /**
         * Indicates to validate schema.
         */
        readonly validate?: boolean;
        /**
         * Inline schema definition.
         */
        readonly schema?: StringMap<any>;
    }
    /**
     * Defines an extra library for intellisense in the typescript editor.
     */
    export interface TypeScriptExtraLib {
        /**
         * The content of the library.
         * For example the content of a library.d.ts file.
         */
        readonly content: string;
        /**
         * The library name.
         * For instance "library.d.ts".
         */
        readonly path?: string;
    }
    /**
     * TypeScript compiler options.
     */
    export interface TypeScriptCompilerOptions {
        /**
         * The target type for compilation.
         * Defaults to ES5.
         */
        readonly target?: TypeScriptTarget;
    }
    /**
     * Definition of a custom language config.
     * See https://microsoft.github.io/monaco-editor/monarch.html
     */
    export interface CustomConfig {
        /**
         * Custom language attributes.
         * These are specific to your language definition.
         *
         * This can be an array of strings:
         *
         * keywords: ["if", "for"],
         *
         * Or this can be a regular expression:
         *
         * symbols: /[=><!~?:&|+-]+/,
         *
         * The attribute can also be a string containing a regular expression.
         */
        readonly [attribute: string]: string | string[] | RegExp | any;
        /**
         * The display name of your language.
         */
        readonly displayName?: string;
        /**
         * Ignore case when compiling regular expressions defined in 'tokenizer'.
         * Default is false.
         */
        readonly ignoreCase?: boolean;
        /**
         * An optional line comment starter.Used in the editor to insert line comments (ctrl + /).
         * Default is two forward slashes.
         */
        readonly lineComment?: string;
        /**
         * A block comment start marker. Used by the editor to insert block comments (shift+alt+A).
         * Default is forward slash asterisk.
         */
        readonly blockCommentStart?: string;
        /**
         * A block comment end marker.
         * Default is asterisk forward slash.
         */
        readonly blockCommentEnd?: string;
        /**
         * The default token returned if nothing matches in the tokenizer.
         * Default is "source".
         * It can be convenient to set this to "invalid" during development of your colorizer to easily spot what is not matched yet.
         */
        readonly defaultToken?: string;
        /**
         * This is used by the tokenizer to easily define matching braces.
         * Each bracket definition is an array of 3 elements, or object, describing the open brace, the close brace, and the token class.
         * The default definition is:
         * [ ['{','}','delimiter.curly'],
         *   ['[',']','delimiter.square'],
         *   ['(',')','delimiter.parenthesis'],
         *   ['<','>','delimiter.angle'] ]
         */
        readonly brackets?: string[][];
        /**
         * A list of auto closing character pairs, used in the editor to automatically insert the closing brace of the pair.
         * The list may end with the single string '@brackets' which automatically includes single-character close brackets defined in the brackets attribute.
         * By default the auto closing pairs are defined as: [['"','"'], ['\'','\''], ['@brackets']]
         */
        readonly autoClosingPairs?: string[][];
        /**
         * Optional postfix attached to all returned tokens.
         * By default this attaches the language name so in the CSS you can refer to your specific language.
         * For example, for the Java language, we could use .identifier.java to target all Java identifiers specifically in CSS.
         */
        readonly tokenPostfix?: string;
        /**
         * The start state of the tokenizer.
         * By default, this is the first entry in the tokenizer attribute.
         */
        readonly start?: string;
        /**
         * Optional list of token classes that are non-word tokens.
         * By default this is defined as: ['delimiter','delimiter.parenthesis','delimiter.curly','delimiter.square','delimiter.angle']
         */
        readonly nonWordTokens?: string[];
        /**
         * Optional string that defines characters that when typed could cause outdentation.
         * This attribute is only used when using advanced brace matching in combination with the bracket attribute.
         * By default it always includes the last characters of the closing brackets in the brackets list.
         * Outdentation happens when the user types a closing bracket word on an line that starts with only white space.
         * If the closing bracket matches a open bracket it is indented to the same amount of that bracket.
         * Usually, this causes the bracket to outdent. For example, in the Ruby language, the end keyword would match with an open declaration like def or class.
         * To make outdentation happen though, we would need to include the d character in the outdentTriggers attribute so it is checked when the users type end:
         *
         * outdentTriggers: 'd',
         */
        readonly outdentTriggers?: string;
        /**
         * This can be used to get autocompletion for certain constructs.
         * For example, in HTML we may want to auto complete a tag with its closing tag when the user types >.
         * A possible way to do this is to define autoComplete:
         *
         * autoComplete: [{
         *     triggers: '>',
         *     match   : '\\s<(\\w+)[^>]*>\\s$',
         *     complete: '</$1>'
         * }],
         *
         * Each matcher specifies three attributes:
         * the triggers attribute gives a string of characters where autocompletion should be checked.
         * On such character, the current input line is tested against match regular expression.
         * If it succeeds, complete is appended to the source with captured groups expanded.
         * To help with matching input, the editor first filters out all whitespace and comment tokens, and then concatenates the remaining tokens where every token is surrounded with a space.
         * The match regular expression is matched against the resulting string.
         */
        readonly autoComplete?: AutoCompleteMatcher[];
        /**
         * This can be used to specify custom auto indentation beyond what is already done for brackets and the bracket attributes.
         * Suppose for example we would like to indent for begin/end pairs.
         * The easy way to do this is off course to just specify this pair as part of the brackets attribute.
         * But for the sake of an example, here is how to do it using autoIndent:
         *
         * autoIndent: [{
         *     match     : "\\sbegin\\s(((?!\\send\\s).)*)$",
         *     matchAfter: "\\send\\s"
         * }],
         *
         * On an enter, the current line is matched against the match regular expression.
         * Note that the line is processed as described in autoComplete where each token is surrounded by a space.
         * If the match succeeds, the next line is indented.
         * If also the matchAfter regular expression matches the tokens following the line break, then an extra break is inserted that is outdented (creating a nice block structure).
         * In the example, the match regular expression matches a line where a begin keyword is present.
         * It uses (?!\\send\\s) to ensure there is no closing end after the begin.
         */
        readonly autoIndent?: AutoIndentMatcher[];
        /**
         * As described for the bracket attribute, the editor uses auto indentation for any bracket.
         * This attribute suppresses auto indentation for any brackets that match the regular expression.
         * For example, here is how to suppress auto indentation for parenthesis and angled braces:
         *
         * noindentBrackets: /[()<>]/,
         */
        readonly noindentBrackets?: RegExp;
        /**
         * Monarch custom language tokenization rules.
         *
         * The tokenizer attribute describes how lexical analysis takes place, and how the input is divided into tokens.
         * Each token is given a CSS class name which is used to render each token in the editor.
         * Standard CSS token classes include:
         *
         *     identifier         entity           constructor
         *     operators          tag              namespace
         *     keyword            info-token       type
         *     string             warn-token       predefined
         *     string.escape      error-token      invalid
         *     comment            debug-token
         *     comment.doc        regexp
         *     constant           attribute
         *
         *     delimiter .[curly,square,parenthesis,angle,array,bracket]
         *     number    .[hex,octal,binary,float]
         *     variable  .[name,value]
         *     meta      .[content]
         *
         *     A tokenizer consists of an object that defines states.
         *     The initial state of the tokenizer is the first state defined in the tokenizer.
         *     When a tokenizer is in a certain state, only the rules in that state will be applied.
         *     All rules are matched in order and when the first one matches its action is used to determine the token class.
         *     No further rules are tried.
         *     Therefore, it can be important to order the rules in a way that is most efficient, i.e. whitespace and identifiers first.
         *
         *     (Advanced) A state is interpreted as dot (.) separated sub-states.
         *     When looking up the rules for a state, the tokenizer first tries the entire state name, and then looks at its parent until it finds a definition.
         *     For example, in our example, the states "comment.block" and "comment.foo" would both be handled by the comment rules.
         *     Hierarchical state names can be used to maintain complex lexer states, as shown for example in the section on complex embeddings.
         *
         *     Each state is defined as an array of rules which are used to match the input.
         */
        readonly tokenizer: {
            [stateName: string]: TokenizationRule[];
        };
        /**
         * Code completion suggestion support for the custom language.
         */
        readonly suggestSupport?: SuggestSupport;
    }
    /**
     * Defines a tokenizer rule.
     * Rules can have the following forms:
     *
     *     {regex: regex, action: action }
     *          TokenizationRegexRule
     *
     *     { include: state }
     *         TokenizationIncludeRule
     *
     *     [regex, action]
     *         Shorthand for TokenizationRegexRule with action: { regex: regex, action: action }
     *
     *     [regex, action, next]
     *         Shorthand for TokenizationRegexRule with action having next: { regex: regex, action: action{ next: next } }
     */
    export type TokenizationRule = TokenizationRegexRule | TokenizationIncludeRule | (RegExp | string | TokenizationRuleAction)[];
    /**
     * Defines a regular expression tokenization rule.
     * When regex matches against the current input, then action is applied to set the token class.
     */
    export interface TokenizationRegexRule {
        /**
         * The regular expression for the rule.
         *
         * The regular expression regex can be either a regular expression (using /regex/), or a string representing a regular expression.
         * If it starts with a ^ character, the expression only matches at the start of a source line.
         * The $ can be used to match against the end of a source line.
         * Note that the tokenizer is not called when the end of the line is already reached, and the empty pattern /$/ will therefore never match (but see '@eos' too).
         * Inside a regular expression, you can reference a string attribute named attr as @attr, which is automatically expanded.
         * This is used in the standard example to share the regular expression for escape sequences using '@escapes' inside the regular expression for characters and strings.
         *
         * Regular expression primer: common regular expression escapes we use are \d for [0-9], \w for [a-zA-Z0-9_], and \s for [ \t\r\n].
         * The notation regex{n} stands for n occurrences of regex.
         * Also, we use (?=regex) for non-consuming `followed by regex', (?!regex) for `not followed by', and (?:regex) for a non-capturing group (i.e. cannot use $n to refer to it).
         */
        readonly regex: RegExp | string;
        /**
         * The action for the rule.
         */
        readonly action: TokenizationRuleAction[];
    }
    /**
     * Used for nice organization of your rules and expands to all the rules defined in state.
     * This is pre-expanded and has no influence on performance.
     * Many samples include the '@whitespace' state for example.
     */
    export interface TokenizationIncludeRule {
        /**
         * The state to include.
         */
        readonly include: string;
    }
    /**
     * The scalar rule actions that are allowed.
     */
    export type TokenizationRuleScalarAction = TokenizationRuleTokenAction | TokenizationRuleCasesAction | string;
    /**
     * Defines a rule action.
     * An action can have the following forms:
     *
     *     { token: tokenclass }
     *         TokenizationRuleTokenAction
     *
     *     { cases: { guard1: action1, ..., guardN: actionN } }
     *         TokenizationRuleCasesAction
     *
     *     string
     *         Shorthand for TokenizationRuleTokenAction with token only: { token: string }.
     *
     *     [action1,...,actionN]
     *         An array of N actions.
     */
    export type TokenizationRuleAction = TokenizationRuleScalarAction | TokenizationRuleScalarAction[];
    /**
     * An object that defines the token class used with CSS rendering.
     */
    export interface TokenizationRuleTokenAction {
        /**
         * The token class.
         *
         * Common token classes are for example 'keyword', 'comment' or 'identifier'.
         * You can use a dot to use hierarchical CSS names, like 'type.identifier' or 'string.escape'.
         * You can also include $ patterns that are substituted with a captured group from the matched input or the tokenizer state.
         * There are some special token classes:
         *
         * "@brackets"or "@brackets.tokenclass
         *     Signifies that brackets were tokenized.
         *     The token class for CSS is determined by the token class defined in the brackets attribute (together with tokenclass if present).
         *     Moreover, bracket attribute is set such that the editor is matches the braces (and does auto indentation).
         *     For example:
         *         [/[{}()\[\]]/, '@brackets']
         *
         * "@rematch"
         *    (Advanced) Backs up the input and re-invokes the tokenizer.
         *    This of course only works when a state change happens too (or we go into an infinite recursion), so this is usually used in combination with the next attribute.
         *    This can be used for example when you are in a certain tokenizer state and want to get out when seeing certain end markers but don't want to consume them while being in that state.
         *    See also nextEmbedded.
         */
        readonly token: string;
        /**
         * If defined it pushes the current state onto the tokenizer stack and makes state the current state.
         * This can be used for example to start tokenizing a block comment: ['/\\*', 'comment', '@comment' ]
         *
         * Note that this is a shorthand for
         *     { regex: '/\\*', action: { token: 'comment', next: '@comment' } }
         *
         * Here the matched /* is given the "comment" token class, and the tokenizer proceeds with matching the input using the rules in state @comment.
         *
         * There are a few special states that can be used for the next attribute:
         *
         *    "@pop"
         *        Pops the tokenizer stack to return to the previous state.
         *        This is used for example to return from block comment tokenizing after seeing the end marker: ['\\*<forward slash>', 'comment', '@pop']
         *
         *    "@push"
         *        Pushes the current state and continues in the current state.
         *        Nice for doing nested block comments when seeing a comment begin marker, i.e.in the @comment state, we can do: ['/\\*', 'comment', '@push']
         *
         *    "@popall"
         *        Pops everything from tokenizer stack and returns to the top state.
         *        This can be used during recovery to 'jump' back to the initial state from a deep nesting level.
         */
        readonly next?: string;
        /**
         * Switch to state without changing the stack.
         */
        readonly switchTo?: string;
        /**
         * Back up the input by number characters.
         */
        readonly goBack?: number;
        /**
         * Advanced bracket kind.
         * The kind can be either '@open' or '@close'.
         * This signifies that a token is either an open or close brace.
         * This attribute is set automatically if the token class is @brackets.
         * The editor uses the bracket information to show matching braces (where an open bracket matches with a close bracket if their token classes are the same).
         * Moreover, when a user opens a new line the editor will do auto indentation on open braces.
         * Normally, this attribute does not need to be set if you are using the brackets attribute and it is only used for complex brace matching.
         */
        readonly bracket?: string;
        /**
         * Signifies to the editor that this token is followed by code in another language specified by the mimeType, i.e. for example text/javascript.
         * Internally, our syntax highlighter keeps tokenizing the source until it finds an an ending sequence.
         * At that point, you can use nextEmbedded with a '@pop' value to pop out of the embedded mode again.
         * Usually, we need to use a next attribute too to switch to a state where we can tokenize the foreign code.
         * As an example, here is how we could support CSS fragments in our language:
         *     root: [
         *         [/<style\s*>/,   { token: 'keyword', bracket: '@open' , next: '@css_block', nextEmbedded: 'text/css' }],
         *         [/<\/style\s*>/, { token: 'keyword', bracket: '@close' }],
         *         ...
         *     ],
         *
         *     css_block: [
         *         [/[^"<]+/, ''],
         *         [/<\/style\s*>/, { token: '@rematch', next: '@pop', nextEmbedded: '@pop' }],
         *         [/"/, 'string', '@string' ],
         *          [/</, '']
         *     ],
         *
         * Note how we switch to the css_block state for tokenizing the CSS source.
         * Also inside the CSS we use the @string state to tokenize CSS strings such that we do not stop the CSS block when we find </style> inside a string.
         * When we find the closing tag, we also "@pop" the state to get back to normal tokenization.
         * Finally, we need to "@rematch" the token (in the root state) since the editor ignores our token classes until we actually exit the embedded mode.
         */
        readonly nextEmbedded?: string;
        /**
         * Debug logging.
         * Logs message to the console window in the browser (press F12 to see it).
         * This can be useful to see if a certain action is executing.
         * For example: [/\d+/, { token: 'number', log: 'found number $0 in state $S0' } ]
         */
        readonly log?: string;
    }
    /**
     * The final kind of action object is a cases statement.
     * A cases object contains an object where each field functions as a guard.
     * Each guard is applied to the matched input and as soon as one of them matches, the corresponding action is applied.
     * Note that since these are actions themselves, cases can be nested.
     * Cases are used for efficiency: for example, we match for identifiers and then test whether the identifier is possibly a keyword or builtin function:
     *
     *     [/[a-z_\$][a-zA-Z0-9_\$]<asterisk>/,
     *         { cases: { '@typeKeywords': 'keyword.type'
     *                  , '@keywords': 'keyword'
     *                  , '@default': 'identifier' }
     *         }
     *     ]
     *
     * The guards can consist of:
     *
     *     "@keywords"
     *         The attribute keywords must be defined in the language object and consist of an array of strings.
     *         The guard succeeds if the matched input matches any of the strings.
     *         (Note: all cases are pre- compiled and the list is tested using efficient hash maps).
     *         Advanced: if the attribute refers to a single string (instead of an array) it is compiled to a regular expression which is tested against the matched input.
     *
     *     "@default"
     *         (or "@" or "") The default guard that always succeeds.
     *
     *     "@eos"
     *         Succeeds if the matched input has reached the end of the line.
     *
     *     "regex"
     *         If the guard does not start with a @ (or $) character it is interpreted as a regular expression that is tested against the matched input.
     *         Note: the regex is prefixed with ^ and postfixed with $ so it must match the matched input entirely.
     *         This can be used for example to test for specific inputs, here is an example from the Koka language which uses this to enter various tokenizer states based on the declaration:
     *
     *         [/[a-z](\w|\-[a-zA-Z])<asterisk>/,
     *             { cases: { '@keywords': {
     *                         cases: { 'alias': { token: 'keyword', next: '@alias-type' }
     *                                , 'struct': { token: 'keyword', next: '@struct-type' }
     *                                , 'type|cotype|rectype': { token: 'keyword', next: '@type' }
     *                                , 'module|as|import': { token: 'keyword', next: '@module' }
     *                                , '@default': 'keyword' }
     *                        }
     *               , '@builtins': 'predefined'
     *               , '@default': 'identifier' }
     *             }
     *         ]
     *
     *         Note the use of nested cases to improve efficiency.
     *         Also, the library recognizes simple regular expressions like the ones above and compiles them efficiently.
     *         For example, the list of words type| cotype | rectype is tested using a Javascript hashmap/ object.
     *
     *     (Advanced) In general, a guard has the form [pat][op]match, with an optional pattern, and operator (which are $# and ~ by default).
     *     The pattern can be any of:
     *
     *     $#
     *         (default) The matched input (or the group that matched when the action is an array).
     *
     *     $n
     *         The nth group of the matched input, or the entire matched input for $0.
     *
     *     $Sn
     *         The nth part of the state, i.e.$S2 returns foo in a state @tag.foo.
     *         Use $S0 for the full state name.
     *
     *     The above patterns can actually occur in many attributes and are automatically expanded.
     *     Attributes where these patterns expand are token, next, nextEmbedded, switchTo, and log.
     *     Also, these patterns are expanded in the match part of a guard.
     *
     *     The guard operator op and match can be any of:
     *
     *      ~regex or !~regex
     *          (default for op is ~) Tests pat against the regular expression or its negation.
     *
     *      "@attribute" or "!@attribute"
     *          Tests whether pat is an element (@), or not an element (!@), of an array of strings defined by attribute.
     *
     *      ==str or != str
     *          Tests if pat is equal or unequal to the given string str.
     *
     *      For example, here is how to check if the second group is not equal to foo or bar: $2!~foo | bar, or if the first captured group equals the name of the current lexer state: $1 == $S0.
     *
     *      If both op and match are empty and there is just a pattern, then the guard succeeds if the pattern is non- empty.
     *      This can be used for example to improve efficiency.
     *      In the Koka language, an upper case identifier followed by a dot is module name, but without the following dot it is a constructor.
     *      This can be matched for in one go using:
     *
     *      [/([A-Z](?:[a-zA-Z0-9_]|\-[a-zA-Z])*)(\.?)/,
     *          { cases: { '$2': ['identifier.namespace', 'keyword.dot']
     *                   , '@default': 'identifier.constructor' }}
     *      ]
     */
    export interface TokenizationRuleCasesAction {
        /**
         * The cases for the action.
         */
        readonly cases: ReadonlyStringMap<TokenizationRuleAction>;
    }
    /**
     * Defines suggestions for code completion in a custom language.
     */
    export interface SuggestSupport {
        /**
         * Indicates if completions should automatically be provided from the current document contents.
         */
        readonly textualCompletions?: boolean;
        /**
         * Array of characters that will trigger suggestions pop-up.
         */
        readonly triggerCharacters?: ReadonlyArray<string>;
        /**
         * Snippet definitions.
         * This is an array containing snippet definitions or simple text suggestions.
         */
        readonly snippets: ReadonlyArray<string | SuggestSupportSnippet>;
    }
    /**
     * Defines a code suggestion snippet for a custom language.
     */
    export interface SuggestSupportSnippet {
        /**
         * The type of snippet.
         */
        readonly type: string;
        /**
         * The label displayed in the suggest support pop up.
         */
        readonly label: string;
        /**
         * The snippet to insert.
         */
        readonly codeSnippet: string;
        /**
         * Documentation to display in the suggest support pop-up.
         */
        readonly documentationLabel?: string;
    }
    /**
     * Auto Complete matcher for custom content type.
     */
    export interface AutoCompleteMatcher {
        /**
         * The string of characters where autocompletion should be checked.
         */
        readonly triggers: string;
        /**
         * Regular expression that is tested against the current input line when triggred.
         */
        readonly match: string;
        /**
         * On match is appended to the source with captured groups expanded.
         */
        readonly complete: string;
    }
    /**
     * Auto indent matcher for custom content type.
     */
    export interface AutoIndentMatcher {
        /**
         * Regular expression matched against the current line on an enter to determine indentation.
         */
        readonly match: string;
        /**
         * Regular expression matched against the tokens following the line break to determing block indentation.
         */
        readonly matchAfter: string;
    }
    /**
     * The typescript script target.
     */
    export const enum TypeScriptTarget {
        /**
         * ECMAScript 3.
         */
        ES3 = 0,
        /**
         * ECMAScript 5.
         */
        ES5 = 1,
        /**
         * ECMAScript 2015.
         */
        ES2015 = 2,
        /**
         * ECMAScript 2016.
         */
        ES2016 = 3,
        /**
         * ECMAScript 2017.
         */
        ES2017 = 4,
        /**
         * ECMAScript 2018.
         */
        ES2018 = 5,
        /**
         * ECMAScript 2019.
         */
        ES2019 = 6,
        /**
         * ECMAScript 2020.
         */
        ES2020 = 7,
        /**
         * ECMAScript Next.
         */
        ESNext = 99,
        /**
         * JSON.
         */
        JSON = 100,
        /**
         * Latest.
         */
        Latest = 6
    }
    /**
     * Generic editor contract.
     */
    export interface EditorContract extends Contract {
        /**
         * The type of the editor content.
         */
        readonly contentType: KnockoutObservableBase<ContentType>;
    }
    /**
     * Custom editor contract.
     */
    export interface CustomEditorContract extends Contract {
        /**
         * Custom language configruation.
         */
        readonly customConfig: KnockoutObservableBase<CustomConfig>;
    }
    /**
     * JSON editor contract.
     */
    export interface KustoEditorContract extends Contract {
        /**
         * The schema of the Kusto database
         */
        readonly contentSchema: KnockoutObservableBase<KustoSchema>;
    }
    /**
     * JSON editor contract.
     */
    export interface JSONEditorContract extends Contract {
    }
    /**
     * TypeScript editor contract.
     */
    export interface TypeScriptEditorContract extends Contract {
        /**
         * The typescript compiler output.
         * Updated on each save.
         * This is the transpiled javascript content.
         */
        readonly typescriptOutput: KnockoutObservableBase<string>;
    }
    /**
     * Editor contract.
     */
    export interface Contract extends Base.Control {
        /**
         * Custom Keyboard shortcuts that can be bound to CallBack functions.
         */
        readonly customCommands: KnockoutObservableArray<CustomCommand>;
        /**
         * Custom aria-label value for the editor to be called out by screen readers.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the editor.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The content of the editor content.
         */
        readonly content: KnockoutObservableBase<string>;
        /**
         * Content uri is used to infer the content type, if content is not given. Editor does not load the content from the Uri.
         */
        readonly contentUri: KnockoutObservableBase<string>;
        /**
         * The currently selected content of the editor content.
         */
        readonly selectedContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * The currently selected range in the editor content.
         */
        readonly selectedRange: KnockoutObservableBase<Range>;
        /**
         *  Definition for markers in the editor.
         */
        readonly markers: KnockoutObservableBase<Marker[]>;
        /**
         *  Current position of the cursor in the editor content. Position is updated when editor saves the content.
         */
        readonly cursorPosition: KnockoutObservableBase<CursorPosition>;
        /**
         * Indicates if edits are allowed.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates if line numbers are displayed.
         */
        readonly showLineNumbers: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the scrollbar with code preview should be shown or not
         */
        readonly enhancedScrollbar: KnockoutObservableBase<boolean>;
        /**
         * Controls the size of tabs in the document.
         */
        readonly tabSize: KnockoutObservableBase<number>;
        /**
         * Indicates if spaces are inserted instead of tabs.
         */
        readonly insertSpaces: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor allows Tab and Shift+Tab to change focus.
         */
        readonly tabFocus: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the wrapping column of the editor.
         *     -1  no wrapping
         *      0  wraps to the current viewport width
         *      n  wraps at fixed column
         */
        readonly wrappingColumn: KnockoutObservableBase<number>;
        /**
         * The minimum height of the control governed by the minimum number of visible lines.
         * Defaults to 2 lines if not set or if less than 0.
         */
        readonly minVisibleLines: KnockoutObservableBase<number>;
        /**
         * Enables highlighting of all words/tokens matching the words/tokens under the cursor position.
         * blockHighlight is not affected by this value.
         * Defaults to true.
         */
        readonly selectionHighlight: KnockoutObservableBase<boolean>;
        /**
         * Highlights the block under the cursor position.
         * The block definition can be provided using the defineBlock callback.
         * selectionHighlight is not affected by this value.
         * Defaults to false.
         */
        readonly blockHighlight: KnockoutObservableBase<boolean>;
        /**
         * The currently block highlighted content of the editor content.
         * Will be populated when blockHighlight is set to true.
         * If the "defineBlock" callback is given, this logic will be used for selecting blocks.
         * If the "defineBlock" callback is not provided and block highlighting is enabled, the default block highlighting is used where blank lines act as the block delimiter.
         */
        readonly blockContent: KnockoutReadOnlyObservableBase<string>;
        /**
         * Indicates if the contents have been modified but not yet saved.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the editor is displayed.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Contains the errors and warnings in the Editor
         */
        readonly currentMarkers: KnockoutReadOnlyObservableArray<Marker>;
        /**
         * Refreshes the editor view.
         */
        refresh(): Promise<void>;
        /**
         * Saves the content of the editor.
         */
        save(): Promise<void>;
    }
    /**
     *  Editor marker severity
     */
    export enum MarkerSeverity {
        /**
         * Ignored marker
         */
        Ignore = 0,
        /**
         * Hint marker
         */
        Hint = 1,
        /**
         * Information marker
         */
        Info = 2,
        /**
         * Warning marker
         */
        Warning = 3,
        /**
         * Error marker
         */
        Error = 4
    }
    /**
     *  Editor marker definition
     */
    export interface Marker {
        /**
         * The message to show in the tool tip
         */
        readonly message: string;
        /**
         * The severity of the marker
         */
        readonly severity: MarkerSeverity;
        /**
         * The text range to apply the marker to
         */
        readonly range: Range;
    }
    /**
     *  A range of text in the text editor.
     */
    export interface Range {
        /**
         * Line number on which the range starts (1-based line number).
         */
        readonly startLineNumber: number;
        /**
         * Column on which the range starts in line `startLineNumber` (1-based line number).
         */
        readonly startColumn: number;
        /**
         * Line number on which the range ends.
         */
        readonly endLineNumber: number;
        /**
         * Column on which the range ends in line `endLineNumber`.
         */
        readonly endColumn: number;
    }
    /**
     * Creates an editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createEditor(lifetime: LifetimeManager, options: EditorOptions): EditorContract;
    /**
     * Creates a custom editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createCustomEditor(lifetime: LifetimeManager, options: CustomEditorOptions): CustomEditorContract;
    /**
     * Creates a Kql editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createKustoEditor(lifetime: LifetimeManager, options: KustoEditorOptions): KustoEditorContract;
    /**
     * Creates a JSON editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createJSONEditor(lifetime: LifetimeManager, options: JSONEditorOptions): JSONEditorContract;
    /**
     * Creates a TypeScript editor control viewmodel.
     *
     * @param lifetime The lifetime manager for the editor.
     * @param options The set of options to configure the editor.
     * @returns an editor contract.
     */
    export function createTypeScriptEditor(lifetime: LifetimeManager, options: TypeScriptEditorOptions): TypeScriptEditorContract;
    /**
     * Defines the column in the table
     */
    export interface KustoColumn {
        /**
         * Name of the column in a table
         */
        name: string;
        /**
         * Type of the column
         */
        type: string;
        /**
         * Documentation of the column
         */
        docstring?: string;
    }
    /**
     * Defines the column in the table for ARG schema
     */
    export interface KustoARGColumn {
        /**
         * Name of the column in a table
         */
        name: string;
        /**
         * Type of the column
         */
        type: string;
        /**
         * Documentation of the column
         */
        docstring?: string;
    }
    /**
     * Defines the table in the Kusto database
     */
    export interface KustoTable {
        /**
         * Name of the table
         */
        name: string;
        /**
         * Type of the table. The type can be "Table", "ExternalTable" or "MaterializedViewTable"
         */
        entityType?: KustoTableEntityType;
        /**
         * The columns in the table
         */
        columns: KustoColumn[];
        /**
         * The documentation of the table
         */
        docstring?: string;
    }
    /**
     * Defines the table in the Kusto database
     */
    export interface KustoARGTable {
        /**
         * Name of the table
         */
        name: string;
        /**
         * The columns in the table
         */
        columns: KustoARGColumn[];
        /**
         * The documentation of the table
         */
        docstring?: string;
    }
    /**
     * Scalar parameter for Kusto function
     */
    export interface KustoScalarParameter {
        /**
         * Name of the scalar parameter
         */
        name: string;
        /**
         * Type of the scalar parameter
         */
        type?: string;
        /**
         * The equivalent of the scalar in Cousteau Semantic Language
         */
        cslType?: string;
        /**
         * Documentation of the scalar parameter
         */
        docstring?: string;
        /**
         * THe default value of the scalar parameter in Cousteau Semantic Language
         */
        cslDefaultValue?: string;
    }
    /**
     * An input parameter can either be a scalar in which case it has a name, type and cslType, or it can be columnar, in which case
     * it will have a name, and a list of scalar types which are the column types.
     */
    export interface KustoInputParameter {
        /**
         * Name of the input parameter
         */
        name: string;
        /**
         * Type of the input parameter
         */
        type?: string;
        /**
         * The equivalent of this type in Cousteau Semantic Language
         */
        cslType?: string;
        /**
         * The documentation for this input parameter
         */
        docstring?: string;
        /**
         * The default value of this type in Cousteau Semantic Language
         */
        cslDefaultValue?: string;
        /**
         * A list of scalar types as a column
         */
        columns?: KustoScalarParameter[];
    }
    /**
     * KustoFunction is a reusable query or query part.
     */
    export interface KustoFunction {
        /**
         * Name of the function
         */
        name: string;
        /**
         * Function implementation
         */
        body: string;
        /**
         * Input parameters to the function
         */
        inputParameters: KustoInputParameter[];
        /**
         * Documentation for the function
         */
        docstring?: string;
    }
    /**
     * The database in your Kusto Cluster
     */
    export interface KustoDatabase {
        /**
         * Name of the database
         */
        name: string;
        /**
         * Tables in the database
         */
        tables: KustoTable[];
        /**
         * Functions in the database
         */
        functions: KustoFunction[];
        /**
         * Major version of the database
         */
        majorVersion: number;
        /**
         * Minor version of the database
         */
        minorVersion: number;
    }
    /**
     * The "Engine" cluster, which contains a string to connect to the cluster and databases inside the cluster.
     */
    export interface KustoEngineCluster {
        /**
         * The string used to connect to the Engine cluster
         */
        connectionString: string;
        /**
         * The databases inside the cluster
         */
        databases: KustoDatabase[];
    }
    /**
     * Schema for cluster type "Engine"
     */
    export interface KustoEngineSchema {
        /**
         * The type of Kusto cluster, which is "Engine" in this case.
         */
        clusterType: "Engine";
        /**
         * The Engine cluster for this schema
         */
        cluster: KustoEngineCluster;
        /**
         * A reference to the database that's in current context.
         */
        database?: KustoDatabase;
        /**
         * Optional global parameters to be provided to the cluster.
         */
        globalParameters?: KustoScalarParameter[];
    }
    /**
     * Schema for Azure Resource Graph
     */
    export interface AzureResourceGraphSchema {
        /**
         * The tables in your schema.
         */
        tables: KustoARGTable[];
    }
    /**
     * Type of your Kusto Table. It can be "Table", "ExternalTable" or "MaterializedViewTable"
     */
    export type KustoTableEntityType = "Table" | "ExternalTable" | "MaterializedViewTable";
    /**
     * Schema types:
     * Engine – The main schema type. Contains clusters, databases, tables, table columns and functions.
     * AzureResourceGraph - The schema for Azure Resource Graph. Contains Tables, where each table contains an array of Columns.
     */
    export type KustoSchema = KustoEngineSchema | AzureResourceGraphSchema;
}

// FILE: Fx\Controls\Essentials.d.ts
declare module "Fx/Controls/Essentials" {
    import { Control, IconPosition, IconAndPosition } from "Fx/Controls/ControlsBase";
    import { ClickableLink, BladeLink, ResourceLink, OnClickHandler } from "Fx/Composition";
    import * as FxCompositionBlade from "Fx/Composition/Blade";
    import * as FxCompositionPdlBlade from "Fx/Composition/Pdl/Blade";
    import * as FxCompositionTemplateBlade from "Fx/Composition/TemplateBlade";
    export type Container = FxCompositionBlade.Container | FxCompositionPdlBlade.Container | FxCompositionTemplateBlade.Container;
    /**
     * Position of the icon.
     */
    export { IconPosition };
    /**
     * Describes an icon and its position with respect to the other content.
     */
    export { IconAndPosition };
    /**
     * Type of Extended Location (Edge Zone)
     */
    export enum ExtendedLocationType {
        EdgeZone = "EdgeZone",
        Region = "Region"
    }
    /**
     * Built-In properties those can be obtained from resource data.
     */
    export const enum BuiltInType {
        /**
         * Built-in resource group property.  Allowed on left or right.
         */
        ResourceGroup = 1,
        /**
         * Built-in status property.  Allowed on left or right.
         */
        Status = 2,
        /**
         * Built-in location property.  Allowed on left or right.
         */
        Location = 3,
        /**
         * Built-in subscription name property.  Allowed on left or right.
         */
        SubscriptionName = 4,
        /**
         * Built-in subscription id property.  Allowed on left or right.
         */
        SubscriptionId = 5,
        /**
         * Built-in tags property.  Allowed on bottom.
         */
        Tags = 6
    }
    /**
     * The base blade close results interface provides the base for blade close results. The BuiltInType sent to the
     * onBladeClose will determine the actual shape of these results.
     */
    export interface BladeCloseResults {
    }
    /**
     * Base options.
     */
    export interface Options {
        /**
         * Expanded state of the essentials control.
         */
        expanded?: KnockoutObservableBase<boolean>;
        /**
         * This function is called when the expander is clicked.
         */
        onExpanderClick?: (isExpanded: boolean) => void;
        /**
         * Show all items without blocking them with "See More/See Less" button.
         */
        showAllItems?: boolean;
    }
    /**
     * Layout options for a resource.
     */
    export interface ResourceLayoutOptions extends Options {
        /**
         * Resource id.
         */
        resourceId: string;
        /**
         * Optional resource instance for the resource id.
         */
        resource?: HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup | KnockoutObservableBase<HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup>;
        /**
         * Flag to control whether the framework should fetch the resource info automatically if the resource instance is not provided.
         */
        skipResourceFetching?: boolean;
        /**
         * Flag to include the tags for the resource.
         */
        includeTags?: boolean;
        /**
         * Flag to indicate whether the location of the resource can be changed or not.
         */
        enableLocationChange?: boolean;
        /**
         * List of built-in types to hide the "change" button, move resource blade opening button, right next to the built-in type label.
         */
        hiddenChangeLink?: BuiltInType[];
        /**
         * This callback function is called when the resource blade is opened.
         */
        onBladeOpen?: (type: BuiltInType) => void;
        /**
         * This callback function is called when the resource blade is closed.
         */
        onBladeClose?: (type: BuiltInType, bladeCloseResults?: BladeCloseResults) => void;
    }
    /**
     * Default layout options for a resource.
     */
    export interface DefaultResourceLayoutOptions extends ResourceLayoutOptions {
        /**
         * List of built-in types to hide.
         */
        hiddenBuiltInTypes?: BuiltInType[];
        /**
         * Additional static properties on the left besides the usual 5 items.
         */
        additionalLeft?: (Item | MultiLineItem)[];
        /**
         * Additional static properties on the right.
         */
        additionalRight: (Item | MultiLineItem)[];
    }
    /**
     * Custom layout options for a resource.
     */
    export interface CustomResourceLayoutOptions extends ResourceLayoutOptions {
        /**
         * List of items to render on the left pane.
         */
        left: (Item | MultiLineItem | BuiltInType)[];
        /**
         * List of items to render on the right pane.
         */
        right: (Item | MultiLineItem | BuiltInType)[];
    }
    /**
     * Layout options for an arbitrary object type (not a resource).
     */
    export interface NonResourceLayoutOptions extends Options {
        /**
         * List of items to render on the left pane.
         */
        left: (Item | MultiLineItem)[];
        /**
         * List of items to render on the right pane.
         */
        right: (Item | MultiLineItem)[];
    }
    /**
     * Properties of an item.
     */
    export interface ItemProperty {
        /**
         * Item value to show.
         */
        value: string | KnockoutObservableBase<string>;
        /**
         * OnClick handler for the item.
         */
        onClick?: OnClickHandler | ClickableLink | BladeLink | ResourceLink;
        /**
         * Displays an icon for the item.
         */
        icon?: IconAndPosition | KnockoutObservableBase<IconAndPosition>;
    }
    /**
     * Single-line item.
     */
    export interface Item extends ItemProperty {
        /**
         * Label for the item.
         */
        label: string;
    }
    /**
     * Multi-line item.
     */
    export interface MultiLineItem {
        /**
         * Label for the multi-line item.
         */
        label: string;
        /**
         * Arrays of item properties.
         * Multi-line item contains one label and multiple item properties.
         */
        lines: ItemProperty[];
    }
    /**
     * Essentials base contract.
     */
    export interface Contract extends Control {
        /**
         * Expanded state.
         */
        expanded: KnockoutObservableBase<boolean>;
        /**
         * Essentials disabled state.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Add items dynamically to the essentials control.
         *
         * @param left An array of item to add.
         * @param right An array of item to add.
         */
        addDynamicProperties(left: (Item | MultiLineItem)[], right: (Item | MultiLineItem)[]): void;
    }
    /**
     * Essentials contract for a resource layout.
     */
    export interface ResourceLayoutContract extends Contract {
        /**
         * Resource instance.
         */
        resource: KnockoutObservableBase<HubsExtension.Azure.Resource | HubsExtension.Azure.ResourceGroup>;
        /**
         * Set "Status" property.
         *
         * @param status A string value to set the "Status" property value.
         */
        modifyStatus(status: string): void;
    }
    /**
     * Essentials contract for an arbitrary object layout.
     */
    export interface NonResourceLayoutContract extends Contract {
    }
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     * @returns an essentials viewmodel
     */
    export function createDefaultResourceLayout(container: Container, options: DefaultResourceLayoutOptions): ResourceLayoutContract;
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     * @returns an essentials viewmodel
     */
    export function createCustomResourceLayout(container: Container, options: CustomResourceLayoutOptions): ResourceLayoutContract;
    /**
     * Creates an Essentials control viewmodel.
     *
     * @param container A template blade container.
     * @param options The set of options to configure the essentials.
     * @returns an essentials viewmodel
     */
    export function createNonResourceLayout(container: Container, options: NonResourceLayoutOptions): NonResourceLayoutContract;
}

// FILE: Fx\Controls\FileDownload.d.ts
declare module "Fx/Controls/FileDownload" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Content type for the downloaded file.
     */
    export const enum ContentType {
        /**
         * Downloaded file is a text file
         */
        Text = 1,
        /**
         * Downloaded file is a binary file
         */
        Binary = 2
    }
    /**
     * Display style options for file download
     */
    export const enum DisplayStyle {
        /**
         * Display file download as a Button.
         */
        Button = 0,
        /**
         * Display file download as a Link.
         */
        Link = 1
    }
    /**
     * Success or failure download status.
     */
    export enum Status {
        /**
         * Indicates a failure even before file download starts.
         * All required properties for file download is not provided correctly.
         */
        DownloadPreConditionFailed = 0,
        /**
         * Download is successful.
         */
        Success = 1,
        /**
         * Download encountered an error.
         */
        DownloadError = 2,
        /**
         * Download uri is not correct.
         */
        UriError = 3
    }
    /**
     * Callback contract to fetch the download context dynamically.
     *
     * @returns A promise returning one of the supported download context (where T is one of - OAuthContext, SasLikeContext, BlobUriContext or DataUriContext)
     */
    export interface DownloadContextCallback<T> {
        (): Promise<T>;
    }
    /**
     * Properties needed to make an authenticated download using OAuth token.
     */
    export interface OAuthContext {
        /**
         * Uri for the file download.
         */
        readonly targetUri: string;
        /**
         * For authenticated download using OAuth an authorization token should be specified.
         * Auth token can expire anytime. So the recommendation is to provide the auth token in the DownloadContextCallback which will be
         * invoked when the download button is clicked.
         */
        readonly authorizationToken: string;
        /**
         * Specify the content type of file to download. The default content type is 'text'.
         */
        readonly contentType?: ContentType;
        /**
         * Specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        readonly targetFileName?: string;
        /**
         * Specify GET or POST type for the http request.
         * Default will be GET.
         */
        readonly httpMethod?: "GET" | "POST";
        /**
         * Specify set of http headers to be included in the request.
         */
        readonly headers?: StringMap<string>;
        /**
         * Specify a JSON request body. Valid only for POST requests.
         */
        readonly httpRequestContent?: string;
        /**
         * Specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        readonly httpRequestContentType?: string;
    }
    /**
     * Properties needed to download a file from Sas like uri.
     */
    export interface SasLikeContext {
        /**
         * Uri for the file download.
         */
        readonly targetUri: string;
    }
    /**
     * Properties needed to make a blob uri download.
     */
    export interface BlobUriContext {
        /**
         * Provide blob uri for the file download.
         */
        readonly targetUri: string;
        /**
         * Specify the target filename for the downloaded file.
         */
        readonly targetFileName?: string;
    }
    /**
     * Properties needed to make a data uri download.
     */
    export interface DataUriContext {
        /**
         * Provide data uri for the file download.
         */
        readonly targetUri: string;
        /**
         * Specify the content type of file to download. The default content type is 'text'.
         */
        readonly contentType?: ContentType;
        /**
         * Specify the target filename for the downloaded file.
         */
        readonly targetFileName?: string;
    }
    /**
     * Download status will be observable updated by providing the status and/or error messages.
     */
    export interface DownloadStatus {
        /**
         * Indicates the file download status.
         */
        readonly status: Status;
        /**
         * Indicates the error message when download fails.
         */
        readonly errorMessage: string;
    }
    /**
     * Options to customize the callback, download confirmation and progress dialogs texts.
     */
    export interface DownloadDialogOptions {
        /**
         * Specify if callback progress dialog should be shown.
         */
        readonly showCallbackProgressDialog?: boolean;
        /**
         * Callback progress title string to indicate uri callback is in progress.
         */
        readonly callbackProgressTitle?: string;
        /**
         * Callback progress description string to indicate uri callback is in progress.
         */
        readonly callbackProgressText?: string;
        /**
         * Specify if download confirmation dialog should be shown.
         * A message box dialog is shown to confirm downloading the file or cancel the download.
         */
        readonly showDownloadConfirmationDialog?: boolean;
        /**
         * Download confirmation title string to indicate if file should be downloaded or canceled.
         */
        readonly downloadConfirmationTitle?: string;
        /**
         * Download confirmation description string to indicate if file should be downloaded or canceled.
         */
        readonly downloadConfirmationText?: string;
        /**
         * Download confirmation ok button text.
         */
        readonly downloadConfirmationOKButtonText?: string;
        /**
         * Download confirmation cancel button text.
         */
        readonly downloadConfirmationCancelButtonText?: string;
        /**
         * Specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         * Progress dialog won't be shown for SAS like file downloads.
         */
        readonly showDownloadProgressDialog?: boolean;
        /**
         * ProgressBox title string to indicate download is in progress.
         */
        readonly downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate download is in progress.
         */
        readonly downloadProgressText?: string;
    }
    /**
     * Options for configuring a FileDownload control.
     */
    export interface Options {
        /**
         * Label displayed in the download button or link.
         */
        readonly label?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the file download button.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Tooltip shown on button or link hover.
         */
        readonly toolTip?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If control should be a link instead of a button
         */
        readonly displayStyle?: DisplayStyle;
        /**
         * Specify the error title when file download fails.
         * This error title will be used to send notification to the user to indicate download failure.
         */
        readonly errorTitle?: string | KnockoutObservableBase<string>;
        /**
         * Specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        readonly errorMessage?: string | KnockoutObservableBase<string>;
        /**
         * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
         */
        readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
        /**
         * Disable default download error notifications.
         * Extension can raise their own custom notifications.
         */
        readonly disableNotifications?: boolean;
        /**
         * Callback executed before download is initiated.
         */
        readonly onStart?: () => void;
    }
    /**
     * File download options for an authenticated download using OAuth token.
     */
    export interface OAuthDownloadOptions extends Options {
        /**
         * Provide the properties needed for making an authenticated file download using OAuth token
         * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
         */
        readonly downloadContext?: OAuthContext | DownloadContextCallback<OAuthContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * File download options using SAS or SAS equivalent uri.
     */
    export interface SasLikeDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using SAS or SAS equivalent uri
         * or provide a callback which will return the properties for file download using SAS or SAS equivalent uri
         */
        readonly downloadContext?: SasLikeContext | DownloadContextCallback<SasLikeContext>;
    }
    /**
     * File download options using blob uri.
     */
    export interface BlobUriDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using blob uri
         * or provide a callback which will return the properties for file download using blob uri.
         */
        readonly downloadContext?: BlobUriContext | DownloadContextCallback<BlobUriContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * File download options using data uri.
     */
    export interface DataUriDownloadOptions extends Options {
        /**
         * Provide the properties needed for making a file download using data uri
         * or provide a callback which will return the properties for file download using data uri.
         */
        readonly downloadContext?: DataUriContext | DownloadContextCallback<DataUriContext>;
        /**
         * Callback executed when download is complete.
         */
        readonly onComplete?: (downloadStatus: DownloadStatus) => void;
    }
    /**
     * FileDownload control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Label displayed in the download button or link.
         */
        readonly label: KnockoutObservableBase<string>;
        /**
         * Aria label for the file download button.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Tooltip shown on button or link hover.
         */
        readonly toolTip: KnockoutObservableBase<string>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Specify the error title when file download fails.
         * This error title will be used to send notification to the user to indicate download failure.
         */
        readonly errorTitle: KnockoutObservableBase<string>;
        /**
         * Specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        readonly errorMessage: KnockoutObservableBase<string>;
        /**
         * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
         */
        readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
        /**
         * Indicates if file is download successfully or not.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         * Download status will not be updated for SasLike file downloads.
         */
        readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
    }
    /**
     * Creates a file download control viewmodel for downloads using OAuth token for authentication.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using OAuth token.
     * @returns a file download view model
     */
    export function createOAuthDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: OAuthDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using SAS or SAS equivalent uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using SAS or SAS equivalent uri.
     * @returns a file download view model
     */
    export function createSasLikeDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: SasLikeDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using blob uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using blob uri.
     * @returns a file download view model
     */
    export function createBlobUriDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: BlobUriDownloadOptions): Contract;
    /**
     * Creates a file download control viewmodel for downloads using data uri.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the file download view model using data uri.
     * @returns a file download view model
     */
    export function createDataUriDownload(lifetime: MsPortalFx.Base.LifetimeManager, options?: DataUriDownloadOptions): Contract;
}

// FILE: Fx\Controls\FileUpload.d.ts
declare module "Fx/Controls/FileUpload" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * The type of Authorization used in making the upload call to the BlobStore.
     */
    export import BlobStoreAuthorizationType = MsPortalFx.ViewModels.FileUpload.BlobStoreAuthorizationType;
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     *  Specifies how the file content should be uploaded.
     */
    export const enum UploadType {
        /**
         * Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         *  File upload to block blob store.
         */
        BlockBlobStore = 2,
        /**
         *  File upload to page blob store.
         */
        PageBlobStore = 3,
        /**
         *  File upload to append blob store.
         */
        AppendBlobStore = 4,
        /**
         *  File upload to Azure file service.
         */
        FileService = 5
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     */
    export const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3
    }
    /**
     * File upload status.
     */
    export const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
        /**
         * Aborted.
         */
        Aborted = 6
    }
    /**
     * Access tier values for blob.
     */
    export const enum BlobAccessTier {
        /**
         * Optimized for storing data that is accessed frequently.
         */
        Hot = 0,
        /**
         * Optimized for storing data that is infrequently accessed and stored for at least 30 days.
         */
        Cool = 1,
        /**
         * Optimized for storing data that is rarely accessed and stored for at least 180 days with flexible latency requirements
         */
        Archive = 2
    }
    /**
     * Resource strings to override the default messages.
     */
    export interface ResourceStrings {
        /**
         * Override the default validation message for invalid allowed file extension.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileExtensionInvalidErrorMessage?: string;
        /**
         * Override the default validation message for file size greater than provided max file size.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         * {1} - Max file size.
         * {2} - File size.
         */
        fileSizeInvalidErrorMessage?: string;
        /**
         * Override the default message when runtime file read error occurs.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileReadAbortedErrorMessage?: string;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    export interface UploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     */
    export interface FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    export interface StreamFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning?: boolean;
    }
    /**
     * Defines SAS uri info needed for periodic SAS uri renewal.
     */
    export interface SasUriInfo {
        /**
         * Specify the SAS uri
         */
        uri: string;
        /**
         * Specify the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    export interface OauthHeaderInfo {
        /**
         * Specifies the URI including the blob.
         */
        uri: string;
        /**
         * Bearer token with permissions to write to this Storage Account.
         */
        authorizationHeader: string;
        /**
         * Specifies the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    /**
     * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
     */
    export interface AuthorizationContext<T> {
        /**
         * Call to fetch required credentials for the given container or storage account.
         *
         * @param fileInfo Metadata about the current file being uploaded. This can be used to renew the correct authorization for that file.
         * @param context The context object specified by the extension to this control. This may be used to pass back specific information needed to fetch authorization in renew scenario.
         * @returns A Promise with either the SASUri info or the OAUTHHeader info depending on the type of authentication this control should use.
         */
        fetchAuthorization: (fileInfo: FileInfoContract, context: T) => Promise<SasUriInfo | OauthHeaderInfo>;
    }
    export interface BlobStoreFileUploadOptions<T> {
        /**
         * Specify how/where the file should be uploaded.
         */
        type?: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context?: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext?: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand?: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback?: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri?: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext?: AuthorizationContext<T>;
        /**
         * Specifies access tier for blob.
         */
        accessTier?: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders?: ReadonlyStringMap<string>;
    }
    /**
     * Holds the full file uploaded content.
     */
    export interface FullFileUploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    /**
     * Holds the streamed file chunks and start/end bytes.
     */
    export interface StreamFileUploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    /**
     * Each file upload task is represented by a unique key. This is used for all management operations to locate the uploads.
     */
    export interface UploadKey {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
    }
    /**
     * Resumable context needed to resume uploads across browser session.
     * This is an optional property in ResumeContext and presence of this property in ResumeContext indicates the intent to resume an upload after browser refresh/crash/close.
     */
    export interface ResumableContext {
        /**
         * Upload key of the initial upload which was stopped due to browser refresh/crash/close.
         * The upload id is used to lookup the persisted/tracked uploaded byte resumable information.
         */
        originalUploadKey: UploadKey;
    }
    /**
     * Optional context information passed to the resume API.
     * Resume is called to start a new upload, start a new upload overriding upload context, resume an in-memory paused upload and resume an upload across browser session.
     * Resume context provides adequate context to enable above resume scenarios.
     */
    export interface ResumeContext {
        /**
         * Optional upload context information to override the default upload context specified in the view model.
         * For multi-select scenarios the default context will be applied to all uploads.
         * If upload type or content type needs to be overridden for a particular upload,
         * a new upload context information can be sent as part of resume context.
         */
        uploadContext?: UploadContext;
        /**
         * For resuming the upload across browser refresh/crash/close scenario, pass in the resumableContext with the upload key for the paused upload.
         * A list of paused uploads due to browser refresh/crash/close will be made avaiable via getResumableUploadInfo API which will have all necessary information including the upload key.
         */
        resumableContext?: ResumableContext;
    }
    /**
     * Optional abort context information sent when upload is aborted.
     */
    export interface AbortContext {
        /**
         * An error message / reason for aborting the file upload.
         */
        reason?: string;
    }
    /**
     * Optional chunk context sent when fetching the next file chunk via GetNextChunk API.
     */
    export interface ChunkContext {
        /**
         * Optionally specify the start byte offset.
         */
        startByte?: number;
        /**
         * Optionally specify the chunk size otherwise the default 2 MB will be used.
         */
        chunkSize?: number;
    }
    /**
     * Dispose context information when file upload is disposed.
     */
    export interface DisposeContext {
        /**
         * Flag to indicate if resumable info needs to be deleted.
         * Setting it to true will cleanup both in-memory resumable info as well as persisted/tracked resumable info unless there is an ongoing upload with that upload key.
         */
        resumable: boolean;
    }
    /**
     * File information.
     */
    export interface FileInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     */
    export interface SelectedFileContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
    /**
     * Upload information.
     */
    export interface UploadInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: KnockoutReadOnlyObservableBase<string>;
        /**
         * Upload category tag provided by extension.
         */
        category: KnockoutReadOnlyObservableBase<string>;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Upload type.
         */
        type: KnockoutReadOnlyObservableBase<UploadType>;
        /**
         * Upload destination like target blob store uri .
         */
        target: KnockoutReadOnlyObservableBase<string>;
        /**
         * The current status of the upload task.
         */
        status: KnockoutReadOnlyObservableBase<UploadStatus>;
        /**
         * The total bytes that have been uploaded/streamed.
         */
        uploadedBytes: KnockoutReadOnlyObservableBase<number>;
        /**
         * The percent complete of the upload task. The values will be in 0-100 range.
         */
        progressPercent: KnockoutReadOnlyObservableBase<number>;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * Async file upload task with upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     */
    export interface AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @returns Promise indicating the success or failure or the operation.
         */
        resume: (context?: ResumeContext) => Promise<void>;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        pause?: () => Promise<void>;
        /**
         * Method to cancel the current file upload.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        cancel: () => Promise<void>;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        complete: () => Promise<void>;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @returns Promise indicating the success or failure or the operation.
         */
        abort: (context?: AbortContext) => Promise<void>;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        dispose: () => Promise<void>;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @returns Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk: (startByte?: number, chunkSize?: number) => Promise<StreamFileUploadContent>;
    }
    /**
     * Full file upload context.
     */
    export class FullFileUploadContext implements UploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: UploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade: string | MsPortalFx.ViewModels.DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings: ResourceStrings;
        constructor(options?: FullFileUploadOptions);
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     */
    export class StreamFileUploadContext extends FullFileUploadContext {
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning: boolean;
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor(options?: StreamFileUploadOptions);
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     */
    export class BlobStoreFileUploadContext<T> extends FullFileUploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext: AuthorizationContext<T>;
        /**
         * Specify the access tier for blob.
         */
        accessTier: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders: ReadonlyStringMap<string>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor(options?: BlobStoreFileUploadOptions<T>);
    }
    /**
     * Options for configuring a file upload control.
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        accept?: string | KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        allowedFileExtensions?: string | KnockoutObservableBase<string>;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The user selected files via browse dialog is surfaced as SelectedFile in the selectedFiles array.
         * For scenarios where selected files should automatically be associated with an UploadTask, set this value to true.
         * If this option is set to false, the extension author is responsible for explicitly adding the selectedFile to uploadTasks by invoking
         * the addUploadTasks() method on view model to create an UploadTask representation and have it available in uploadTasks array.
         * By default, this option is set to true.
         */
        autoAddUploadTasks?: boolean;
        /**
         * Enable drag and drop UX for fileupload control.
         * By default drag and drop UX is not enabled. Set this option to true to enable drag and drop UX.
         */
        enableDragAndDrop?: boolean;
        /**
         * Show or hide the default file list and status in the drag and drop UX.
         * By default the file list will be show. Set this option to true to hide the file list and
         * extension can create their own UX to show the file list.
         */
        hideDragAndDropFileList?: boolean;
        /**
         * Override default drag and drop display text.
         * Default display text in the drop area is 'Drag and drop the files'
         */
        dragAndDropDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the file upload control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a file upload control for full file uploads.
     */
    export interface FullUploadOptions extends Options {
        /**
         * The full upload context options.
         */
        uploadContext: FullFileUploadContext | KnockoutObservableBase<FullFileUploadContext>;
    }
    /**
     * Options for configuring a file upload control for streaming file uploads.
     */
    export interface StreamUploadOptions extends Options {
        /**
         * The stream upload context options.
         */
        uploadContext: StreamFileUploadContext | KnockoutObservableBase<StreamFileUploadContext>;
    }
    /**
     * Options for configuring a file upload control for blob store file uploads.
     */
    export interface BlobUploadOptions<T> extends Options {
        /**
         * The blob store upload context options around how/where to upload and size limits.
         */
        uploadContext: BlobStoreFileUploadContext<T> | KnockoutObservableBase<BlobStoreFileUploadContext<T>>;
    }
    /**
     * FileUpload view model contract.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * Each time user clicks on the browse dialog, user can choose one or multiple files and each selected file is represented as SelectedFile on the extension iframe.
         * The selected files are surfaced in the selectedFiles array.
         * The array will be cleared if user chooses to click browse dialog to pick a different set of files.
         * Setting the value property null or calling resetUploadTasks() will clear the array.
         */
        readonly selectedFiles: KnockoutReadOnlyObservableArray<SelectedFileContract>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
         * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
         */
        readonly uploadTasks: KnockoutReadOnlyObservableArray<AsyncUploadTaskContract>;
        /**
         * A comma-separated list of allowed file mime-types, excluding extensions.
         * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
         * The file filtering  behavior depends on native browser support.
         */
        readonly accept: KnockoutObservableBase<string>;
        /**
         * A comma-separated list of allowed file extensions.
         * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
         * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
         * Eg: "pfx,cer"
         */
        readonly allowedFileExtensions: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Overrode default drag and drop display text.
         */
        readonly dragAndDropDisplayText: KnockoutObservableBase<string>;
        /**
         * Method to create an UploadTask associated with the selected file and populate that in the uploadTasks array.
         * File browse selections can be made any number of times. When autoAddUploadTaks is set to true, the selected files will be added automatically to the uploadTasks array.
         * If autoAddploadTasks is false, the selected file should be explicitly added to uploadTasks array by calling the addUploadTasks() method.
         * Extension authors will then be able to start the upload.
         *
         * @param selectedFiles User selected files to add to uploadTasks array to prepare for the file upload.
         */
        addUploadTasks: (selectedFiles: SelectedFileContract[]) => Promise<void>;
        /**
         * Method to reset the uploadTasks array. This method will use the widget callback to intialize the uploadTasks array with empty array.
         * Calling this method will not dispose(abort) the uploads.
         * Uploads which have already started will continue upload in the background.
         * Uploads which have not been started will be cleaned up.
         * Invoking this method will clear the uploadTasks array, selectedFiles array and the value property.
         */
        resetUploadTasks: () => Promise<void>;
    }
    /**
     * FileUpload view model contract for full file upload.
     */
    export interface FullUploadContract extends Contract {
        /**
         * The full upload context options.
         */
        readonly uploadContext: KnockoutObservableBase<FullFileUploadContext>;
    }
    /**
     * FileUpload view model contract for streaming file upload.
     */
    export interface StreamUploadContract extends Contract {
        /**
         * The stream upload context options.
         */
        readonly uploadContext: KnockoutObservableBase<StreamFileUploadContext>;
    }
    /**
     * FileUpload view model for blob store file uploads.
     */
    export interface BlobUploadContract<T> extends Contract {
        /**
         * The blob store upload context options around how/where to upload and size limits.
         */
        readonly uploadContext: KnockoutObservableBase<BlobStoreFileUploadContext<T>>;
    }
    /**
     * Creates a FileUpload control viewmodel for Full File uploads
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a file upload control viewmodel
     */
    export function createFullUpload(lifetime: MsPortalFx.Base.LifetimeManager, options: FullUploadOptions): FullUploadContract;
    /**
     * Creates a FileUpload control viewmodel for Stream File uploads.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a file upload control viewmodel
     */
    export function createStreamUpload(lifetime: MsPortalFx.Base.LifetimeManager, options: StreamUploadOptions): StreamUploadContract;
    /**
     * Creates a FileUpload control viewmodel for Blob store and Azure File Servie uploads.
     *
     * @param lifetime The lifetime of the control
     * @param options BlobUploadOptions that modify the appearance and behavior of the control.
     * @returns a file upload control viewmodel
     */
    export function createBlobStoreUpload<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: BlobUploadOptions<T>): BlobUploadContract<T>;
    global {
        interface EventHandlerContracts {
            "fileUploadSasUri"?: {
                renew(fileInfo: FileInfoContract, context?: unknown): Promise<SasUriInfo>;
            };
            "fileUploadAuthorization"?: {
                renew(authorizationType: BlobStoreAuthorizationType, fileInfo: FileInfoContract, context?: unknown): Promise<SasUriInfo | OauthHeaderInfo>;
            };
        }
    }
    export module EventHandler {
        /**
         * A decorator that is used to specify that the annotated class should be used to handle
         * FileUpload related events originating from the framework.
         *
         * @param contractName The name of the contract to be handled.
         */
        function Decorator<TContractName extends "fileUploadSasUri" | "fileUploadAuthorization">(contractName: TContractName): (target: new (...args: any[]) => EventHandlerContracts[TContractName]) => void;
    }
}

// FILE: Fx\Controls\FileUploadManagement.d.ts
declare module "Fx/Controls/FileUploadManagement" {
    import * as FileUpload from "Fx/Controls/FileUpload";
    export import SasUriInfo = FileUpload.SasUriInfo;
    /**
     * Upload action performed on upload task. This enum is used when using invokeUploadAction management API.
     */
    export const enum UploadAction {
        /**
         * No-op.
         */
        None = 0,
        /**
         * Pause the current upload task.
         */
        Pause = 1,
        /**
         * Resume the current upload task.
         */
        Resume = 2,
        /**
         * Cancel the current upload task
         */
        Cancel = 3,
        /**
         * Dispose the current upload task.
         */
        Dispose = 4,
        /**
         * Add selected file to upload task array.
         */
        AddUploadTasks = 5,
        /**
         * Reset Upload task array.
         */
        ResetUploadTasks = 6,
        /**
         * Complete the current upload task.
         * This action is used for streaming file upload to indicate the completion of the upload.
         */
        Complete = 7,
        /**
         * Abort the current upload task.
         * This action is used for aborting the current upload due to runtime errors.
         */
        Abort = 8,
        /**
         * Gets the next file chunk for streaming upload.
         * This action is used for streaming file upload to get the next file chunk.
         */
        GetNextChunk = 9
    }
    /**
     * API to get the list of upload information for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of upload information.
     */
    export function getUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Promise<FileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of resumable upload information.
     */
    export function getResumableUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Promise<FileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns Promise which contains the array of AsyncUploadTask objects.
     */
    export function getAsyncUploadTasks(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: FileUpload.UploadKey[], category?: string): Promise<FileUpload.AsyncUploadTaskContract[]>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @returns A promise indicating success or failure of the management operation.
     */
    export function invokeUploadAction<TResult>(uploadKey: FileUpload.UploadKey, action: UploadAction, context?: FileUpload.ResumableContext | FileUpload.AbortContext | FileUpload.ChunkContext | FileUpload.DisposeContext): Promise<TResult>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the start byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @returns A promise indicating success or failure of the operation.
     */
    export function getNextChunk(uploadKey: FileUpload.UploadKey, startByte?: number, chunkSize?: number): Promise<FileUpload.StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo on successful completion.
     */
    export function registerRenewSasUriCallback(callback: (fileInfo: FileUpload.FileInfoContract, context?: unknown) => Promise<SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     */
    export function registerRenewAuthorizationCallback(callback: (authorizationType: FileUpload.BlobStoreAuthorizationType, fileInfo: FileUpload.FileInfoContract, context?: unknown) => Promise<FileUpload.SasUriInfo | FileUpload.OauthHeaderInfo>): void;
}

// FILE: Fx\Controls\FormBase.d.ts
declare module "Fx/Controls/FormBase" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { Validation, ValidationResult } from "Fx/Controls/Validations";
    /**
     * Base properties on all form controls
     */
    export interface Contract extends Control {
        /**
         * The dirty state of the control.  This will only change when the user performs an action to change the value, or the dirty state is set explicitly by the extension.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        readonly validations: KnockoutObservableArray<Validation>;
        /**
         * Latest validation results.
         */
        readonly validationResults: KnockoutReadOnlyObservableArray<ValidationResult>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on this control when called.  Returns a promise that resolves once validation on this control has completed.
         * Promise return a value of true (valid) or false (invalid)
         */
        readonly triggerValidation: (focusOnFirstInvalid?: boolean, validateHidden?: boolean) => Promise<boolean>;
        /**
         * Clears validation on the field.
         *
         * @returns A promise that is resolved when the validation has been cleared.
         */
        readonly clearValidation: () => Promise<void>;
    }
    export const enum ValueUpdateTrigger {
        /**
         * (default) Trigger value update when the control widget value changes
         */
        Input = 4,
        /**
         * Trigger value update on blur.
         */
        Blur = 3
    }
    export class DateTimeRange {
        /**
         * Start date/time in local timezone.
         */
        startDateTime: KnockoutObservable<Date>;
        /**
         * End date/time in local timezone.
         */
        endDateTime: KnockoutObservable<Date>;
        /**
         * Creates a DateTimeRange object
         *
         * @param startDateTime The start date/time in local timezone
         * @param endDateTime The end date/time in local timezone
         */
        constructor(startDateTime?: Date, endDateTime?: Date);
    }
}

// FILE: Fx\Controls\FrameControl.d.ts
declare module "Fx/Controls/FrameControl" {
    /**
     * Options for configuring a FrameControl control.
     */
    export interface Options {
        /**
         * The URL of the page to embed in an iframe.
         */
        readonly src: string;
        /**
         * Callback to handle messages posted from iframe to the FrameControl.
         * FrameControl defines the shape of the message received from iframe.
         *
         * @param message Message received from iframe.
         */
        readonly onReceiveMessage?: (message: unknown) => void;
    }
    /**
     * FrameControl view model contract.
     */
    export interface Contract extends MsPortalFx.Control {
        /**
         * Method to post message from FrameControl to iframe.
         * FrameControl defines the shape for the message posted to iframe.
         *
         * @param message Data posted from FrameControl to iframe.
         */
        readonly postMessage: (message: unknown) => void;
    }
    /**
     * Creates a FrameControl viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a FrameControl viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Graph.d.ts
declare module "Fx/Controls/Graph" {
    import Internal = MsPortalFx.Base.Internal;
    import Loadable = MsPortalFx.ViewModels.Controls.Loadable;
    /**
     * Scroll-bars enabled for the control. Flags enum, literals can be combined.
     */
    export enum GraphScrollBars {
        /**
         * No scroll-bars.
         */
        None = 0,
        /**
         * Horizontal scroll-bar.
         */
        Horizontal = 1,
        /**
         * Vertical scroll-bar.
         */
        Vertical = 2
    }
    /**
     * Modes of scroll-bars appearance.
     */
    export enum GraphScrollBarsVisibilityMode {
        /**
         * Scroll-bars are visible all the time when mouse pointer is on the graph canvas.
         */
        AlwaysVisible = 0,
        /**
         * Scroll-bars are hidden all the time.
         */
        AlwaysHidden = 1,
        /**
         * Scroll-bars are only visible when some node(s) are not fully inside the view rectangle.
         */
        AppearWhenNodesOutsideOfTheView = 2
    }
    /**
     * Skin styles of the graph editor.
     */
    export enum GraphEditorSkinStyle {
        /**
         * Canvas and node background colors are consistent with typical blade and parts background colors.
         */
        Blade = 0,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a tint of blue.
         */
        Document = 1,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is a more bright tint of blue, node shape has borders stroke.
         */
        Document2 = 2,
        /**
         * Canvas background color is strictly white or black (depending on main color theme), node background color is grey-ish, node shape has borders stroke.
         */
        Document3 = 3
    }
    /**
     * Strategies defining how edges connect to nodes and how they follow the nodes' moves.
     */
    export enum EdgeConnectionStrategy {
        /**
         * Edge line is a ray originating at the center of the start node and going to the center of the end node.
         */
        NodeCenter = 0,
        /**
         * Edge path is a Bezier curve originating at the output port of the start node and going to the input port of the end node.
         */
        NodePort = 1
    }
    /**
     * Capabilities of the graph editor. Flags enum, literals can be combined.
     */
    export enum GraphEditorCapabilities {
        /**
         * No editor capabilities. Only viewing, panning and zooming-in/-out allowed on the graph.
         */
        None = 0,
        /**
         * Capability to move nodes (connected edges move accordingly).
         */
        MoveEntities = 1,
        /**
         * Capability to update lists of nodes and edges.
         */
        AddRemoveEntities = 2
    }
    /**
     * Defines how graph entities are rendered.
     */
    export enum EntityRenderMode {
        /**
         * When a graph entity is added or removed, all entities are rebuilt and re-rendered on the DOM.
         */
        Rebuild = 0,
        /**
         * When a graph entity is added or removed, existing entities are not re-rendered. Node bindings
         * will be updated for existing nodes, but only the changed (added or removed) entities are
         * modified in the DOM structure of the graph.
         */
        Incremental = 1
    }
    /**
     * Definition of edge line types.
     */
    export enum EdgeType {
        /**
         * Single line/curve.
         */
        Single = 1,
        /**
         * 2 parallel lines/curves.
         */
        Double = 2
    }
    /**
     * Definition of edge line styles.
     */
    export enum EdgeStyle {
        /**
         * Solid line/curve.
         */
        Solid = 1,
        /**
         * Dotted line/curve.
         */
        Dotted = 2,
        /**
         * Dashed line/curve.
         */
        Dashed = 3
    }
    /**
     * Definition of edge markers.
     */
    export enum EdgeMarker {
        /**
         * None.
         */
        None = 1,
        /**
         * Arrow.
         */
        Arrow = 2,
        /**
         * Circle.
         */
        Circle = 3
    }
    /**
     * The Edge end contract.
     */
    export interface IEdgeEnd {
        /**
         * The identifier of the edge end.
         */
        id: KnockoutObservable<string>;
    }
    /**
     * Enum for type of graph entity.
     */
    export enum GraphEntityType {
        GraphNode = 0,
        GraphEdge = 1
    }
    /**
     * Represents the selected entity in the selectableSet
     */
    export class SelectedGraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        id: string;
        entityType: GraphEntityType;
        detailBlade: string;
        detailBladeInputs: Object;
        extension: string;
        constructor(id: string, entityType: GraphEntityType, detailBlade: string, detailBladeInputs: Object, extension?: string);
    }
    /**
     * An abstract class that holds common elements for things that go in the graph.
     * Don't instantiate this.
     */
    export class GraphEntity {
        /**
         * Whether this entity allows being selected by a user or not.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Whether this entity is selected or not.
         */
        selected: KnockoutObservable<boolean>;
        /**
         * The id of this entity. Used for referring to other graph nodes. You may need to
         * overwrite the default one when loading existing graphs.
         */
        id: KnockoutObservable<string>;
        /**
         * A meaningful label for screen readers to use. This should be a concise name of the graph application. https://www.w3.org/TR/wai-aria-1.1/#aria-label
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Set whether the entity should be dimmed (i.e. reduce the opacity).
         */
        dimmed: KnockoutObservable<boolean>;
        /**
         * CommandGroup to display in the context menu of node.
         */
        commandGroup: KnockoutObservable<string>;
        /**
         * Creates a graph entity.
         *
         * @param id The object's id.
         */
        constructor(id?: string);
    }
    /**
     * A graph edge. Put these in Graph.ViewModel's edge array.
     */
    export class GraphEdge extends GraphEntity {
        /**
         * The id of the start node for the edge. Do not change this after adding the edge to the
         * graph. This is set automatically by the constructor, and you should never need to change it.
         */
        startNodeId: KnockoutObservable<string>;
        /**
         * The id of the end node for the edge. Do not change this after adding the edge to the graph.
         * This is set automatically by the constructor, and you should never need to change it.
         */
        endNodeId: KnockoutObservable<string>;
        /**
         * The edge line thickness (in pixels). Limited to values in the range [1; 6].
         */
        strength: KnockoutObservable<number>;
        /**
         * The compound type characteristics of the edge line.
         */
        type: KnockoutObservable<EdgeType>;
        /**
         * The style of the edge line.
         */
        style: KnockoutObservable<EdgeStyle>;
        /**
         * The start marker of the edge.
         */
        startMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The end marker of the edge.
         */
        endMarker: KnockoutObservable<EdgeMarker>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the start node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        startNodePadding: KnockoutObservable<number>;
        /**
         * The padding (in pixels) value used to float the edge ray a bit off the end node bounding rectangle. Only applied when graph EdgeConnectionStrategy is NodeCenter. Default value is 7px.
         */
        endNodePadding: KnockoutObservable<number>;
        /**
         * The label of the edge
         */
        label: KnockoutObservable<string>;
        /**
         * Create a graph edge.
         *
         * @param startNode The node the edge emanates from.
         * @param endNode the node the edge ends on.
         */
        constructor(startNode: IEdgeEnd, endNode: IEdgeEnd);
    }
    /**
     * An interface for optionally updating a rectangle.
     */
    export interface IUpdateRect {
        /**
         * The X coordinate of the node's top-left corner.
         */
        x?: number;
        /**
         * The Y coordinate of the node's top-left corner.
         */
        y?: number;
        /**
         * The height of the node.
         */
        height?: number;
        /**
         * The width of the node.
         */
        width?: number;
    }
    /**
     * A cartesian point interface definition.
     */
    export interface IPoint {
        /**
         * The x coordinate of the point.
         */
        x: number;
        /**
         * The y coordinate of the point.
         */
        y: number;
    }
    /**
     * A rectangle interface definition.
     */
    export interface IRect {
        /**
         * The x coordinate of the rectangle.
         */
        x: number;
        /**
         * The y coordinate of the rectangle.
         */
        y: number;
        /**
         * The height of the rectangle.
         */
        height: number;
        /**
         * The width of the rectangle.
         */
        width: number;
    }
    /**
     * A graph node. Put these in Graph.ViewModel's graphNodes array.
     */
    export class GraphNode extends GraphEntity implements MsPortalFx.ViewModels.DynamicBladeSelection {
        /**
         * The view model to use for displaying the graph node's content.
         */
        extensionViewModel: any;
        /**
         * A Knockout template describing what the graph node looks like.
         */
        extensionTemplate: string;
        /**
         * The name of the blade to launch when the user activates this node.
         */
        detailBlade: string;
        /**
         * Inputs to the blade to launch when the user activates this node.
         */
        detailBladeInputs: Object;
        /**
         * The extension to which the blade specified in detailBlade belongs.
         */
        extension: string;
        /**
         * Specifies if the node is detached link holder
         */
        detachedLinkHolder: boolean;
        /**
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private initialRect;
        constructor(initialRect?: IUpdateRect);
    }
    /**
     * The contract definition of Graph edge interface for the purposes of addition logic.
     */
    export interface IGraphEdgeForAddition {
        /**
         * The identifier of the node the edge starts from.
         */
        startNodeId: string;
        /**
         * The identifier of the node the edge ends at.
         */
        endNodeId: string;
    }
    /**
     * Configurable options for the setNodeRects function call.
     */
    export interface ISetNodeRectOptions {
        /**
         * When true, clears the existing undo/redo stack.
         * Default: false;
         */
        clearUndo?: boolean;
    }
    /**
     * The contract definition of Graph node interface for the purposes of deletion logic.
     */
    export interface IGraphNodeForDeletion {
        /**
         * The identifier of the node.
         */
        id: string;
    }
    /**
     * The contract definition of Graph edge interface for the purposes of deletion logic.
     */
    export interface IGraphEdgeForDeletion {
        /**
         * The identifier of the edge.
         */
        id: string;
    }
    /**
     * Utility class encapsulates deletion functionality.
     */
    export class GraphEntitiesDeletion {
        /**
         * Performs deletion of the specified nodes and edges from the specified graph model.
         *
         * @param model ViewModel instance to run the deletion on.
         * @param nodesToDelete List of nodes to delete.
         * @param edgesToDelete List of edges to delete.
         */
        static run(model: ViewModel, nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): void;
    }
    /**
     * The contract that defines a graph for the pcGraph binding.
     */
    export interface Contract extends Loadable.Contract {
        /**
         * A meaningful label for screenreaders to use. This should be a concise name of the graph application. https://www.w3.org/TR/wai-aria-1.1/#aria-label
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * The scroll-bars enabled for the graph instance. Make sure to set .scrollBarsVisibilityMode property as needed as well.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * The mode of scroll-bars appearance/visibility. Make sure to set .scrollBars property as needed as well.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * The strategy defining how edges connect to nodes and how they follow the nodes' moves.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * The editing capabilities the graph editor exposes.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * A collection of all the graph nodes in the graph.
         */
        graphNodes: MsPortalFx.Base.Internal.IObservableMap<GraphNode>;
        /**
         * A collection of all the edges in the graph.
         */
        edges: MsPortalFx.Base.Internal.IObservableMap<GraphEdge>;
        /**
         * How many pixels tall and wide each grid cell is. Used in snap to grid.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * The currently selected nodes and edges.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * When true, the user can multi-select by clicking in the background and dragging. When false, clicking and dragging in the background pans.
         * Default is false.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
         * The strategy that determines how graph entities are rendered when the list of nodes or edges is updated. Default is
         * EdgeRenderingStrategy.Rebuild, but performance gains may be seen when adding or removing entities by setting this
         * to EntityRenderMode.Incremental.
         */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom and center the graph in the viewport.
         */
        zoomToFit: KnockoutObservable<() => Promise<any>>;
        /**
         * Padding (in pixels) around the graph bounds when zoomToFit is called. Takes effect for zoomToFit() calls made AFTER zoomToFitPadding observable value change. Default value is 100.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom in.
         */
        zoomIn: KnockoutObservable<() => Promise<any>>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom out.
         */
        zoomOut: KnockoutObservable<() => Promise<any>>;
        /**
         * Once the widget has loaded, causes the graph widget to zoom to 100%.
         */
        zoomTo100Percent: KnockoutObservable<() => Promise<any>>;
        /**
         * Once the widget has loaded, causes the graph widget to select the node and bring it into the view with animation.
         */
        focusOnNode: KnockoutObservable<(id: string) => Promise<any>>;
        /**
         * Once the widget has loaded, causes the graph widget to select the edge and bring it into the view with animation.
         */
        focusOnEdge: KnockoutObservable<(id: string) => Promise<any>>;
        /**
         * Bring a rectangle into the view with animation.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => Promise<any>>;
        /**
         * Adds the specified GraphEdge instance to the list of the view model edges.
         * To be overridden in custom ViewModel implementation to customize the edge that is being created when user drags it from source to destination node.
         *
         * @param edgeToAdd The edge instance to add.
         * @returns A promise object that is resolved when the operation completes or fails.
         */
        addEdge(edgeToAdd: IGraphEdgeForAddition): Promise<void>;
        /**
         * Creates copies of selected entities
         */
        duplicateSelectedEntities: KnockoutObservable<() => Promise<void>>;
        /**
         * Flag specifying whether to show link context menu
         */
        edgeContextMenuVisible: KnockoutObservable<boolean>;
        /**
         * Deletes the specified graph entities (nodes and edges).
         *
         * @param nodesToDelete The array of nodes to delete.
         * @param edgesToDelete The array of edges to delete.
         * @returns A promise object that is resolved when the operation completes or fails.
         */
        deleteEntities(nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]): Promise<void>;
        /**
         * Whether or not the widget has been attached yet.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * Notifies subscribers when the a layout change has been committed to the graph. The number given has no useful meaning but is used to trigger
         * the notification to the extension.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * Returns a new candidate layout without overlaps, given a proposed movement of some nodes.
         * The returned candidate layout is used to preview the change and, if the user commits the change,
         * to update the committed locations of nodes.
         * This should be specified by the extension. If it's set null, no automatic layout will occur.
         *
         * @param changedNodes The nodes with explicitly changed positions.
         * @param rootId The node under the user's cursor (which should not move).
         * @returns The nodes with implicitly changed positions.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => Promise<StringMap<IPoint>>>;
        /**
         * Sets the rects for specified graph nodes.
         *
         * All calls to this function will result in animation, so best practice is to initialize nodes with
         * their starting rects (per the optional constructor).
         * This API is used to allow the widget to track animated and committed state, as well as allow for batch updates.
         *
         * @param rects Map of rects.
         * @param options Configurable options (ex: undo/redo stack).
         * @returns A promise that resolves once the changes have been applied.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => Promise<any>>;
        /**
         * Returns all rects for every graph node, or a specified list of graph node ids.
         *
         * This can only be called after widgetAttached() is true, otherwise it will throw an exception.
         *
         * @param ids The list of ids from which to return corresponding graphNodes.
         * @returns A promise that resolves with a string map of committed rects.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => Promise<StringMap<IRect>>>;
        /**
         * A flag to disable zoom in/out behavior on mouse wheel events. If not provided, default to false.
         *
         * @returns A value indicating whether zoom in/out behavior on mouse wheel events is disabled.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * A flag to enable lineage display for graphs (i.e. dim [reduce opacity] all the nodes except the selected and nodes in
         * its upstream and downstream).
         *
         * @returns A boolean indicating if lineage display should be enabled.
         */
        enableLineage: KnockoutObservable<boolean>;
    }
    /**
     * The view model for pcGraph. Contains the representation of a graph.
     */
    export class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * See contract.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * See contract.
         */
        scrollBars: KnockoutObservable<GraphScrollBars>;
        /**
         * See contract.
         */
        scrollBarsVisibilityMode: KnockoutObservable<GraphScrollBarsVisibilityMode>;
        /**
         * See contract.
         */
        edgeConnectionStrategy: KnockoutObservable<EdgeConnectionStrategy>;
        /**
         * See contract.
         */
        editorCapabilities: KnockoutObservable<GraphEditorCapabilities>;
        /**
         * See contract.
         */
        graphNodes: Internal.ObservableMap<GraphNode>;
        /**
         * See contract.
         */
        edges: Internal.ObservableMap<GraphEdge>;
        /**
         * See contract.
         */
        gridResolution: KnockoutObservable<number>;
        /**
         * See contract.
         */
        selectableSet: MsPortalFx.ViewModels.SelectableSet<SelectedGraphEntity, SelectedGraphEntity>;
        /**
         * See contract.
         */
        widgetAttached: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        layoutChanged: KnockoutObservable<number>;
        /**
         * See contract.
         */
        getLayoutNoOverlaps: KnockoutObservable<(changedNodes: StringMap<IPoint>, rootId: string) => Promise<StringMap<IPoint>>>;
        /**
         * See contract.
         */
        setNodeRects: KnockoutObservable<(rects: StringMap<IUpdateRect>, options?: ISetNodeRectOptions) => Promise<any>>;
        /**
         * See contract.
         */
        getNodeRects: KnockoutObservable<(ids?: string[]) => Promise<StringMap<IRect>>>;
        /**
         * See contract.
         */
        rectSelectionMode: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        entityRenderMode: KnockoutObservable<EntityRenderMode>;
        /**
         * See contract.
         */
        zoomToFit: KnockoutObservable<() => Promise<any>>;
        /**
         * See contract.
         */
        zoomToFitPadding: KnockoutObservable<number>;
        /**
         * See contract.
         */
        zoomIn: KnockoutObservable<() => Promise<any>>;
        /**
         * See contract.
         */
        zoomOut: KnockoutObservable<() => Promise<any>>;
        /**
         * See contract.
         */
        zoomTo100Percent: KnockoutObservable<() => Promise<any>>;
        /**
         * See contract.
         */
        focusOnNode: KnockoutObservable<(id: string) => Promise<any>>;
        /**
         * See contract.
         */
        focusOnEdge: KnockoutObservable<(id: string) => Promise<any>>;
        /**
         * See contract.
         */
        bringRectIntoView: KnockoutObservable<(rect: IRect) => Promise<any>>;
        /**
         * See contract.
         */
        addEdge: (edgeToAdd: IGraphEdgeForAddition) => Promise<void>;
        /**
         * See contract.
         */
        duplicateSelectedEntities: KnockoutObservable<() => Promise<any>>;
        /**
         * See contract.
         */
        edgeContextMenuVisible: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        deleteEntities: (nodesToDelete: IGraphNodeForDeletion[], edgesToDelete: IGraphEdgeForDeletion[]) => Promise<void>;
        /**
         * See contract.
         */
        disableMouseWheelZoom: KnockoutObservable<boolean>;
        /**
         * See contract.
         */
        enableLineage: KnockoutObservable<boolean>;
        /**
         * Used by selectable set to determine if a graph node is part of the selected set. Extension authors
         * should never need to call this.
         *
         * @param selectedGraphEntity the SelectedGraphEntity to compare.
         * @param selectionItem the selected item to compare.
         * @returns boolean whether the selected item is the graph entity or not.
         */
        static itemMatchesSelection(selectedGraphEntity: SelectedGraphEntity, selectionItem: SelectedGraphEntity): boolean;
        /**
         * Transforms a graph entity into a selection contract. Extension authors should never need to call this.
         *
         * @param graphEntity the graph node to transform.
         * @returns the graph node that manages selection state.
         */
        static createSelection(selectedGraphEntity: SelectedGraphEntity): SelectedGraphEntity;
        /**
         * The style skin applied to the graph editor defining canvas and entities styling (mostly colors).
         * Only used for constructor purposes. Shouldn't be touched by the extension.
         * We would make this protected, but it need to be proxied over, so we can't.
         */
        private styleSkin;
        /**
         * Creates a graph view model
         *
         * @param lifetimeManager Lifetime manager object dealing with proper resources disposal.
         * @param styleSkin Style skin for the graph editor. Default to GraphEditorSkinStyle.Blade.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, styleSkin?: GraphEditorSkinStyle);
    }
}

// FILE: Fx\Controls\GridBase.d.ts
declare module "Fx/Controls/GridBase" {
    /**
     * Grid selection mode.
     */
    export const enum SelectionMode {
        /**
         * Select a single row at a time.
         */
        Single = 0,
        /**
         * Select a multiple rows at a time.
         */
        Multiple = 1
    }
    /**
     * Grid sort direction.
     */
    export const enum SortDirection {
        /**
         * Data is sorted in ascending order.
         */
        Ascending = 1,
        /**
         * Data is sorted in descending order.
         */
        Descending = -1,
        /**
         * Data is not sorted.
         */
        Unsorted = 0
    }
}

// FILE: Fx\Controls\HotSpot.d.ts
declare module "Fx/Controls/HotSpot" {
    /**
     * Fx/Controls/HotSpot.ViewModelOptions is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export type ViewModelOptions = Obsolete;
    /**
     * Fx/Controls/HotSpot.ViewModel is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export const ViewModel: Obsolete;
    /**
     * Fx/Controls/HotSpot.ViewModel2 is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export const ViewModel2: Obsolete;
}

// FILE: Fx\Controls\InfoBalloon.d.ts
declare module "Fx/Controls/InfoBalloon" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Link object with URI text content.
     */
    export class Link {
        /**
         * Link text.
         */
        linkText: string;
        /**
         * Link Uri.
         */
        linkUri: string;
        /**
         * Creates a Link class.
         *
         * @param linkText The link text to be displayed.
         * @param linkUri The link uri.
         */
        constructor(linkText?: string, linkUri?: string);
    }
    /**
     * Box oject defined by its (top, left) coordinates and its (width, height) dimensions.
     */
    export class Box {
        /**
         * Vertical distance from the top of the document.
         */
        top: number;
        /**
         * Horizontal distance from the left of the document.
         */
        left: number;
        /**
         * Width of the box.
         */
        width: number;
        /**
         * Height of the box.
         */
        height: number;
        /**
         * Creates a Box class.
         *
         * @param top The horizontal offset from the top of the document.
         * @param left The vertical offset from the left of the document.
         * @param width The width of the box.
         * @param height The height of the box.
         */
        constructor(top?: number, left?: number, width?: number, height?: number);
    }
    export interface Options {
        /**
         * Html to be shown in the balloon.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Desired aria-label value of the anchor. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        ariaLabel?: KnockoutObservableBase<string> | string;
    }
    /**
     * InfoBalloon control view model
     */
    export interface Contract extends Control {
        /**
         * Html to be shown in the balloon.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Desired aria-label value of the anchor. If 'content' member field is too long, please
         * make use of this field; make it a shorter summary of the full content.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an InfoBalloon control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns an InfoBalloon viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\InfoBox.d.ts
declare module "Fx/Controls/InfoBox" {
    import { BladeLink, ResourceLink, ClickableLink, OnClickHandler } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The style options for info box.
     */
    export const enum Style {
        /**
         * Info style.
         */
        Info = 1,
        /**
         * Upsell style.
         */
        Upsell = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Warning style.
         */
        Warning = 4,
        /**
         * Error style.
         */
        Error = 5
    }
    /**
     * InfoBox create options.
     */
    export interface Options extends BaseOptions {
        /**
         * Clickable invoked when the InfoBox is clicked.
         *
         * If a function is specified, clicking the infobox will trigger a callback to the function.
         * If a clickable link is provided, then clicking the info box will open that external link.
         * If a blade-reference clickable is provided (BladeLink, or ResourceLink), then the respective
         * blade will get opened.
         */
        onClick?: OnClickHandler | BladeLink | ResourceLink | ClickableLink;
        /**
         * Flag indicating if the info box can be closed.
         */
        canClose?: boolean;
        /**
         * Defines the action performed once the infobox is dismissed.
         */
        onCloseClickCallback?: Function;
    }
    /**
     * Inline InfoBox create options.
     */
    export interface InlineOptions extends BaseOptions {
    }
    /**
     * Base InfoBox create options.
     */
    export interface BaseOptions {
        /**
         * Style of the infobox, defaults to Info.
         */
        style?: Style | KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The text or html to display in the control.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the infobox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * InfoBox control view model.
     */
    export interface Contract extends BaseContract {
    }
    /**
     * Inline InfoBox control view model.
     */
    export interface InlineContract extends BaseContract {
    }
    /**
     * InfoBox control base view model.
     */
    export interface BaseContract extends Control {
        /**
         * Style of the infobox, defaults to Info.
         */
        readonly style: KnockoutObservableBase<Style>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The text or html to display in the control.
         */
        readonly text: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Whether the form element is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The aria-label on the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an InfoBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns an InfoBox viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
    /**
     * Creates an inline InfoBox control viewmodel (no border, no background fill, which does not support canClose or clickables).
     *
     * @param lifetime The lifetime of the control.
     * @param options inline InfoBox Options that modify the appearance and behavior of the control.
     * @returns an inline InfoBox viewmodel.
     */
    export function createInline(lifetime: MsPortalFx.Base.LifetimeManager, options?: InlineOptions): InlineContract;
}

// FILE: Fx\Controls\Legend.d.ts
declare module "Fx/Controls/Legend" {
    import { HatchingPattern as Pattern } from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    import { Control } from "Fx/Controls/ControlsBase";
    export { Pattern };
    export { FxChartColorClass };
    /**
     * ItemSetting defines the properties required to build legend items.
     * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
     */
    export interface ItemSetting {
        /**
         * Data key used to identify the row index. Leave unset to use the index within data.
         */
        readonly indexKey?: string;
        /**
         * Data key used to identify the color.
         */
        readonly colorKey?: string;
        /**
         * Data key of the hatching pattern.
         */
        readonly hatchingKey?: string;
        /**
         * Data key used to identify the boolean column indicating if the row is selected.
         */
        readonly selectedKey?: string;
        /**
         * Data key used to label the row for display purpose. Data has to be string, we use to show center caption for quick indication of the item.
         */
        readonly labelKey: string;
    }
    /**
     * Options for Legend ViewModel.
     */
    export interface Options<T> {
        /**
         * ItemSetting defines the properties required to build legend items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
         */
        itemSetting?: ItemSetting;
        /**
         * Legend items to display.
         */
        items?: T[] | KnockoutObservableArray<T>;
        /**
         * Index of current hovered row in the legend. If hoveredIndex is not initialized, legend items cannot be navigated or selected.
         */
        hoveredIndex?: KnockoutObservableBase<string>;
        /**
         * Enable or disable legend hover and selection. By default legend selection behavior is enabled.
         */
        enableSelection?: boolean;
        /**
         * Aria label for the legend.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Legend ViewModel contract.
     */
    export interface Contract<T> extends Control {
        /**
         * ItemSetting defines the properties required to build legend items.
         * The user data should be mapped to the properties defined by the ItemSetting for proper rendering of legend items.
         */
        readonly itemSetting: ItemSetting;
        /**
         * Legend items to display.
         */
        readonly items: KnockoutObservableArray<T>;
        /**
         * Index of current hovered row in the legend. If hoveredIndex is not initialized, legend items cannot be navigated or selected.
         */
        readonly hoveredIndex: KnockoutObservableBase<string>;
        /**
         * Aria label for the legend.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a Legend control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Legend control viewmodel
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\LineChart.d.ts
declare module "Fx/Controls/LineChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export import ChartEvents = ChartBase.ChartEvents;
    export import ConditionOperator = ChartBase.ConditionOperator;
    export import Interpolation = ChartBase.Interpolation;
    export import RenderingCondition = ChartBase.RenderingCondition;
    export { FxChartColorClass };
    /**
     * Defines line styles of the line chart.
     */
    export const enum LineStyle {
        /**
         * The series line is solid.
         */
        Solid = 0,
        /**
         * The series line is dotted.
         */
        Dotted = 1,
        /**
         * The series line is dashed.
         */
        Dashed = 2,
        /**
         * The series line is a trendline.
         */
        Trendline = 3,
        /**
         * The series line is a usage threshold.
         */
        UsageThreshold = 4,
        /**
         * The series line is a warning threshold.
         */
        WarningThreshold = 5
    }
    /**
     * This base interface defines how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        readonly renderingConditions?: RenderingCondition[];
        /**
         * Indicates if the series is selectable.
         * By default, the series line is selectable and selectable styling is shown. To disallow selecting the series line, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the series line is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Defines the interpolation type for the series.
         * By default the interpolation is Linear and the data points will be connected by straight lines.
         */
        readonly interpolation?: Interpolation;
        /**
         * Defines the line type for the series in the current view.
         * By default solid line will be rendered.
         */
        readonly lineStyle?: LineStyle;
        /**
         * Optionally show a circle for the data point.
         * Default value is true and data point circle will be shown.
         */
        readonly showDataPoints?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Options for configuring a LineChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the line chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * LineChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics: KnockoutObservableBase<boolean>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the line chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @returns A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Promise<void>;
    }
    /**
     * Creates a LineChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a LineChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\ListView.d.ts
declare module "Fx/Controls/ListView" {
    import { ToolbarItem } from "Fx/Controls/Toolbar";
    import { ClickableLink, BladeLink, ResourceLink, OnClickHandler } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Base ListView options.
     */
    export interface Options {
        /**
         * The accessibility label for the List.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Minimum item width in pixels.
         * The default is determined by by UX and can be overriden with this option.
         */
        readonly itemMinWidth?: number | KnockoutObservableBase<number>;
        /**
         * Indicates when the list is in a loading state.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list is in a loading state.
         */
        readonly loadingMessage?: string | KnockoutObservableBase<string>;
        /**
         * Indicates when the list has no data to display.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Message displayed when list is empty.
         */
        readonly noDataMessage?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Css class specific to this List.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Context menu options.
         */
        readonly contextMenu?: ContextMenuOptions<any, any>;
        /**
         * Selection options.
         */
        readonly selection?: SelectionOptions<any>;
    }
    /**
     * SimpleListView options.
     */
    export interface SimpleListViewOptions extends Options {
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<SimpleItemDefinition> | KnockoutObservableArray<SimpleItemDefinition>;
    }
    /**
     * TemplateListView options.
     */
    export interface TemplateListViewOptions<TViewModel> extends Options {
        /**
         * Template used on each item.
         */
        readonly itemTemplate?: string | KnockoutObservableBase<string>;
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<TemplateItemDefinition<TViewModel>> | KnockoutObservableArray<TemplateItemDefinition<TViewModel>>;
        /**
         * Gallery display options.
         */
        readonly galleryView?: GalleryViewOptions;
    }
    /**
     * CustomListView options.
     */
    export interface CustomListViewOptions extends Options {
        /**
         * Items displayed in the list.
         */
        readonly items: ReadonlyArray<CustomItemDefinition> | KnockoutObservableArray<CustomItemDefinition>;
        /**
         * Gallery display options.
         */
        readonly galleryView?: GalleryViewOptions;
    }
    /**
     * Base ListView contract.
     */
    export interface Contract<TItem extends Item> extends Control {
        /**
         * Items displayed in the list.
         */
        readonly items: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The accessibility label for the List.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Minimum item width in pixels.
         * The default is determined by by UX and can be overriden with this property.
         */
        readonly itemMinWidth: KnockoutObservableBase<number>;
        /**
         * Indicates when the list is in a loading state.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list is in a loading state.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the list has no data to display.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Message to display when the list has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Css class specific to this List.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Context menu properties and methods.
         * Will be null when no contextMenu options is provided during ListView's initialization.
         */
        readonly contextMenu: ContextMenuContract;
        /**
         * ListView selection properties and methods.
         * Will be null when no selection options is provided during ListView initialization.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * ListView focus properties and methods.
         */
        readonly focus: FocusContract<TItem>;
    }
    /**
     * SimpleListView contract.
     */
    export interface SimpleListViewContract extends Contract<SimpleItem> {
    }
    /**
     * TemplateListView contract.
     */
    export interface TemplateListViewContract<TViewModel> extends Contract<TemplateItem<TViewModel>> {
        /**
         * galleryView display properties and methods.
         */
        readonly galleryView?: GalleryViewContract;
    }
    /**
     * CustomListView contract.
     */
    export interface CustomListViewContract extends Contract<CustomItem> {
        /**
         * galleryView display properties and methods.
         */
        readonly galleryView?: GalleryViewContract;
    }
    /**
     * Base ListView ItemDefinition.
     */
    export interface ItemDefinition {
        /**
         * The item accessibility description.
         */
        readonly ariaDescription?: string | KnockoutObservableBase<string>;
        /**
         * The item accessibility label.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Css class specific to this item.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state of the item.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback executed or link opened when the user clicks the item.
         */
        readonly onItemClick?: OnClickHandler | ClickableLink | BladeLink | ResourceLink;
    }
    /**
     * ItemDefinition to define SimpleListView item
     */
    export interface SimpleItemDefinition extends ItemDefinition {
        /**
         * Content to be displayed for item
         */
        readonly content: string | KnockoutObservableBase<string>;
    }
    /**
     * ItemDefinition to define TemplateListView item
     */
    export interface TemplateItemDefinition<TViewModel> extends ItemDefinition {
        /**
         * viewModel that bind to the itemTemplate
         */
        readonly viewModel: TViewModel;
    }
    /**
     * ItemDefinition to define CustomListView item
     */
    export interface CustomItemDefinition extends ItemDefinition {
        /**
         * Content to be displayed
         */
        readonly content: HtmlContent | Control | KnockoutObservableBase<HtmlContent | Control>;
    }
    /**
     * Base ListView Item Contract.
     */
    export interface Item {
        /**
         * Css class specific to this item.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The item accessibility description.
         */
        readonly ariaDescription: KnockoutObservableBase<string>;
        /**
         * The item accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Disabled state of the item.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is selected.
         */
        readonly selected: KnockoutReadOnlyObservableBase<boolean>;
    }
    /**
     * SimpleListView Item Contract.
     */
    export interface SimpleItem extends Item {
        /**
         * Content to be displayed
         */
        readonly content: KnockoutObservableBase<string>;
    }
    /**
     * TemplateListView Item Contract.
     */
    export interface TemplateItem<TViewModel> extends Item {
        /**
         * viewModel that bind to the itemTemplate
         */
        readonly viewModel: TViewModel;
    }
    /**
     * CustomListView Item Contract.
     */
    export interface CustomItem extends Item {
        /**
         * Content to be displayed
         */
        readonly content: KnockoutReadOnlyObservableBase<HtmlContent | Control>;
    }
    /**
     * ListView selection mode.
     */
    export const enum SelectionMode {
        /**
         * Select a single row at a time.
         */
        Single = 0,
        /**
         * Select a multiple rows at a time.
         */
        Multiple = 1
    }
    /**
     * ListView selection options.
     */
    export interface SelectionOptions<TItem extends Item> {
        /**
         * Selection mode (defaults to Single).
         */
        readonly selectionMode: SelectionMode;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @returns Indicates if the item can be selected.
         */
        readonly canSelectItem?: (item: TItem) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item can be unselected.
         */
        readonly canUnselectItem?: (item: TItem) => boolean;
        /**
         * Determines if selection UI is visible.
         * Defaults to true.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ListView selection contract.
     */
    export interface SelectionContract<TItem extends Item> {
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * The currently selected items.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * Selects an item.
         *
         * @param item The item to select.
         * @returns Indicates if the item was selected. Would return false if the item is unselectable.
         */
        readonly selectItem: (item: TItem) => boolean;
        /**
         * Unselects an item.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item was unselected.
         */
        readonly unselectItem: (item: TItem) => boolean;
        /**
         * Selects all items.
         *
         * @returns Indicates if all items were selected. Would return false if any item is unselectable.
         */
        readonly selectAllItems: () => boolean;
        /**
         * Unselects all items.
         *
         * @returns Indicates if all items were unselected. Would return false if any item is still selected.
         */
        readonly unselectAllItems: () => boolean;
        /**
         * Determines if selection UI is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu options.
     */
    export interface ContextMenuOptions<TItem extends Item, TContract extends Contract<TItem>> {
        /**
         * Determines if the list item supports context menu.
         * This is true by default and only needs to be implemented to opt specific list items out.
         * This controls if the context menu shortcut is displayed in the list item.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param item The item to show menus for.
         * @returns Indicates if the item can show a context menu.
         */
        readonly canShowMenu?: (item: TItem) => boolean;
        /**
         * Supplies commands to be displayed in the Items context menu.
         * This is not called when multiple items are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param item The item to supply commands for.
         * @returns The commands for the context menu or a promise for the commands.
         */
        readonly supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, item: TItem, list: TContract) => ToolbarItem[] | Promise<ToolbarItem[]>;
        /**
         * Supplies commands to be displayed in the Items context menu.
         * This is called only when multiple rows are selected. And SelectionOptions with SelectionMode.Multi must be supplied.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply the commands for.
         * @param list The list.
         * @returns The commands for the context menu or a promise for the commands.
         */
        readonly supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionContract<TItem>, list: TContract) => ToolbarItem[] | Promise<ToolbarItem[]>;
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         * Defaults to true.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu contract.
     */
    export interface ContextMenuContract {
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * ListView context menu contract.
     */
    export interface FocusContract<TItem extends Item> {
        /**
         * Indicates if the context menu buttons are displayed in the list margin.
         */
        readonly currentItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * Gallery Options for horizonal display
     */
    export interface GalleryViewOptions {
        /**
         * If wrapping overflow items.
         * Set to true by default.
         */
        wrap: boolean | KnockoutObservableBase<boolean>;
        /**
         * If each item can grow/shrink its size based on its container.
         * Set to false by default.
         */
        autofit: boolean | KnockoutObservableBase<boolean>;
        /**
         * Displays standard border styling for the item.
         * This is false by default for backwards compatability.
         * However, it is highly recommended this be set to true for consistent styling across the portal.
         */
        showBorder?: boolean;
    }
    /**
     * Gallery properties for horizonal display
     */
    export interface GalleryViewContract {
        /**
         * If wrapping overflow items.
         * Set to true by default.
         */
        readonly wrap: KnockoutObservableBase<boolean>;
        /**
         * If each item can grow/shrink its size based on its container.
         * Set to false by default.
         */
        readonly autofit: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a SimpleListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the SimpleListView.
     * @returns a SimpleListView viewmodel
     */
    export function createSimpleListView(lifetime: MsPortalFx.Base.LifetimeManager, options: SimpleListViewOptions): SimpleListViewContract;
    /**
     * Creates a TemplateListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the TemplateListView.
     * @returns a TemplateListView viewmodel
     */
    export function createTemplateListView<TViewModel>(lifetime: MsPortalFx.Base.LifetimeManager, options: TemplateListViewOptions<TViewModel>): TemplateListViewContract<TViewModel>;
    /**
     * Creates a CustomListView viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the TemplateListView.
     * @returns a CustomListView viewmodel
     */
    export function createCustomListView(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomListViewOptions): CustomListViewContract;
}

// FILE: Fx\Controls\LocationDropDown.d.ts
declare module "Fx/Controls/LocationDropDown" {
    import { Location as BaseLocation, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Location as ArmLocation } from "Fx/ResourceManagement";
    /**
     * The contract for the values returned by the location dropdown
     */
    export type Location = ArmLocation;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Location>;
    /**
     * The contract for options to create the location drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseLocation.Options<THtmlKeyMap>;
    /**
     * The contract for options to create the location drop down
     */
    export type CustomOptions<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseLocation.CustomOptions<THtmlKeyMap>;
    /**
     * The contract for the location dropdown
     */
    export interface Contract extends BaseLocation.Contract {
    }
    /**
     * This creates a location dropdown control.
     *
     * @param container The container associated with the part or blade.
     * @param options The location dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: MsPortalFx.Base.LifetimeManager, options: Options<THtmlKeyMap>): Contract;
    /**
     * This creates a location dropdown control with the ability to add additional locations.
     *
     * @param container The container associated with the part or blade.
     * @param options The location dropdown options. See interface
     */
    export function createCustom<THtmlKeyMap extends StringMap<HtmlContent>>(container: MsPortalFx.Base.LifetimeManager, options: CustomOptions<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\LogStream.d.ts
declare module "Fx/Controls/LogStream" {
    import { Control } from "Fx/Controls/ControlsBase";
    export const enum LogItemType {
        /**
         * Indicates general information.
         */
        Text = 0,
        /**
         * Indicates important information.
         */
        Information = 1,
        /**
         * Indicates success information
         */
        Success = 2,
        /**
         * Indicates warning information.
         */
        Warning = 3,
        /**
         * Indicates error information.
         */
        Error = 4
    }
    export interface LogItem {
        /**
         * The text to log.
         */
        text: string;
        /**
         * The type of text to log.
         */
        type?: LogItemType;
    }
    export interface Options {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Controls display updating.
         */
        paused?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Controls filtering of messages in the log stream.
         */
        filters?: LogItemType[] | KnockoutObservableArray<LogItemType>;
    }
    export interface Contract extends Control {
        /**
         * Alternate text for screen reader, label for this log-stream
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Controls display updating.  When set to true, the log stream will buffer messages and will show them when unpaused.
         */
        readonly paused: KnockoutObservableBase<boolean>;
        /**
         * Controls filtering of messages in the log stream.
         */
        readonly filters: KnockoutObservableArray<LogItemType>;
        /**
         * Clears the log stream control.
         */
        reset(): void;
        /**
         * Writes an entry to the log
         *
         * @param entry The text to show in the control.  Passing in a LogItem or array of LogItems allows you to control the level of entry (error, warning, etc.)
         */
        log(entry: string | string[] | LogItem | LogItem[]): void;
    }
    /**
     * Creates an LogStream control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns an LogStream viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\ManagementGroupDropDown.d.ts
declare module "Fx/Controls/ManagementGroupDropDown" {
    import { Contract as BaseResourceDropDownContract } from "Fx/Controls/BaseResourceDropDown";
    import { ManagementGroup } from "Fx/ResourceManagement/ManagementGroups";
    import { Validation } from "Fx/Controls/Validations";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * The contract for ManagementGroupDropdown control
     */
    export interface Contract extends Control, Pick<BaseResourceDropDownContract<ManagementGroup>, "value" | "fetchedValues"> {
    }
    /**
     * ManagementGroupDropDown control options
     */
    export interface Options {
        /**
         * Turn multiselect on/off.
         */
        multiSelect?: boolean;
        /**
         * Callback that should be invoked on item to determine whether it should be disabled or not.
         */
        disableItem?: (item: ManagementGroup) => Promise<boolean>;
        /**
         * The aria-label on the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        readonly validations?: Validation[] | KnockoutObservableArray<Validation>;
    }
    /**
     * Creates a ManagementGroupDropDown control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a ManagementGroupDropDown control viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Map.d.ts
declare module "Fx/Controls/Map" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export { FxChartColorClass };
    export import Image = MsPortalFx.Base.Image;
    /**
     * By default, map will take the size(width) of the container and will grow or shrink based on the container width.
     * The height will be adjusted automatically based on the supported aspect ratio.
     */
    export const mapAspectRatio = 2;
    /**
     * Map item coordinate.
     */
    export interface Location {
        /**
         * Latitude coordinate for the map item.
         */
        readonly latitude: number | string;
        /**
         * Longitude coordinate for the map item.
         */
        readonly longitude: number | string;
    }
    /**
     * Map Item contract for basic layout.
     */
    export interface Item {
        /**
         * Specify unique id for the item.
         */
        readonly id: string;
        /**
         * Location for the item.
         */
        readonly location: Location;
        /**
         * The icon displayed for the item.
         */
        readonly icon?: KnockoutObservableBase<Image>;
        /**
         * The width of the icon
         */
        readonly iconWidth?: KnockoutObservableBase<number>;
        /**
         * The height of the icon
         */
        readonly iconHeight?: KnockoutObservableBase<number>;
    }
    /**
     * Link style
     */
    export const enum LinkStyle {
        /**
         * The link is solid line
         */
        Solid = 0,
        /**
         * The link is dashed line
         */
        Dashed = 1,
        /**
         * The link is dashed line with animation
         */
        AnimatedDashed = 2
    }
    /**
     * Shape of the link
     */
    export const enum LinkType {
        /**
         * A straight line connects the two locations
         */
        Line = 0,
        /**
         * A bezier curve connects the two locations
         */
        Curve = 1,
        /**
         * Multiple lines are drawn to connect the two locations
         */
        Step = 2
    }
    /**
     * Additional configuration for curve link
     */
    export interface CurveLinkMetadata {
        /**
         * Mid location to strech the bezier curve to avoid any visual overlap.
         * Customize the curve shape to declutter links between closer locations.
         */
        readonly midCoordinate: Location;
    }
    /**
     * Additional configuration for step link
     */
    export interface StepLinkMetadata {
        /**
         * Specify the latitude where the top line will be drawn to connect two locations.
         * By default the top line will be at latitude coordinate 75.
         */
        readonly latitude: string | number;
    }
    /**
     * Link contract
     */
    export interface Link {
        /**
         * Specify unique id for the link.
         */
        readonly id: string;
        /**
         * Start location for the link
         */
        readonly source: Item;
        /**
         * End location for the link
         */
        readonly target: Item;
        /**
         * Link shape to render. Default link shape will be curve connecting two map items.
         */
        readonly linkType?: LinkType;
        /**
         * Link styling to render. Default link style will be solid.
         */
        readonly linkStyle?: LinkStyle;
        /**
         * Additonal configuration for link
         */
        readonly metadata?: CurveLinkMetadata | StepLinkMetadata;
        /**
         * Link color class. Any supported color class from FxChartColorClass can be used for link color.
         */
        readonly colorClass?: FxChartColorClass;
    }
    /**
     * Event callback for Map interactions.
     */
    export interface Events {
        /**
         * Click on an item.
         */
        readonly itemClick?: (item: Item) => void;
        /**
         * Mouse enter on an item.
         */
        readonly itemMouseEnter?: (item: Item) => void;
        /**
         * Mouse leave on an item.
         */
        readonly itemMouseLeave?: (item: Item) => void;
    }
    /**
     * Initialization options for basic layout map.
     */
    export interface Options {
        /**
         * Map items to be displayed.
         */
        readonly items?: Item[] | KnockoutObservableArray<Item>;
        /**
         * Links between map items.
         */
        readonly links?: Link[] | KnockoutObservableArray<Link>;
        /**
         * Events supported by the map control.
         */
        readonly events?: Events;
        /**
         * The width of the control.
         * If map size needs to be fixed, provide the width for the map. The height will be automatically calculated based on the supported aspect ratio.
         * By default/width is set to 0, map will take the width of the container and will grow or shrink based on the container width.
         * The height will be adjusted automatically based on the supported aspect ratio.
         */
        readonly width?: number | KnockoutObservableBase<number>;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * View model contract for the map widget with basic layout.
     */
    export interface Contract extends Control {
        /**
         * Map items to be displayed.
         */
        readonly items: KnockoutObservableArray<Item>;
        /**
         * Links between map items.
         */
        readonly links: KnockoutObservableArray<Link>;
        /**
         * The width of the control.
         * If map size needs to be fixed, provide the width for the map. The height will be automatically calculated based on the supported aspect ratio.
         * By default/width is set to 0, map will take the width of the container and will grow or shrink based on the container width.
         * The height will be adjusted automatically based on the supported aspect ratio.
         */
        readonly width: KnockoutObservableBase<number>;
        /**
         * The height of the control.
         * The new map layout will preserve the aspect ratio and automatically compute the height.
         */
        readonly height: KnockoutReadOnlyObservableBase<number>;
        /**
         * Aria label for the control.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the control.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a basic layout Map control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a basic layout Map control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Markdown.d.ts
declare module "Fx/Controls/Markdown" {
    import { Control } from "Fx/Controls/ControlsBase";
    export interface Options {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        markdown?: string | KnockoutObservableBase<string>;
        /**
         * @deprecated Fx/Controls/Markdown.Options ariaLabel is deprecated. Please do not use.
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         * Alternate text for screen reader to describe this article shortly.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * markdown Input string containing markdown to be converted to html and displayed.
         */
        readonly markdown: KnockoutObservableBase<string>;
        /**
         * @deprecated Fx/Controls/Markdown.Contract ariaLabel is deprecated. Please do not use.
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         * Alternate text for screen reader to describe this article shortly.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates an Markdown control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Markdown viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Menu.d.ts
declare module "Fx/Controls/Menu" {
    import { MenuItem as TabMenuItem } from "Fx/Controls/TabMenu";
    import { BladeReference } from "Fx/Composition/Selectable";
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    /**
     * Attributes common to all items and groups in the menu.
     */
    export interface MenuItemBase {
        /**
         * Gets the ID for the item.
         */
        id: string;
        /**
         * The display text for the item.
         */
        displayText: string | KnockoutObservableBase<string>;
        /**
         * A space-delimited list of keywords associated to the item.
         */
        keywords?: string | string[];
    }
    /**
     * Defines an item in a group of the menu.
     */
    export interface MenuItem extends MenuItemBase {
        /**
         * The icon associated to the menu item.
         */
        icon: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * A value indicating whether or not the item is enabled.
         */
        enabled?: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not the item should be visible in the menu.
         */
        visible?: KnockoutObservableBase<boolean>;
        /**
         * The tooltip for the menu item.
         */
        tooltip?: string | KnockoutObservableBase<string>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * in response to a user-invoked navigation.
         *
         * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReference?: () => BladeReference<any>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * asynchronously in response to a user-invoked navigation.
         *
         * @returns A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReferenceAsync?: () => Promise<BladeReference<any>>;
        /**
         * The menu items in the tab list.
         */
        tabItems?: TabMenuItem[];
    }
    /**
     * Defines a group in the menu.
     */
    export interface MenuGroup extends MenuItemBase {
        /**
         * The menu items in the group.
         */
        items: MenuItem[];
    }
    /**
     * The options for the menu.
     */
    export interface Options {
        /**
         * Defines the overview item.
         */
        overview?: MenuItem;
        /**
         * The ID of the item to be selected by default.
         */
        defaultId?: string;
        /**
         * This optionally overrides the blade reference factory for tab menu rendering.
         * Use this to change the default behavior of rendering with the HubsExtension's HostedTabMenuBlade.
         *
         * @param item The menu item containing tabItems.
         * @param selectedMenuId The id of the menu item within the item.tabItems array which should be selected upon render.
         * @returns A BladeReference to a TabMenuBlade which renders the item.tabItems given the selectedMenuId.
         */
        overrideTabBlade?: (item: MenuItem, selectedMenuId: string) => BladeReference<any>;
    }
    /**
     * The sort order used for groups in the menu.
     */
    export const enum SortOrder {
        /**
         * Unsorted.
         */
        Unsorted = 0,
        /**
         * Sorted ascending.
         */
        Ascending = 1,
        /**
         * Sorted descending.
         */
        Descending = 2
    }
    /**
     * The sort functions used to sort groups in the menu.
     */
    export enum SortFunction {
        /**
         * Uses the built-in Array.sort() function.
         */
        Default = 0,
        /**
         * Uses the getTime() value of Date object to sort.
         */
        DateTime = 1,
        /**
         * Uses custom sorting, that ensures that the support group is prioritized over others.
         */
        SupportFirst = 9999
    }
    /**
     * Defines the view model for the menu control.
     */
    export class ViewModel extends FxControls.Base.ViewModel {
        /**
         * The groups of menu items.
         */
        groups: KnockoutObservableArray<MenuGroup>;
        /**
         * Specifies the sort order used for groups in the menu.
         */
        groupSortOrder: SortOrder;
        /**
         * Specifies the sort function used to order groups in the menu.
         */
        groupSortFunction: SortFunction;
        /**
         * A value indicating whether or not to show the search box.
         */
        showSearch: boolean;
        /**
         * Asynchronously initializes the view model.
         *
         * @param groups The menu groups.
         * @param options The menu options.
         * @returns A Promise that resolves once the view model is initialized.  This Promise can be included in that Promise returned
         * from the containing Blade's 'onInitialize'/'onInputsSet' method.
         */
        initialize: (groups: MenuGroup[], options: Options) => Promise<void>;
        private _msPortalFxData;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, groupSortFunction?: SortFunction);
        /**
         * Sets the options for the menu.
         *
         * @param options The options to configure the menu.
         */
        setOptions: (options: Options) => void;
    }
}

// FILE: Fx\Controls\Metrics.d.ts
declare module "Fx/Controls/Metrics" {
    import { Contract as SingleMetricContract } from "Fx/Controls/SingleMetric";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Size of the metrics.
     */
    export const enum Size {
        /**
         * Shows small metrics - Font: 20px, Height: 32px, Margin: 14px.
         */
        Small = 0,
        /**
         * Shows medium metrics - Font: 40px, Height: 35px, Margin: 30px.
         */
        Medium = 1,
        /**
         * Shows large metrics - Font: 40px, Height: 45px, Margin: 22px.
         */
        Large = 2,
        /**
         * Shows Xlarge metrics - Font: 40px, Height: 45px, Margin: 25px.
         */
        XLarge = 3,
        /**
         * Shows extra small metrics - Font: 20px, Height: 30px, Margin: 12px.
         */
        ExtraSmall = 4
    }
    /**
     * Orientation of the metrics.
     */
    export const enum Orientation {
        /**
         * Metrics will be displayed horizontally.
         */
        Horizontal = 0,
        /**
         * Metrics will be displayed vertically.
         */
        Vertical = 1
    }
    /**
     * Layout of the metrics.
     */
    export const enum Layout {
        /**
         * In wrap layout the metrics will flow to the next row.
         * The height will expand for the overflow metrics.
         */
        Wrap = 0,
        /**
         * Enable scrolling logic to scroll through overflow metrics.
         */
        Scroll = 1
    }
    export interface Options {
        /**
         * Metrics items to display
         */
        items?: SingleMetricContract[] | KnockoutObservableArray<SingleMetricContract>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation?: Orientation | KnockoutObservableBase<Orientation>;
        /**
         * Layout enum specifies whether metrics items should reflow or have custom scrolling ux.
         * The 'layout' property is honored only for horizontal orientation (and ignored otherwise).
         */
        layout?: Layout | KnockoutObservableBase<Layout>;
        /**
         * The size of the items in the metrics.
         */
        size?: Size | KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * Metrics items to display
         */
        readonly items: KnockoutObservableArray<SingleMetricContract>;
        /**
         * The orientation of the items in the metrics.
         */
        readonly orientation: KnockoutObservableBase<Orientation>;
        /**
         * Layout enum specifies whether metrics items should reflow or have custom scrolling ux.
         * The 'layout' property is honored only for horizontal orientation (and ignored otherwise).
         */
        readonly layout: KnockoutObservableBase<Layout>;
        /**
         * The size of the items in the metrics.
         */
        readonly size: KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a Metrics control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Metrics control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\MonitorChartV2.d.ts
declare module "Fx/Controls/MonitorChartV2" {
    import { BladeReference } from "Fx/Composition";
    import { AnyContainer } from "Fx/Composition/ViewModelBase";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     *  Describes the ARM resource whose metric is being plotted on the chart.
     */
    export interface ResourceMetadata {
        /**
         * The ARM resource id of the resource.
         */
        id: string;
        /**
         * The resource kind of the resource.
         * This is optional and makes fetching the resource faster.
         * When this is not specified it is fetched from ARM and populated.
         */
        kind?: string;
        /**
         * The sku of the resource.
         * These optional features makes fetching the resource faster.
         * When this is not specified it is fetched from ARM and populated.
         */
        sku?: {
            /**
             * The sku name.
             */
            name?: string;
            /**
             * The sku tier.
             */
            tier?: string;
            /**
             * The sku size.
             */
            size?: string;
            /**
             * The sku family.
             */
            family?: string;
            /**
             * The sku model.
             */
            model?: string;
            /**
             * The sku capacity.
             */
            capacity?: string;
        };
    }
    /**
     *  Describes the scope of the metric is being plotted on the chart.
     *  Use Scope when creating a chart with cross-resource queries.
     */
    export interface CrossResourceMetadata {
        /**
         * The subscription to query metrics for.
         */
        subscription: Pick<MsPortalFx.Azure.Subscription, "subscriptionId" | "uniqueDisplayName">;
        /**
         * The resource type to query metric for.
         * For example, "microsoft.compute/virtualmachines" or "microsoft.keyvault/vault"
         */
        resourceType: string;
        /**
         * The region in which to query the resource type.
         * For example, "westus2"
         */
        region: string;
    }
    /**
     * This namespace contains types related to a threshold line to be plotted on the metric on chart.
     */
    export namespace Threshold {
        /**
         * Describes the properties of a threshold line on the metric plotted on chart.
         */
        interface Options {
            /**
             * The identifier for the threshold.
             * Each threshold on a metric has a unique identifier.
             * The id can also be used to identify and access a threshold from `Metric.Threshold` array.
             * If not provided a default one is created.
             */
            id?: string;
            /**
             * The upper bound of the threshold line. Defaults to 0.
             */
            upperThreshold?: number | KnockoutObservableBase<number>;
            /**
             * The lower bound of the threshold. Defaults to 0.
             */
            lowerThreshold?: number | KnockoutObservableBase<number>;
            /**
             * Boolean to indicate if the threshold appears as a locked line on chart
             * or a moveable line to change values. The threshold line is always locked on dashboards.
             */
            isLocked?: boolean;
        }
        /**
         * Returned from `MonitorChartV2.Threshold.create`. Represents a threshold line for a metric plotted on the chart.
         */
        interface Contract {
            /**
             * The identifier for the threshold.
             * Each threshold on a metric has a unique identifier.
             * The id can also be used to identify and access a threshold from `Metric.Threshold` array.
             * If not provided a default one is created.
             */
            readonly id: string;
            /**
             * The upper bound of the threshold line.
             */
            readonly upperThreshold: KnockoutObservableBase<number>;
            /**
             * The lower bound of the threshold line.
             */
            readonly lowerThreshold: KnockoutObservableBase<number>;
        }
        /**
         * Creates a new `Threshold.Contract` from the provided `Threshold.Options`.
         *
         * @param lifetime The lifetime object.
         * @param options The `Threshold.Options` object.
         * @returns A `Threshold.Contract` object.
         */
        function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    }
    /**
     * This namespace contains types related to a metric being plotted on the chart
     */
    export namespace Metric {
        /**
         * Aggregation to use for the metric values
         */
        const enum AggregationType {
            /**
             * No aggregation. Invalid value.
             */
            None = 0,
            /**
             * Sum of metric values per bucket.
             */
            Sum = 1,
            /**
             * Minimum of metric values per bucket.
             */
            Min = 2,
            /**
             * Maximum of metric values per bucket.
             */
            Max = 3,
            /**
             * Average of metric values per bucket.
             */
            Avg = 4,
            /**
             * Unique count of metric values per bucket.
             */
            Unique = 5,
            /**
             * 90th Percentile of metric values per bucket.
             */
            Percentile = 6,
            /**
             * Count of metric values per bucket.
             */
            Count = 7
        }
        /**
         * Visualization options related to a metric on the chart
         */
        interface Visualization {
            /**
             * The localized metric display name to be displayed on the chart.
             * When not specified the metric id is used to display on the chart.
             */
            displayName?: string;
            /**
             * The localized resource display name to be displayed on the chart
             * When not specified the ARM resource name is displayed on the chart.
             */
            resourceDisplayName?: string;
            /**
             * Color of the metric when plotted on the chart, in hexadecimal format (e.g. #c7f1c7).
             * NOTE: Make sure the colors work in dark and light themes.
             * When unspecified, chart chooses a random color.
             */
            color?: string;
        }
        /**
         * Options for creating a metric.
         */
        interface Options {
            /**
             * Information that identifies the resource to which the metric belongs.
             */
            resourceMetadata: ResourceMetadata | CrossResourceMetadata;
            /**
             * The name of the metric.
             */
            name: string;
            /**
             * The aggregation type to use for this metric.
             */
            aggregationType: AggregationType | KnockoutObservableBase<AggregationType>;
            /**
             * Additional information to use when determining the correct metrics provider.
             * This is required when making a cross-resource query and using a Scope as the resourceMetadata.
             * For example, VM providers need to use this, because they can have multiple providers for
             * one VM resource (i.e. Host and Guest metrics).
             * This is only needed for certain providers and not all.
             * When not specified, chart uses a fixed default for each metric type.
             */
            namespace?: string;
            /**
             * Visualization options for the metric.
             * Defaults to a fixed visualization options on all metrics.
             */
            metricVisualization?: Visualization | KnockoutObservableBase<Visualization>;
            /**
             * Threshold options for the metric.
             * This is used to place threshold lines on the chart for the metric.
             * When not specified, there are no threshold lines placed on the chart.
             */
            thresholds?: Threshold.Options[];
        }
        /**
         * Returned from `MonitorChartV2.Metric.create` call. Contract object for the metric.
         */
        interface Contract {
            /**
             * Information that identifies the resource to which the metric belongs.
             */
            readonly resourceMetadata: ResourceMetadata | CrossResourceMetadata;
            /**
             * Name of the metric. This can be used to uniquely identify the metric, inside a chart's Metric array.
             */
            readonly name: string;
            /**
             * The aggregation type to use for this metric.
             */
            readonly aggregationType: KnockoutObservableBase<AggregationType>;
            /**
             * Additional information to use when determining the correct metrics provider.
             * For example, VM providers need to use this, because they can have multiple providers for
             * one VM resource (i.e. Host and Guest metrics).
             * This is only needed for certain providers and not all
             * When not specified, chart uses a fixed default for each metric type.
             */
            readonly namespace?: string;
            /**
             * Visualization options for the metric.
             */
            readonly metricVisualization: KnockoutObservableBase<Visualization>;
            /**
             * Threshold options for the metric. This is used to place threshold lines on the chart
             * for the metric
             */
            readonly thresholds: KnockoutObservableArray<Threshold.Contract>;
        }
        /**
         * Creates a `Metric.Contract` for the `Metric.Options` provided by callers.
         * Use this `Metric.Contract` object to later manipulate the `MonitorChartV2.charts().metrics` array.
         *
         * @param lifetime The lifetime object. Use the lifetime associated with MonitorChart control here.
         * @param options The `Metric.Options` object for the metric.
         * @returns A `Metric.Contract` object.
         */
        function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    }
    /**
     *  Sort order when fetching the groups/segments
     */
    export const enum SortOrder {
        /**
         * No specific sort-order requested.
         */
        Unsorted = 0,
        /**
         * The groups returned are sorted in increasing order by value of individual group
         */
        Ascending = 1,
        /**
         * The groups returned are sorted in decreasing order by value of individual group
         */
        Descending = 2
    }
    /**
     * Describes the grouping/segmentation of the metric on the chart.
     */
    export interface Grouping {
        /**
         * The dimension(s) to group against. You can specify single dimension or multiple dimensions as array.
         */
        dimension: string | string[];
        /**
         * the number of dimensions to fetch when grouped, default is 10.
         */
        top?: number;
        /**
         * Order of the groups fetched, default is descending
         */
        sort?: SortOrder;
    }
    /**
     * A collection of all the filters on the chart.
     */
    export interface FilterCollection {
        /**
         * Array containing all the Filters applied to the chart.
         */
        filters: Filter[];
    }
    /**
     * Operators for filter comparisons.
     */
    export const enum FilterComparisonOperator {
        Equal = 0,
        NotEqual = 1,
        Contains = 2,
        StartsWith = 3
    }
    /**
     * Describes an individual filter which can be added to the FilterCollection of the chart.
     */
    export interface Filter {
        /**
         * The dimension key for the filter.
         */
        key: string;
        /**
         * Filter operator to be applied to the values (= or ≠)
         * Defaults to equal.
         */
        operator?: FilterComparisonOperator;
        /**
         * The set of values for the key we want to filter against.
         */
        values: string[];
    }
    /**
     * Time range over which data points are fetched and plotted.
     */
    export interface TimeRange {
        /**
         * The start of the time range.
         */
        startTime: Date;
        /**
         * The end of the time range.
         */
        endTime: Date;
    }
    /**
     * Supported grains that can be applied on a timespan for the chart.
     */
    export const enum Grain {
        /**
         * Chart chooses an automatic grain to display.
         */
        Automatic = 1,
        /**
         * Grain to set to per minute over the given time range.
         */
        Minutely = 2,
        /**
         * Grain to set to per hour over the given time range.
         */
        Hourly = 3,
        /**
         * Grain to set to per day over the given time range.
         */
        Daily = 4,
        /**
         * Grain to set to per week over the given time range.
         */
        Weekly = 5,
        /**
         * Grain to set to per month over the given time range.
         */
        Monthly = 6,
        /**
         * Grain to set to every 5 minutes over the given time range.
         */
        Every_5_Minutes = 7,
        /**
         * Grain to set to every 15 minutes over the given time range.
         */
        Every_15_Minutes = 8,
        /**
         * Grain to set to every 30 minutes over the given time range.
         */
        Every_30_Minutes = 9,
        /**
         * Grain to set to every 6 hours over the given time range.
         */
        Every_6_Hours = 10,
        /**
         * Grain to set to every 12 hours over the given time range.
         */
        Every_12_Hours = 11
    }
    /**
     * Timespan signifies the absolute or relative time range for which the chart displays the data.
     */
    export interface Timespan {
        /**
         * The absolute time range of the chart's timespan.
         * If this is not present relative duration is used.
         * If neither of absolute or relative is specified, chart defaults to past 24 hours time range.
         */
        absolute?: TimeRange;
        /**
         * The related duration for the chart's timespan.
         * If this is not present absolute duration is used.
         * If neither of absolute or relative is specified, chart defaults to past 24 hours time range.
         */
        relative?: {
            duration: number;
        };
        /**
         * The grain of the time context.
         * Defaults to a fixed grain with respect to the timespan.
         */
        grain?: Grain;
        /**
         * Set to true to display time as UTC on the chart
         * Defaults to using local time.
         */
        showUTCTime?: boolean;
    }
    /**
     * Represents the visual elements of a chart.
     */
    export interface VisualizationContract {
        /**
         * The type of chart to be used. Defaults to a line chart.
         */
        readonly chartType: KnockoutObservableBase<ChartType>;
        /**
         * Options related to how the legend should be displayed.
         * Defaults to a fixed legend visualization with legends on bottom.
         */
        readonly legendVisualization: KnockoutObservableBase<LegendVisualization>;
        /**
         * Options related to how the axis should be displayed.
         * Defaults to a fixed axis visualization.
         */
        readonly axisVisualization: KnockoutObservableBase<AxisVisualization>;
        /**
         * Indicates whether users can pin this chart to their dashboard.
         * Defaults to false and pin button is always shown.
         */
        readonly disablePinning: KnockoutObservableBase<boolean>;
        /**
         * Indicates whether users have a toolbar item to directly go to alerts blade to configure alert for the metrics on this chart.
         * Defaults to false and alert toolbar button is hidden.
         */
        readonly enableAlertToolbar: KnockoutObservableBase<boolean>;
    }
    /**
     * Represents the visual elements of a chart.
     */
    export interface Visualization {
        /**
         * The type of chart to be used. Defaults to a line chart.
         */
        chartType?: ChartType | KnockoutObservableBase<ChartType>;
        /**
         * Options related to how the legend should be displayed.
         * Defaults to a fixed legend visualization with legends on bottom.
         */
        legendVisualization?: LegendVisualization | KnockoutObservableBase<LegendVisualization>;
        /**
         * Options related to how the axis should be displayed.
         * Defaults to a fixed axis visualization.
         */
        axisVisualization?: AxisVisualization | KnockoutObservableBase<AxisVisualization>;
        /**
         * Indicates whether users can pin this chart to their dashboard.
         * Defaults to false and pin button is always shown.
         */
        disablePinning?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates whether users have a toolbar item to directly go to alerts blade to configure alert for the metrics on this chart.
         * Defaults to false and alert toolbar button is hidden.
         */
        enableAlertToolbar?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * List of supported chart types.
     */
    export const enum ChartType {
        /**
         * Bar Chart.
         */
        Bar = 1,
        /**
         * Line Chart.
         */
        Line = 2,
        /**
         * Area Chart.
         */
        Area = 3,
        /**
         * Scatter plot chart.
         */
        Scatter = 4
    }
    /**
     * Represents how to display a chart's axis.
     */
    export interface AxisVisualization {
        /**
         * x-axis visualization options.
         */
        x?: IndividualAxisVisualization;
        /**
         * y-axis visualization options.
         */
        y: IndividualAxisVisualization;
    }
    /**
     * Visualization options for a particular axis.
     */
    export interface IndividualAxisVisualization {
        /**
         * Determines if the axis is visible on the chart or hidden.
         */
        isVisible: boolean;
        /**
         * Defines the smallest value shown for the axis.
         * Defaults to '0' for numeric axis and start timespan for date axis.
         */
        min?: number;
        /**
         * Defines the largest value shown for the axis.
         * Defaults to maximum data value of the plotted data for numeric axis and end timespan for date axis.
         */
        max?: number;
    }
    /**
     * List of relative positions to place legend.
     */
    export const enum LegendPosition {
        /**
         * Legends placed on bottom of chart.
         */
        Bottom = 2,
        /**
         * Legends placed on right of chart.
         */
        Right = 4
    }
    /**
     * Represents how to style a chart's legend.
     */
    export interface LegendVisualization {
        /**
         * Controls if the legend is visible or hidden on the chart.
         */
        isVisible: boolean;
        /**
         * Controls the position of legend with respect to the chart.
         * Default is to position on bottom of chart.
         */
        position?: LegendPosition;
        /**
         * Defines the maximum fraction digits displayed in the number column.
         * If not defined, legends will show 2 fraction digits for all units and 4 fraction digits for percentages
         */
        maximumDecimalDigits?: number;
    }
    /**
     * Indicating create Blade reference event type.
     */
    export enum CreateBladeReferenceEvent {
        OnPin = 0,
        OnClick = 1
    }
    /**
     * Options for how the MonitorChart reacts to a click.
     */
    export interface OpenBladeOptions {
        /**
         * Set to false to disable chart click behavior. Default to 'true'
         */
        openBlade?: boolean;
        /**
         * A function invoked both when the Chart is clicked and when the Chart is pinned to a Dashboard.
         * Must return a BladeReference that doesn't include any functions (like any 'onClosed' callback function).
         *
         * @param event An indication of why the BladeReference is being created.
         * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        createBladeReference?: (event: CreateBladeReferenceEvent) => BladeReference<any>;
    }
    /**
     * MonitorChartV2 title kind.
     */
    export const enum TitleKind {
        /** no title */
        None = 0,
        /** title is automatically generated */
        Auto = 1,
        /** title is customized */
        Custom = 2
    }
    /**
     * MonitorChartV2 options.
     */
    export interface Options {
        /**
         * The list of metrics to plot on this chart.
         */
        metrics: Metric.Options[];
        /**
         * The filters to apply on the chart for all metrics.
         * If not specified, data isn't filtered.
         */
        filterCollection?: FilterCollection | KnockoutObservableBase<FilterCollection>;
        /**
         * Specify the grouping to segment the chart against.
         * If not specified chart is not segmented.
         */
        grouping?: Grouping | KnockoutObservableBase<Grouping>;
        /**
         * Controls the display properties of chart.
         */
        visualization?: Visualization;
        /**
         * Title for the chart. Defaults to no title.
         */
        title?: string | KnockoutObservableBase<string>;
        /**
         * Specifies the kind of title to be displayed.
         * Defaults to 'Custom' if 'title' is supplied. Otherwise, defaults to 'None'.
         */
        titleKind?: TitleKind | KnockoutObservableBase<TitleKind>;
        /**
         * The timespan used for the MonitorChartV2
         * Defaults to past 24 hours.
         */
        timespan?: Timespan | KnockoutObservableBase<Timespan>;
        /**
         * Aria label for the MonitorChartV2. Defaults to "MonitorChartV2"
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Control blade to open when chart is clicked.
         * When omitted, click chart will navigate to metric blade for editing the chart.
         */
        openBladeOnClick?: OpenBladeOptions | KnockoutObservableBase<OpenBladeOptions>;
    }
    /**
     * MonitorChartV2 control.
     */
    export interface Contract extends Control {
        /**
         * The list of metrics to plot on this chart.
         */
        readonly metrics: KnockoutObservableArray<Metric.Contract>;
        /**
         * The filters applied on all metrics on this chart.
         */
        readonly filterCollection: KnockoutObservableBase<FilterCollection>;
        /**
         * Specifies the grouping the chart is segmented against.
         */
        readonly grouping: KnockoutObservableBase<Grouping>;
        /**
         * Controls the display properties of chart.
         */
        readonly visualization: VisualizationContract;
        /**
         * Title for the chart.
         */
        readonly title: KnockoutObservableBase<string>;
        /**
         * Specifies the kind of title to be displayed.
         * Defaults to 'Custom' if 'title' is supplied. Otherwise, defaults to 'None'.
         */
        readonly titleKind: KnockoutObservableBase<TitleKind>;
        /**
         * The timespan used for the chart.
         */
        readonly timespan: KnockoutObservableBase<Timespan>;
        /**
         * Aria label for the MonitorChartV2.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Control blade to navigate to when chart is clicked.
         * When omitted, click chart will navigate to metric blade for editing the chart.
         */
        readonly openBladeOnClick: KnockoutObservableBase<OpenBladeOptions>;
        /**
         * Metrics data provider.
         * Used to fetch filter dimensions and their values.
         */
        readonly metricsDataProvider: Promise<MetricsDataProvider>;
    }
    /**
     * Creates a MonitorChartV2 viewModel.
     *
     *  @param container The container of the control. This must be a container object.
     *  @param options Options that modify the appearance and behavior of the control.
     *  @returns a MonitorChartV2 viewModel.
     */
    export function create(container: AnyContainer, options?: Options): Contract;
    /**
     * Metrics filter dimension name.
     */
    export interface FilterName {
        /**
         * Unique identifier for filter dimension.
         */
        id: string;
        /**
         * The localized display name for filter dimension.
         */
        displayName?: string;
    }
    /**
     * Metrics filter dimension
     */
    export interface DimensionDefinition {
        /**
         * The name for the dimension.
         */
        dimensionName: FilterName;
        /**
         * Description for the dimension.
         */
        description?: string;
        /**
         * List of operators supported by this dimension".
         * Note: default is Equals and Not Equals.
         */
        supportedOperators?: FilterComparisonOperator[];
        /**
         * List of operators not supporting multiselect
         */
        multiSelectNonSupportedOpList?: FilterComparisonOperator[];
    }
    /**
     * Metrics Chart data providers.
     */
    export interface MetricsDataProvider {
        /**
         * Get all filter attributes for a set of metrics.
         *
         * @param metrics Metrics to fetch filters for
         */
        getFilterAttributes(metrics: Metric.Options[]): Promise<DimensionDefinition[]>;
        /**
         * Get values for a filter.
         *
         * @param metrics Metrics to fetch filter values for
         * @param filterId Filter attribute to fetch values for
         * @param timespan Timespan for values query
         */
        getFilterValues(metrics: Metric.Options[], filterId: string, timespan: Timespan): Promise<string[]>;
    }
}

// FILE: Fx\Controls\MultiLineTextBox.d.ts
declare module "Fx/Controls/MultiLineTextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which vlue of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a multiline textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * the number of lines in the control.
         */
        rows?: number | KnockoutObservableBase<number>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Controls when the control will update it's value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Enable the control to be spellcheck. Default as false
         * (Warning. Perf hit. Do not enable this for a huge text).
         */
        spellcheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * @deprecated Any value supplied for the 'hideValidationCheck' property will be ignored. The new default behavior for the control is to always hide the validation checkmark.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the Enter + Shift key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * Multiline textbox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * the number of lines in the control.
         */
        readonly rows: KnockoutObservableBase<number>;
        /**
         * Enable the MultiLintTextBox to be spellcheck.
         * (Warning. Perf hit. Do not enable this for a huge text).
         */
        readonly spellcheck: KnockoutObservableBase<boolean>;
        /**
         * @deprecated Any value supplied for the 'hideValidationCheck' property will be ignored. The new default behavior for the control is to always hide the validation checkmark.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         *
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a mulitline textbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a multiline textbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\NumericTextBox.d.ts
declare module "Fx/Controls/NumericTextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which vlue of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a numeric textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * Minimum number allowed.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum number allowed.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        decimalPoint?: number | KnockoutObservableBase<number>;
        /**
         * Text to display when entered text is not numeric.
         */
        notANumberErrorMessage?: string;
        /**
         * Specifies whether an empty value should be allowed or if it should be replaced with a 0 value.  Defaults to false.
         */
        allowEmpty?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Controls when the control will update it's value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * Aria label for the textbox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: number) => void;
    }
    /**
     * Numeric TextBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
        /**
         * Minimum number allowed.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum number allowed.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         *  Maximum decimal points allowed for the number. No more than 20.
         */
        readonly decimalPoint: KnockoutObservableBase<number>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a Numeric TextBox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a numeric textbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\OAuthButton.d.ts
declare module "Fx/Controls/OAuthButton" {
    import { Style } from "Fx/Controls/Button";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Styling of the button.
     */
    export { Style };
    export interface Options {
        /**
         * Aria label for the OAuthButton.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText?: string | KnockoutObservableBase<string>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: number;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: number;
        /**
         * Request url used to pop up the OAuth window.  Note: When registering app with provider (e.g., github) you need to specify Authorization callback URL: https://portal.azure.com/TokenAuthorize
         * e.g. for github it is https://github.com/login/oauth/authorize?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&state=<RANDOM_STRING>
         */
        requestUrl?: string | KnockoutObservableBase<string>;
        /**
         * The style of the button.
         */
        style?: Style | KnockoutObservableBase<Style>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Called when authentication is successful.
         * value is a string in the form of "https://portal.azure.com/TokenAuthorize?code=abcd12345678abcdef12"
         */
        onAuthenticationSucceeded: (value: string) => void;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface Contract extends FormBase.Contract {
        /**
         * Button text used to populate the text content of the OAuthButton
         */
        buttonText: KnockoutObservableBase<string>;
        /**
         * Request url used to pop up the OAuth window.  Note: When registering app with provider (e.g., github) you need to specify Authorization callback URL: https://portal.azure.com/TokenAuthorize
         * e.g. for github it is https://github.com/login/oauth/authorize?client_id=<CLIENT_ID>&client_secret=<CLIENT_SECRET>&state=<RANDOM_STRING>
         */
        requestUrl: KnockoutObservableBase<string>;
        /**
         * The style of the button (Primary / Secondary).
         */
        readonly style: KnockoutObservableBase<Style>;
    }
    /**
     * Creates an OAuth button control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns an OAuth button control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\OptionsGroup.d.ts
declare module "Fx/Controls/OptionsGroup" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Item<TValue> {
        text: string;
        value: TValue;
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a options group control
     */
    export interface Options<TValue> {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If true, sets each item to equal width and the total size of the control to the size of the element.
         * Otherwise, sets the width of each item in the options group to the size of the content. Defaults to false.
         */
        uniformItemWidth?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The list of items of the options group
         */
        items?: Array<Item<TValue>> | KnockoutObservableArray<Item<TValue>>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * ItemPicker control view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * The list of items of the options group
         */
        readonly items: KnockoutObservableArray<Item<TValue>>;
    }
    /**
     * Creates a options group control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns an options group control viewmodel
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\PagedDataGrid.d.ts
declare module "Fx/Controls/PagedDataGrid" {
    import { Control, HtmlContent } from "Fx/Controls/ControlsBase";
    import { SelectionMode, SortDirection } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import { BladeReference, FxElement } from "Fx/Composition";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    export { 
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    HtmlContent, 
    /**
     * PagedDataGrid selection mode.
     */
    SelectionMode, 
    /**
     * PagedDataGrid sort direction.
     */
    SortDirection, };
    /**
     * PagedDataGrid column sort order.
     */
    export interface SortOrder {
        /**
         * The column id.
         */
        id: string;
        /**
         * The sort direction.
         */
        direction: SortDirection;
    }
    /**
     * PagedDataGrid cell definition.
     */
    export interface CellDefinitionBase<TItem> {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
    }
    /**
     * Text cell definition.
     */
    export interface TextCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies the text to display in the cell.
         *
         * @param item The data item,
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A string or a value that is convertible to string or an observable containing the value.
         */
        text: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * Text column definition.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinition<TItem> extends TextColumnDefinitionOptions<TItem> {
        /**
         * Text column definition type.
         * A column that displays text in each cell.
         */
        type: "Text";
    }
    /**
     * Text column definition options.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A Text cell definition.
         */
        cell: TextCellDefinition<TItem>;
    }
    /**
     * Template cell definition.
     */
    export interface TemplateCellDefinition<TItem, TViewModel = any> extends CellDefinitionBase<TItem> {
        /**
         * The template used for all cells in the column.
         */
        template: string;
        /**
         * Supplies a viewmodel to bind with the template.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @param grid The grid.
         * @returns A view model or an observable containing the view model.
         */
        viewModel: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => TViewModel | KnockoutReadOnlyObservableBase<TViewModel>;
    }
    /**
     * Template column definition.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinition<TItem> extends TemplateColumnDefinitionOptions<TItem, any> {
        /**
         * Template column definition type.
         * A column that binds a view model to an HTML template in each cell.
         */
        type: "Template";
    }
    /**
     * Template column definition options.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinitionOptions<TItem, TViewModel = any> extends ColumnDefinitionBase<TItem> {
        /**
         * A Template cell definition.
         */
        cell: TemplateCellDefinition<TItem, TViewModel>;
    }
    /**
     * UriLink definition.
     */
    export interface UriLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the uri.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The link target.
         */
        target?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The link text.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
        /**
         * The URI to navigate to when the link is clicked.
         * A non-null URI will render a clickable link.
         * A null URI will render plain text that is not clickable.
         */
        uri: string | KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * UriLink cell definition.
     */
    export interface UriLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a UriLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A UriLink definition.
         */
        uriLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => UriLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * UriLink column definition.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinition<TItem> extends UriLinkColumnDefinitionOptions<TItem> {
        /**
         * UriLink column definition type.
         * A column that displays a URI link in each cell.
         */
        type: "UriLink";
    }
    /**
     * UriLink column definition options.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A UriLink cell definition.
         */
        cell: UriLinkCellDefinition<TItem>;
    }
    /**
     * BladeLink definition.
     */
    export interface BladeLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the bladeReference.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The blade reference for the link.
         * A non-null blade reference will render a clickable link.
         * A null blade reference will render plain text that is not clickable.
         * A blade reference that uses object-typed blade parameters or is too long will result in an href of "#" instead of a deep link.
         */
        bladeReference: BladeReference<unknown> | KnockoutReadOnlyObservableBase<BladeReference<unknown>>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * Text to display with link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * BladeLink cell definition.
     */
    export interface BladeLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a BladeLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A BladeLink definition.
         */
        bladeLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => BladeLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * BladeLink column definition.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinition<TItem> extends BladeLinkColumnDefinitionOptions<TItem> {
        /**
         * BladeLink column definition type.
         * A column that displays a link that opens a blade in each cell.
         */
        type: "BladeLink";
    }
    /**
     * BladeLink column definition options.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A BladeLink cell definition.
         */
        cell: BladeLinkCellDefinition<TItem>;
    }
    /**
     * ResourceLink definition.
     */
    export interface ResourceLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick instead.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The resource id to link to.
         * A non-null resource id will render a clickable link unless canClick is false.
         * A null resource id will render plain text that is not clickable.
         */
        resourceId: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The resource kind to link to.
         */
        resourceKind?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * Overrides the default text determined from the resource id.
         *
         * You can use the getDisplayName utility function to generate a name that utilizes a hidden-title tag.
         *
         * text: ResourceName.getDisplayName({
         *     id: getResourceId(item),
         *     tags: getResourceTags(item),
         * }),
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * ResourceLink cell definition.
     */
    export interface ResourceLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a resource link definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A resource link definition.
         */
        resourceLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => ResourceLink;
        /**
         * Indicates to display the resource icon in the link.
         * Defaults to true.
         */
        showIcon?: boolean;
        /**
         * Indicates to display the preview badge on the resource icon in the link.
         * Defaults to true.
         * For preview blades you may set this to false if you find it too noisy to show these on every icon.
         * If you do hide the badging for a preview blade make sure the blade itself indicates it is preview.
         */
        showPreview?: boolean;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * ResourceLink column definition.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinition<TItem> extends ResourceLinkColumnDefinitionOptions<TItem> {
        /**
         * ResourceLink column definition type.
         * A column that displays a link that opens a resource in each cell.
         */
        type: "ResourceLink";
    }
    /**
     * ResourceLink column definition options.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A ResourceLink cell definition.
         */
        cell: ResourceLinkCellDefinition<TItem>;
    }
    /**
     * CustomLink definition.
     */
    export interface CustomLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The text to display in the link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * CustomLink cell definition.
     */
    export interface CustomLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Changes the role of the link to "button".
         * By default the role will be a "link" and the user expects the link to navigate using openBlade or openContextPane.
         * If your onClick does not navigate you should change the role of the link to "button".
         * However, you may want to consider alteratives such as supplyButtonCommands which is designed to add command buttons to grid rows.
         */
        buttonRole?: boolean;
        /**
         * Supplies a CustomLink definition to display a custom link in a cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A CustomLink definition.
         */
        customLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => CustomLink;
        /**
         * Callback to provide custom behavior for clicking on the link.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         * If your onClick does not navigate you should set buttonRole to true.
         *
         * @param item The data item.
         * @param row The row containing the data item.
         * @param target The framework element that was clicked on.
         */
        onClick?: (item: TItem, row: Row<TItem>, target: FxElement) => void;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * CustomLink column definition.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinition<TItem> extends CustomLinkColumnDefinitionOptions<TItem> {
        /**
         * CustomLink column definition type.
         * A column that displays a custom link in each cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         */
        type: "CustomLink";
    }
    /**
     * CustomLink column definition options.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A CustomLink cell definition.
         */
        cell: CustomLinkCellDefinition<TItem>;
    }
    /**
     * TagList cell definition.
     */
    export interface TagListCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Notification when an item tag has been clicked.
         *
         * @param item The item being clicked.
         * @param tagIndex The index of the tag being clicked.
         */
        onClick?: (item: TItem, tagIndex: number) => void;
        /**
         * Supplies the tags to display in a cell.
         *
         * @param lifetime The cell lifetime.
         * @param item The item to get tags for.
         * @param row The row containing the cell.
         * @returns The tags or an observable containing the tags.
         */
        tags: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string[] | KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * TagList column definition.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinition<TItem> extends TagListColumnDefinitionOptions<TItem> {
        /**
         * TagList column definition type.
         * A TagList column displays a list of strings as bubbled text in a cell.
         */
        type: "TagList";
    }
    /**
     * TagList column definition options.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A TagList cell definition.
         */
        cell: TagListCellDefinition<TItem>;
    }
    /**
     * PagedDataGrid data node.
     */
    export interface DataNode<TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The unique id.
         * If the object identity of your items is changing this is required to allow
         * the grid to preserve selection and other UI state across refreshes.
         * Can be set to null if you do not have an identifier or do not care about preserving UI state.
         */
        id: TId;
        /**
         * The data item.
         */
        item: TItem;
        /**
         * The child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the child nodes when the children property is not set.
         * Allows for delayed loading of child items.
         *
         * @param parentNode The parent node.
         * @returns The child nodes or a promise for the child nodes.
         */
        getChildren?: (parentNode: DataNode<TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * PagedDataGrid group data node.
     * A group node is a parent node for all the children in the group.
     * A group node creates a group row with a single cell spanning the row to contains the group header.
     */
    export interface GroupNode<TGroup, TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The group unique id.
         */
        id: TId;
        /**
         * The group data item.
         */
        group: TGroup;
        /**
         * The group child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the group child nodes when the children property is not set.
         * Allows for asynchronous loading of group items.
         *
         * @param parentNode The parent node.
         * @returns The group child nodes or a promise for the group child nodes.
         */
        getChildren?: (parentNode: GroupNode<TGroup, TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * Query parameters for the callback data source.
     */
    export interface CallbackDataSourceParams<TParams = any> {
        /**
         * Custom query parameters for the datasource.
         */
        params: TParams;
        /**
         * Indicates if the data source has been reset.
         * The data source may return uncached data in this case.
         */
        reset: boolean;
        /**
         * The requested sort order to return the data in.
         */
        sortOrder: SortOrder[];
        /**
         * The start index of the requested page.
         */
        skip: number;
        /**
         * The requested page length.
         */
        take: number;
    }
    /**
     * Result to return from the callback data source.
     */
    export interface CallbackDataSourceResult<TItem, TGroup = any> {
        /**
         * The data nodes for the requested page.
         */
        nodes: DataNode<TItem>[] | GroupNode<TGroup, TItem, any>[];
        /**
         * The total count of data nodes.
         */
        totalCount: number;
    }
    /**
     * PagedDataGrid callback data source.
     */
    export interface CallbackDataSource<TItem, TGroup = any, TParams = any> {
        /**
         * Callback to get the data items.
         *
         * @param queryParams Query parameters such as sort order for making the correct query.
         * @returns The data result or a promise for the result.
         */
        (queryParams: CallbackDataSourceParams<TParams>): CallbackDataSourceResult<TItem, TGroup> | Promise<CallbackDataSourceResult<TItem, TGroup>>;
    }
    /**
     * Refresh options.
     */
    export interface RefreshOptions<TParams = any> {
        /**
         * Message to display and announce while refreshing.
         */
        message?: string;
        /**
         * Message to announce when refresh is completed.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
        /**
         * Custom query parameters to pass to the dataSource.
         */
        params?: TParams;
        /**
         * Indicates if the refresh should fully reset the grid data.
         * Typically used with a refresh command in the UI.
         * When reset the grid will clear selection and other UI state that may not apply with new data.
         * The data source should use this option to determine if cached data should be returned or not.
         * The default is false.
         */
        reset?: boolean;
        /**
         * Determines if the message and spinner are shown while the dataSource is called.
         * If true the dataSource will be called asyncronously after the message UI has been displayed.
         * If false the dataSource will be called synchronously and the message UI will not be shown.
         * If undefined (the default) the dataSource will be called synchronously and the message UI will only be shown if
         * the dataSouce implementation is async and yields execution.
         */
        showMessage?: boolean;
        /**
         * The requested sort order to return the data in.
         * This is an array of the column ids and sort directions in order of precedence.
         * When sortOrder is provided as an option it is passed to the dataSource.
         * When sortOrder is not provided the sortOrder is constructed from the column collection using the column id and sortDirection.
         * If sorting is disabled for the grid this option will have no effect.
         * The current sortOrder can also be accessed with grid.sorting.sortOrder.
         */
        sortOrder?: SortOrder[];
    }
    /**
     * PagedDataGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, HTML content, or an observable that returns a string or HTML content.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * PagedDataGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
    }
    /**
     * PagedDataGrid cell definition.
     * The CellDefinition contains properties that are used to create a Cell.
     */
    export type CellDefinition<TItem> = BladeLinkCellDefinition<TItem> | CustomLinkCellDefinition<TItem> | ResourceLinkCellDefinition<TItem> | TagListCellDefinition<TItem> | TemplateCellDefinition<TItem> | TextCellDefinition<TItem> | UriLinkCellDefinition<TItem>;
    /**
     * PagedDataGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export type ColumnDefinition<TItem> = BladeLinkColumnDefinition<TItem> | CustomLinkColumnDefinition<TItem> | ResourceLinkColumnDefinition<TItem> | TagListColumnDefinition<TItem> | TemplateColumnDefinition<TItem> | TextColumnDefinition<TItem> | UriLinkColumnDefinition<TItem>;
    /**
     * PagedDataGrid column definition common properties.
     */
    export interface ColumnDefinitionBase<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         * Defaults to false.
         * When set to true the dataSource must implement sorting for it to work.
         */
        canSort?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * To set additional column header properties provide a column header definition.
         */
        header?: string | ColumnHeaderDefinition;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Sort direction of the column.
         * Defaults to unsorted.
         */
        sortDirection?: SortDirection | KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid column.
     * Part of the PagedDataGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         */
        readonly canSort: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * Sort direction of the column.
         */
        readonly sortDirection: KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         *
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * PagedDataGrid cell.
     * Part of the PagedDataGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
    }
    /**
     * PagedDataGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
    }
    /**
     * PagedDataGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         *
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * PagedDataGrid row.
     * Part of the PagedDataGrid object model.
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is hovered.
         */
        readonly hovered: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The data id.
         */
        readonly id: any;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * PagedDataGrid row group definition.
     * Used to initialize new row groups.
     */
    export interface RowGroupDefinition<TGroup> {
        /**
         * Supplies the accessibility label for the row group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The accessibility label.
         */
        ariaLabel?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the content for the group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The row group content label.
         */
        content?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | HtmlContent | KnockoutObservableBase<string>;
    }
    /**
     * PagedDataGrid row group.
     * Part of the PagedDataGrid object model.
     */
    export interface RowGroup<TGroup, TItem> {
        /**
         * The row group accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * Indicates if the row group is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row group is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * The group.
         */
        readonly group: TGroup;
        /**
         * The data id.
         */
        readonly id: any;
    }
    /**
     * PagedDataGrid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid header.
     * Part of the PagedDataGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid focus options.
     */
    export interface FocusOptions<TItem, TGroup = any> {
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * PagedDataGrid focus contract.
     */
    export interface FocusContract<TItem, TGroup = any> {
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * The current row group.
         * This row group is the focused row group when the grid has focus.
         * When focus leaves the grid the current row group remains.
         */
        readonly currentRowGroup: KnockoutReadOnlyObservable<RowGroup<TGroup, TItem>>;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
    }
    /**
     * PagedDataGrid selection options.
     */
    export interface SelectionOptions<TItem, TGroup = any> {
        /**
         * Determines if all items can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be selected at once.
         */
        canSelectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @param grid The grid.
         * @returns Indicates if the item can be selected.
         */
        canSelectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if all items can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be unselected at once.
         */
        canUnselectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @param grid The grid.
         * @returns Indicates if the item can be unselected.
         */
        canUnselectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
    }
    /**
     * PagedDataGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Indicates if all items can be selected.
         */
        readonly canSelectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be selected.
         *
         * @param item The item to select.
         * @returns Indicates if an item can be selected.
         */
        canSelectItem(item: TItem): boolean;
        /**
         * Indicates if all items can be unselected.
         */
        readonly canUnselectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be unselected.
         *
         * @param item The item to unselect.
         * @returns Indicates if an item can be unselected.
         */
        canUnselectItem(item: TItem): boolean;
        /**
         * Selects all items.
         *
         * @returns Indicates if all items were selected.
         */
        selectAllItems(): boolean;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Selects an item.
         *
         * @param item The item to select.
         * @returns Indicates if the item was selected.
         */
        selectItem(item: TItem): boolean;
        /**
         * Selects an item by id.
         *
         * @param id The item's id to select.
         * @returns Indicates if the item was selected.
         */
        selectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Unselects all items.
         *
         * @returns Indicates if all items were unselected.
         */
        unselectAllItems(): boolean;
        /**
         * Unselects an item.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItem(item: TItem): boolean;
        /**
         * Unselects an item by id.
         *
         * @param id The item's id to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid activation options.
     */
    interface ActivationOptions {
        /**
         * Hides the selection while a child blade is opened.
         * Leaves the current row highlighting only on the activated row.
         * When the child blade is closed the selection is restored unless the user changed the selection while the child blade was open.
         * There are very few scenarios where you would enable this behavior.
         * Typically the only scenario this is used is when you want to collapse the parent blade to show the child blade next to it.
         * This is disabled by default.
         */
        hideSelectionDuringActivation?: boolean;
    }
    /**
     * PagedDataGrid activation contract.
     * Activation occurs when a child blade is opened from a grid cell using a BladeLinkColumn,
     * CustomLinkColumn, ResourceLinkColumn, or fxclick in an HTML template.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * PagedDataGrid hover contract.
     */
    export interface HoverContract<TItem> {
        /**
         * The currently hovered row.
         * Null when a row is not hovered.
         */
        readonly hoveredRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param row The row.
         * @returns A promise for completion
         */
        hoverRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param id The id.
         * @returns A promise for completion
         */
        hoverRowById<TId extends string | ConvertsToString>(id: TId): Promise<boolean>;
    }
    /**
     * PagedDataGrid context menu options.
     */
    export interface ContextMenuOptions<TItem, TGroup = any> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid hierarchy options.
     */
    export interface HierarchyOptions<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be collapsed.
         */
        canCollapseAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @param grid The grid.
         * @returns Indicates if the row can be collapsed.
         */
        canCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @param grid The grid.
         * @returns Indicates if the row group can be collapsed.
         */
        canCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be expanded.
         */
        canExpandAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @param grid The grid.
         * @returns Indicates if the row can be expanded.
         */
        canExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @param grid The grid.
         * @returns Indicates if the row group can be expanded.
         */
        canExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Notifies when the hierarchy is collapsed.
         *
         * @param grid The grid.
         */
        onCollapseAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is collapsed.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is collapsed.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when the hierarchy is expanded.
         *
         * @param grid The grid.
         */
        onExpandAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is expanded.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is expanded.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Customize the initial expanded state of a hierarchical parent row.
         * The grid will call this when a new row is being created to determine if it should be expanded or not.
         * The grid will only call if the item has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded The default expanded state which is expanded for root items and collapsed for all child item.
         * @param level The item level in the hierarchy 1 is top level.
         * @param item The row item.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForItem?: (cachedExpanded: boolean, defaultExpanded: boolean, level: number, item: TItem) => boolean;
        /**
         * Customize the initial expanded state of a row group.
         * The grid will call this when a new row group is being created to determine if it should be expanded or not.
         * The grid will only call if the group has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded  The default expanded state which is expanded for row groups.
         * @param group The row group.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForGroup?: (cachedExpanded: boolean, defaultExpanded: boolean, group: TGroup) => boolean;
    }
    /**
     * PagedDataGrid hierarchy contract.
     */
    export interface HierarchyContract<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @returns Indicates if the hiearrchy can be collapsed.
         */
        canCollapseAll(): boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @returns Indicates if a row can be collapsed.
         */
        canCollapseRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if a row group can be collapsed.
         */
        canCollapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @returns Indicates if the hiearrchy can be expanded.
         */
        canExpandAll(): boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @returns Indicates if a row can be expanded.
         */
        canExpandRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if a row group can be expanded.
         */
        canExpandRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Collapse the hierarchy.
         *
         * @returns Indicates if the hierarchy was collapsed.
         */
        collapseAll(): Promise<boolean>;
        /**
         * Collapses a row.
         *
         * @param row The row to collapse.
         * @returns Indicates if the row was collapsed.
         */
        collapseRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Collapses a row group.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if the row group was collapsed.
         */
        collapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
        /**
         * Expands the hierarchy.
         *
         * @returns Indicates if the hierarchy was expanded.
         */
        expandAll(): Promise<boolean>;
        /**
         * Expands a row.
         *
         * @param row The row to expand.
         * @returns Indicates if the row was expanded.
         */
        expandRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Expands a row group.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if the row group was expanded.
         */
        expandRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
    }
    /**
     * PagedDataGrid paging options.
     */
    export interface PagingOptions<TItem> {
        /**
         * The count of rows in a page.
         * The default is 100.
         */
        pageSize?: number;
        /**
         * Message displayed when loading the page.
         */
        pageLoadingMessage?: string;
        /**
         * Custom content to display on the right side of the pager.
         */
        rightContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
    }
    /**
     * PagedDataGrid paging contract.
     */
    export interface PagingContract<TItem> {
        /**
         * Indicates if a page can be loaded.
         *
         * @param pageNumber The page number to load.
         * @returns If page can be loaded.
         */
        canLoadPage(pageNumber: number): boolean;
        /**
         * Indicates if the next page can be loaded.
         *
         * @returns If the next page can be loaded.
         */
        canLoadNextPage(): boolean;
        /**
         * Indicates if the previous page can be loaded.
         *
         * @returns If the previous page can be loaded.
         */
        canLoadPreviousPage(): boolean;
        /**
         * Loads the specified page.
         *
         * @param pageNumber The pabe number to load.
         * @returns Promise for completion.
         */
        loadPage(pageNumber: number): Promise<boolean>;
        /**
         * Loads the next page.
         *
         * @returns Promise for completion.
         */
        loadNextPage(): Promise<boolean>;
        /**
         * Loads the previous page.
         *
         * @returns Promise for completion.
         */
        loadPreviousPage(): Promise<boolean>;
    }
    /**
     * PagedDataGrid resizing options.
     */
    export interface ResizingOptions<TItem, TGroup = any> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * PagedDataGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is disabled.
         * Vertical scrolling requires that the element the grid is bound to has a height.
         * Having a height allows the grid to display a vertical scrollbar and fix the header at the top.
         */
        vertical?: boolean;
    }
    /**
     * PagedDataGrid sorting options.
     */
    export interface SortingOptions<TItem, TGroup = any> {
        /**
         * Determines whether additional sorted columns can be added to the current sort order.
         * This can be used to limit the number of columns that can be sorted at the same time.
         * The default is to allow all the sortable columns to be sorted at the same time.
         *
         * @param sortOrder All columns with their column ids and sort directions.
         * @param grid The grid.
         * @returns A boolean that indicates if additional columns can be added to the current sort order.
         */
        canSortAdditionalColumns?: (sortOrder: SortOrder[], grid: Contract<TItem, TGroup>) => boolean;
    }
    /**
     * PagedDataGrid sorting properties and methods.
     */
    export interface SortingContract<TItem, TGroup = any> {
        /**
         * The current sort order.
         * This is an array of the column ids and sort directions in order of precedence.
         */
        readonly sortOrder: KnockoutReadOnlyObservableArray<SortOrder>;
    }
    /**
     * PagedDataGrid options.
     */
    export interface Options<TItem, TGroup = any> {
        /**
         * Activation options.
         * Activation is enabled by default.
         * Activation can not be disabled by omitting the activation options or setting to null.
         */
        activation?: ActivationOptions;
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[];
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem, TGroup>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The data source.
         */
        dataSource: CallbackDataSource<TItem, TGroup>;
        /**
         * Disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem, TGroup>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Hierarchy options.
         * Heirarchy is enabled by default.
         * The hierarchy is determined by the node structure returned from the data source.
         */
        hierarchy?: HierarchyOptions<TItem, TGroup>;
        /**
         * Content to display when the grid has no data.
         */
        noDataMessage?: string | HtmlContent;
        /**
         * Paging options.
         * Paging is enabled by default and cannot be disabled.
         */
        paging?: PagingOptions<TItem>;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem, TGroup>;
        /**
         * Row initialization options.
         */
        row?: RowDefinition<TItem>;
        /**
         * Row group options.
         */
        rowGroup?: RowGroupDefinition<TGroup>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is auto-detected.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is not enabled by default.
         * Selection is enabled by providing selection options.
         */
        selection?: SelectionOptions<TItem, TGroup>;
        /**
         * Sorting options.
         * Sorting is enabled by default.
         * Sorting can be disabled by setting to null.
         * To sort you must set canSort to true on a column and implement sorting in the dataSource.
         */
        sorting?: SortingOptions<TItem, TGroup>;
        /**
         * Hides or shows the grid.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PagedDataGrid loading message options.
     */
    export interface LoadingMessageOptions {
        /**
         * Message to be displayed/announced while loading.
         */
        message?: string;
        /**
         * Message to be announced on loading completion.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
    }
    /**
     * PagedDataGrid contract.
     */
    export interface Contract<TItem, TGroup = any> extends Control {
        /**
         * DataGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * If called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional messages to display and announce to screen readers.
         * @returns A Promise that is resolved when the message is shown or determined not to be shown.
         */
        displayLoadingMessage(completion: Promise<any>, message?: string | LoadingMessageOptions): Promise<boolean>;
        /**
         * DataGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem, TGroup>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Hierarchy properties and methods.
         */
        readonly hierarchy: HierarchyContract<TItem, TGroup>;
        /**
         * Hover properties and methods.
         */
        readonly hover: HoverContract<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the grid has no data to display.
         */
        readonly noData: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Paging properties and methods.
         */
        readonly paging: PagingContract<TItem>;
        /**
         * Refreshes the grid data.
         *
         * @param options Refresh options.
         * @returns A promise for completion.
         */
        refresh<TParams>(options?: RefreshOptions<TParams>): Promise<any>;
        /**
         * The grid row groups when the grid is grouped.
         */
        readonly rowGroups: KnockoutReadOnlyObservableArray<RowGroup<TGroup, TItem>>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * DataGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * Sorting properties and methods.
         */
        readonly sorting: SortingContract<TItem>;
        /**
         * Hides or shows the DataGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a PagedDataGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem, TGroup = any>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TGroup>): Contract<TItem, TGroup>;
    /**
     * Creates a BladeLink column definition that displays a link to a blade in each cell.
     *
     * @param options The BladeLink column definition options.
     * @returns A BladeLink column definition.
     */
    export function createBladeLinkColumn<TItem>(options: BladeLinkColumnDefinitionOptions<TItem>): BladeLinkColumnDefinition<TItem>;
    /**
     * Creates a CustomLink column definition that displays a custom link in each cell.
     * Only use for exceptional cases where you do not require browser behaviors like
     * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
     * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
     *
     * @param options The CustomLink column definition options.
     * @returns A CustomLink column definition.
     */
    export function createCustomLinkColumn<TItem>(options: CustomLinkColumnDefinitionOptions<TItem>): CustomLinkColumnDefinition<TItem>;
    /**
     * Creates a ResourceLink column definition that displays a link to a resource in each cell.
     *
     * @param options The ResourceLink column definition options.
     * @returns A ResourceLink column definition.
     */
    export function createResourceLinkColumn<TItem>(options: ResourceLinkColumnDefinitionOptions<TItem>): ResourceLinkColumnDefinition<TItem>;
    /**
     * Creates a TagList column definition that displays a list of tags as bubbled text in each cell.
     *
     * @param options The TagList column definition options.
     * @returns A TagList column definition.
     */
    export function createTagListColumn<TItem>(options: TagListColumnDefinitionOptions<TItem>): TagListColumnDefinition<TItem>;
    /**
     * Creates a template column definition that displays an HTML template bound to a view model in each cell.
     *
     * @param options The template column definition options.
     * @returns A Template column definition.
     */
    export function createTemplateColumn<TItem, TViewModel = any>(options: TemplateColumnDefinitionOptions<TItem, TViewModel>): TemplateColumnDefinition<TItem>;
    /**
     * Creates a text column definition that displays text in each cell.
     *
     * @param options The text column definition options.
     * @returns A Text column definition.
     */
    export function createTextColumn<TItem>(options: TextColumnDefinitionOptions<TItem>): TextColumnDefinition<TItem>;
    /**
     * Creates a UriLink column definition that displays a URI link in each cell.
     *
     * @param options The UriLink column definition options.
     * @returns A UriLink column definition.
     */
    export function createUriLinkColumn<TItem>(options: UriLinkColumnDefinitionOptions<TItem>): UriLinkColumnDefinition<TItem>;
}

// FILE: Fx\Controls\Pager.d.ts
declare module "Fx/Controls/Pager" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * @deprecated Fx/Controls/Pager is deprecated. Please use Fx/Controls/Pager2 instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    export interface PagerState {
        /**
         * The page number.
         * The page number is in the range from one to the total page count.
         * The page number defaults to zero unless initialized through options.
         * The page number is zero in error conditions.
         */
        pageNumber: number;
        /**
         * The total page count.
         * The total page count defaults to zero unless initialized through options.
         * The total page count is zero in error conditions.
         */
        totalPageCount: number;
    }
    /**
     * @deprecated Fx/Controls/Pager is deprecated. Please use Fx/Controls/Pager2 instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    export interface Options {
        /**
         * Classes to add to pager element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Disables or enables the Pager.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback to load a page.
         * Called whenever a page is to be loaded.
         *
         * @param pageNumber The requested page number to load.
         * @param pager The pager control.
         * @returns The page state after loading the requested page.
         */
        loadPage: (pageNumber: number, pager: Contract) => Promise<PagerState>;
        /**
         * The initial page number and total page count.
         */
        state?: PagerState;
        /**
         * Hides or shows the Pager.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated Fx/Controls/Pager is deprecated. Please use Fx/Controls/Pager2 instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    export interface Contract extends Control {
        /**
         * Determines if the next page can be loaded.
         */
        readonly canLoadNextPage: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if the previous page can be loaded.
         */
        readonly canLoadPreviousPage: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Classes to add to pager element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disables or enables the Pager.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates when the pager is loading.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Loads the next page.
         *
         * @returns Indicates if the page was loaded.
         */
        loadNextPage(): Promise<boolean>;
        /**
         * Loads the page.
         *
         * @param pageNumber The page number starting at 1.
         * @returns Indicates if the page was loaded.
         */
        loadPage(pageNumber: number): Promise<boolean>;
        /**
         * Loads the previous page.
         *
         * @returns Indicates if the page was loaded.
         */
        loadPreviousPage(): Promise<boolean>;
        /**
         * The current page number and total page count.
         * The page number is in the range from one to the total page count.
         */
        readonly state: KnockoutObservable<PagerState>;
        /**
         * Hides or shows the Pager.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated Fx/Controls/Pager is deprecated. Please use Fx/Controls/Pager2 instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Pager2.d.ts
declare module "Fx/Controls/Pager2" {
    import { Control, HtmlContent } from "Fx/Controls/ControlsBase";
    export { 
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    HtmlContent, };
    /**
     * Pager options.
     */
    export interface Options {
        /**
         * Classes to add to pager element class attribute.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Disables or enables the Pager.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Overrides the default description provided by the pager.
         */
        readonly description?: string | KnockoutObservableBase<string>;
        /**
         * Controls the loading state of the pager.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Callback to load a page.
         * Called whenever a page is to be loaded.
         * Implementors should set loading to true while loading the page.
         * Implementors should update the pager startIndex and totalCount upon completion.
         * Implementors should set totalCount to zero upon error.
         * Implementors should set loading to false at the completion of the load.
         *
         * @param startIndex The zero based index of the first record in the page to load.
         * @param pageSize The requested number of records in a full page. This may not match the actual count of records in the last page.
         * @param pager A reference to the pager control that can be used by the implementor.
         * @returns A promise for completion.
         */
        readonly onLoadPage: (startIndex: number, pageSize: number, pager: Contract) => Promise<void>;
        /**
         * The number of records in a full page.
         * Generally, this will stay constant.
         * This may not match the actual count of records in the last page.
         * Defaults to 100.
         */
        readonly pageSize?: number | KnockoutObservableBase<number>;
        /**
         * Custom content to display on the right side of the pager.
         */
        readonly rightContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The zero based index of the first record in the page.
         * This should range from 0 to totalCount-1.
         * Defaults to zero.
         */
        readonly startIndex?: number | KnockoutObservableBase<number>;
        /**
         * The total count of records in the data set.
         * Defaults to zero.
         */
        readonly totalCount?: number | KnockoutObservableBase<number>;
        /**
         * Hides or shows the Pager.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Pager contract.
     */
    export interface Contract extends Control {
        /**
         * Determines if the next page can be loaded.
         */
        readonly canLoadNextPage: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if the previous page can be loaded.
         */
        readonly canLoadPreviousPage: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Classes to add to pager element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disables or enables the Pager.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Overrides the default description provided by the pager.
         */
        readonly description: KnockoutObservableBase<string>;
        /**
         * Indicates when the pager is loading.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Loads the next page.
         *
         * @returns Indicates if the page was loaded.
         */
        loadNextPage(): Promise<boolean>;
        /**
         * Loads a page.
         *
         * @param pageNumber The page number starting at 1.
         * @returns Indicates if the page was loaded.
         */
        loadPage(pageNumber: number): Promise<boolean>;
        /**
         * Loads the previous page.
         *
         * @returns Indicates if the page was loaded.
         */
        loadPreviousPage(): Promise<boolean>;
        /**
         * The page number.
         * The page number is in the range from one to the total page count.
         * The page number is zero when there are no pages.
         * The page number is computed from the startIndex, pageSize, and totalCount.
         */
        readonly pageNumber: KnockoutReadOnlyObservableBase<number>;
        /**
         * The number of records in a full page.
         */
        readonly pageSize: KnockoutObservableBase<number>;
        /**
         * Custom content to display on the right side of the pager.
         */
        readonly rightContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The zero based index of the first record in the page.
         */
        readonly startIndex: KnockoutObservableBase<number>;
        /**
         * The total count of records in the data set.
         */
        readonly totalCount: KnockoutObservableBase<number>;
        /**
         * The total page count.
         * The total page count is zero when there are no pages.
         * The total page count is computed from totalCount and pageSize.
         */
        readonly totalPageCount: KnockoutReadOnlyObservableBase<number>;
        /**
         * Hides or shows the Pager.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a pager control view model.
     *
     * @param lifetime The lifetime manager.
     * @param options The creation options.
     * @returns A pager control instance.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\PairedTimeline.d.ts
declare module "Fx/Controls/PairedTimeline" {
    import * as PairedTimelineBadges from "Fx/Controls/PairedTimelineBadges";
    import * as RangeSelection from "Fx/Controls/RangeSelection";
    import Controls = MsPortalFx.ViewModels.Controls;
    import Visualization = Controls.Visualization;
    import Chart = Visualization.Chart;
    import Metrics = Visualization.Metrics;
    import Loadable = Controls.Loadable;
    export const enum SelectionMode {
        /**
         * Indicates that the user can select one item at at time by clicking.
         */
        Single = 0,
        /**
         * Indicates that the user can select and unselect multiple items at at time by clicking and control-clicking.
         */
        Multiple = 1
    }
    export interface SelectableOptions {
        /**
         * Indicates selection mode or single or multiple selection (default Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Gets or sets the selected item for single selection backward compatibility.
         */
        selectedItem?: KnockoutObservable<any>;
        /**
         * Gets or sets the selected items.
         */
        selection?: MsPortalFx.ViewModels.SelectableSet<any, any>;
        /**
         * Indicates that the item should activate when selected (default true).
         */
        activateOnSelected?: boolean;
    }
    /**
     * Extension options
     */
    export interface ExtensionOptions {
        /**
         * Selection options.
         */
        selectable?: SelectableOptions;
    }
    /**
     * Contract container for the Chart and Metrics controls
     */
    export interface PairedTimelineChartContract<TX, TY> extends Loadable.Contract {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control contract
         */
        chart: Chart.Contract<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
        /**
         * The title for the chart.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Whether or not the title is shown.
         */
        showTitle: KnockoutObservableBase<boolean>;
    }
    /**
     * Container for the Chart and Metrics controls
     */
    export class PairedTimelineChart<TX, TY> extends Loadable.ViewModel implements PairedTimelineChartContract<TX, TY> {
        /**
         * Identifier of chart
         */
        id: string;
        /**
         * Chart control
         */
        chart: Chart.ViewModel<TX, TY>;
        /**
         * Chart height in number of units(integer). Each unit is 45 px.
         */
        chartHeight: KnockoutObservableBase<number>;
        /**
         * The message to display when the chart is un-configured or there is no chart data.
         */
        noDataMessage: KnockoutObservableBase<string>;
        /**
         * CSS class to be applied to the List View item
         */
        cssClass: KnockoutObservableBase<string>;
        /**
         * Selectable for the buttons in the PT
         */
        buttonSelectables: MsPortalFx.ViewModels.Selectable<string>[];
        /**
         * The title for the chart.
         */
        title: KnockoutObservableBase<string>;
        /**
         * Whether or not the title is shown.
         * Title will only be shown for >1 chart height charts.
         */
        showTitle: KnockoutObservableBase<boolean>;
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, id: string);
        dispose(): void;
    }
    export const enum PairedTimelineButtonVisibilityOptions {
        ShowOnHover = 1,
        AlwaysShow = 2
    }
    export interface PairedTimelineButtonOptions {
        /**
         * Whether the Edit buttons should be shown.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Text to use for the edit button, default is "Edit"
         */
        text: KnockoutObservableBase<string>;
        /**
         * Controls the visibility of the buttons. (always vs onhover)
         */
        visibility: KnockoutObservableBase<PairedTimelineButtonVisibilityOptions>;
    }
    export interface Contract<TX, TY> extends Loadable.Contract {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
         * A null or undefined value disables selection.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Enable metrics rules.
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * Metrics options
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
    }
    export class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The collection of Paired Timeline charts.
         */
        ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>;
        /**
         * Options used to configure the loaded plugins for selection.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionOptions: ExtensionOptions;
        /**
         * Enable Metrics Rules
         */
        enableMetricsRules: KnockoutObservableBase<boolean>;
        /**
         * MetricsOptions
         */
        metricsOptions: Metrics.VisualContract;
        /**
         * Enables sliders to select a range on the x axis.
         */
        enableRangeSelection: KnockoutObservableBase<boolean>;
        /**
         * Range selection view model.
         */
        rangeSelectionViewModel: RangeSelection.ViewModel<TX>;
        /**
         * Badges View model
         */
        badgesViewModel: PairedTimelineBadges.ViewModel<TX>;
        /**
         * Options for the buttons defined in the PT.
         */
        buttonOptions: PairedTimelineButtonOptions[];
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ptCharts: KnockoutObservableArray<PairedTimelineChart<TX, TY>>, extensionOptions: ExtensionOptions, rangeSelectionOptions?: RangeSelection.Options<TX>, pairedTimelineBadgesOptions?: PairedTimelineBadges.Options<TX>);
    }
}

// FILE: Fx\Controls\PairedTimelineBadges.d.ts
declare module "Fx/Controls/PairedTimelineBadges" {
    import * as InfoBalloon from "Fx/Controls/InfoBalloon";
    import FxViewModelsControlsBase = MsPortalFx.ViewModels.Controls.Base;
    /**
     * Contract for an individual displayable badge.
     */
    export interface BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate?: KnockoutObservableBase<number>;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible?: KnockoutObservableBase<boolean>;
    }
    /**
     * Class for an individual Badge.
     */
    export class Badge<TX> extends FxViewModelsControlsBase.ViewModel implements BadgeContract<TX> {
        /**
         * Badge Identifier
         */
        id: string;
        /**
         * Unique class name for this badge.
         */
        className: KnockoutObservableBase<string>;
        /**
         * The badge text
         */
        text: string;
        /**
         * The x value corresponding to the event this badge is reporting.
         */
        xValue: TX;
        /**
         * The icon to display for the badge.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * Whether the badge is displayed.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * The coordinate where the badge is rendered.
         */
        coordinate: KnockoutObservableBase<number>;
        /**
         * Creates a paired timeline.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param id Id of this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: BadgeContract<TX>);
    }
    export interface Options<TX> {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<InfoBalloon.Contract>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
    }
    export class ViewModel<TX> extends FxViewModelsControlsBase.ViewModel {
        /**
         * The collection of badges
         */
        badges: KnockoutObservableArray<BadgeContract<TX>>;
        /**
         * Height of the badges when displayed on the paired timeline
         */
        height: KnockoutObservableBase<number>;
        /**
         * Balloon for displaying badge information.
         */
        balloon: KnockoutObservableBase<InfoBalloon.Contract>;
        /**
         * Enables badges that will be displayed at top of paired timeline
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * An optional selectableSet to make the badges selectable
         */
        selectableSet: KnockoutObservableBase<MsPortalFx.ViewModels.SelectableSet<any, any>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<TX>);
        /**
         * Set the viewmodel's array of badges to the incoming badges. Optionally set up a selectableSet on these badges with the given callbacks.
         */
        pushAllBadges(newBadges: BadgeContract<TX>[], useSelectableSet?: boolean, itemMatchesSelection?: (item: BadgeContract<TX>, selection: any) => boolean, createSelection?: (item: BadgeContract<TX>) => any): void;
    }
}

// FILE: Fx\Controls\PasswordBox.d.ts
declare module "Fx/Controls/PasswordBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which value of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a password textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Determines when the control will update its value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Shows validation as a popup.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Aria label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specifies whether the reveal password button should be shown.
         * Ignored on Edge since it supports this intrinsically for password boxes.
         */
        showRevealPassword?: boolean;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * Password box control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a password box control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a password box control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Pill.d.ts
declare module "Fx/Controls/Pill" {
    import { BladeLink, ResourceLink, OnClickHandler } from "Fx/Composition";
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import * as Dialog from "Fx/Composition/Dialog";
    import { Image } from "Fx/Images";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Common edit contract properties.
     */
    export interface Editor {
        /**
         * The editor will render this content in edit mode.
         */
        content: Control | HtmlContent;
    }
    /**
     * Inline editor.
     *
     * @deprecated InlineEditor<T> has been deprecated. Please migrate to dialog editor or custom editor for this scenario.
     */
    export interface InlineEditor<T> extends Editor {
        /**
         * Callback function called when the editMode is ended.
         *
         * @returns new value for the pill.
         */
        onEditModeExited: () => T | Promise<T>;
    }
    /**
     * Dialog editor.
     */
    export interface DialogEditor<T> extends Editor {
        /**
         * Dialog title.
         */
        title: string | KnockoutObservableBase<string>;
        /**
         * Hides the title.
         * If the title is hidden, the title provided will still be used as the accessible label of the dialog.
         */
        hideTitle?: boolean;
        /**
         * Callback function called when the editMode is ended.
         *
         * @param result Obtained dialog result by clicking a dialog button or dismiss the dialog. When the user clicks outside of the dialog, the dialog will be dismissed and will return DialogButton.Cancel.
         * @returns new value for the pill.
         */
        onEditModeExited: (result: Dialog.DialogButton) => T | Promise<T>;
        /**
         * Buttons used for the dialog.
         */
        buttons: Dialog.CustomDialogButton[] | Dialog.DialogButtons;
        /**
         * Optional telemetry name that is used when the show dialog telemetry is logged
         */
        telemetryName?: string;
    }
    /**
     * Custom editor.
     */
    export interface CustomEditor {
        /**
         * Clickable invoked when the pill is clicked.
         * It supports a traditional callback, or a blade-reference based clickable.
         * The author has responsibility to manage the pill value to make changes.
         */
        onClick: OnClickHandler | BladeLink | ResourceLink;
    }
    /**
     * Options for configuring a pill control.
     */
    export interface Options<T> {
        /**
         * A function that generates the displaying text for key.
         */
        getKeyText: (value: T) => string;
        /**
         * A function that generates the displaying text for operator.
         */
        getOperatorText?: (value: T) => string;
        /**
         * A function that generates the displaying text for value.
         */
        getValueText: (value: T) => string;
        /**
         * The initial value of the pill.
         */
        value: T | KnockoutObservableBase<T>;
        /**
         * When the user clicks the pill the enter edit mode, this callback will be called to create editing controls.
         * The 'editorLifetime' reflects the time in edit mode and should be used when instantiating the control view models.
         */
        createEditor: (editorLifetime: MsPortalFx.Base.DisposableLifetimeManager) => InlineEditor<T> | DialogEditor<T> | CustomEditor | Promise<InlineEditor<T>> | Promise<DialogEditor<T>> | Promise<CustomEditor>;
        /**
         * Callback that fires when the pill is removed.
         */
        onRemoved?: (value: T) => void;
        /**
         * Show a remove button to allow users to remove the pill.
         */
        showRemoveButton?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show an icon on the left side of the pill.
         */
        icon?: Image | KnockoutObservableBase<Image>;
        /**
         * Enable "readOnly" mode that removes editable behavior from the pill.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates that whether the pill is in edit mode or not.
         */
        editMode?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Sanitized html string shown in the info balloon popup in readonly mode.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If true then this pill will not trigger the unsaved changes dialog, even after the user makes changes.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Aria label for pill.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Pill's disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Pill control contract.
     */
    export interface Contract<T> extends Control {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<T>;
        /**
         * Show a remove button to allow users to remove the pill.
         */
        readonly showRemoveButton: KnockoutObservableBase<boolean>;
        /**
         * Show an icon on the left side of the pill.
         */
        readonly icon: KnockoutObservableBase<Image>;
        /**
         * Enable "readOnly" mode that removes editable behavior from the pill.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Indicates that whether the pill is in edit mode or not.
         */
        readonly editMode: KnockoutObservableBase<boolean>;
        /**
         * Sanitized html string shown in the info balloon popup in readonly mode.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * Aria label for pill.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Pill's disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a pill control with inline edit mode contract.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Pill contract
     */
    export function create<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<T>): Contract<T>;
}

// FILE: Fx\Controls\PillCollection.d.ts
declare module "Fx/Controls/PillCollection" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import * as Pill from "Fx/Controls/Pill";
    import { FxElement } from "Fx/Composition";
    import { Image } from "Fx/Images";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export const enum Theme {
        /**
         * Theme for filters (default).
         */
        Filter = 1,
        /**
         * Theme for tags.
         */
        Tag = 2
    }
    /**
     * Options for configuring a pill collection control.
     */
    export interface Options {
        /**
         * The initial set of pills in the collection.
         */
        items: Pill.Contract<any>[] | KnockoutObservableArray<Pill.Contract<any>>;
        /**
         * Options for "add pill" button.
         */
        addition?: AdditionOptions;
        /**
         * Aria label for pill collection.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Pill collection's disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Pill collection's theme.
         */
        theme?: Theme;
        /**
         * Max number of items of pill to show.
         */
        maxVisibleItems?: number;
        /**
         * Show pills in multiple rows or truncate them when they exceeds a single row.
         */
        multipleRows?: boolean;
    }
    /**
     * Options for "add pill" button.
     */
    export interface AdditionOptions {
        /**
         * Enable the "add pill" button.
         */
        canAddPill?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Set this true to always show label or label will be hidden, if there is any items.
         */
        alwaysShowLabel?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon for "add pill" button. If not given, default icon will be used.
         */
        icon?: Image | KnockoutObservableBase<Image>;
        /**
         * Label for "add pill" button.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for "add pill" button.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * A function called when the user clicks "add pill" button.
         * Returns a pill viewModel that will be added to "items".
         * If nothing is returned, this callback becomes like simple onClick handler and the author has responsibility to manage the pill collection items to make changes.
         *
         * @param target The target FxElement of the "add pill" button.
         */
        addPill?: (target: FxElement) => Pill.Contract<any> | void;
    }
    export interface Addition {
        /**
         * Enable the "add pill" button.
         */
        readonly canAddPill: KnockoutObservableBase<boolean>;
        /**
         * Set this true to always show label or label will be hidden, if there is any items.
         */
        readonly alwaysShowLabel: KnockoutObservableBase<boolean>;
        /**
         * Icon for "add pill" button. If not given, default icon will be used.
         */
        readonly icon: KnockoutObservableBase<Image>;
        /**
         * Label for "add pill" button.
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for "add pill" button.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * The set of pills in the collection.
         */
        readonly items: KnockoutObservableArray<Pill.Contract<any>>;
        /**
         * Options for "add pill" button.
         */
        readonly addition: Addition;
        /**
         * Aria label for pill collection.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Pill collection's disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an Pill collection control contract.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a Pill collection contract
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\PricingControl.d.ts
declare module "Fx/Controls/PricingControl" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    export interface Options<TValue> {
        /**
         * Text of the Pricing control.
         */
        text?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * SubText of the Pricing control.
         */
        subText?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Barcolor in HEX.
         * If your color is not accessible in dark theme. You can use `.ext-pricing-control-border` in your css to add themeable colors instead of this.
         *
         * Example:
         *   .ext-pricing-control-border { border-color: blue }
         *   .ext-dark-mode .ext-pricing-control-border { border-color: red }
         */
        barColor?: string | KnockoutObservableBase<string>;
        /**
         * Link text.
         */
        linkText?: string | KnockoutObservableBase<string>;
        /**
         * Callback for when link is clicked.
         */
        onLinkClick?: Function;
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * The value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * Indicates that the control is in a loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * PricingControl view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * Text of the Pricing control.
         */
        readonly text: KnockoutObservableBase<string | HtmlContent>;
        /**
         * SubText of the Pricing control.
         */
        readonly subText: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Color of the Pricing control. Must be valid Hexadecimal.
         * Default is Green.
         */
        readonly barColor: KnockoutObservableBase<string>;
        /**
         * Link text.
         */
        readonly linkText: KnockoutObservableBase<string>;
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * Indicates that the control is in a loading state.
         */
        readonly loading: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an  Pricing Control view model.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Pricing Control.
     * @returns an Pricing Control viewmodel.
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\ProgressBar.d.ts
declare module "Fx/Controls/ProgressBar" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Status type of progress indicators
     */
    export const enum StatusType {
        /**
         * In progress style.
         */
        InProgress = 0,
        /**
         * Error style.
         */
        Error = 1,
        /**
         * Warning style.
         */
        Warning = 2,
        /**
         * Success style.
         */
        Success = 3,
        /**
         * Indeterminate style.
         */
        Indeterminate = 4
    }
    export interface Options {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * String/HtmlContent shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Value percentage of the current progress.
         */
        valuePercentage?: number | KnockoutObservableBase<number>;
        /**
         * Status of the progress indicator.
         */
        status?: StatusType | KnockoutObservableBase<StatusType>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Text for screen reader to describe this progress bar.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract extends Control {
        /**
         * The label of the control
         */
        readonly label: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        readonly infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        readonly infoBalloonAriaLabel: KnockoutObservableBase<string>;
        /**
         * Value percentage of the current progress.
         */
        readonly valuePercentage: KnockoutObservableBase<number>;
        /**
         * Status of the progress indicator.
         */
        readonly status: KnockoutObservableBase<StatusType>;
        /**
         * The disabled state of the control.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Text for screen reader to describe this progressbar
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a ProgressBar control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a ProgressBar viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\QuotaGauge.d.ts
declare module "Fx/Controls/QuotaGauge" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Warning shape.
     */
    export const enum ErrorWarningShape {
        /**
         * Default triangle warning/error.
         */
        Triangle = 0,
        /**
         * Circle warning/error.
         */
        Circle = 1
    }
    /**
     * Built-in sizes for QuotaGauge control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, height).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyLarge = 3,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 4,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 5,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 6,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 7
    }
    /**
     * Options for configuring a QuotaGauge control.
     */
    export interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle the css style for warning/error. True for triangle or false for circle.
         */
        errorWarningShape?: ErrorWarningShape | KnockoutObservableBase<ErrorWarningShape>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * The current tracking instance value. For example, CPU/Memory/Website instance.
         */
        instance?: number | KnockoutObservableBase<number>;
        /**
         * The quota for current instance.
         */
        instanceQuota?: number | KnockoutObservableBase<number>;
        /**
         * The total value of all instances. For example, all CPU/Memory/Websites usage.
         */
        total?: number | KnockoutObservableBase<number>;
        /**
         * The quota for total value of all instances.
         */
        totalQuota?: number | KnockoutObservableBase<number>;
        /**
         * Show center content.
         */
        showCenter?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        omitTotal?: boolean | KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        noQuota?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * Total caption value display formatter. The following formatter arguments will be substituted with respective values when displaying the total caption,
         *  {0} is instance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         */
        totalCaptionFormat?: string | KnockoutObservableBase<string>;
        /**
         * Center Text value display format. The following formatter arguments will be substituted with respective values when displaying the center text,
         *  {0} is instance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        valueDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        hideTick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * QuotaGauge control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle the css style for warning/error. True for triangle or false for circle.
         */
        readonly errorWarningShape: KnockoutObservableBase<ErrorWarningShape>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * The current tracking instance value. For example, CPU/Memory/Website instance.
         */
        readonly instance: KnockoutObservableBase<number>;
        /**
         * The quota for current instance.
         */
        readonly instanceQuota: KnockoutObservableBase<number>;
        /**
         * The total value of all instances. For example, all CPU/Memory/Websites usage.
         */
        readonly total: KnockoutObservableBase<number>;
        /**
         * The quota for total value of all instances.
         */
        readonly totalQuota: KnockoutObservableBase<number>;
        /**
         * Total caption value display formatter. The following formatter arguments will be substituted with respective values when displaying the total caption,
         *  {0} is instance
         *  {1} is instanceQuota,
         *  {2} is total
         *  {3} is totalQuota
         */
        readonly totalCaption: KnockoutObservableBase<string>;
        /**
         * Show center content.
         */
        readonly showCenter: KnockoutObservableBase<boolean>;
        /**
         * Omit Total bar.
         */
        readonly omitTotal: KnockoutObservableBase<boolean>;
        /**
         * No quota verification.
         */
        readonly noQuota: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        readonly maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         *  Center text unit.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * Center Text value display format. The following formatter arguments will be substituted with respective values when displaying the center text,
         *  {0} is instance value
         *  {1} is instance Quota,
         *  {2} is total
         *  {3} is total Quota
         *  {4} is maximum
         */
        readonly valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Hide the current tick mark.
         */
        readonly hideTick: KnockoutObservableBase<boolean>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a QuotaGauge control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a QuotaGauge control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\RadioButtons.d.ts
declare module "Fx/Controls/RadioButtons" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a radio item.
     */
    export interface Item<TValue> {
        /**
         * Content to render for the item.
         */
        text: string | HtmlContent;
        /**
         * Description content to render for the item.
         */
        description?: string | HtmlContent;
        /**
         * Value of your item.
         */
        value: TValue;
        /**
         * Disabled state.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    /**
     * Options for configuring a radio button control
     */
    export interface Options<TValue> {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, each button will each appear on their own line.  Defaults to false.
         * Effective when displayStyle is set to Vertical. Has no effect when displayStyle is set to Horizontal.
         */
        singleItemPerLine?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The list of items of the radio buttons
         */
        items?: Array<Item<TValue>> | KnockoutObservableArray<Item<TValue>>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: TValue | KnockoutObservableBase<TValue>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Optional alternate text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Display style for the radio button control. Defaults to Vertical if not set.
         */
        displayStyle?: DisplayStyle | KnockoutObservableBase<DisplayStyle>;
    }
    /**
     * Display style options for the radio button control.
     */
    export const enum DisplayStyle {
        /**
         * Default display style. Vertical format with radio buttons on the left and text on the right.
         */
        Vertical = 0,
        /**
         * Horizontal format with text above radio buttons.
         */
        Horizontal = 1
    }
    /**
     * RadioButtons control view model
     */
    export interface Contract<TValue> extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * The list of items of the radio button
         */
        readonly items: KnockoutObservableArray<Item<TValue>>;
    }
    /**
     * Creates a radio buttons control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a radio buttons control viewmodel
     */
    export function create<TValue>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TValue>): Contract<TValue>;
}

// FILE: Fx\Controls\RangeSelection.d.ts
declare module "Fx/Controls/RangeSelection" {
    import FxControls = MsPortalFx.ViewModels.Controls;
    export const enum LabelPosition {
        /**
         * Range selection labels will be oriented on the inside of the selection range
         */
        Inside = 0,
        /**
         * Range selection labels will be oriented on the outside of the selection range
         */
        Outside = 1
    }
    export interface Range<T> {
        /**
         * The beginning of the range selection.  May be null to indicate open beginning of range.
         */
        start: T;
        /**
         * The end of the range selection.  May be null to indicate open ended range.
         */
        end: T;
    }
    export interface Options<T> {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition?: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection?: KnockoutObservableBase<Range<T>>;
    }
    export class ViewModel<T> extends FxControls.Base.ViewModel {
        /**
         * Specifies position of range selection labels.
         */
        labelPosition: KnockoutObservableBase<LabelPosition>;
        /**
         * The range selected if enableRangeSelection was enabled.
         */
        rangeSelection: KnockoutObservableBase<Range<T>>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options<T>);
    }
}

// FILE: Fx\Controls\RangeSlider.d.ts
declare module "Fx/Controls/RangeSlider" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import { SliderLegends } from "Fx/Controls/Slider";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a range slider control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria label of the control, for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Legends for the slider.
         */
        legends?: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        hideTextbox?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Options for configuring a simple range slider control
     */
    export interface SimpleRangeSliderOptions extends Options {
        /**
         * Minimum value of the range slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
    }
    /**
     * Options for configuring a custom range slider control
     */
    export interface CustomRangeSliderOptions extends Options {
        /**
         * Custom range slider clickstop values.
         */
        customValues: Array<number> | KnockoutObservableBase<Array<number>>;
    }
    /**
     * RangeSlider control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * Start value of the range.
         */
        readonly start: KnockoutObservableBase<number>;
        /**
         * End value of the range.
         */
        readonly end: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        readonly showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Legends for the slider.
         */
        readonly legends: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        readonly hideTextbox: KnockoutObservableBase<boolean>;
    }
    /**
     * RangeSlider control view model for simple values
     */
    export interface SimpleRangeSliderContract extends Contract {
        /**
         * Minimum value of the range slider.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        readonly step: KnockoutObservableBase<number>;
    }
    /**
     * RangeSlider control view model for custom values
     */
    export interface CustomRangeSliderContract extends Contract {
        /**
         * Custom slider clickstop values.
         */
        readonly customValues: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a range slider control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a range slider control viewmodel
     */
    export function createSimpleRangeSlider(lifetime: MsPortalFx.Base.LifetimeManager, options?: SimpleRangeSliderOptions): SimpleRangeSliderContract;
    /**
     * Creates a range slider control viewmodel with custom values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a range slider control viewmodel
     */
    export function createCustomRangeSlider(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomRangeSliderOptions): CustomRangeSliderContract;
}

// FILE: Fx\Controls\Recommendations.d.ts
declare module "Fx/Controls/Recommendations" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options supplied to the Recommendations control.
     */
    export interface Options {
        /**
         * The ARM resource id.
         */
        readonly resourceId: string;
    }
    /**
     *  View model contract for the Recommendations control.
     */
    export interface Contract extends Control {
        /**
         * The total number of recommendations.
         */
        readonly totalRecommendationCount: KnockoutReadOnlyObservableBase<number>;
    }
    /**
     * Creates a Recommendations view model.
     *
     *  @param lifetime The lifetime of the control.
     *  @param options Options that modify the appearance and behavior of the control.
     *  @returns a Recommendations view model.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\ResourceGroupDropDown.d.ts
declare module "Fx/Controls/ResourceGroupDropDown" {
    import { ResourceGroup as BaseResourceGroup, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    /**
     * The modes possible for the dropdown
     */
    export import Mode = BaseResourceGroup.Mode;
    /**
     * The mode of the value returned by the control
     */
    export import SelectedMode = BaseResourceGroup.SelectedMode;
    /**
     * The contract for the values returned by the resource group dropdown
     * It contains the ARM Value and a flag for if you are in create mode
     */
    export import Value = BaseResourceGroup.Value;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Value>;
    /**
     * The contract for options to create the resource group drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseResourceGroup.Options<THtmlKeyMap>;
    /**
     * The contract for the resource group dropdown
     */
    export interface Contract extends BaseResourceGroup.Contract {
    }
    /**
     * This creates a resource group dropdown control.
     *
     * @param container The container associated with the part or blade.
     * @param options The resource group dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: MsPortalFx.Base.LifetimeManager, options: Options<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\ScatterChart.d.ts
declare module "Fx/Controls/ScatterChart" {
    import { Control } from "Fx/Controls/ControlsBase";
    import * as ChartBase from "Fx/Controls/ChartBase";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export import Pattern = ChartBase.HatchingPattern;
    export import Axis = ChartBase.Axis;
    export import AxisOptions = ChartBase.AxisOptions;
    export import Scale = ChartBase.Scale;
    export import MetricRuleAggregationType = ChartBase.MetricRuleAggregationType;
    export import MetricRuleAggregationScope = ChartBase.MetricRuleAggregationScope;
    export import MetricRuleScope = ChartBase.MetricRuleScope;
    export import Metric = ChartBase.Metric;
    export import MetricRule = ChartBase.MetricRule;
    export import ChartItem = ChartBase.ChartItem;
    export import SeriesSelection = ChartBase.SeriesSelection;
    export import EventData = ChartBase.EventData;
    export { FxChartColorClass };
    /**
     * This base interface defines how a series should be rendered on the chart.
     */
    export interface SeriesViewOptions {
        /**
         * The display name of the series.
         * The display name will be shown in the legend if seriesName is not provided or autogenerated.
         */
        readonly displayName?: string;
        /**
         * The name of the "CSS" class for the series.
         * The css class will be used to override the default colors.
         */
        readonly cssClass?: string | FxChartColorClass;
        /**
         * Defines the radius of circles.
         * By default 2px radius will be used to show the data point circle.
         */
        readonly radius?: number;
        /**
         * Indicates if the series is selectable.
         * By default, the data point circle is selectable and selectable styling is shown. To disallow selecting the data point circle, set selectable to false.
         */
        readonly selectable?: boolean;
        /**
         * Indicates if the series is hoverable.
         * By default, the data point is hoverable and hover styling is shown. To disallow hover behavior, set hoverable to false.
         */
        readonly hoverable?: boolean;
        /**
         * Indicates if the series is hidden from the legend
         */
        readonly hideFromLegend?: boolean;
    }
    /**
     * Defines the contract for series data and its display options.
     */
    export interface Series<TX, TY> {
        /**
         * The name of the series.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The data source for the chart.
         */
        readonly values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Optional view options for customizing the display of each series.
         */
        readonly viewOptions?: KnockoutObservableBase<SeriesViewOptions>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Users can optionally provide event handler callbacks for all or subset of events.
     */
    export interface ChartEvents<TX, TY> {
        /**
         * Event handler for mouse click on the plot area.
         *
         * Event callback.
         *
         * @param x The pixel value of x coordinate
         * @param y The pixel value of y coordinate.
         * @param xValue The x axis value at the x coordinate.
         * @param yValue The y axis value at the y coordinate.
         */
        readonly plotAreaClick?: (x: number, y: number, xValue: TX, yValue: TY) => void;
        /**
         * Event handler for click on a point.
         *
         * Event callback.
         *
         * @param data EventData with clicked seriesName and the x, y value to the clicked point.
         */
        readonly pointClick?: (data: EventData<TX, TY>) => void;
    }
    /**
     * Options for configuring a ScatterChart control.
     */
    export interface Options<TX, TY> {
        /**
         * Provide an array of data series.
         */
        readonly series?: Series<TX, TY>[] | KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis?: AxisOptions<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis?: AxisOptions<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules?: MetricRule[] | KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth?: number | KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events?: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the scatter chart, will be utilized by screen-reader.
         */
        readonly ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * ScatterChart control view model contract.
     */
    export interface Contract<TX, TY> extends Control {
        /**
         * Provide an array of data series.
         */
        readonly series: KnockoutObservableArray<Series<TX, TY>>;
        /**
         * The X-axis of the chart.
         */
        readonly xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart.
         */
        readonly yAxis: Axis<TY>;
        /**
         * Metric rules used by the control.
         */
        readonly metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Show/hide the metrics.
         */
        readonly showMetrics: KnockoutObservableBase<boolean>;
        /**
         * Show/hide the legend.
         */
        readonly showLegend: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        readonly legendWidth: KnockoutObservableBase<number>;
        /**
         * Optionally add chart event handlers.
         */
        readonly events: ChartEvents<TX, TY>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        readonly noData: KnockoutObservableBase<boolean>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         */
        readonly noDataMessage: KnockoutObservableBase<string>;
        /**
         * Specifies selections on the chart.
         */
        readonly seriesSelections: KnockoutReadOnlyObservable<SeriesSelection<TX, TY>[]>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the scatter chart, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
        /**
         * Method to programmatically set the chart selections which will clear existing seriesSelections
         * and set the provided selections. Set [] to clear the current selections.
         *
         * @param seriesSelections Array of SeriesSelections to be set.
         * @returns A promise to indicate completion.
         */
        setSeriesSelections(seriesSelections: SeriesSelection<TX, TY>[]): Promise<void>;
    }
    /**
     * Creates a ScatterChart control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a ScatterChart control viewmodel
     */
    export function create<TX, TY>(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options<TX, TY>): Contract<TX, TY>;
}

// FILE: Fx\Controls\SearchBox.d.ts
declare module "Fx/Controls/SearchBox" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options for configuring a SearchBox control
     */
    export interface Options {
        /**
         * The default placeholder text.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * The delay after you finish typing to trigger the update callback in milliseconds.  Defaults to 400 ms
         */
        valueUpdateTimeout?: number;
        /**
         * The update callback. Called when the user types in the search box (after stopping typing for the duration specified as 'valueUpdateTimeout').
         * Screen readers will voice the number of entries returned by this callback (e.g. '<N> results for <keyword>').
         * Only by supplying this 'update' property will the FX cause screen readers to operate in this expected way.
         *
         * @param value is the value typed in by the user.
         * @returns the values shown in the dropdown.
         */
        update: (value: string) => Promise<string[]>;
        /**
         * The submit callback.  Called when the user selects an item, or hits enter.
         *
         * @param value is the value of the selected item.
         * @param typedValue is the value that the user typed in (this will match value when the user hits enter).
         * @returns a promise that when resolved will take the control out of the busy state.
         */
        submit?: (value: string, typedValue: string) => Promise<boolean>;
        /**
         * Disabled state of the search box.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Hide suggestion box.
         */
        hideSuggestions?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Aria label for search box.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Maximum number of results shown.  Defaults to 5.
         */
        resultLimit?: number | KnockoutObservableBase<number>;
    }
    /**
     * SearchBox control view model
     */
    export interface Contract extends Control {
        /**
         * The placeholder text that is shown when the user has not entered a value.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * Disabled state of the search box.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Hide suggestion box.
         */
        readonly hideSuggestions: KnockoutObservableBase<boolean>;
        /**
         * Aria label for search box.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Maximum number of results shown.
         */
        readonly resultLimit: KnockoutObservableBase<number>;
        /**
         * Programmatically updates the internal SearchBox value as if the end-user typed it in.
         * This triggers updates and/or submits callbacks.
         */
        updateValue(newValue: string): void;
        /**
         * A helper function for that removes all items, closes dropdown & clears textbox.
         *
         * @returns A promise that is resolved when the reset has been completed.
         */
        reset(): Promise<void>;
    }
    /**
     * Creates a SearchBox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a SearchBox viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Section.d.ts
declare module "Fx/Controls/Section" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a form section
     */
    export interface Options {
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sections, controls & HtmlContent to nest within the section.
         */
        children?: any[] | KnockoutObservableArray<any>;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The minimum height of the section in pixels.  Use this to reduce jumpiness in forms.
         */
        minHeight?: number;
        /**
         * Labels will appear to the left of child controls when this is set to true.
         * Labels are set to the size of the largest label in a consecutive set (unless leftLabelWidth is set).
         *
         * If smartAlignLabels is set to true, this has no effect.
         */
        leftLabelPosition?: boolean;
        /**
         * The width of the left label in px.
         * Setting this property implies leftLabelPosition = true.
         *
         * If smartAlignLabels is set to true, this has no effect.
         */
        leftLabelWidth?: number;
        /**
         * Custom css classes to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Align labels by available size of the blade. (left or above the control).
         */
        smartAlignLabel?: boolean;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        telemetryName?: string;
    }
    /**
     * Section view model
     */
    export interface Contract extends Control {
        /**
         * The sections, controls & HtmlContent to nest within the section.
         */
        readonly children: KnockoutObservableArray<any>;
        /**
         * Changes the section state to disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * The dirty state of the control.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The name of the section.
         * Can be an HTML template and optional view model. See HtmlContent interface in Fx/Controls/ControlsBase
         * This will be displayed as a tab header if the section is inside a tab control.
         *
         * To track telemetry across locales, please use telemetryName for a consistent identifier.
         */
        readonly name: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Custom css classes to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Name used to identify tab for telemetry purposes. Do not localize.
         * Used for tracking telemetry across locales.
         */
        readonly telemetryName: KnockoutObservableBase<string>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Promise<boolean>;
        /**
         * Clears validation on the field.
         *
         * @returns A promise that is resolved when the validation has been cleared.
         */
        readonly clearValidation: () => Promise<void>;
    }
    /**
     * Creates a section view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\SequentialDataGrid.d.ts
declare module "Fx/Controls/SequentialDataGrid" {
    import { Control, HtmlContent } from "Fx/Controls/ControlsBase";
    import { SelectionMode, SortDirection } from "Fx/Controls/GridBase";
    import * as ToolbarControl from "Fx/Controls/Toolbar";
    import { BladeReference, FxElement } from "Fx/Composition";
    import ToolbarItemContract = ToolbarControl.ToolbarItems.ToolbarItemContract;
    export { 
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    HtmlContent, 
    /**
     * SequentialDataGrid selection mode.
     */
    SelectionMode, 
    /**
     * SequentialDataGrid sort direction.
     */
    SortDirection, };
    /**
     * SequentialDataGrid column sort order.
     */
    export interface SortOrder {
        /**
         * The column id.
         */
        id: string;
        /**
         * The sort direction.
         */
        direction: SortDirection;
    }
    /**
     * SequentialDataGrid cell definition.
     */
    export interface CellDefinitionBase<TItem> {
        /**
         * The accessibility label for the cell.
         */
        ariaLabel?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
    }
    /**
     * Text cell definition.
     */
    export interface TextCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies the text to display in the cell.
         *
         * @param item The data item,
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A string or a value that is convertible to string or an observable containing the value.
         */
        text: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * Text column definition.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinition<TItem> extends TextColumnDefinitionOptions<TItem> {
        /**
         * Text column definition type.
         * A column that displays text in each cell.
         */
        type: "Text";
    }
    /**
     * Text column definition options.
     * Defines a column that displays text in each cell.
     */
    export interface TextColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A Text cell definition.
         */
        cell: TextCellDefinition<TItem>;
    }
    /**
     * Template cell definition.
     */
    export interface TemplateCellDefinition<TItem, TViewModel = any> extends CellDefinitionBase<TItem> {
        /**
         * The template used for all cells in the column.
         */
        template: string;
        /**
         * Supplies a viewmodel to bind with the template.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @param grid The grid.
         * @returns A view model or an observable containing the view model.
         */
        viewModel: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem>) => TViewModel | KnockoutReadOnlyObservableBase<TViewModel>;
    }
    /**
     * Template column definition.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinition<TItem> extends TemplateColumnDefinitionOptions<TItem, any> {
        /**
         * Template column definition type.
         * A column that binds a view model to an HTML template in each cell.
         */
        type: "Template";
    }
    /**
     * Template column definition options.
     * Defines a column that binds a view model to an HTML template in each cell.
     */
    export interface TemplateColumnDefinitionOptions<TItem, TViewModel = any> extends ColumnDefinitionBase<TItem> {
        /**
         * A Template cell definition.
         */
        cell: TemplateCellDefinition<TItem, TViewModel>;
    }
    /**
     * UriLink definition.
     */
    export interface UriLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the uri.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The link target.
         */
        target?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The link text.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
        /**
         * The URI to navigate to when the link is clicked.
         * A non-null URI will render a clickable link.
         * A null URI will render plain text that is not clickable.
         */
        uri: string | KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * UriLink cell definition.
     */
    export interface UriLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a UriLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A UriLink definition.
         */
        uriLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => UriLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * UriLink column definition.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinition<TItem> extends UriLinkColumnDefinitionOptions<TItem> {
        /**
         * UriLink column definition type.
         * A column that displays a URI link in each cell.
         */
        type: "UriLink";
    }
    /**
     * UriLink column definition options.
     * Defines a column that displays a URI link in each cell.
     */
    export interface UriLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A UriLink cell definition.
         */
        cell: UriLinkCellDefinition<TItem>;
    }
    /**
     * BladeLink definition.
     */
    export interface BladeLink {
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link return null for the bladeReference.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The blade reference for the link.
         * A non-null blade reference will render a clickable link.
         * A null blade reference will render plain text that is not clickable.
         * A blade reference that uses object-typed blade parameters or is too long will result in an href of "#" instead of a deep link.
         */
        bladeReference: BladeReference<unknown> | KnockoutReadOnlyObservableBase<BladeReference<unknown>>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * Text to display with link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * BladeLink cell definition.
     */
    export interface BladeLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a BladeLink definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A BladeLink definition.
         */
        bladeLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => BladeLink;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * BladeLink column definition.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinition<TItem> extends BladeLinkColumnDefinitionOptions<TItem> {
        /**
         * BladeLink column definition type.
         * A column that displays a link that opens a blade in each cell.
         */
        type: "BladeLink";
    }
    /**
     * BladeLink column definition options.
     * Defines a column that displays a link that opens a blade in each cell.
     */
    export interface BladeLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A BladeLink cell definition.
         */
        cell: BladeLinkCellDefinition<TItem>;
    }
    /**
     * ResourceLink definition.
     */
    export interface ResourceLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick instead.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The resource id to link to.
         * A non-null resource id will render a clickable link unless canClick is false.
         * A null resource id will render plain text that is not clickable.
         */
        resourceId: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * The resource kind to link to.
         */
        resourceKind?: string | KnockoutReadOnlyObservableBase<string>;
        /**
         * Overrides the default text determined from the resource id.
         *
         * You can use the getDisplayName utility function to generate a name that utilizes a hidden-title tag.
         *
         * text: ResourceName.getDisplayName({
         *     id: getResourceId(item),
         *     tags: getResourceTags(item),
         * }),
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * ResourceLink cell definition.
     */
    export interface ResourceLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Supplies a resource link definition to display in a cell.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A resource link definition.
         */
        resourceLink: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => ResourceLink;
        /**
         * Indicates to display the resource icon in the link.
         * Defaults to true.
         */
        showIcon?: boolean;
        /**
         * Indicates to display the preview badge on the resource icon in the link.
         * Defaults to true.
         * For preview blades you may set this to false if you find it too noisy to show these on every icon.
         * If you do hide the badging for a preview blade make sure the blade itself indicates it is preview.
         */
        showPreview?: boolean;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * ResourceLink column definition.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinition<TItem> extends ResourceLinkColumnDefinitionOptions<TItem> {
        /**
         * ResourceLink column definition type.
         * A column that displays a link that opens a resource in each cell.
         */
        type: "ResourceLink";
    }
    /**
     * ResourceLink column definition options.
     * Defines a column that displays a link that opens a resource in each cell.
     */
    export interface ResourceLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A ResourceLink cell definition.
         */
        cell: ResourceLinkCellDefinition<TItem>;
    }
    /**
     * CustomLink definition.
     */
    export interface CustomLink {
        /**
         * Indicates if the link can be clicked.
         * The default is true.
         * Set to false to display the link as text that is not clickable.
         */
        canClick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Disables the link.
         * If you want the link to be displayed as text instead of a disabled link use canClick.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Icon to display with link.
         */
        icon?: MsPortalFx.Base.Image | KnockoutReadOnlyObservableBase<MsPortalFx.Base.Image>;
        /**
         * The text to display in the link.
         */
        text?: string | ConvertsToString | KnockoutReadOnlyObservableBase<string | ConvertsToString>;
    }
    /**
     * CustomLink cell definition.
     */
    export interface CustomLinkCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Changes the role of the link to "button".
         * By default the role will be a "link" and the user expects the link to navigate using openBlade or openContextPane.
         * If your onClick does not navigate you should change the role of the link to "button".
         * However, you may want to consider alteratives such as supplyButtonCommands which is designed to add command buttons to grid rows.
         */
        buttonRole?: boolean;
        /**
         * Supplies a CustomLink definition to display a custom link in a cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         *
         * @param item The data item.
         * @param cellLifetime The cell lifetime manager.
         * @param row The row containing the cell.
         * @returns A CustomLink definition.
         */
        customLink?: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => CustomLink;
        /**
         * Callback to provide custom behavior for clicking on the link.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         * If your onClick does not navigate you should set buttonRole to true.
         *
         * @param item The data item.
         * @param row The row containing the data item.
         * @param target The framework element that was clicked on.
         */
        onClick?: (item: TItem, row: Row<TItem>, target: FxElement) => void;
        /**
         * Identifier to use in telemetry logging.
         */
        telemetryName?: string;
    }
    /**
     * CustomLink column definition.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinition<TItem> extends CustomLinkColumnDefinitionOptions<TItem> {
        /**
         * CustomLink column definition type.
         * A column that displays a custom link in each cell.
         * Only use for exceptional cases where you do not require browser behaviors like
         * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
         * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
         * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
         */
        type: "CustomLink";
    }
    /**
     * CustomLink column definition options.
     * Defines a column that displays a custom link in each cell.
     */
    export interface CustomLinkColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A CustomLink cell definition.
         */
        cell: CustomLinkCellDefinition<TItem>;
    }
    /**
     * TagList cell definition.
     */
    export interface TagListCellDefinition<TItem> extends CellDefinitionBase<TItem> {
        /**
         * Notification when an item tag has been clicked.
         *
         * @param item The item being clicked.
         * @param tagIndex The index of the tag being clicked.
         */
        onClick?: (item: TItem, tagIndex: number) => void;
        /**
         * Supplies the tags to display in a cell.
         *
         * @param lifetime The cell lifetime.
         * @param item The item to get tags for.
         * @param row The row containing the cell.
         * @returns The tags or an observable containing the tags.
         */
        tags: (item: TItem, cellLifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>) => string[] | KnockoutReadOnlyObservableBase<string[]>;
    }
    /**
     * TagList column definition.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinition<TItem> extends TagListColumnDefinitionOptions<TItem> {
        /**
         * TagList column definition type.
         * A TagList column displays a list of strings as bubbled text in a cell.
         */
        type: "TagList";
    }
    /**
     * TagList column definition options.
     * A TagList column displays a list of strings as bubbled text in a cell.
     */
    export interface TagListColumnDefinitionOptions<TItem> extends ColumnDefinitionBase<TItem> {
        /**
         * A TagList cell definition.
         */
        cell: TagListCellDefinition<TItem>;
    }
    /**
     * SequentialDataGrid data node.
     */
    export interface DataNode<TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The unique id.
         * If the object identity of your items is changing this is required to allow
         * the grid to preserve selection and other UI state across refreshes.
         * Can be set to null if you do not have an identifier or do not care about preserving UI state.
         */
        id: TId;
        /**
         * The data item.
         */
        item: TItem;
        /**
         * The child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the child nodes when the children property is not set.
         * Allows for delayed loading of child items.
         *
         * @param parentNode The parent node.
         * @returns The child nodes or a promise for the child nodes.
         */
        getChildren?: (parentNode: DataNode<TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * SequentialDataGrid group data node.
     * A group node is a parent node for all the children in the group.
     * A group node creates a group row with a single cell spanning the row to contains the group header.
     */
    export interface GroupNode<TGroup, TItem, TId extends string | ConvertsToString = string | ConvertsToString> {
        /**
         * The group unique id.
         */
        id: TId;
        /**
         * The group data item.
         */
        group: TGroup;
        /**
         * The group child nodes.
         */
        children?: DataNode<TItem, TId>[];
        /**
         * Gets the group child nodes when the children property is not set.
         * Allows for asynchronous loading of group items.
         *
         * @param parentNode The parent node.
         * @returns The group child nodes or a promise for the group child nodes.
         */
        getChildren?: (parentNode: GroupNode<TGroup, TItem, TId>) => DataNode<TItem, TId>[] | Promise<DataNode<TItem, TId>[]>;
    }
    /**
     * Query parameters for the callback data source.
     */
    export interface CallbackDataSourceParams<TParams = any> {
        /**
         * Custom query parameters for the datasource.
         */
        params: TParams;
        /**
         * Indicates if the data source has been reset.
         * The data source may return uncached data in this case.
         */
        reset: boolean;
        /**
         * The requested sort order to return the data in.
         */
        sortOrder: SortOrder[];
        /**
         * The continuation token for sequential navigation.
         * The token is undefined or null for first request and when navigation is reset.
         */
        token?: any;
    }
    /**
     * Result to return from the callback data source.
     */
    export interface CallbackDataSourceResult<TItem, TGroup = any> {
        /**
         * The data nodes for the requested page.
         */
        nodes: DataNode<TItem>[] | GroupNode<TGroup, TItem, any>[];
        /**
         * The continuation token for the next request.
         * Leave undefined or null when the end of the sequential enumeration is reached.
         */
        token?: any;
    }
    /**
     * SequentialDataGrid callback data source.
     */
    export interface CallbackDataSource<TItem, TGroup = any, TParams = any> {
        /**
         * Callback to get the data items.
         *
         * @param queryParams Query parameters such as sort order for making the correct query.
         * @returns The data result or a promise for the result.
         */
        (queryParams: CallbackDataSourceParams<TParams>): CallbackDataSourceResult<TItem, TGroup> | Promise<CallbackDataSourceResult<TItem, TGroup>>;
    }
    /**
     * Refresh options.
     */
    export interface RefreshOptions<TParams = any> {
        /**
         * Message to display and announce while refreshing.
         */
        message?: string;
        /**
         * Message to announce when refresh is completed.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
        /**
         * Custom query parameters to pass to the dataSource.
         */
        params?: TParams;
        /**
         * Indicates if the refresh should fully reset the grid data.
         * Typically used with a refresh command in the UI.
         * When reset the grid will clear selection and other UI state that may not apply with new data.
         * The data source should use this option to determine if cached data should be returned or not.
         * The default is false.
         */
        reset?: boolean;
        /**
         * Determines if the message and spinner are shown while the dataSource is called.
         * If true the dataSource will be called asyncronously after the message UI has been displayed.
         * If false the dataSource will be called synchronously and the message UI will not be shown.
         * If undefined (the default) the dataSource will be called synchronously and the message UI will only be shown if
         * the dataSouce implementation is async and yields execution.
         */
        showMessage?: boolean;
        /**
         * The requested sort order to return the data in.
         * This is an array of the column ids and sort directions in order of precedence.
         * When sortOrder is provided as an option it is passed to the dataSource.
         * When sortOrder is not provided the sortOrder is constructed from the column collection using the column id and sortDirection.
         * If sorting is disabled for the grid this option will have no effect.
         * The current sortOrder can also be accessed with grid.sorting.sortOrder.
         */
        sortOrder?: SortOrder[];
    }
    /**
     * SequentialDataGrid column header definition.
     * The ColumnHeaderDefinition contains properties that are used to create a ColumnHeader
     * when constructing the grid or adding dynamic columns via grid.columnDefinitions.
     */
    export interface ColumnHeaderDefinition {
        /**
         * Aria label for the header.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column header text will be bold.
         * The default is determined by portal styling which can change.
         */
        bold?: boolean;
        /**
         * Content for the header.
         * The content can be a string, HTML content, or an observable that returns a string or HTML content.
         */
        content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Indicates if the column header text will be in upper case.
         * The default is determined by portal styling which can change.
         */
        upperCase?: boolean;
    }
    /**
     * SequentialDataGrid column header.
     * Accessed by grid.columns()[index].header or grid.columns.get(id).header.
     */
    export interface ColumnHeader {
        /**
         * Aria label for the header.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Content for the header.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
    }
    /**
     * SequentialDataGrid cell definition.
     * The CellDefinition contains properties that are used to create a Cell.
     */
    export type CellDefinition<TItem> = BladeLinkCellDefinition<TItem> | CustomLinkCellDefinition<TItem> | ResourceLinkCellDefinition<TItem> | TagListCellDefinition<TItem> | TemplateCellDefinition<TItem> | TextCellDefinition<TItem> | UriLinkCellDefinition<TItem>;
    /**
     * SequentialDataGrid column definition.
     * The ColumnDefinition contains properties that are used to create a Column.
     */
    export type ColumnDefinition<TItem> = BladeLinkColumnDefinition<TItem> | CustomLinkColumnDefinition<TItem> | ResourceLinkColumnDefinition<TItem> | TagListColumnDefinition<TItem> | TemplateColumnDefinition<TItem> | TextColumnDefinition<TItem> | UriLinkColumnDefinition<TItem>;
    /**
     * SequentialDataGrid column definition common properties.
     */
    export interface ColumnDefinitionBase<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         * Defaults to true.
         */
        canResize?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         * Defaults to false.
         * When set to true the dataSource must implement sorting for it to work.
         */
        canSort?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The column header definition or text content.
         * For simple cases this can be a string.
         * To set additional column header properties provide a column header definition.
         */
        header?: string | ColumnHeaderDefinition;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        id?: string;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Sort direction of the column.
         * Defaults to unsorted.
         */
        sortDirection?: SortDirection | KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        width?: string | KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         * Default is true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid column.
     * Part of the SequentialDataGrid object model.
     * Accessed by grid.columns.
     */
    export interface Column<TItem> {
        /**
         * Indicates if the column width is resizable or fixed.
         */
        readonly canResize: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the column is sortable or not.
         */
        readonly canSort: KnockoutObservableBase<boolean>;
        /**
         * The column header.
         */
        readonly header: ColumnHeader;
        /**
         * The column identifier.
         * Each column requires a unique identifier.
         * If not provided a default one is created.
         * The id can also be used to access a cell row.cells.get(column.id).
         */
        readonly id: string;
        /**
         * Sort direction of the column.
         */
        readonly sortDirection: KnockoutObservableBase<SortDirection>;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         */
        readonly width: KnockoutObservableBase<string>;
        /**
         * Indicates if the column is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid column collection.
     */
    export interface ColumnCollection<TItem> extends KnockoutReadOnlyObservableArray<Column<TItem>> {
        /**
         * Adds columns to the grid.
         * The columns are created from the supplied column definitions and inserted.
         *
         * @param columnDefinitions Array of column definitions create columns from.
         * @param index The index to insert the new columns in the columns collection.  If not specified the columns are added to the end.
         */
        add(columsDefinitions: ColumnDefinition<TItem>[], index?: number): void;
        /**
         * Gets a column by column id.
         *
         * @param columnId The id of the column.
         * @returns The indicated column.
         */
        get(columnId: string): Column<TItem>;
        /**
         * Removes columns from the grid.
         *
         * @param ids The column ids of the columns to remove from the grid.
         * @returns The original column definitions used to create the columns.
         */
        remove(ids: string[]): ColumnDefinition<TItem>[];
        /**
         * Removes all columns from the grid.
         *
         * @returns The original column definitions used to create the columns.
         */
        removeAll(): ColumnDefinition<TItem>[];
    }
    /**
     * SequentialDataGrid cell.
     * Part of the SequentialDataGrid object model.
     * Accessed by row.cells()[index] or row.cells.get(columnId).
     */
    export interface Cell<TItem> {
        /**
         * Indicates if the cell is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The aria label for the cell.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The cell column.
         */
        readonly column: Column<TItem>;
    }
    /**
     * SequentialDataGrid row options.
     * Used to initialize new rows.
     */
    export interface RowDefinition<TItem> {
        /**
         * Supplies the accessibility label for the row.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The accessibility label.
         */
        ariaLabel?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the row disabled state.
         *
         * @param item The data item for the row.
         * @param rowLifetime The lifetime manager for the row.
         * @returns The disabled state.
         */
        disabled?: (item: TItem, rowLifetime: MsPortalFx.Base.LifetimeManager) => boolean | KnockoutObservableBase<boolean>;
        /**
         * The row height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
    }
    /**
     * SequentialDataGrid cell collection.
     */
    export interface CellCollection<TItem> extends KnockoutReadOnlyObservableArray<Cell<TItem>> {
        /**
         * Gets a cell by column id.
         *
         * @param columnId The column id.
         * @returns The requested cell.
         */
        get(columnId: string): Cell<TItem>;
    }
    /**
     * SequentialDataGrid row.
     * Part of the SequentialDataGrid object model.
     */
    export interface Row<TItem> {
        /**
         * Indicates if the row is activated or not.
         */
        readonly activated: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The row accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The row cells.
         * A particular cell can be retrieved by column id cells.get(columnId).
         */
        readonly cells: CellCollection<TItem>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * The row disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the row is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row is hovered.
         */
        readonly hovered: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The data id.
         */
        readonly id: any;
        /**
         * The data item.
         */
        readonly item: TItem;
        /**
         * Indicates if the row is selected.
         */
        readonly selected: KnockoutReadOnlyObservable<boolean>;
    }
    /**
     * SequentialDataGrid row group definition.
     * Used to initialize new row groups.
     */
    export interface RowGroupDefinition<TGroup> {
        /**
         * Supplies the accessibility label for the row group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The accessibility label.
         */
        ariaLabel?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | KnockoutObservableBase<string>;
        /**
         * Supplies the content for the group.
         *
         * @param group The data item for the row group.
         * @param rowGroupLifetime The lifetime manager for the row group.
         * @returns The row group content label.
         */
        content?: (group: TGroup, rowGroupLifetime: MsPortalFx.Base.LifetimeManager) => string | HtmlContent | KnockoutObservableBase<string>;
    }
    /**
     * SequentialDataGrid row group.
     * Part of the SequentialDataGrid object model.
     */
    export interface RowGroup<TGroup, TItem> {
        /**
         * The row group accessibility label.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Child rows.
         */
        readonly children: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * Indicates if the row group is expanded.
         */
        readonly expanded: KnockoutReadOnlyObservable<boolean>;
        /**
         * Indicates if the row group is currently focused.
         */
        readonly focused: KnockoutReadOnlyObservable<boolean>;
        /**
         * The group.
         */
        readonly group: TGroup;
        /**
         * The data id.
         */
        readonly id: any;
    }
    /**
     * SequentialDataGrid header definition.
     */
    export interface HeaderDefinition {
        /**
         * The header height in pixels.
         * The default is determined by portal styling which can change.
         */
        height?: number;
        /**
         * Indicates if the header should be visible.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid header.
     * Part of the SequentialDataGrid object model.
     * Accessed by grid.header.
     */
    export interface Header {
        /**
         * Determines if the header is visible.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid focus options.
     */
    export interface FocusOptions<TItem, TGroup = any> {
        /**
         * Event handler for CellEnter event.
         *
         * @param cell The cell being entered.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onEnterCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowEnter event.
         *
         * @param row The row being entered.
         * @param grid The grid.
         */
        onEnterRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for CellExit event.
         *
         * @param cell The cell being exited.
         * @param row The row containing the cell.
         * @param grid The grid.
         */
        onExitCell?: (cell: Cell<TItem>, row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Event handler for RowExit event.
         *
         * @param row The row being exited.
         * @param grid The grid.
         */
        onExitRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * SequentialDataGrid focus contract.
     */
    export interface FocusContract<TItem, TGroup = any> {
        /**
         * The current cell.
         * This cell is the focused cell when the grid has focus.
         * When focus leaves the grid the current cell remains.
         * The current cell will be null when no cell contains the focus.
         */
        readonly currentCell: KnockoutReadOnlyObservable<Cell<TItem>>;
        /**
         * The current row.
         * This row is the focused row when the grid has focus.
         * When focus leaves the grid the current row remains.
         */
        readonly currentRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * The current row group.
         * This row group is the focused row group when the grid has focus.
         * When focus leaves the grid the current row group remains.
         */
        readonly currentRowGroup: KnockoutReadOnlyObservable<RowGroup<TGroup, TItem>>;
        /**
         * Moves the focus from the current row to the row below it if possible.
         *
         * @returns Indicates if the focus moved down.
         */
        moveDown(): boolean;
        /**
         * Moves the focus from the current row to the first row if possible.
         *
         * @returns Indicates if the focus moved to the first row.
         */
        moveFirst(): boolean;
        /**
         * Moves the focus from the current row to the last row if possible.
         *
         * @returns Indicates if the focus moved to the last row.
         */
        moveLast(): boolean;
        /**
         * Moves the focus from the current row to the specified row.
         * Makes the specified row the current row.
         * Focus will not change unless the grid already has focus.
         *
         * @param row The row to move to.
         * @returns Indicates if the focus moved.
         */
        moveToRow(row: Row<TItem>): boolean;
        /**
         * Moves the focus from the current row to the row above it if possible.
         *
         * @returns Indicates if the focus moved up.
         */
        moveUp(): boolean;
    }
    /**
     * SequentialDataGrid selection options.
     */
    export interface SelectionOptions<TItem, TGroup = any> {
        /**
         * Determines if all items can be selected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be selected at once.
         */
        canSelectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be selected.
         *
         * @param item The item to select.
         * @param grid The grid.
         * @returns Indicates if the item can be selected.
         */
        canSelectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if all items can be unselected at once.
         *
         * @param grid The grid.
         * @returns Indicates if all items can be unselected at once.
         */
        canUnselectAllItems?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a item can be unselected.
         *
         * @param item The item to unselect.
         * @param grid The grid.
         * @returns Indicates if the item can be unselected.
         */
        canUnselectItem?: (item: TItem, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Disables Ctrl+A or the select all checkbox from selecting all rows at once in multiple selection mode.
         */
        selectAllDisabled?: boolean;
        /**
         * Selection mode (defaults to Single).
         */
        selectionMode?: SelectionMode;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid selection state.
     */
    export interface SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
    }
    /**
     * SequentialDataGrid selection contract.
     */
    export interface SelectionContract<TItem> extends SelectionState<TItem> {
        /**
         * Indicates if all items are selected.
         */
        readonly allItemsSelected: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Indicates if all items can be selected.
         */
        readonly canSelectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be selected.
         *
         * @param item The item to select.
         * @returns Indicates if an item can be selected.
         */
        canSelectItem(item: TItem): boolean;
        /**
         * Indicates if all items can be unselected.
         */
        readonly canUnselectAllItems: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Determines if an item can be unselected.
         *
         * @param item The item to unselect.
         * @returns Indicates if an item can be unselected.
         */
        canUnselectItem(item: TItem): boolean;
        /**
         * Selects all items.
         *
         * @returns Indicates if all items were selected.
         */
        selectAllItems(): boolean;
        /**
         * The currently selected items.
         * Commands should use the selectedOrCurrentItems property in most scenarios.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selected items or the current item if there are no selected items.
         * Commands should use this property instead of selectedItems if they
         * must work on the current item when the user has not made a selection yet.
         */
        readonly selectedOrCurrentItems: KnockoutReadOnlyObservableArray<TItem>;
        /**
         * The selection mode.
         */
        readonly selectionMode: SelectionMode;
        /**
         * Selects an item.
         *
         * @param item The item to select.
         * @returns Indicates if the item was selected.
         */
        selectItem(item: TItem): boolean;
        /**
         * Selects an item by id.
         *
         * @param id The item's id to select.
         * @returns Indicates if the item was selected.
         */
        selectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Unselects all items.
         *
         * @returns Indicates if all items were unselected.
         */
        unselectAllItems(): boolean;
        /**
         * Unselects an item.
         *
         * @param item The item to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItem(item: TItem): boolean;
        /**
         * Unselects an item by id.
         *
         * @param id The item's id to unselect.
         * @returns Indicates if the item was unselected.
         */
        unselectItemById<TId extends string | ConvertsToString>(id: TId): boolean;
        /**
         * Determines if selection UI is visible.
         * This includes the header and row check boxes.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid activation options.
     */
    interface ActivationOptions {
        /**
         * Hides the selection while a child blade is opened.
         * Leaves the current row highlighting only on the activated row.
         * When the child blade is closed the selection is restored unless the user changed the selection while the child blade was open.
         * There are very few scenarios where you would enable this behavior.
         * Typically the only scenario this is used is when you want to collapse the parent blade to show the child blade next to it.
         * This is disabled by default.
         */
        hideSelectionDuringActivation?: boolean;
    }
    /**
     * SequentialDataGrid activation contract.
     * Activation occurs when a child blade is opened from a grid cell using a BladeLinkColumn,
     * CustomLinkColumn, ResourceLinkColumn, or fxclick in an HTML template.
     */
    export interface ActivationContract<TItem> {
        /**
         * Activated column id.
         */
        readonly activatedColumnId: KnockoutReadOnlyObservableBase<string>;
        /**
         * Activated item.
         */
        readonly activatedItem: KnockoutReadOnlyObservableBase<TItem>;
    }
    /**
     * SequentialDataGrid hover contract.
     */
    export interface HoverContract<TItem> {
        /**
         * The currently hovered row.
         * Null when a row is not hovered.
         */
        readonly hoveredRow: KnockoutReadOnlyObservable<Row<TItem>>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param row The row.
         * @returns A promise for completion
         */
        hoverRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Adds hover styling to a row.
         * Use null to clear the hovered row.
         *
         * @param id The id.
         * @returns A promise for completion
         */
        hoverRowById<TId extends string | ConvertsToString>(id: TId): Promise<boolean>;
    }
    /**
     * SequentialDataGrid context menu options.
     */
    export interface ContextMenuOptions<TItem, TGroup = any> {
        /**
         * Determines if the row supports context menu.
         * This is true by default and only needs to be implemented to opt specific rows out.
         * This controls if the context menu shortcut is displayed in the row.
         * It also controls if right-click/menu-key call supplyMenuCommands/supplyMenuBulkCommands.
         * supplyMenuCommands/supplyMenuBulkCommands can still return nothing if they do not want a menu shown.
         *
         * @param row The row to show menus for.
         * @param grid The grid.
         * @returns Indicates if the row can show a context menu.
         */
        canShowMenu?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines the maximum buttons commands to display directly in the row.
         * The default is one.
         * Command buttons will be displayed in the row until the count of commands exceeds this max.
         * When the max is exceeded the ellipsis will be displayed indicating more commands and providing a way to open the menu.
         * If zero only the ellipsis will ever be shown.
         */
        maxButtonCommands?: number;
        /**
         * Supplies command buttons to be displayed in the row margin.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyButtonCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies bulk commands to be displayed for the rows in a context menu.
         * This is called only when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param selection The selection to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuBulkCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, selection: SelectionState<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Supplies commands to be displayed in the row context menu.
         * This is not called when multiple rows are selected.
         *
         * @param lifetime The lifetime manager for any command related allocations.
         * @param row The row to supply commands for.
         * @param grid The grid.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyMenuCommands?: (lifetime: MsPortalFx.Base.LifetimeManager, row: Row<TItem>, grid: Contract<TItem, TGroup>) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         * Defaults to true.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid context menu contract.
     */
    export interface ContextMenuContract<TItem> {
        /**
         * Indicates if the context menu buttons are displayed in the grid margin.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid hierarchy options.
     */
    export interface HierarchyOptions<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be collapsed.
         */
        canCollapseAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @param grid The grid.
         * @returns Indicates if the row can be collapsed.
         */
        canCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @param grid The grid.
         * @returns Indicates if the row group can be collapsed.
         */
        canCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @param grid The grid.
         * @returns Indicates if the hierarchy can be expanded.
         */
        canExpandAll?: (grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @param grid The grid.
         * @returns Indicates if the row can be expanded.
         */
        canExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @param grid The grid.
         * @returns Indicates if the row group can be expanded.
         */
        canExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => boolean;
        /**
         * Notifies when the hierarchy is collapsed.
         *
         * @param grid The grid.
         */
        onCollapseAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is collapsed.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onCollapseRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is collapsed.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onCollapseRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when the hierarchy is expanded.
         *
         * @param grid The grid.
         */
        onExpandAll?: (grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row is expanded.
         *
         * @param row The row.
         * @param grid The grid.
         */
        onExpandRow?: (row: Row<TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Notifies when a row group is expanded.
         *
         * @param rowGroup The row group.
         * @param grid The grid.
         */
        onExpandRowGroup?: (rowGroup: RowGroup<TGroup, TItem>, grid: Contract<TItem, TGroup>) => void;
        /**
         * Customize the initial expanded state of a hierarchical parent row.
         * The grid will call this when a new row is being created to determine if it should be expanded or not.
         * The grid will only call if the item has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded The default expanded state which is expanded for root items and collapsed for all child item.
         * @param level The item level in the hierarchy 1 is top level.
         * @param item The row item.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForItem?: (cachedExpanded: boolean, defaultExpanded: boolean, level: number, item: TItem) => boolean;
        /**
         * Customize the initial expanded state of a row group.
         * The grid will call this when a new row group is being created to determine if it should be expanded or not.
         * The grid will only call if the group has children.
         * It will not call if the children are not known as in the case of async loading of children.
         *
         * @param cachedExpanded The cached expanded state if the grid has one (undefined otherwise).
         * @param defaultExpanded  The default expanded state which is expanded for row groups.
         * @param group The row group.
         * @returns The expanded state the grid will use.
         */
        supplyInitialExpansionForGroup?: (cachedExpanded: boolean, defaultExpanded: boolean, group: TGroup) => boolean;
    }
    /**
     * SequentialDataGrid hierarchy contract.
     */
    export interface HierarchyContract<TItem, TGroup = any> {
        /**
         * Determines if the hierarchy can be collapsed.
         *
         * @returns Indicates if the hiearrchy can be collapsed.
         */
        canCollapseAll(): boolean;
        /**
         * Determines if a row can be collapsed.
         *
         * @param row The row to collapse.
         * @returns Indicates if a row can be collapsed.
         */
        canCollapseRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be collapsed.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if a row group can be collapsed.
         */
        canCollapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Determines if the hierarchy can be expanded.
         *
         * @returns Indicates if the hiearrchy can be expanded.
         */
        canExpandAll(): boolean;
        /**
         * Determines if a row can be expanded.
         *
         * @param row The row to expand.
         * @returns Indicates if a row can be expanded.
         */
        canExpandRow(row: Row<TItem>): boolean;
        /**
         * Determines if a row group can be expanded.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if a row group can be expanded.
         */
        canExpandRowGroup(rowGroup: RowGroup<TGroup, TItem>): boolean;
        /**
         * Collapse the hierarchy.
         *
         * @returns Indicates if the hierarchy was collapsed.
         */
        collapseAll(): Promise<boolean>;
        /**
         * Collapses a row.
         *
         * @param row The row to collapse.
         * @returns Indicates if the row was collapsed.
         */
        collapseRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Collapses a row group.
         *
         * @param rowGroup The row group to collapse.
         * @returns Indicates if the row group was collapsed.
         */
        collapseRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
        /**
         * Expands the hierarchy.
         *
         * @returns Indicates if the hierarchy was expanded.
         */
        expandAll(): Promise<boolean>;
        /**
         * Expands a row.
         *
         * @param row The row to expand.
         * @returns Indicates if the row was expanded.
         */
        expandRow(row: Row<TItem>): Promise<boolean>;
        /**
         * Expands a row group.
         *
         * @param rowGroup The row group to expand.
         * @returns Indicates if the row group was expanded.
         */
        expandRowGroup(rowGroup: RowGroup<TGroup, TItem>): Promise<boolean>;
    }
    /**
     * SequentialDataGrid paging options.
     */
    export interface PagingOptions<TItem> {
        /**
         * Message displayed when loading the page.
         */
        pageLoadingMessage?: string;
    }
    /**
     * SequentialDataGrid paging contract.
     */
    export interface PagingContract<TItem> {
        /**
         * Indicates if an additional page of data can be loaded.
         *
         * @returns Indicates if an additional page of data can be loaded.
         */
        canLoadAdditionalPage(): boolean;
        /**
         * Loads an additional page of data.
         *
         * @returns Promise for completion.
         */
        loadAdditionalPage(): Promise<boolean>;
    }
    /**
     * SequentialDataGrid resizing options.
     */
    export interface ResizingOptions<TItem, TGroup = any> {
        /**
         * Notification when columns have been resized by the user.
         *
         * @param columns The columns that changed widths.
         * @param grid The grid.
         */
        onColumnsResized?: (columns: Column<TItem>[], grid: Contract<TItem, TGroup>) => void;
    }
    /**
     * SequentialDataGrid scrolling options.
     */
    export interface ScrollingOptions {
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (% or fr units) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * By default vertical scrolling is disabled.
         * Vertical scrolling requires that the element the grid is bound to has a height.
         * Having a height allows the grid to display a vertical scrollbar and fix the header at the top.
         */
        vertical?: boolean;
    }
    /**
     * SequentialDataGrid sorting options.
     */
    export interface SortingOptions<TItem, TGroup = any> {
        /**
         * Determines whether additional sorted columns can be added to the current sort order.
         * This can be used to limit the number of columns that can be sorted at the same time.
         * The default is to allow all the sortable columns to be sorted at the same time.
         *
         * @param sortOrder All columns with their column ids and sort directions.
         * @param grid The grid.
         * @returns A boolean that indicates if additional columns can be added to the current sort order.
         */
        canSortAdditionalColumns?: (sortOrder: SortOrder[], grid: Contract<TItem, TGroup>) => boolean;
    }
    /**
     * SequentialDataGrid sorting properties and methods.
     */
    export interface SortingContract<TItem> {
        /**
         * The current sort order.
         * This is an array of the column ids and sort directions in order of precedence.
         */
        readonly sortOrder: KnockoutReadOnlyObservableArray<SortOrder>;
    }
    /**
     * SequentialDataGrid options.
     */
    export interface Options<TItem, TGroup = any> {
        /**
         * Activation options.
         * Activation is enabled by default.
         * Activation can not be disabled by omitting the activation options or setting to null.
         */
        activation?: ActivationOptions;
        /**
         * The accessibility label for the grid.
         */
        ariaLabel: string | KnockoutObservableBase<string>;
        /**
         * The column definitions.
         * This is required because it is expected that the existing columns will be known or obtained before creating the grid.
         */
        columns: ColumnDefinition<TItem>[];
        /**
         * Context menu options.
         */
        contextMenu?: ContextMenuOptions<TItem, TGroup>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The data source.
         */
        dataSource: CallbackDataSource<TItem, TGroup>;
        /**
         * Disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Focus options.
         * Focus is enabled by default.
         * Focus can not be disabled by omitting the focus options or setting to null.
         */
        focus?: FocusOptions<TItem, TGroup>;
        /**
         * Header definition.
         * Initializes the grid header.
         */
        header?: HeaderDefinition;
        /**
         * Hierarchy options.
         * Heirarchy is enabled by default.
         * The hierarchy is determined by the node structure returned from the data source.
         */
        hierarchy?: HierarchyOptions<TItem, TGroup>;
        /**
         * Content to display when the grid has no data.
         */
        noDataMessage?: string | HtmlContent;
        /**
         * Paging options.
         * Paging is enabled by default and cannot be disabled.
         */
        paging?: PagingOptions<TItem>;
        /**
         * Resizing options.
         * Resizing is enabled by default.
         * Resizing can be disabled by setting to null.
         */
        resizing?: ResizingOptions<TItem, TGroup>;
        /**
         * Row initialization options.
         */
        row?: RowDefinition<TItem>;
        /**
         * Row group options.
         */
        rowGroup?: RowGroupDefinition<TGroup>;
        /**
         * Scrolling options.
         * By default horizontal scrolling is enabled and vertical scrolling is auto-detected.
         * Setting to null will disable all in-grid scrolling.
         */
        scrolling?: ScrollingOptions;
        /**
         * Selection options.
         * Selection is not enabled by default.
         * Selection is enabled by providing selection options.
         */
        selection?: SelectionOptions<TItem, TGroup>;
        /**
         * Sorting options.
         * Sorting is enabled by default.
         * Sorting can be disabled by setting to null.
         * To sort you must set canSort to true on a column and implement sorting in the dataSource.
         */
        sorting?: SortingOptions<TItem, TGroup>;
        /**
         * Hides or shows the grid.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * SequentialDataGrid loading message options.
     */
    export interface LoadingMessageOptions {
        /**
         * Message to be displayed/announced while loading.
         */
        message?: string;
        /**
         * Message to be announced on loading completion.
         */
        completedMessage?: string;
        /**
         * Message to be announced on loading completion when there are results.
         * The message can contain a "{count}" placeholder and the grid will fill it with the loaded row count.
         */
        completedDataMessage?: string;
        /**
         * Message to be announced on loading completion when there are not any results.
         */
        completedNoDataMessage?: string;
    }
    /**
     * SequentialDataGrid contract.
     */
    export interface Contract<TItem, TGroup = any> extends Control {
        /**
         * SequentialDataGrid activation properties and methods.
         */
        readonly activation: ActivationContract<TItem>;
        /**
         * The accessibility label for the grid.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The columns of the grid.
         */
        readonly columns: ColumnCollection<TItem>;
        /**
         * Context menu properties and methods.
         */
        readonly contextMenu: ContextMenuContract<TItem>;
        /**
         * Classes to add to the grid fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Displays a loading message until the supplied promise is resolved or rejected.
         * If called multiple times the promises are queued and the grid remains in a loading state until all loading tasks are completed.
         *
         * @param completion Promise for completion.
         * @param message Optional messages to display and announce to screen readers.
         * @returns A Promise that is resolved when the message is shown or determined not to be shown.
         */
        displayLoadingMessage(completion: Promise<any>, message?: string | LoadingMessageOptions): Promise<boolean>;
        /**
         * SequentialDataGrid focus properties and methods.
         */
        readonly focus: FocusContract<TItem, TGroup>;
        /**
         * The grid header.
         */
        readonly header: Header;
        /**
         * Hierarchy properties and methods.
         */
        readonly hierarchy: HierarchyContract<TItem, TGroup>;
        /**
         * Hover properties and methods.
         */
        readonly hover: HoverContract<TItem>;
        /**
         * Indicates when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid is in a loading state.
         * Controlled by calling the displayLoadingMessage() or refresh() methods.
         */
        readonly loadingMessage: KnockoutObservableBase<string>;
        /**
         * Indicates when the grid has no data to display.
         */
        readonly noData: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Message to display when the grid has no data.
         */
        readonly noDataMessage: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Paging properties and methods.
         */
        readonly paging: PagingContract<TItem>;
        /**
         * Refreshes the grid data.
         *
         * @param options Refresh options.
         * @returns A promise for completion.
         */
        refresh<TParams>(options?: RefreshOptions<TParams>): Promise<any>;
        /**
         * The grid row groups when the grid is grouped.
         */
        readonly rowGroups: KnockoutReadOnlyObservableArray<RowGroup<TGroup, TItem>>;
        /**
         * The grid rows.
         */
        readonly rows: KnockoutReadOnlyObservableArray<Row<TItem>>;
        /**
         * SequentialDataGrid selection properties and methods.
         */
        readonly selection: SelectionContract<TItem>;
        /**
         * Sorting properties and methods.
         */
        readonly sorting: SortingContract<TItem>;
        /**
         * Hides or shows the SequentialDataGrid.
         */
        readonly visible: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a SequentialDataGrid control.
     *
     * @param lifetime The lifetime manager for the grid.
     * @param options The options for creating the grid.
     * @returns The created grid.
     */
    export function create<TItem, TGroup = any>(lifetime: MsPortalFx.Base.LifetimeManager, options: Options<TItem, TGroup>): Contract<TItem, TGroup>;
    /**
     * Creates a BladeLink column definition that displays a link to a blade in each cell.
     *
     * @param options The BladeLink column definition options.
     * @returns A BladeLink column definition.
     */
    export function createBladeLinkColumn<TItem>(options: BladeLinkColumnDefinitionOptions<TItem>): BladeLinkColumnDefinition<TItem>;
    /**
     * Creates a CustomLink column definition that displays a custom link in each cell.
     * Only use for exceptional cases where you do not require browser behaviors like
     * right+click to 'copy link' and ctrl+click to 'open in a new tab'.
     * Use BladeLink, UriLink, or ResourceLink instead to get full support of browser right+click and ctrl+click on the link.
     * This can be used for opening in the context pane and other scenarios where 'open in a new tab' would not make sense.
     *
     * @param options The CustomLink column definition options.
     * @returns A CustomLink column definition.
     */
    export function createCustomLinkColumn<TItem>(options: CustomLinkColumnDefinitionOptions<TItem>): CustomLinkColumnDefinition<TItem>;
    /**
     * Creates a ResourceLink column definition that displays a link to a resource in each cell.
     *
     * @param options The ResourceLink column definition options.
     * @returns A ResourceLink column definition.
     */
    export function createResourceLinkColumn<TItem>(options: ResourceLinkColumnDefinitionOptions<TItem>): ResourceLinkColumnDefinition<TItem>;
    /**
     * Creates a TagList column definition that displays a list of tags as bubbled text in each cell.
     *
     * @param options The TagList column definition options.
     * @returns A TagList column definition.
     */
    export function createTagListColumn<TItem>(options: TagListColumnDefinitionOptions<TItem>): TagListColumnDefinition<TItem>;
    /**
     * Creates a template column definition that displays an HTML template bound to a view model in each cell.
     *
     * @param options The template column definition options.
     * @returns A Template column definition.
     */
    export function createTemplateColumn<TItem, TViewModel = any>(options: TemplateColumnDefinitionOptions<TItem, TViewModel>): TemplateColumnDefinition<TItem>;
    /**
     * Creates a text column definition that displays text in each cell.
     *
     * @param options The text column definition options.
     * @returns A Text column definition.
     */
    export function createTextColumn<TItem>(options: TextColumnDefinitionOptions<TItem>): TextColumnDefinition<TItem>;
    /**
     * Creates a UriLink column definition that displays a URI link in each cell.
     *
     * @param options The UriLink column definition options.
     * @returns A UriLink column definition.
     */
    export function createUriLinkColumn<TItem>(options: UriLinkColumnDefinitionOptions<TItem>): UriLinkColumnDefinition<TItem>;
}

// FILE: Fx\Controls\SingleMetric.d.ts
declare module "Fx/Controls/SingleMetric" {
    import { HatchingPattern as Pattern } from "Fx/Controls/ChartBase";
    import { Contract as InfoBalloonContract } from "Fx/Controls/InfoBalloon";
    import { FxChartColorClass } from "Fx/Controls/ChartColor";
    export { Pattern };
    export { FxChartColorClass };
    export const enum Alignment {
        /**
         * Top edge for vertical alignment.
         */
        Top = 1,
        /**
         * Left edge for horizontal alignment.
         */
        Left = 2,
        /**
         * Right edge for horizontal alignment.
         */
        Right = 4,
        /**
         * Bottom edge for vertical alignment.
         */
        Bottom = 8
    }
    export interface Options {
        /**
         * The value of the metric.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The unit for the metric.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * The caption for the metric.
         */
        caption?: string | KnockoutObservableBase<string>;
        /**
         * The info balloon for the metric.
         */
        infoBalloon?: InfoBalloonContract | KnockoutObservableBase<InfoBalloonContract>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass?: string | FxChartColorClass | KnockoutObservableBase<string | FxChartColorClass>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: Pattern | KnockoutObservableBase<Pattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * The visibility of the single metric.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    export interface Contract {
        /**
         * The value of the metric.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The unit for the metric.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * The caption for the metric.
         */
        readonly caption: KnockoutObservableBase<string>;
        /**
         * The info balloon for the metric.
         */
        readonly infoBalloon: KnockoutObservableBase<InfoBalloonContract>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        readonly hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        readonly barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        readonly showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        readonly hatchingPattern: KnockoutObservableBase<Pattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        readonly unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        readonly captionAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The visibility of the single metric.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        readonly prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * Creates a SingleMetric viewmodel which will be used in Metrics viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a SingleMetric viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\SingleValueGauge.d.ts
declare module "Fx/Controls/SingleValueGauge" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Built-in sizes for SingleValueGauge control.
     */
    export const enum GaugeSize {
        /**
         * Default Automatically adjust size base on current Div size.
         * Currently, it is determined by Min(width, hight).
         * If less than 100px, display QuotaGaugeSize.CenterOnly.
         * else if less than 254px, display QuotaGaugeSize.Small.
         * else display QuotaGaugeSize.Large.
         */
        Auto = 0,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlySmall = 1,
        /**
         * No outer donut gauge. Center only.
         */
        CenterOnlyMedium = 2,
        /**
         * No outer donut gauge. Center only
         */
        CenterOnlyLarge = 3,
        /**
         * Icon 21px square size of donut shape gauge with center.
         */
        Icon = 4,
        /**
         * Tiny 30px square size of donut shape gauge with center.
         */
        Tiny = 5,
        /**
         * Small 100px square size of donut shape gauge with center.
         */
        Small = 6,
        /**
         * Medium 146px square size of donut shape gauge with center.
         */
        Medium = 7,
        /**
         * MediumLarge 220px square size of donut shape gauge with center.
         */
        MediumLarge = 8,
        /**
         * Small 254px square size of donut shape gauge with center.
         */
        Large = 9
    }
    /**
     * Options for configuring a SingleValueGauge control.
     */
    export interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        gaugeSize?: GaugeSize | KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        hideTick?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        maximum?: number | KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        startOffset?: number | KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        current?: number | KnockoutObservableBase<number>;
        /**
         * Formatter for displaying caption value. The following formatter arguments will be substituted with respective values when displaying the caption value,
         *  {0} is current
         */
        captionDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Formatter for displaying center value. The following formatter arguments will be substituted with respective values when displaying the center value,
         *  {0} is current
         */
        valueDisplayFormat?: string | KnockoutObservableBase<string>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        ariaDesc?: string | KnockoutObservableBase<string>;
    }
    /**
     * SingleValueGauge control view model contract.
     */
    export interface Contract extends Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Gauge Size for display.
         */
        readonly gaugeSize: KnockoutObservableBase<GaugeSize>;
        /**
         * Hide the current tick mark.
         */
        readonly hideTick: KnockoutObservableBase<boolean>;
        /**
         * The number represent the whole gauge value.
         */
        readonly maximum: KnockoutObservableBase<number>;
        /**
         *  Gauge start point (units in degree).
         *  -90 : bottom  (default)
         *    0 : left
         *   90 : top
         *  180 : right
         */
        readonly startOffset: KnockoutObservableBase<number>;
        /**
         * Center text unit.
         */
        readonly unit: KnockoutObservableBase<string>;
        /**
         * Current value.
         */
        readonly current: KnockoutObservableBase<number>;
        /**
         * Formatter for displaying caption value. The following formatter arguments will be substituted with respective values when displaying the caption value,
         *  {0} is current
         */
        readonly captionDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Formatter for displaying center value. The following formatter arguments will be substituted with respective values when displaying the center value,
         *  {0} is current
         */
        readonly valueDisplayFormat: KnockoutObservableBase<string>;
        /**
         * Aria-label of the Gauge, a short description, will be utilized by screen-reader.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Detailed description of the Gauge, will be utilized by screen-reader.
         */
        readonly ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * Creates a SingleValueGauge control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a SingleValueGauge control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Slider.d.ts
declare module "Fx/Controls/Slider" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring a slider control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria label of the control, for screen reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: number | KnockoutObservableBase<number>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Legends for the slider.
         */
        legends?: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        hideTextbox?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Options for configuring the slider control with simple values
     */
    export interface SimpleSliderOptions extends Options {
        /**
         * Minimum value of the slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
    }
    /**
     * Options for configuring the slider control with custom values
     */
    export interface CustomSliderOptions extends Options {
        /**
         * Custom slider clickstop values.
         */
        customValues: number[] | KnockoutObservableBase<number[]>;
    }
    /**
     * Legend for Slider
     */
    export interface SliderLegends {
        /**
         * The labels for the slider.
         */
        labels: SliderLabel[];
        /**
         * Label to show when the value is active.
         */
        activeValueLabel: (value: number) => string;
        /**
         * Sublabel to show when the value is active.
         */
        activeValueSublabel?: (value: number) => string;
    }
    /**
     * Label for Slider
     */
    export interface SliderLabel {
        /**
         * The value of the slider to map.
         */
        value: number;
        /**
         * The label for the corresponding slider value.
         */
        label: string;
    }
    /**
     * Slider control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        readonly showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Legends for the slider.
         */
        readonly legends: SliderLegends;
        /**
         * Hide the textbox of the control.
         */
        readonly hideTextbox: KnockoutObservableBase<boolean>;
    }
    /**
     * Slider control view model for simple values
     */
    export interface SimpleSliderContract extends Contract {
        /**
         * Minimum value of the range slider.
         */
        readonly min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the range slider.
         */
        readonly max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the range slider takes between min and max.
         */
        readonly step: KnockoutObservableBase<number>;
    }
    /**
     * Slider control view model for custom values
     */
    export interface CustomSliderContract extends Contract {
        /**
         * Custom slider clickstop values.
         */
        readonly customValues: KnockoutObservableBase<number[]>;
    }
    /**
     * Creates a slider control viewmodel with simple values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a slider control viewmodel
     */
    export function createSimpleSlider(lifetime: MsPortalFx.Base.LifetimeManager, options?: SimpleSliderOptions): SimpleSliderContract;
    /**
     * Creates a slider control viewmodel with custom values.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a slider control viewmodel
     */
    export function createCustomSlider(lifetime: MsPortalFx.Base.LifetimeManager, options: CustomSliderOptions): CustomSliderContract;
}

// FILE: Fx\Controls\Splitter.d.ts
declare module "Fx/Controls/Splitter" {
    import { Control } from "Fx/Controls/ControlsBase";
    export const enum Panes {
        Primary = 0,
        Secondary = 1,
        Both = 2
    }
    /**
     * @deprecated Fx.Controls.Splitter is deprecated.
     * Please migrate to Fx/Controls/Splitter2.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export interface Options {
        /**
         * The initial size of the primary pane.
         */
        primaryPaneSize?: number;
        /**
         * Controls which panes are visible.  Defaults to Both
         */
        showPanes?: Panes | KnockoutObservableBase<Panes>;
        /**
         * Set to true to change splitter orientation to vertical.  Defaults to false.
         */
        vertical?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Reverses the splitter's flow.  This is mostly used to put the primary pane on the right in order to set a fixed initial width via primaryPaneSize.
         */
        reversed?: boolean;
        /**
         * Minimum pane sizes
         */
        minPaneSizes?: {
            primaryPaneSize: number;
            secondaryPaneSize: number;
        };
        /**
         * Accessibility names for the splitter panes.
         */
        ariaLabels?: {
            /**
             * Accessibility name for the primary pane.
             */
            primaryPane?: string | KnockoutObservableBase<string>;
            /**
             * Accessibility name for the secondary pane.
             */
            secondaryPane?: string | KnockoutObservableBase<string>;
        };
    }
    /**
     * @deprecated Fx.Controls.Splitter is deprecated.
     * Please migrate to Fx/Controls/Splitter2.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export interface Contract extends Control {
        /**
         * Controls which panes are visible.  Defaults to Both
         */
        readonly showPanes: KnockoutObservableBase<Panes>;
        /**
         * Set to true to change splitter orientation to vertical.  Defaults to false.
         */
        readonly vertical: KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated Fx.Controls.Splitter is deprecated.
     * Please migrate to Fx/Controls/Splitter2.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Splitter2.d.ts
declare module "Fx/Controls/Splitter2" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Orientation of splitter bar in the splitter control
     */
    export const enum Orientation {
        /**
         * Primary pane on the top, secondary pane on the bottom
         */
        Horizontal = 0,
        /**
         * Primary pane on the left, secondary pane on the right
         */
        Vertical = 1
    }
    /**
     * Options for configuring a Splitter control
     */
    export interface Options {
        /**
         * The orientation of splitter bar
         */
        readonly orientation?: Orientation | KnockoutObservableBase<Orientation>;
        /**
         * The top or left pane
         */
        readonly primaryPane: PaneContract | KnockoutObservableBase<PaneContract>;
        /**
         * The bottom or right pane
         */
        readonly secondaryPane: PaneContract | KnockoutObservableBase<PaneContract>;
        /**
         * Size of the primary pane in px or %
         */
        readonly primaryPaneSize?: string | KnockoutObservableBase<string>;
    }
    /**
     * The viewmodel for the Splitter control.
     */
    export interface Contract extends Control {
        /**
         * Sets the orientation of the splitter bar
         */
        readonly orientation: KnockoutObservableBase<Orientation>;
        /**
         * The top or left pane
         */
        readonly primaryPane: KnockoutObservableBase<PaneContract>;
        /**
         * The bottom or right pane
         */
        readonly secondaryPane: KnockoutObservableBase<PaneContract>;
        /**
         * Size of the primary pane in px or %
         */
        readonly primaryPaneSize: KnockoutObservableBase<string>;
    }
    /**
     * Options for a Pane in Splitter control
     */
    export interface PaneOptions {
        /**
         * Content for your Pane.
         * Can also be a HTML template.
         * Can be a Promise.
         */
        readonly content: string | HtmlContent | KnockoutObservableBase<string | HtmlContent> | Promise<string | HtmlContent>;
        /**
         * Minimum pane size in px
         */
        readonly minSize?: number | KnockoutObservableBase<number>;
        /**
         * Accessibility names for the splitter pane.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Specifies whether or not this pane can be collapsed by the user
         * Defaults to false
         */
        readonly collapsible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specifies whether the pane is currently collapsed
         * Defult to false
         */
        readonly collapsed?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * The viewmodel for a Pane.
     */
    export interface PaneContract {
        /**
         * Content for your Pane.
         */
        readonly content: KnockoutObservableBase<string | HtmlContent>;
        /**
         * If content is passed as a promise this value will be set to false until the promise returns
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Minimum pane size in px
         */
        readonly minSize: KnockoutObservableBase<number>;
        /**
         * Accessibility names for the splitter panes.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * Specifies whether or not this pane can be collapsed by the user
         */
        readonly collapsible: KnockoutObservableBase<boolean>;
        /**
         * Specifies whether the pane is currently collapsed
         */
        readonly collapsed: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates an Splitter2 control viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the splitter.
     * @returns a Splitter2 viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
    /**
     * Creates a Pane for use in the Splitter control
     *
     * @param lifetime The lifetime for the created view model.
     * @param paneOptions The set of PaneOptions to configure the pane.
     * @returns a PaneContract viewmodel
     */
    export function createPane(lifetime: MsPortalFx.Base.LifetimeManager, options: PaneOptions): PaneContract;
}

// FILE: Fx\Controls\Storage\BlobContainerDropDown.d.ts
declare module "Fx/Controls/Storage/BlobContainerDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Actions user can take using a SAS signature.
     */
    export type AccessPolicyPermissons = "Read" | "Write" | "List" | "Delete" | "Add" | "Create";
    /**
     * The lease state for the given blob container.
     */
    export type LeaseState = "available" | "leased" | "expired" | "breaking" | "broken";
    /**
     * The contract for the values returned by the storage container dropdown.
     */
    export interface Container {
        /**
         * The name of the selected container.
         */
        readonly name: string;
        /**
         * The full URI path to the selected container, including SAS token.
         */
        readonly uri: string;
        /**
         * The lease state of this container.
         */
        readonly leaseState: LeaseState;
    }
    export interface Options {
        /**
         * Required. The ID of the Storage Account for which to pull containers.
         */
        readonly storageAccountId: string | KnockoutObservableBase<string>;
        /**
         * The aria-label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control
         */
        readonly validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        readonly infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        readonly filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Toggle multiselect on.
         */
        readonly multiSelect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText?: string | KnockoutObservableBase<string>;
        /**
         * Enables select all for multiselect.
         */
        readonly selectAll?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        readonly suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * File share drop down Viewmodel
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown
         */
        readonly value: KnockoutObservableBase<Container> & KnockoutObservableBase<Container[]>;
        /**
         * The Storage Account ID for which to pull containers.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly storageAccountId: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
    }
    export interface GenerateSasUriOptions {
        /**
         * The URI to the specific container
         */
        readonly containerUri: string;
        /**
         * ARM id of the storage account in which this container exists.
         */
        readonly storageAccountId: string;
        /**
         * Set of actions user can take with the generated SASUri.
         */
        readonly accessPolicyPermissions: AccessPolicyPermissons[];
        /**
         * The SAS token will not be valid after this time.
         */
        readonly accessPolicyEndTime: Date;
        /**
         * The SAS token will not be valid until this time.
         */
        readonly accessPolicyStartTime?: Date;
        /**
         * The name of the specified blob in the container to generate a SAS Uri for.
         */
        readonly blobName?: string;
    }
    /**
     * Given a container, generate a URI signed with a SAS (Shared Access Signature) token.
     * Use the options to control permissions and duration of availability for this url.
     *
     * @param options Options that modify the duration and permissions for the SasUri.
     * @returns A URI that can be used to access the container with authentication.
     */
    export function generateSasUri(options: GenerateSasUriOptions): Promise<string>;
    /**
     * Creates a container drop down viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a container drop down viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Storage\FileShareDropDown.d.ts
declare module "Fx/Controls/Storage/FileShareDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The contract for the values returned by the file share dropdown
     */
    export interface FileShare {
        /**
         * The name of the select File Share.
         */
        readonly name: string;
        /**
         * The full URL path to the selected File Share.
         */
        readonly url: string;
    }
    /**
     * Options for configuring the file share drop down.
     */
    export interface Options {
        /**
         * Required. The ID of the Storage Account for which to pull file shares
         */
        storageAccountId: string | KnockoutObservableBase<string>;
        /**
         * The aria-label for the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        filterPlaceholder?: string | KnockoutObservableBase<string>;
        /**
         * Toggle multiselect on.
         */
        multiSelect?: boolean;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        multiItemDisplayText?: string | KnockoutObservableBase<string>;
        selectAll?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * File share drop down Viewmodel
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown
         */
        readonly value: KnockoutObservableBase<FileShare> & KnockoutObservableBase<FileShare[]>;
        /**
         * The Storage Account ID for which to pull file shares.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly storageAccountId: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.
         */
        readonly loading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Multiple items text format (multiselect only).
         * By default the format string is "{0} selected"
         */
        readonly multiItemDisplayText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a file share drop down viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a file share drop down viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Storage\StorageAccountDropDown.d.ts
declare module "Fx/Controls/Storage/StorageAccountDropDown" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * The specific type of Storage Account.
     * Used for filtering storage accounts. These values from the Storage Resource Provider.
     */
    export type StorageAccountType = "Premium_LRS" | "Standard_LRS" | "Standard_ZRS" | "Standard_GRS" | "Standard_RAGRS";
    /**
     * The specific kind of Storage Account.
     * Used for filtering storage accounts. These values from the Storage RP.
     */
    export type StorageAccountKind = "Storage" | "StorageV2" | "BlobStorage";
    /**
     * Type for the 'value' property of the StorageAccount DropDown.
     */
    export interface StorageAccount {
        /**
         * ID of the selected storage account.
         */
        readonly id: string;
        /**
         * Name of the storage account. Matches the name in the 'id' property.
         */
        readonly name: string;
        /**
         * Storage account type as in 'StorageAccountType'.
         */
        readonly type: StorageAccountType;
        /**
         * Storage account kind as in 'StorageAccountKind'.
         */
        readonly kind: StorageAccountKind;
        /**
         * Indicates whether the selected storage account exists, or needs to be created by
         * the consumer of the picker.
         */
        readonly isExisting: boolean;
        /**
         * Indicates whether the storage account is a classic storage account.
         */
        readonly isClassic: boolean;
        /**
         * The selected location object.
         */
        readonly location: string;
    }
    export interface CreateOptions {
        /**
         * Indicates whether the location dropdown should be shown.
         * Default is false.
         */
        readonly showLocationDropdown?: boolean;
        /**
         * The default storage account type to select in the create account blade
         * Default is all account types shown.
         */
        readonly defaultStorageAccountType?: string;
    }
    /**
     * Options for configuring the storage account picker.
     */
    export interface Options {
        /**
         * The subscription ID where accounts should be pulled from.
         *
         * If this is not supplied a warning is logged indicating an invalid subscriptionId.
         */
        readonly subscriptionId?: string | KnockoutObservableBase<string>;
        /**
         * Region of the resource in DNS form (e.g. westus).
         *
         * If specified, only storage accounts in this location will be displayed.
         * If not specified, all locations are shown.
         */
        readonly location?: string | KnockoutObservableBase<string>;
        /**
         * Name of the resource group.
         *
         * If specified, only storage accounts in this resource group will be displayed.
         * If not specified, storage accounts from all resource groups will be displayed.
         */
        readonly resourceGroup?: string | KnockoutObservableBase<string>;
        /**
         * If specified, only account types in the list will be shown.
         * Cannot be used at the same time as invalidAccountTypes, filtering will be
         * performed only if one of the two parameters is added.
         *
         * If not specified, (and invalid account types not specified) all accounts types will be shown.
         *
         * See StorageAccountType.
         */
        readonly validAccountTypes?: ReadonlyArray<StorageAccountType> | KnockoutObservableArray<StorageAccountType>;
        /**
         * If specified, all account types except those in the list will be shown.
         * Cannot be used at the same time as validAccountTypes, filtering will be
         * performed only if one of the two parameters is added.
         *
         * If not specified, (and valid account types not specified) all accounts types will be shown.
         *
         * See StorageAccountType.
         */
        readonly invalidAccountTypes?: ReadonlyArray<StorageAccountType> | KnockoutObservableArray<StorageAccountType>;
        /**
         * If specified, only account of the specified kinds will be shown.
         * If not specified, all accounts kinds will be shown.
         *
         * See StorageAccountKind.
         */
        readonly kinds?: ReadonlyArray<StorageAccountKind>;
        /**
         * Indicates whether classic resources should be listed.
         *
         * Defaults to: false
         */
        readonly showClassicResources?: boolean;
        /**
         * Indicates whether ARM resources should be listed.
         *
         * Defaults to: false
         */
        readonly showArmResources?: boolean;
        /**
         * Indicates whether the create new option should be displayed.
         *
         * Defaults to: false
         */
        readonly showCreate?: boolean;
        /**
         * Indicates whether a "none" option should be selectable.
         *
         * Defaults to: false
         */
        readonly hideNoneItem?: boolean;
        /**
         * Create options to pass to the picker.
         *
         * If not specified the create storage account experience will display with no defaults selected.
         */
        readonly createOptions?: CreateOptions;
        /**
         * The aria-label for the control.
         */
        readonly ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The label of the control
         */
        readonly label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        readonly subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * validations on the control
         */
        readonly validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        readonly infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Change the default filter string.
         */
        readonly filterPlaceholder?: string;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        readonly suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        readonly disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Control or view the visible state of this control.
         */
        readonly visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Storage Account drop down ViewModel.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the dropdown.
         */
        readonly value: KnockoutObservableBase<StorageAccount>;
        /**
         * The Subscription Id from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly subscriptionId: KnockoutObservableBase<string>;
        /**
         * The location from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly location: KnockoutObservableBase<string>;
        /**
         * The name of the resourceGroup from which to pull Storage Accounts.
         * Updating this value will cause the set of items in the drop down to get updated as well.
         */
        readonly resourceGroup: KnockoutObservableBase<string>;
        /**
         * Current value of the filter textbox.
         */
        readonly filterString: KnockoutObservableBase<string>;
        /**
         * Puts the control into a loading state.  When in the loading state, the control will be disabled and have the text "Loading..." shown.
         */
        readonly loading: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a storage account drop down viewmodel.
     *
     * @param container The container for the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a storage account drop down viewmodel
     */
    export function create(container: AnyBladeContainer, options: Options): Contract;
}

// FILE: Fx\Controls\SubscriptionDropDown.d.ts
declare module "Fx/Controls/SubscriptionDropDown" {
    import { Subscription as BaseSubscription, Validation as BaseValidation } from "Fx/Controls/BaseResourceDropDown";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    /**
     * The contract for the values returned by the subscription dropdown
     */
    export import Subscription = MsPortalFx.Azure.Subscription;
    /**
     * The contract for options to create the subscription drop down
     */
    export type Options<THtmlKeyMap extends StringMap<HtmlContent> = StringMap<HtmlContent>> = BaseSubscription.Options<THtmlKeyMap>;
    /**
     * The validation type accepted by the dropdown
     */
    export type Validation = BaseValidation<Subscription>;
    /**
     * The contract for the subscription dropdown
     */
    export interface Contract extends BaseSubscription.Contract {
    }
    /**
     * This creates a subscription dropdown control.
     *
     * @param container The container associated with the part or blade.
     * @param options The subscription dropdown options. See interface
     */
    export function create<THtmlKeyMap extends StringMap<HtmlContent>>(container: MsPortalFx.Base.LifetimeManager, options: Options<THtmlKeyMap>): Contract;
}

// FILE: Fx\Controls\Summary.d.ts
declare module "Fx/Controls/Summary" {
    import { HtmlContent, Control } from "Fx/Controls/ControlsBase";
    import { ValidationResult } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Options for configuring an Summary control.
     */
    export interface Options {
        /**
         * The title for the control.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The children to display within the control.
         */
        children?: Array<Group> | KnockoutObservableArray<Group>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Summary view model
     */
    export interface Contract extends Control {
        /**
         * The title for the control.
         */
        readonly name: KnockoutObservableBase<string | HtmlContent>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * The children to display within the control.
         */
        readonly children: KnockoutObservableArray<Group>;
    }
    /**
     * Creates an Summary control view model.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the summary.
     * @returns an Summary viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
    /**
     * Summary Group.
     *
     * Collection of Items.
     */
    export interface Group {
        /**
         * Label for the item.
         */
        name?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The items to layout inside the Group
         */
        children: Array<Item | HtmlContent> | KnockoutObservableArray<Item | HtmlContent>;
        /**
         * Enables multi column layout. Default is false.
         * Displays a predefined layout with a bolded label, value, and icon.
         */
        isMultiColumn?: boolean;
    }
    /**
     * Summary Item.
     *
     * Label/Value pairs to display in a 2 column layout.
     */
    export interface Item {
        /**
         * Label for the item.
         */
        label: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Item value.
         */
        value: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Show a control's invalid validations.
         *
         * Takes a validationResults array from a control.
         * This array is available on any control which supports validations.
         *
         * If you create a TextBox.
         *      const myTextBoxVm = TextBox.create(container, {options});
         *
         * You can then set this property to myTextBoxVm.validationResults.
         */
        validationResults?: KnockoutReadOnlyObservableArray<ValidationResult>;
        /**
         * Icon that is left of the label/value.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
    }
}

// FILE: Fx\Controls\TabControl.d.ts
declare module "Fx/Controls/TabControl" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { Contract as SectionContract } from "Fx/Controls/Section";
    /**
     * Options for configuring a tab control
     */
    export interface Options {
        /**
         * The section view models containing the contents of each tab.
         */
        tabs?: SectionContract[];
        /**
         * Custom css classes to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * The minimum height of the tab control in pixels.  Use this to reduce jumpiness in forms.
         */
        minHeight?: number;
        /**
         * Show required asterisks on tab.
         * If there is any required control or section within the tab we show a red '*' on the left of the tab header.
         */
        showRequiredStatusOnTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Show validation failure on tab.
         * If there is any invalid control or section within the tab we show a red 'o' on the right of the tab header.
         */
        showValidationStatusOnTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Align labels by available size of the blade. (left or above the control).
         */
        smartAlignLabel?: boolean;
        /**
         * Indicates if tabs are closeable. Adds a 'x' to the tab header.
         */
        allowClosableTabs?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Popup an alert when a tab is closed when dirty.
         */
        alertOnClose?: boolean | KnockoutObservableBase<boolean>;
    }
    export interface TabIndexObservable extends KnockoutReadOnlyObservableBase<number> {
        /**
         * Sets active tab by index.
         * setFocus focuses on the tab header, if focus is within the blade.
         */
        (index: number, setFocus?: boolean): number;
    }
    export interface TabObservable extends KnockoutReadOnlyObservableBase<SectionContract> {
        /**
         * Sets active tab by section.
         * setFocus focuses on the tab header, if focus is within the blade.
         */
        (section: SectionContract, setFocus?: boolean): SectionContract;
    }
    /**
     * Tab control view model
     */
    export interface Contract extends Control {
        /**
         * The section view models containing the contents of each tab.
         */
        readonly tabs: KnockoutObservableArray<SectionContract>;
        /**
         * Gets and sets the currently active tab.
         */
        readonly activeTab: TabObservable;
        /**
         * Gets and sets the currently active tab.
         */
        readonly activeTabIndex: TabIndexObservable;
        /**
         * The dirty state of the control.
         */
        readonly dirty: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Show required asterisks on tab.
         * If there is any required control or section within the tab we show a red '*' on the left of the tab header.
         */
        readonly showRequiredStatusOnTabs: KnockoutObservableBase<boolean>;
        /**
         * Show validation failure on tab.
         * If there is any invalid control or section within the tab we show a red 'o' on the right of the tab header.
         */
        readonly showValidationStatusOnTabs: KnockoutObservableBase<boolean>;
        /**
         * Indicates if tabs are closeable. Adds a 'x' to the tab header.
         */
        readonly allowClosableTabs: KnockoutObservableBase<boolean>;
        /**
         * The validation state of the control.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * Popup an alert when a tab is closed when dirty.
         */
        readonly alertOnClose: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Promise<boolean>;
        /**
         * Custom css classes to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
    }
    /**
     * Creates a tab control view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TabMenu.d.ts
declare module "Fx/Controls/TabMenu" {
    import { BladeReference } from "Fx/Composition/Selectable";
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import FxViewModels = MsPortalFx.ViewModels;
    import FxControls = FxViewModels.Controls;
    /**
     * Defines an item in the menu.
     */
    export interface MenuItem {
        /**
         * Gets the ID for the item.
         */
        id: string;
        /**
         * The display text for the item.
         */
        displayText: string | KnockoutObservableBase<string>;
        /**
         * A space-delimited list of keywords associated to the item.
         */
        keywords?: string | string[];
        /**
         * The icon associated to the item.
         */
        icon?: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * in response to a user-invoked navigation.
         *
         * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReference?: () => BladeReference<any>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * asynchronously in response to a user-invoked navigation.
         *
         * @returns A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReferenceAsync?: () => Promise<BladeReference<any>>;
    }
    /**
     * The options for the menu.
     */
    export interface Options {
        /**
         * The ID of the item to be selected by default.
         */
        defaultId?: string;
        /**
         * The main menu management driving the tab menu.
         */
        mainMenu?: FxBladeBase.MenuBladeManagement;
    }
    /**
     * Defines the view model for the menu control.
     */
    export class ViewModel extends FxControls.Base.ViewModel {
        /**
         * The menu items.
         */
        items: KnockoutObservableArray<MenuItem>;
        /**
         * Asynchronously initializes the view model.
         *
         * @param items The menu items.
         * @returns A Promise that resolves once the view model is initialized.  This Promise can be included in that Promise returned
         * from the containing Blade's 'onInitialize'/'onInputsSet' method.
         */
        initialize: (items: MenuItem[], options: Options) => Promise<void>;
        private _msPortalFxData;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager);
        /**
         * Sets the options for the menu.
         *
         * @param options The options to configure the menu.
         */
        setOptions: (options: Options) => void;
    }
}

// FILE: Fx\Controls\TagsByResource.d.ts
declare module "Fx/Controls/TagsByResource" {
    import { Control } from "Fx/Controls/ControlsBase";
    import { CustomV, Required } from "Fx/Controls/Validations";
    export type Validation<TValue> = CustomV<TValue> | Required;
    /**
     * Options for configuring a TagsByResource control.
     */
    export interface Options {
        /**
         * Initial list of resources with the number of instances.
         */
        readonly resources: ReadonlyArray<TargetItem> | KnockoutObservableArray<TargetItem>;
        /**
         * Optional list of subscriptions for tag suggestion lookups by GUID.
         */
        readonly customSubscriptionIds?: ReadonlyArray<string> | KnockoutObservableArray<string>;
        /**
         * The initial value of the control.
         * If an observable is provided, there will be a 2-way binding set up between the observable and the value of the control.
         */
        readonly value?: ReadonlyArray<TaggedResource> | KnockoutObservableArray<TaggedResource>;
        /**
         * Validations on the control.
         */
        readonly validations?: KnockoutObservableArray<Validation<TaggedResource[]>> | Validation<TaggedResource[]>[];
        /**
         * Button commands for tag row in the grid.
         */
        readonly buttonCommands?: ReadonlyArray<Command>;
        /**
         * Menu commands for tag row in the grid.
         */
        readonly menuCommands?: ReadonlyArray<Command>;
        /**
         * Flag to hide the resource column in the tags grid.
         * Default is to show the resource column.
         */
        readonly hideResourceColumn?: boolean | KnockoutObservable<boolean>;
    }
    /**
     * TagsByResource control view model.
     */
    export interface Contract extends Control {
        /**
         * List of resources with the number of instances.
         * This property is read-only. To mutate, change the value of the resources property provided in the TagsByResource options.
         */
        readonly resources: KnockoutReadOnlyObservableArray<TargetItem>;
        /**
         * The set of resources with their associated tags.
         */
        readonly value: KnockoutReadOnlyObservableArray<TaggedResource>;
        /**
         * The EditableGrid dirty state.
         */
        readonly dirty: KnockoutObservableBase<boolean>;
        /**
         * The EditableGrid disabled state.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * List of subscriptions used for tag suggestion lookups.
         * This property is read-only. To mutate, change the value of the customSubscriptionIds property provided in the
         * TagsByResource options.
         */
        readonly customSubscriptionIds: KnockoutReadOnlyObservableArray<string>;
        /**
         * The maximum number of tags reached externally state.
         * This property can be set by the caller if the maximum number of tags is reached when merging tags in the
         * control with existing tags on resources external to the editor.
         */
        readonly maxTagsReached: KnockoutObservableBase<boolean>;
        /**
         * Triggers validation on all child elements.
         */
        readonly triggerValidation: () => Promise<boolean>;
        /**
         * Validations on the control.
         */
        readonly validations: KnockoutObservableArray<Validation<TaggedResource[]>>;
        /**
         * Indicates the validation state of the grid.
         * This is the result of the latest validation.
         */
        readonly valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Retrieves the tags for a given resource as a StringMap for the provisioner parameters.
         */
        readonly resourceTagsAsMap: (resource: TargetItem) => ReadonlyStringMap<string>;
    }
    /**
     * The types of items that can be passed to the TagsByResource control through the options object.
     */
    export type TargetItem = TargetResource | TargetResourceType;
    /**
     * Target resource details applied to dropdown.
     * Use the id property for updating deployment template.
     */
    export interface TargetResource {
        /**
         * Resource unique identifier.
         */
        readonly id: string;
        /**
         * Custom display name for target resource.
         */
        readonly displayName: string;
        /**
         * The number of resource instances.
         */
        readonly count: number | KnockoutObservableBase<number>;
    }
    /**
     * Target resource type details applied to dropdown.
     */
    export interface TargetResourceType {
        /**
         * The fully qualified resource type name (e.g., "Microsoft.Web/Sites").
         * Used for retrieving the localized display name.
         * If there is no asset defined in PDL matching this name, the string will be displayed as-is.
         */
        readonly resourceType: string;
        /**
         * The number of resource instances.
         */
        readonly count: number | KnockoutObservableBase<number>;
    }
    /**
     * A single tag item.
     */
    export interface TagItem {
        /**
         * The tag name or key.
         */
        readonly name: string;
        /**
         * The tag value.
         */
        readonly value: string;
    }
    /**
     * Output of user-defined key/value pairs by ID.
     */
    export interface TaggedResource {
        /**
         * The unique identifier for the resource.
         */
        readonly id: string;
        /**
         * Set of key/value pairs used to tag the resource type.
         */
        readonly tags: ReadonlyArray<TagItem>;
    }
    /**
     * Command information for button and menu commands.
     */
    export interface Command {
        /**
         * The label for the command.
         */
        readonly label: string;
        /**
         * The icon for the command.
         */
        readonly icon: MsPortalFx.Base.Image;
        /**
         * The flag which indicates whether the command can execute or not.
         */
        readonly canExecute: KnockoutObservableBase<boolean>;
        /**
         * The callback to execute the command.
         */
        readonly execute: (target: CommandTarget) => Promise<void>;
    }
    /**
     * Target information for the button and menu commands.
     */
    export interface CommandTarget {
        /**
         * The name of the tag.
         */
        readonly name: string;
        /**
         * The value of the tag.
         */
        readonly value: string;
        /**
         * The resources associated with the tag.
         */
        readonly resources: ReadonlyArray<string>;
    }
    /**
     * Creates a TagsByResource control.
     *
     * @param lifetime The lifetime manager for the TagsByResource control.
     * @param options The options for creating the TagsByResource control.
     * @returns The created TagsByResource control.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\TextBlock.d.ts
declare module "Fx/Controls/TextBlock" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options for configuring a TextBlock control
     */
    export interface Options {
        /**
         * Text shown in the TextBlock
         */
        text?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * TextBlock control view model
     */
    export interface Contract extends Control {
        /**
         * Text shown in the TextBlock
         */
        readonly text: KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        readonly visible: KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        readonly cssClass: KnockoutObservableBase<string>;
    }
    /**
     * Creates a TextBlock control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a TextBlock viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TextBox.d.ts
declare module "Fx/Controls/TextBox" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Events on which value of the control can be updated
     */
    export import ValueUpdateTrigger = FormBase.ValueUpdateTrigger;
    /**
     * Options for configuring a TextBox control.
     */
    export interface Options {
        /**
         * The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Validations on the control.
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup.
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * When set, the TextBox will be read only.
         */
        readOnly?: boolean | KnockoutObservableBase<boolean>;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Determines when the control will update its value in response to the user typing into it.
         */
        valueUpdateTrigger?: ValueUpdateTrigger;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Aria label for the TextBox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Show validation as a popup to the right of the control.
         */
        showValidationsAsPopup?: boolean;
        /**
         * Enable the TextBox to be spellchecked. Default is false.
         * (Warning. Perf hit. Do not enable this for a large text).
         */
        spellcheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        hideValidationCheck?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: string) => void;
    }
    /**
     * TextBox control viewmodel.
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<string>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
        /**
         * When set, the TextBox will be read only.
         */
        readonly readOnly: KnockoutObservableBase<boolean>;
        /**
         * Specifies whether to hide the validation check marks.
         */
        readonly hideValidationCheck: KnockoutObservableBase<boolean>;
        /**
         * Event is triggered when user presses the enter key.
         */
        readonly onEnterPressed: (value: string) => void;
        /**
         * Enable the TextBox to be spellchecked. Default is false.
         * (Warning. Perf hit. Do not enable this for a large text).
         */
        readonly spellcheck: KnockoutObservableBase<boolean>;
    }
    /**
     * Creates a TextBox control viewmodel.
     *
     * @param lifetime The lifetime of the control.
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a TextBox viewmodel.
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\TimePicker.d.ts
declare module "Fx/Controls/TimePicker" {
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Defines a range of date/time
     */
    export import DateTimeRange = FormBase.DateTimeRange;
    /**
     * Options for configuring a time picker control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the DatePicker.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        enabledDateTimeRange?: DateTimeRange | KnockoutObservableBase<DateTimeRange> | DateTimeRange[] | KnockoutObservableArray<DateTimeRange>;
        /**
         * Whether the control should allow empty(null) value as valid.
         */
        allowEmpty?: boolean;
        /**
         * The text shown when no value is set in the control.
         */
        placeHolderText?: string | KnockoutObservableBase<string>;
        /**
         * If true displays hours, minutes, and seconds. If false displays only hours and minutes.
         */
        showSeconds?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Date | KnockoutObservableBase<Date>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
    }
    /**
     * TimePicker control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Date>;
        /**
         * Date/time range in which user is able to select date/time.
         */
        readonly enabledDateTimeRange: KnockoutObservableBase<DateTimeRange> | KnockoutObservableArray<DateTimeRange>;
        /**
         * The text shown when no value is set in the control.
         */
        readonly placeHolderText: KnockoutObservableBase<string>;
    }
    /**
     * Creates a time picker control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a time picker control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Toggle.d.ts
declare module "Fx/Controls/Toggle" {
    import { Contract as FormBaseContract } from "Fx/Controls/FormBase";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Text value shown besides the toggle control.
     */
    export interface ValueText {
        /**
         * Text value shown besides the toggle control during on state.
         */
        onText: string | HtmlContent;
        /**
         * Text value shown besides the toggle control during off state.
         */
        offText: string | HtmlContent;
    }
    /**
     * Options for the Toggle control.
     */
    export interface Options {
        /**
         *  The label of the control.
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Text for screen readers.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Options text value for when the Toggle is in either active or inactive state.
         */
        valueText?: ValueText | KnockoutObservableBase<ValueText>;
        /**
         * validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set, the control will never be in a dirty state. This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed. Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * Indicates if the control is currently disabled.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         *  Indicates whether the control is visble or not.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Initial value of the control.
         */
        value?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * Toggle control view model
     */
    export interface Contract extends FormBaseContract {
        /**
         * The value of the control.
         */
        readonly value: KnockoutObservableBase<boolean>;
        /**
         * Options text value for when the Toggle is in either active or inactive state.
         */
        readonly valueText: KnockoutObservableBase<ValueText>;
    }
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
}

// FILE: Fx\Controls\Toolbar.d.ts
declare module "Fx/Controls/Toolbar" {
    import { Image } from "Fx/Images";
    import { AnyBladeContainer } from "Fx/Composition/BladeBase";
    import { BladeLink, ResourceLink, ClickableLink, OnClickHandler } from "Fx/Composition";
    import * as FileDownload from "Fx/Controls/FileDownload";
    import { Control } from "Fx/Controls/ControlsBase";
    import * as FileUpload from "Fx/Controls/FileUpload";
    import { HtmlContent } from "Fx/Controls/ControlsBase";
    export { HtmlContent };
    export import DownloadContextCallback = FileDownload.DownloadContextCallback;
    export import DownloadDialogOptions = FileDownload.DownloadDialogOptions;
    export import DownloadStatus = FileDownload.DownloadStatus;
    export import DataUriContext = FileDownload.DataUriContext;
    export import SasLikeContext = FileDownload.SasLikeContext;
    export import OAuthContext = FileDownload.OAuthContext;
    export import BlobUriContext = FileDownload.BlobUriContext;
    /**
     * Union type of all items supported by the Toolbar.
     */
    export type ToolbarItem = ToolbarItems.BasicButtonContract | ToolbarItems.ToggleButtonContract | ToolbarItems.MoveResourceButtonContract | ToolbarItems.OAuthButtonContract | ToolbarItems.SeparatorContract | ToolbarItems.BlobUriFileDownloadButtonContract | ToolbarItems.DataUriFileDownloadButtonContract | ToolbarItems.SasLikeFileDownloadButtonContract | ToolbarItems.OAuthFileDownloadButtonContract | ToolbarItems.StreamFileUploadButtonContract | ToolbarItems.BlobFileUploadButtonContract<any> | ToolbarItems.MenuButtonContract | ToolbarItems.FeedbackButtonContract;
    /**
     * Union type of all items supported by the Menu Button
     */
    export type MenuItem = Exclude<ToolbarItem | ToolbarItems.MenuItemCustomButtonContract, ToolbarItems.MenuButtonContract>;
    /**
     * Options used to configure the toolbar control.
     */
    export interface Options {
        /**
         * Controls label visibility.  Defaults to false.
         */
        readonly showLabels?: boolean | KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently disabled. Defaults to false.
         */
        readonly disabled?: boolean | KnockoutObservable<boolean>;
        /**
         * Items shown in the toolbar.
         */
        readonly items: ToolbarItems.ToolbarItemContract[] | KnockoutObservable<ToolbarItems.ToolbarItemContract[]>;
    }
    /**
     * Toolbar control viewmodel.
     */
    export interface Contract extends Control {
        /**
         * Controls label visibility.
         */
        readonly showLabels: KnockoutObservable<boolean>;
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservable<boolean>;
        /**
         * Sets the list of items that will be shown in the toolbar.
         */
        readonly setItems: (items: ToolbarItems.ToolbarItemContract[]) => void;
    }
    /**
     * Creates a toolbar viewmodel.
     *
     * @param lifetime lifetime of the viewmodel
     * @param options Options used to configure the toolbar
     * @returns A toolbar viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options: Options): Contract;
    /**
     * namespace for all toolbar item create methods and their respective interfaces.
     */
    export namespace ToolbarItems {
        /**
         * Base toolbar item interface.
         */
        interface ToolbarItemContract extends MsPortalFx.ToolbarItemContract {
            /**
             * Set by the button create methods and used internally.
             * Exposed on the public API surface in order to provide some measure of type safety when passing in items into toolbar apis.
             */
            readonly type: number;
        }
        /**
         * Base toolbar button viewmodel.
         */
        interface BaseButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel: KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip: KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label: KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon: KnockoutObservableBase<Image>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass: KnockoutObservableBase<string>;
        }
        /**
         * Options used to configure a toolbar button.
         */
        interface BasicButtonOptions {
            /**
             * callback invoked when the button is clicked.
             */
            readonly onClick: OnClickHandler | BladeLink | ResourceLink | ClickableLink;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Toolbar button viewmodel.
         */
        interface BasicButtonContract extends BaseButtonContract {
        }
        /**
         * Creates a toolbar button viewmodel.
         *
         * @param lifetime
         * @param options
         * @returns A toolbar button viewmodel
         */
        function createBasicButton(lifetime: MsPortalFx.Base.LifetimeManager, options: BasicButtonOptions): BasicButtonContract;
        /**
         * Options used to create a toggle button.
         */
        interface ToggleButtonOptions {
            /**
             * State of the toggle button.
             */
            readonly checked?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The option group that contains the toggle button.
             */
            readonly optionGroupName?: string;
            /**
             * callback invoked when the button is clicked.
             * data is the state of the button.
             */
            readonly onToggled: (checked: boolean) => void;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the button.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Toggle button viewmodel
         */
        interface ToggleButtonContract extends BaseButtonContract {
            /**
             * The Current state of the toggle button.
             */
            readonly checked: KnockoutObservableBase<boolean>;
        }
        /**
         * Creates a toggle button viewmodel.
         *
         * @param lifetime the lifetime of the viewmodel
         * @param options Options used to create the viewmodel
         * @returns A create button viewmodel
         */
        function createToggleButton(lifetime: MsPortalFx.Base.LifetimeManager, options: ToggleButtonOptions): ToggleButtonContract;
        /**
         * Options used to configure an OAuth button.
         */
        interface OAuthButtonOptions {
            /**
             * Request url used to pop up the OAuth window.
             */
            readonly requestUrl?: string | KnockoutObservable<string>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * OAuth button viewmodel
         */
        interface OAuthButtonContract extends BaseButtonContract {
            /**
             * Request url used to pop up the OAuth window.
             */
            readonly requestUrl: KnockoutObservable<string>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth: KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight: KnockoutObservable<number>;
            /**
             * This will be updated with the value of the full url containing the token once the user has signed in.
             */
            readonly value: KnockoutReadOnlyObservable<string>;
        }
        /**
         * Creates an OAuth button.
         *
         * @param lifetime lifetime of the viewmodel
         * @param options Options used to create the OAuth button viewmodel
         * @returns An OAuth button viewmodel
         */
        function createOAuthButton(lifetime: MsPortalFx.Base.LifetimeManager, options?: OAuthButtonOptions): OAuthButtonContract;
        /**
         * The selected resources for move operation.
         */
        interface MoveResourcesSelection {
            /**
             * The id of the resource to be moved.
             */
            readonly resourceId: string;
            /**
             * The region of the resource to be moved.
             */
            readonly sourceRegion?: string;
        }
        /**
         * Options used to configure the move resource button
         */
        interface MoveResourceButtonOptions {
            /**
             * The id of the resource to be moved.
             */
            readonly resourceId: string;
            /**
             * Opens the move blade as a sub journey.
             */
            readonly asSubJourney?: boolean;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
            /**
             * A list of selected resource ids for move operation.
             */
            readonly selectedResourceIds?: ReadonlyArray<MoveResourcesSelection> | KnockoutReadOnlyObservableArray<MoveResourcesSelection>;
            /**
             * A flag indicating whether to show region move option or not.
             */
            readonly enableRegionMove?: boolean;
            /**
             * A flag indicating whether to show zonal move option or not.
             */
            readonly enableZonalMove?: boolean;
        }
        /**
         * Move resource button viewmodel.
         */
        interface MoveResourceButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass: KnockoutObservableBase<string>;
        }
        /**
         * Creates a move resource button.
         *
         * @param container the container hosting this control
         * @param options Options used to configure the move resource button
         * @returns A move resource button viewmodel
         */
        function createMoveResourceButton(container: AnyBladeContainer, options: MoveResourceButtonOptions): MoveResourceButtonContract;
        /**
         * Options used to configure a data uri download button.
         */
        interface DataUriFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: DataUriContext | DownloadContextCallback<DataUriContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Disable default download error notifications.
             * Extension can raise their own custom notifications.
             */
            readonly disableNotifications?: boolean;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Data uri download button viewmodel.
         */
        interface DataUriFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates a data uri download button viewmodel
         *
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a data uri download button
         * @returns a data uri download button viewmodel
         */
        function createDataUriFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: DataUriFileDownloadButtonOptions): DataUriFileDownloadButtonContract;
        /**
         * Options used to configure a sas like download button.
         */
        interface SasLikeFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: SasLikeContext | DownloadContextCallback<SasLikeContext>;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Disable default download error notifications.
             * Extension can raise their own custom notifications.
             */
            readonly disableNotifications?: boolean;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Sas-like download button viewmodel.
         */
        interface SasLikeFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
        }
        /**
         * Creates a sas-like download button viewmodel
         *
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a sas-like download button
         * @returns a sas-like download button viewmodel
         */
        function createSasLikeFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: SasLikeFileDownloadButtonOptions): SasLikeFileDownloadButtonContract;
        /**
         * Options used to configure an OAuth download button.
         */
        interface OAuthFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: OAuthContext | DownloadContextCallback<OAuthContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Disable default download error notifications.
             * Extension can raise their own custom notifications.
             */
            readonly disableNotifications?: boolean;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * OAuth download button viewmodel.
         */
        interface OAuthFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates an OAuth download button viewmodel
         *
         * @param container the lifetime of the viewmodel
         * @param options Options used to create an OAuth download button
         * @returns an OAuth download button viewmodel
         */
        function createOAuthFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: OAuthFileDownloadButtonOptions): OAuthFileDownloadButtonContract;
        /**
         * Options used to configure a blob uri download button.
         */
        interface BlobUriFileDownloadButtonOptions {
            /**
             * Provide the properties needed for making an authenticated file download using OAuth token
             * or provide a callback which will return the properties for making an authenticated file download using OAuth token.
             */
            readonly downloadContext?: BlobUriContext | DownloadContextCallback<BlobUriContext>;
            /**
             * Callback executed when download is complete.
             */
            readonly onComplete?: (downloadStatus: DownloadStatus) => void;
            /**
             * The width of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupWidth?: number | KnockoutObservable<number>;
            /**
             * The height of the popup. Set to half the height of the screen if not specified.
             */
            readonly popupHeight?: number | KnockoutObservable<number>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle?: string | KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage?: string | KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions?: DownloadDialogOptions | KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Disable default download error notifications.
             * Extension can raise their own custom notifications.
             */
            readonly disableNotifications?: boolean;
            /**
             * Callback executed before download is initiated.
             */
            readonly onStart?: () => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
        }
        /**
         * Blob uri download button viewmodel.
         */
        interface BlobUriFileDownloadButtonContract extends BaseButtonContract {
            /**
             * Specify the error title when file download fails.
             * This error title will be used to send notification to the user to indicate download failure.
             */
            readonly errorTitle: KnockoutObservableBase<string>;
            /**
             * Specify the error message when file download fails.
             * This error message will be used to send notification to the user along with internal http status code.
             * If this error message is not specified, a default file download error message will be used for notification.
             */
            readonly errorMessage: KnockoutObservableBase<string>;
            /**
             * Specify the resource strings for callback execution progress, download confirmation and/or download progress.
             */
            readonly downloadDialogOptions: KnockoutObservableBase<DownloadDialogOptions>;
            /**
             * Indicates if the file is downloaded successfully or not.
             * When command is executing and downloading the file, the downloadStatus will be set to null.
             */
            readonly downloadStatus: KnockoutReadOnlyObservable<DownloadStatus>;
        }
        /**
         * Creates a blob uri download button viewmodel
         *
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a blob uri download button
         * @returns a blob uri download button viewmodel
         */
        function createBlobUriFileDownloadButton(container: MsPortalFx.Base.LifetimeManager, options: BlobUriFileDownloadButtonOptions): BlobUriFileDownloadButtonContract;
        /**
         * Base options for configuring a file upload button.
         */
        interface FileUploadButtonOptions {
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The button label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the button.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file mime-types, excluding extensions.
             * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
             * The file filtering  behavior depends on native browser support.
             */
            readonly accept?: string | KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file extensions.
             * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
             * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
             * Eg: "pfx,cer"
             */
            readonly allowedFileExtensions?: string | KnockoutObservableBase<string>;
            /**
             * The maximum number of files allowed to be uploaded at once.
             * This limit is applied post-selection.
             */
            readonly maxFiles?: number;
        }
        /**
         * Options for configuring a file upload button for streaming file uploads.
         */
        interface StreamFileUploadButtonOptions extends FileUploadButtonOptions {
            /**
             * The stream upload context.
             */
            uploadContext: FileUpload.StreamFileUploadContext | KnockoutObservableBase<FileUpload.StreamFileUploadContext>;
        }
        /**
         * Options for configuring a file upload button for blob store file uploads.
         */
        interface BlobFileUploadButtonOptions<T> extends FileUploadButtonOptions {
            /**
             * The blob store upload context around how/where to upload and size limits.
             */
            uploadContext: FileUpload.BlobStoreFileUploadContext<T> | KnockoutObservableBase<FileUpload.BlobStoreFileUploadContext<T>>;
        }
        /**
         * FileUpload button view model contract.
         */
        interface FileUploadButtonContract extends BaseButtonContract {
            /**
             * A comma-separated list of allowed file mime-types, excluding extensions.
             * This maps directly to the HTML accept attribute for file input controls and filters the file based on specified mime-types in the file browse dialog.
             * The file filtering  behavior depends on native browser support.
             */
            readonly accept: KnockoutObservableBase<string>;
            /**
             * A comma-separated list of allowed file extensions.
             * This is upload control specific validations that will validate if the selected file is in the allowed file extension list.
             * If the selected file is not in the extension list, a validation error will be flagged and the selected file will be marked as invalid.
             * Eg: "pfx,cer"
             */
            readonly allowedFileExtensions: KnockoutObservableBase<string>;
            /**
             * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress etc.
             * UploadTask is used to initiate the file upload, pause/resume uploads, cancel and dispose the file upload.
             */
            readonly uploadTasks: KnockoutReadOnlyObservableArray<FileUpload.AsyncUploadTaskContract>;
            /**
             * Method to reset the uploadTasks array. This method will use the widget callback to initialize the uploadTasks array with empty array.
             * Calling this method will not dispose(abort) the uploads.
             * Uploads which have already started will continue upload in the background.
             * Uploads which have not been started will be cleaned up.
             */
            readonly resetUploadTasks: () => Promise<void>;
        }
        /**
         * FileUpload button view model contract for streaming file upload.
         */
        interface StreamFileUploadButtonContract extends FileUploadButtonContract {
            /**
             * The stream upload context.
             */
            readonly uploadContext: KnockoutObservableBase<FileUpload.StreamFileUploadContext>;
        }
        /**
         * FileUpload button view model for blob store file uploads.
         */
        interface BlobFileUploadButtonContract<T> extends FileUploadButtonContract {
            /**
             * The blob store upload context around how/where to upload and size limits.
             */
            readonly uploadContext: KnockoutObservableBase<FileUpload.BlobStoreFileUploadContext<T>>;
        }
        /**
         * Creates a FileUpload button view model for Stream File uploads.
         *
         * @param lifetime The lifetime of the file upload button
         * @param options Options that modify the appearance and behavior of the file upload button.
         * @returns a file upload button view model
         */
        function createStreamUploadButton(lifetime: MsPortalFx.Base.LifetimeManager, options: StreamFileUploadButtonOptions): StreamFileUploadButtonContract;
        /**
         * Creates a FileUpload button view model for Blob store and Azure File Service uploads.
         *
         * @param lifetime The lifetime of the file upload button
         * @param options BlobFileUploadButtonOptions that modify the appearance and behavior of the file upload button.
         * @returns a file upload button viewmodel
         */
        function createBlobStoreUploadButton<T>(lifetime: MsPortalFx.Base.LifetimeManager, options: BlobFileUploadButtonOptions<T>): BlobFileUploadButtonContract<T>;
        /**
         * Options for configuring a custom menu item button.
         */
        interface MenuItemCustomButtonOptions extends BasicButtonOptions {
            /**
             * Menu item button can render text content or html content.
             */
            readonly content?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        }
        /**
         * Custom menu item button view model contract.
         * This button can render html content.
         * This button must be used only in Menu button.
         */
        interface MenuItemCustomButtonContract extends BaseButtonContract {
        }
        /**
         * Creates an instance of custom menu item button view model.
         * This button visually differs from other buttons as it can render html content.
         * This button must be used only in Menu button.
         *
         * @param lifetime The lifetime of the view model.
         * @param options Options to configure the appearance of custom menu item button.
         * @returns an instance of custom menu item button viewmodel
         */
        function createMenuItemCustomButton(lifetime: MsPortalFx.Base.LifetimeManager, options: MenuItemCustomButtonOptions): MenuItemCustomButtonContract;
        /**
         * Options used to configure a menu button
         */
        interface MenuButtonOptions {
            /**
             * Buttons shown in the menu
             */
            readonly buttons?: MenuItem[] | KnockoutObservableBase<MenuItem[]>;
            /**
             * The aria label to use instead of the default text label.
             */
            readonly ariaLabel?: string | KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip?: string | KnockoutObservableBase<string>;
            /**
             * The command label.
             */
            readonly label?: string | KnockoutObservableBase<string>;
            /**
             * The icon for the command.
             */
            readonly icon?: Image | KnockoutObservableBase<Image>;
            /**
             * The disabled state of the button.
             */
            readonly disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            readonly disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * A custom css class applied to the button.
             */
            readonly cssClass?: string | KnockoutObservableBase<string>;
            /**
             * Optionally popup width can be specified.
             */
            readonly popupWidth?: number | KnockoutObservableBase<number>;
        }
        /**
         * Group button viewmodel.
         */
        interface MenuButtonContract extends BaseButtonContract {
            /**
             * Buttons shown in the menu
             */
            readonly buttons: KnockoutObservableBase<MenuItem[]>;
            /**
             * Optionally popup width can be specified.
             */
            readonly popupWidth: KnockoutObservableBase<number>;
        }
        /**
         * Creates a menu button viewmodel
         *
         * @param container the lifetime of the viewmodel
         * @param options Options used to create a menu button
         * @returns a menu button viewmodel
         */
        function createMenuButton(container: MsPortalFx.Base.LifetimeManager, options: MenuButtonOptions): MenuButtonContract;
        /**
         * Toolbar separator.
         */
        interface SeparatorContract extends ToolbarItemContract {
        }
        /**
         * Creates a toolbar separator.
         *
         * @returns a toolbar separator viewmodel
         */
        function createSeparator(): SeparatorContract;
        /**
         * Toolbar feedback button.
         */
        interface FeedbackButtonContract extends ToolbarItemContract {
            /**
             * disables this toolbar item.
             * message is the tooltip shown for the disabled item.
             */
            readonly disabled: KnockoutObservableBase<boolean>;
            /**
             * enables the toolbar item.
             */
            readonly disabledMessage: KnockoutObservableBase<string>;
            /**
             * The regular tooltip of the toolbar item.
             */
            readonly tooltip: KnockoutObservableBase<string>;
        }
        /**
         * Options for the feedback button.
         */
        interface FeedbackButtonOptions {
            /**
             * Callback triggered after the button is clicked, and subsequently after the feedback pane opens.
             * Note that this callback cannot be used for navigation.
             * Note that this callback is often supplied by extensions to perform custom logging/telemetry.
             *
             * @param keypress Indicates if the button is opened by keypress.
             */
            readonly onButtonClicked?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName: string;
        }
        /**
         * Creates a feedback button.
         *
         * @param container The lifetime of the viewmodel.
         * @param options The feedback button options.
         * @returns a feedback button viewmodel
         */
        function createFeedbackButton(container: MsPortalFx.Base.LifetimeManager, options: FeedbackButtonOptions): FeedbackButtonContract;
        /**
         * Item to be written to or read from the clipboard.
         */
        interface ClipboardContent {
            /**
             * The type of the data to stored in the clipboard
             */
            typeName: string;
            /**
             * The data to be stored in the clipboard
             */
            data: unknown;
        }
        /**
         * Copy to clipboard button.
         */
        interface CopyButtonOptions {
            /**
             * The aria label to use instead of the default text label.
             */
            ariaLabel?: KnockoutObservableBase<string> | string;
            /**
             * The regular tooltip of the toolbar item.
             */
            tooltip?: KnockoutObservableBase<string> | string;
            /**
             * The command label.
             */
            label?: KnockoutObservableBase<string> | string;
            /**
             * Telemetry identifier.
             */
            telemetryName?: string;
            /**
             * The icon for the command.
             */
            icon?: KnockoutObservableBase<Image> | Image;
            /**
             * The disabled state of the button.
             */
            disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * custom css class applied to the button.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * Called when the copy button is clicked, the value returned is written to the clipboard
             */
            readonly onClick: () => ClipboardContent | string;
        }
        /**
         * Paste from clipboard button.
         */
        interface PasteButtonOptions {
            /**
             * The aria label to use instead of the default text label.
             */
            ariaLabel?: KnockoutObservableBase<string> | string;
            /**
             * The regular tooltip of the toolbar item.
             */
            tooltip?: KnockoutObservableBase<string> | string;
            /**
             * The command label.
             */
            label?: KnockoutObservableBase<string> | string;
            /**
             * Telemetry identifier.
             */
            telemetryName?: string;
            /**
             * The icon for the command.
             */
            icon?: KnockoutObservableBase<Image> | Image;
            /**
             * The disabled state of the button.
             */
            disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The tooltip shown when the button is disabled.
             */
            disabledMessage?: string | KnockoutObservableBase<string>;
            /**
             * custom css class applied to the button.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * Called when the paste button is clicked, the value passed to this function is what has been read from the clipboard
             */
            readonly onClick: (values: ClipboardContent | string) => void;
        }
        /**
         * The viewmodel for the Clipboard CopyButton control.
         */
        interface CopyButtonContract extends BaseButtonContract {
        }
        /**
         * The viewmodel for the Clipboard PasteButton control.
         */
        interface PasteButtonContract extends BaseButtonContract {
        }
        /**
         * Creates an copy button.
         *
         * @param lifetime The lifetime for the created view model.
         * @param options The options to configure the ClipboardButton to copy to the clipboard.
         * @returns a ClipboardButton viewmodel
         */
        function createCopyButton(container: MsPortalFx.Base.LifetimeManager, options: CopyButtonOptions): CopyButtonContract;
        /**
         * Creates an paste button.
         *
         * @param lifetime The lifetime for the created view model.
         * @param options The options to configure the ClipboardButton to paste from the clipboard
         * @returns a ClipboardButton viewmodel
         */
        function createPasteButton(lifetime: MsPortalFx.Base.LifetimeManager, options: PasteButtonOptions): PasteButtonContract;
    }
}

// FILE: Fx\Controls\TreeView.d.ts
declare module "Fx/Controls/TreeView" {
    import * as ControlsBase from "Fx/Controls/ControlsBase";
    import * as Toolbar from "Fx/Controls/Toolbar";
    import { Image } from "Fx/Images";
    import ToolbarItemContract = Toolbar.ToolbarItems.ToolbarItemContract;
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * A query result from loading items.
     * This is returned by loadMoreChildItems.
     */
    export interface LoadMoreItemsResult<TItem> {
        /**
         * The newly fetched items.
         */
        readonly items: TItem[];
        /**
         * The continuation token used to request next chunk of data.
         */
        readonly continuationToken: any;
    }
    /**
     * A metadata entry corresponding to a single item in the TreeView.
     */
    export interface ItemMetadata {
        /**
         * Gets or sets whether the item is expanded or not (effective if the item has child items).
         */
        readonly expanded?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is disabled.
         */
        readonly disabled?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is focused.
         */
        readonly focused?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selected.
         */
        readonly selected?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is selectable.
         * Observably changing this value will not change selected state of the item.
         */
        readonly selectable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item has deferred loading.
         */
        readonly loadable?: KnockoutObservable<boolean>;
        /**
         * Indicates if the item is loadable by a continuation token through loadMoreChildItems.
         */
        readonly loadableByContinuationToken?: KnockoutObservable<boolean>;
    }
    /**
     * Sequential loading options.
     */
    export interface SequentialLoadingOptions<TItem extends Item> {
        /**
         * Callback for when the user clicks "load more" as a child of the item.
         *
         * @param item The item that is getting more children.
         * @param continuationToken The continuation token supplied by previous calls for this item.
         * @returns A promise for the newly loaded children and a continuation token for the next call.
         */
        loadMoreChildItems?: (item: TItem, continuationToken: any) => Promise<LoadMoreItemsResult<TItem>>;
        /**
         * Callback for when the user clicks "load more" at the root of the tree.
         * Note: The tree will show a "load more" item at the root as long as canLoadMoreRootItems is set to true.
         * If there are no more items to fetch after this call, set canLoadMoreRootItems to false.
         * Extension authors are responsible for keeping track of what items to load next.
         *
         * @returns A promise for the items to load into the tree.
         */
        loadMoreRootItems?: () => Promise<TItem[]>;
        /**
         * Determines whether or not to show the "load more" button at the root of the tree.
         */
        canLoadMoreRootItems?: KnockoutObservableBase<boolean>;
    }
    /**
     * Selection modes supported by the tree view control.
     */
    export const enum SelectionMode {
        /**
         * Single selection
         */
        Single = 0,
        /**
         * Multiple selection
         */
        Multiple = 1
    }
    /**
     * Selected item data.
     */
    export interface SelectedItem<TItem> {
        /**
         * The item.
         */
        readonly item: TItem;
        /**
         * The item path.
         */
        readonly path: string;
    }
    /**
     * Options for treeView selection.
     */
    export interface SelectionOptions<TItem extends Item> {
        /**
         * Selection mode of the tree.  Defaults to single selection
         */
        selectionMode?: SelectionMode;
        /**
         * Add custom click handler for tree item.
         */
        onItemClicked?: (item: TItem) => void;
    }
    /**
     * Options for deferring loading of children until the item is expanded.
     */
    export interface DeferredLoadingOptions<TItem extends Item> {
        /**
         * Notifies that a load is required.
         *
         * @param item The tree item.
         * @param path The tree item path.
         */
        loadItem?: (item: TItem, path: string) => void;
    }
    /**
     * Options for the TreeView context menu.
     */
    export interface ContextMenuOptions<TItem extends Item> {
        /**
         * Supplies commands to be displayed in the tree item context menu.
         *
         * @param item The tree item.
         * @param commandLifetime The lifetime manager for any command related allocations.
         * @returns The commands for the context menu or a promise for the commands.
         */
        supplyCommands?: (item: TItem, commandLifetime: LifetimeManager) => ToolbarItemContract[] | Promise<ToolbarItemContract[]>;
    }
    /**
     * Options for TreeView creation.
     */
    export interface Options<TItem extends Item> {
        /**
         * The items to display in the TreeView.
         */
        items?: TItem[] | KnockoutObservableArray<TItem>;
        /**
         * Separator used to build the path of an item.
         * Default separator is forward slash "/".
         */
        pathSeparator?: string;
        /**
         * A map of html templates to be used by the items.
         * The items indicate the template to use from this map by the templateKey property.
         */
        htmlTemplates?: ReadonlyStringMap<string>;
        /**
         * Options for TreeView selection.
         * If null, items will not be selectable.
         */
        selection?: SelectionOptions<TItem>;
        /**
         * Options for the deferred loading of items upon expansion.
         * If null, children will not beloaded upon expand and the hierarchy needs to be loaded up-front.
         */
        deferredLoading?: DeferredLoadingOptions<TItem>;
        /**
         * Options for the sequential loading of child items.
         * If null, child items will be loaded at once.
         */
        sequentialLoading?: SequentialLoadingOptions<TItem>;
        /**
         * Options for displaying context menus.
         */
        contextMenu?: ContextMenuOptions<TItem>;
        /**
         * Classes to add to the tree fixture element class attribute.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Disabled state.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Loading state.
         */
        loading?: boolean | KnockoutObservableBase<boolean>;
    }
    /**
     * The TreeView hierarchy item contract.
     */
    export interface Item {
        /**
         * Text of the item.
         */
        readonly text: KnockoutObservableBase<string>;
        /**
         * Child items of this item.
         */
        readonly items?: KnockoutObservableArray<Item>;
        /**
         * Icon specified to the item to be displayed with text.
         */
        readonly icon?: KnockoutObservableBase<Image>;
        /**
         * Css class specific to this item.
         */
        readonly cssClass?: KnockoutObservableBase<string>;
        /**
         * Metadata information about this item.
         */
        readonly metadata?: ItemMetadata;
        /**
         * Key of the template for this item.
         * This is the key of a template specified by the htmlTemplates property.
         */
        readonly templateKey?: KnockoutObservableBase<string>;
        /**
         * Optional alternate text for screen readers.
         */
        readonly ariaLabel?: KnockoutObservableBase<string>;
        /**
         * Suppresses context menu commands and hides the context menu icon for this item.
         */
        readonly noContextMenu?: KnockoutObservableBase<boolean>;
    }
    /**
     * The TreeView contract.
     */
    export interface Contract<TItem extends Item> extends ControlsBase.Control {
        /**
         * Indicates if the widget is currently disabled.
         */
        readonly disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        readonly loading: KnockoutObservableBase<boolean>;
        /**
         * Classes to add to the tree fixture element class attribute.
         */
        readonly cssClass: KnockoutObservableBase<string>;
        /**
         * Items displayed in the tree.
         */
        readonly items: KnockoutObservableArray<TItem>;
        /**
         * Amount of child item padding in px.
         */
        readonly padding: KnockoutObservable<number>;
        /**
         * Indicates whether all the items in tree are visible and expand/collapse icons are invisible.
         */
        readonly alwaysExpanded: KnockoutObservable<boolean>;
        /**
         * Expands a treeview item.
         *
         * @param item The treeview item to expand
         */
        expandNode(item: Item): void;
        /**
         * Collapses a treeview item.
         *
         * @param item The treeview item to collapses
         */
        collapseNode(item: Item): void;
        /**
         * Toggles the expanded state of a treeview item.
         *
         * @param item The treeview item to collapses
         * @param expanded Optional. The desired expanded state of the treeview item.
         */
        toggleNode(item: Item, expanded?: boolean): void;
        /**
         * Load more nodes by continuation token.
         *
         * @param item The treeview item to be appended (parentNode)
         * @returns new continuationToken or null (no data to be fetched)
         */
        loadMoreChildItems(item: TItem, continuationToken: any): Promise<LoadMoreItemsResult<TItem>>;
        /**
         * Requests more items be loaded into the tree at the root level.
         *
         * @returns A promise for completion.
         */
        loadMoreRootItems(): Promise<void>;
        /**
         * Determines whether or not to show the "load more" button at the root of the tree.
         */
        readonly canLoadMoreRootItems: KnockoutObservableBase<boolean>;
        /**
         * Text label to be read out loud by screen readers for the tree root.
         */
        readonly ariaLabel: KnockoutObservableBase<string>;
        /**
         * The currently selected items of the tree.
         */
        readonly selectedItems: KnockoutReadOnlyObservableArray<SelectedItem<TItem>>;
        /**
         * Gets or sets the selection by paths to the selected items.
         */
        readonly selectedPaths: KnockoutObservableArray<string>;
    }
    /**
     * Creates a TreeView control.
     *
     * @param lifetime The lifetime manager for the TreeView.
     * @param options The options for creating the TreeView.
     * @returns The created TreeView.
     */
    export function create<TItem extends Item>(lifetime: LifetimeManager, options: Options<TItem>): Contract<TItem>;
}

// FILE: Fx\Controls\TriStateCheckBox.d.ts
declare module "Fx/Controls/TriStateCheckBox" {
    import { HtmlContent, OverflowMode } from "Fx/Controls/ControlsBase";
    import * as FormBase from "Fx/Controls/FormBase";
    import { Validation } from "Fx/Controls/Validations";
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    export { HtmlContent };
    /**
     * Overflow Mode for text overflow
     */
    export { OverflowMode };
    /**
     * CheckBoxValue value states.
     */
    export const enum Value {
        /**
         * TriStateCheckBox state representing unchecked state.
         */
        Unchecked = 0,
        /**
         * TriStateCheckBox state representing checked state.
         */
        Checked = 1,
        /**
         * TriStateCheckBox state representing indeterminate state.
         */
        Indeterminate = 2
    }
    /**
     * Options for configuring a tri-state textbox control
     */
    export interface Options {
        /**
         * The label of the control
         */
        label?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The sublabel of the control. If supplied, also provide the `arialLabel` property with the `label` and `subLabel` values concatenated in a meaningful way for accessibility.
         * The subLabel is meant for suffixing or adding short, concise, inline helper text and it will be grayed out in disabled scenarios. Do not add whole controls in the subLabel as the framework cannot support hierarchical labelling, contrasting, or proper accessibility and usability for that usage.
         */
        subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * The aria-label on the control.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
        /**
         * Validations on the control
         */
        validations?: Validation[] | KnockoutObservableArray<Validation>;
        /**
         * Sanitized html string shown in the info balloon popup
         */
        infoBalloonContent?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
        /**
         * Aria label for the info balloon anchor.
         */
        infoBalloonAriaLabel?: string | KnockoutObservableBase<string>;
        /**
         * If set to true, the label will be placed to the right of the control
         */
        labelOnRight?: boolean;
        /**
         * If set to true, the user can set the indeterminate state of the control
         */
        userCanSetIndeterminate?: boolean;
        /**
         * If set, the control will never be in a dirty state.  This means it will not display dirty highlighting, nor will it trigger an alert when blades are closed.  Validation is not affected.
         */
        suppressDirtyBehavior?: boolean;
        /**
         * The disabled state of the control.
         */
        disabled?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The initial value of the control.  If an observable is provided, there will be a 2 way binding set up between the observable and the value of the control.
         */
        value?: Value | KnockoutObservableBase<Value>;
        /**
         * The visible state of the control.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A custom css class to apply to the control.
         */
        cssClass?: string | KnockoutObservableBase<string>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        overflowMode?: OverflowMode | KnockoutObservableBase<OverflowMode>;
    }
    /**
     * TriStateCheckBox control view model
     */
    export interface Contract extends FormBase.Contract {
        /**
         * The value of the control
         */
        readonly value: KnockoutObservableBase<Value>;
        /**
         * Overflow display mode for label text. If not supplied, overflow text would be wrapped to a new line.
         */
        readonly overflowMode: KnockoutObservableBase<OverflowMode>;
    }
    /**
     * Creates a tristate checkbox control viewmodel.
     *
     * @param lifetime The lifetime of the control
     * @param options Options that modify the appearance and behavior of the control.
     * @returns a tristate checkbox control viewmodel
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Controls\Validations.d.ts
declare module "Fx/Controls/Validations" {
    export import CaseInsensitiveComparisonOptions = MsPortalFx.ViewModels.CaseInsensitiveComparisonValidationOptions;
    export import CaseInsensitiveComparison = MsPortalFx.ViewModels.CaseInsensitiveComparisonValidation;
    export import ContainsOptions = MsPortalFx.ViewModels.ContainsValidationOptions;
    export import Contains = MsPortalFx.ViewModels.ContainsValidation;
    export import ContainsCharactersOptions = MsPortalFx.ViewModels.ContainsCharactersValidationOptions;
    export import ContainsCharacters = MsPortalFx.ViewModels.ContainsCharactersValidation;
    export import CustomOptions = MsPortalFx.ViewModels.CustomValidationOptions;
    export import Custom = MsPortalFx.ViewModels.CustomValidation;
    export import CustomOptionsV = MsPortalFx.ViewModels.CustomValidationOptionsV;
    export import CustomV = MsPortalFx.ViewModels.CustomValidationV;
    export import EqualsOptions = MsPortalFx.ViewModels.EqualsValidationOptions;
    export import Equals = MsPortalFx.ViewModels.EqualsValidation;
    export import HasDigitOptions = MsPortalFx.ViewModels.HasDigitValidationOptions;
    export import HasDigit = MsPortalFx.ViewModels.HasDigitValidation;
    export import HasLetterOptions = MsPortalFx.ViewModels.HasLetterValidationOptions;
    export import HasLetter = MsPortalFx.ViewModels.HasLetterValidation;
    export import HasLowerCaseLetterOptions = MsPortalFx.ViewModels.HasLowerCaseLetterValidationOptions;
    export import HasLowerCaseLetter = MsPortalFx.ViewModels.HasLowerCaseLetterValidation;
    export import HasPunctuationOptions = MsPortalFx.ViewModels.HasPunctuationValidationOptions;
    export import HasPunctuation = MsPortalFx.ViewModels.HasPunctuationValidation;
    export import HasUpperCaseLetterOptions = MsPortalFx.ViewModels.HasUpperCaseLetterValidationOptions;
    export import HasUpperCaseLetter = MsPortalFx.ViewModels.HasUpperCaseLetterValidation;
    export import InvalidOptions = MsPortalFx.ViewModels.InvalidValidationOptions;
    export import Invalid = MsPortalFx.ViewModels.InvalidValidation;
    export import LengthRangeOptions = MsPortalFx.ViewModels.LengthRangeValidationOptions;
    export import LengthRange = MsPortalFx.ViewModels.LengthRangeValidation;
    export import LocaleAwareCaseInsensitiveComparisonOptions = MsPortalFx.ViewModels.LocaleAwareCaseInsensitiveComparisonValidationOptions;
    export import LocaleAwareCaseInsensitiveComparison = MsPortalFx.ViewModels.LocaleAwareCaseInsensitiveComparisonValidation;
    export import MaxLengthOptions = MsPortalFx.ViewModels.MaxLengthValidationOptions;
    export import MaxLength = MsPortalFx.ViewModels.MaxLengthValidation;
    export import MaxValueOptions = MsPortalFx.ViewModels.MaxValueValidationOptions;
    export import MaxValue = MsPortalFx.ViewModels.MaxValueValidation;
    export import MinLengthOptions = MsPortalFx.ViewModels.MinLengthValidationOptions;
    export import MinLength = MsPortalFx.ViewModels.MinLengthValidation;
    export import MinValueOptions = MsPortalFx.ViewModels.MinValueValidationOptions;
    export import MinValue = MsPortalFx.ViewModels.MinValueValidation;
    export import NotContainsOptions = MsPortalFx.ViewModels.NotContainsValidationOptions;
    export import NotContains = MsPortalFx.ViewModels.NotContainsValidation;
    export import NotContainsCharactersOptions = MsPortalFx.ViewModels.NotContainsCharactersValidationOptions;
    export import NotContainsCharacters = MsPortalFx.ViewModels.NotContainsCharactersValidation;
    export import NotRegExMatchOptions = MsPortalFx.ViewModels.NotRegExMatchValidationOptions;
    export import NotRegExMatch = MsPortalFx.ViewModels.NotRegExMatchValidation;
    export import NumericOptions = MsPortalFx.ViewModels.NumericValidationOptions;
    export import Numeric = MsPortalFx.ViewModels.NumericValidation;
    export import RangeOptions = MsPortalFx.ViewModels.RangeValidationOptions;
    export import Range = MsPortalFx.ViewModels.RangeValidation;
    export import RegExMatchOptions = MsPortalFx.ViewModels.RegExMatchValidationOptions;
    export import RegExMatch = MsPortalFx.ViewModels.RegExMatchValidation;
    export import RequiredOptions = MsPortalFx.ViewModels.RequiredValidationOptions;
    export import Required = MsPortalFx.ViewModels.RequiredValidation;
    export import StaticMessageOptions = MsPortalFx.ViewModels.StaticMessageValidationOptions;
    export import StaticMessage = MsPortalFx.ViewModels.StaticMessageValidation;
    export import UriOptions = MsPortalFx.ViewModels.UriValidationOptions;
    export import Uri = MsPortalFx.ViewModels.UriValidation;
    export import Validation = MsPortalFx.ViewModels.FormValidation;
    export import ValidationResult = MsPortalFx.ViewModels.ValidationResult;
    export import ValidationState = MsPortalFx.ViewModels.Controls.Validators.ValidationState;
    export import ValidationType = MsPortalFx.ViewModels.FormValidationType;
}

// FILE: Fx\Controls\Video.d.ts
declare module "Fx/Controls/Video" {
    import { Control } from "Fx/Controls/ControlsBase";
    /**
     * Options that can be set on the Video control.
     */
    export interface Options {
        /**
         * Source of the video.
         */
        src?: KnockoutObservableBase<string> | string;
        /**
         * Play video immediately after load.
         */
        autoplay?: KnockoutObservableBase<boolean> | boolean;
        /**
         * On first play callback function.
         */
        onFirstPlay?: KnockoutObservableBase<Callback> | Callback;
    }
    /**
     * Video control view model
     */
    export interface Contract extends Control {
        /**
         * URL of the desired video (Supports HTML5 video, YouTube, Channel9).
         */
        src: KnockoutObservableBase<string>;
        /**
         * Play video immediately after load (only works for HTML5 and YouTube).
         */
        autoplay: KnockoutObservableBase<boolean>;
        /**
         * True if current video type supports autoplay.
         */
        canAutoplay: KnockoutReadOnlyObservable<boolean>;
        /**
         * Called when the video is played in first time (only works for HTML5, YouTube and Channel9).
         */
        onFirstPlay: KnockoutObservableBase<Callback>;
    }
    /**
     * Callback function type for events.
     */
    export type Callback = () => void;
    /**
     * Creates a Video control viewmodel.
     *
     * @param lifetime The lifetime for the created view model.
     * @param options The set of options to configure the Video view model.
     * @returns a Video view model
     */
    export function create(lifetime: MsPortalFx.Base.LifetimeManager, options?: Options): Contract;
}

// FILE: Fx\Cryptography.d.ts
declare module "Fx/Cryptography" {
    import FxRpc = FxImpl.Rpc;
    export module Internal {
        const getHmacSha256EndPoint: FxRpc.FuncEndPointDefinition<GetHmacSha256Options, string>;
        /**
         * Returns an hmac sha256 token generated by hashing the provided string with the specified key.
         *
         * @param options Parameters required by the function.
         * @param client The rpc client from which this call originates. Defaults to the current iFrame.
         *  Note: the default behavior should only be overridden for testing.
         * @returns A promise that resolves to a hmac sha256 hashed string.
         */
        function getHmacSha256(options: GetHmacSha256Options, client?: FxRpc.Client): Promise<string>;
    }
    /**
     * Options that must be passed when calling the getHmacSha256 function.
     */
    export interface GetHmacSha256Options {
        /**
         * The string to hash, can be any length.
         */
        stringToHash: string;
        /**
         * The key, encoded in base 64.
         */
        key: string;
        /**
         * Optional parameter to skip retry on failed API calls
         */
        skipRetry?: boolean;
    }
    /**
     * HmacSha256 RPC endpoint response interface
     */
    export interface HmacSha256ResponseModel {
        data: string;
    }
    /**
     * Returns an hmac sha256 token generated by hashing the provided string with the specified key.
     *
     * @param options Parameters required by the function.
     * @returns A promise that resolves to a hmac sha256 hashed string.
     */
    export function getHmacSha256(options: GetHmacSha256Options): Promise<string>;
    /**
     * Returns an hmac sha256 token generated by hashing the provided string with the specified key using browser crypto api.
     *
     * @param key The key, encoded in base 64.
     * @param stringToHash The string to hash, can be any length.
     */
    export function getHmacSha256UsingCryptoApi(key: string, stringToHash: string): Promise<string>;
}

// FILE: Fx\CustomNotificationsProvider.d.ts
declare module "Fx/CustomNotificationsProvider" {
    import { CommonOptions, PollingDetails, Status } from "Fx/Notifications";
    import ClientNotificationData = MsPortalFx.Hubs.Notifications.ClientNotificationData;
    /**
     * Data supplied for a client notification.
     */
    export interface SerializedNotification extends CommonOptions {
        /**
         * The notification's id.
         * Can be used to follow the notification's lifecycle in telemetry.
         */
        id: string;
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        readonly percentComplete?: number;
        /**
         * When present, this property provides the instructions on what to poll and
         * what notification properties to use in updating original polling notification for a given response to the polled url.
         */
        readonly pollingDetails?: PollingDetails;
        /**
         * The notification status - Information, InProgress, Warning, Error, Success.
         */
        readonly status: Status;
        /**
         * The notification's timestamp.
         */
        readonly timestamp: Date;
    }
    /**
     * A provider that allows two way communication between portal and a specified extension to allow the extension to manage a custom notifications pane.
     */
    export interface CustomNotificationsProvider {
        /**
         * Helps the portal to know if the custom notifications pane is currently open or closed.
         */
        readonly isPaneOpen: KnockoutObservable<boolean>;
        /**
         * List of notifications still active available to be read in the notifications pane.
         */
        readonly notifications: KnockoutObservableArray<ClientNotificationData | SerializedNotification>;
        /**
         * The number to be displayed over the topbar bell icon, signalling how many unread notifications there are.
         */
        readonly unreadNotificationsCount: KnockoutObservable<number>;
    }
}

// FILE: Fx\DataCache.d.ts
declare module "Fx/DataCache" {
    /**
     * Expiration types, all APIs default to caching for the lifetime of the current portal instance.
     */
    export const enum Expiration {
        /**
         * Cache is kept until this portal is closed, or manually cleared.
         */
        OnPortalClose = "PortalClose"
    }
    /**
     * Adds the value that the promise resolves to into the cache, note the value must be serializable.
     * Note that if a value already exists, this will update the existing value to match.
     * The value can later be retrieved using "get" or cleared using "clearItem".
     *
     * @param id The id for the cache entry
     * @param value The Promise that resolves to the value to put into the cache
     * @param expires Number of seconds before the entry is invalid, defaults to PortalClose (forever)
     * @returns the value that was passed in, for convenience in chaining
     */
    export function add<T>(id: string, value: Promise<T>, expires?: Expiration.OnPortalClose | number): Promise<T>;
    /**
     * Returns the cached value if available, otherwise returns a promise that by default waits for the value to become available.
     *
     * @example
     * A simple example of usage at the usage level
     * ```
     * const myResponse = await DataCache.get("myApi");
     * ```
     * @param id The id for the cache entry
     * @returns the value that was passed in, for convenience in chaining
     */
    export function get<T>(id: string, undefinedOnEmpty?: boolean): Promise<T>;
    /**
     * Returns the cached value if available, otherwise calls the callback, adds that value to cache, and returns it.
     * The value can later be retrieved using "get" or cleared using "clearItem".
     *
     * @example
     * A simple example of usage at the caller level
     * ```
     * const myResponse = await DataCache.getOrAdd("myApi", () => fetch("https://mysite.com/myApi")).then(r => r.json()));
     * ```
     * @param id The id for the cache entry
     * @param value The Promise that resolves to the value to put into the cache
     * @param expires Number of seconds before the entry is invalid, defaults to PortalClose (forever)
     * @returns the value that was passed in, for convenience in chaining
     */
    export function getOrAdd<T>(id: string, callback: () => Promise<T>, expires?: Expiration.OnPortalClose | number): Promise<T>;
    /**
     * Clears all cache entries.
     */
    export function clear(): void;
    /**
     * Clears any cache entries with the associated id.
     */
    export function clearItem(id: string): void;
}

// FILE: Fx\DependencyInjection.d.ts
declare module "Fx/DependencyInjection" {
    export * from "Fx/DependencyInjectionCore";
}

// FILE: Fx\DirectoryManagement.d.ts
declare module "Fx/DirectoryManagement" {
    /**
     * Directory information saved in user settings.
     */
    export interface UserSettingsDirectoryInfo {
        /**
         * Tenant id.
         */
        readonly id: string;
        /**
         * The tenant domain name.
         */
        readonly domainName: string;
        /**
         * The tenant display name.
         */
        readonly displayName: string;
    }
    /**
     * Interface for user's directory settings.
     */
    export interface UserDirectorySettings {
        /**
         * List of favorite tenants.
         */
        readonly favoriteDirectoriesList: ReadonlyArray<string>;
        /**
         * The default directory for the user.
         */
        readonly userDefaultDirectory: UserSettingsDirectoryInfo;
    }
    /**
     * Gets the current directory settings for the user.
     * Note: this is a highly privileged operation, only available to a small set of extensions.
     */
    export function getUserDirectorySettings(): Promise<UserDirectorySettings>;
    /**
     * Saves the given directory settings for the user.
     * Note: this is a highly privileged operation, only available to a small set of extensions.
     *
     * @param settings The directory settings to persist.
     * @returns A boolean indicating whether the settings were saved successfully.
     */
    export function saveUserDirectorySettings(settings: Partial<UserDirectorySettings>): Promise<boolean>;
}

// FILE: Fx\DynamicDx.d.ts
declare module "Fx/DynamicDx" {
    /**
     * The dynamic dx runtime model of a dx.json view.
     */
    export interface DynamicDxView {
        /**
         * The source content of the dx.json file.
         */
        readonly viewSource: {
            /**
             * The view json.
             */
            view: Record<string, any> & {
                /**
                 * The view kind.
                 */
                kind: string;
            };
        };
        /**
         * Optional resjson content for localization of fields in the view source.
         */
        readonly stringSource?: Record<string, string>;
        /**
         * Optional referenced file content. The record Keys are relative file paths, the Values are the file contents.
         */
        readonly files?: Record<string, any>;
    }
    /**
     * Dynamic dx handler options. This is the only input used to construct the dx content.
     */
    export interface DynamicDxOptions {
        /**
         * The blade name suffix.
         */
        readonly bladeNameSuffix: string;
    }
    /**
     * Registers the dynamic dx RPC handler for resolving source dx.json for a given blade name.
     * The response will be compiled on the fly and rendered as a standard dx blade from the extension.
     *
     * Dynamic dx should only be used for scenarios where the ux can't be statically compiled. An example
     * would be remote sources (like GitHub) used to create experiences in portal. In this case the
     * content changes at a cadence different than the deployment of the extension.
     *
     * @param handler dynamic dx handler
     */
    export function registerDynamicDxHandler(handler: DynamicDxHandler): void;
    /**
     * The DynamicDx handler used by shell during blade open to resolve the dynamic dx content of a given blade.
     *
     * @param options The dynamic dx options.
     * @returns A promise resulting in the dx view contents to be compiled.
     */
    export type DynamicDxHandler = (options: DynamicDxOptions) => Promise<DynamicDxView>;
}

// FILE: Fx\Feedback.d.ts
declare module "Fx/Feedback" {
    import Rpc = FxImpl.Rpc;
    export interface NpsDetails {
        /**
         * The display name of the product to be shown in the NPS survey.
         * The question will be of the form:
         *     How likely are you to recommend {your product name} to a friend or colleague?
         */
        readonly productDisplayName: string;
        /**
         * The product id that will be logged in the portal telemetry table.
         */
        readonly productId: string;
    }
    export module Internal {
        /**
         * RPC endpoint to show survey.
         */
        const showNpsEndpoint: Rpc.FuncEndPointDefinition<NpsDetails, void>;
        /**
         * RPC endpoint to check if survey can be shown.
         */
        const canShowNpsEndpoint: Rpc.FuncEndPointDefinition<void, boolean>;
    }
    /**
     * Requests an NPS toast to be displayed. The response to the feedback will be recorded in the portal telemetry tables.
     *
     * Note that the NPS survey will only be shown once per session. Calling this API does not guarantee that the survey will be shown.
     *
     * @param params NPS parameters.
     */
    export function showNps(params: NpsDetails): void;
    /**
     * Checks if an NPS survey can be shown. If this returns true, extensions can call the showNPSSurvey to show NPS.
     * If this returns false, an NPS survey has already been shown and calling the showNPSSurvey will result in a no-op.
     *
     */
    export function canShowNps(): Promise<boolean>;
}

// FILE: Fx\Images.d.ts
declare module "Fx/Images" {
    /**
     * Available SVG elements provided by the framework.
     */
    export import SvgType = MsPortalFx.Services.Image.SvgType;
    /**
     * Built in SVGs provided by the framework.
     */
    export import Images = MsPortalFx.Base.Images;
    export type Image = import("Fx/Images/Image").Image;
}

// FILE: Fx\Notifications.d.ts
declare module "Fx/Notifications" {
    import { BatchResponseItem } from "Fx/Ajax";
    import { BladeReference } from "Fx/Composition";
    import NotificationTypes = Common.Notifications;
    /**
     * Status accompanying a notification with no remaining updates.
     */
    export import CompletedStatus = NotificationTypes.CompletedStatus;
    /**
     * Notification contract returned when a notification is published, and has no following actions to be called.
     */
    export import Notification = NotificationTypes.Notification;
    /**
     * Status accompanying a notification.
     */
    export import Status = NotificationTypes.Status;
    /**
     * Notification toast duration.
     */
    export import ToastDuration = NotificationTypes.ToastDuration;
    /**
     * Defines the base options required to create a notification.
     */
    export type CommonOptions = {
        /**
         * List of Click To Actions (CTAs) available on this notification.
         * Currently the only supported CTAs are buttons, for a maximum of 3 buttons in total.
         */
        readonly actions?: ReadonlyArray<Button>;
        /**
         * The notification's description.
         */
        readonly description: string | HtmlContent;
        /**
         * The notification's title.
         */
        readonly title: string;
        /**
         * A string URI that the notification links to or the BladeReference used to open a blade with.
         *
         * @example
         * (As deepLink)
         *  action: '#/blade/myextensionname/mybladename'
         * @example
         * (As externalLink)
         *  action: 'https://www.bing.com/'
         * @example
         * (As BladeReference)
         *  action: {
         *      blade: 'MyBladeName',
         *      extension: 'MyExtensionName',
         *      parameters: { ...MyBladeParameters },
         *      openContextPane: true|false
         *  }
         */
        readonly linkTo?: string | BladeReference<OpenBladeArgs>;
    };
    /**
     * Defines an actionable notification's action.
     */
    export type Action = string | PinToDashboardArgs | BladeReference<OpenBladeArgs>;
    /**
     * Defines an actionable notification button. Will appear below the description area of the notification.
     */
    export type Button = {
        /**
         * Optional button id which will be logged in telemetry (non-localized string).
         */
        id?: string;
        /**
         * Button label (should be localized).
         */
        readonly label: string;
        /**
         * Determines what clicking the button will do.
         *
         * Can be a string, a valid BladeReference, or the options for a pin to dashboard action.
         * If a fully qualified uri as a string, it will open a new tab. If a deeplink, it will navigate within same tab.
         *
         * @example
         * (As deepLink)
         *  action: '#/blade/myextensionname/mybladename'
         * @example
         * (As externalLink)
         *  action: 'https://www.bing.com/'
         * @example
         * (As BladeReference)
         *  action: {
         *      blade: 'MyBladeName',
         *      extension: 'MyExtensionName',
         *      parameters: { ...MyBladeParameters },
         *      openContextPane: true|false
         *  }
         * @example
         * (As PinToDashboard)
         *  action: {
         *      partName: 'MyPartName',
         *      extension: 'MyExtensionName',
         *      parameters: { ...MyPartParameters }
         *  }
         */
        readonly action: Action;
        /**
         * Styles the button as a secondary button. Defaults to false.
         */
        readonly isSecondary?: boolean;
    };
    /**
     * The acceptable properties that a notification can use to publish/update to a complete state.
     */
    export type CompleteOptions = CommonUpdateOptions & Pick<Options, "status">;
    /**
     * The acceptable properties that an InProgress notification can have updated.
     */
    export type CommonUpdateOptions = {
        /**
         * List of Click To Actions (CTAs) available on this notifications.
         * Currently the only supported CTAs are buttons, for a maximum of 3 buttons in total.
         */
        readonly actions?: ReadonlyArray<Button>;
        /**
         * The notification's description.
         */
        readonly description?: string | HtmlContent;
        /**
         * A string URI that the notification links to or the BladeReference used to open a blade.
         *
         * @example
         * (As deepLink)
         *  action: '#/blade/myextensionname/mybladename'
         * @example
         * (As externalLink)
         *  action: 'https://www.bing.com/'
         * @example
         * (As BladeReference)
         *  action: {
         *      blade: 'MyBladeName',
         *      extension: 'MyExtensionName',
         *      parameters: { ...MyBladeParameters },
         *      openContextPane: true|false
         *  }
         */
        readonly linkTo?: string | BladeReference<OpenBladeArgs>;
        /**
         * The notification's title.
         */
        readonly title?: string;
    };
    /**
     * The acceptable properties that an InProgress pending notification can have updated.
     */
    export type PendingUpdateOptions = CommonUpdateOptions & Pick<PendingOptions, "percentComplete">;
    /**
     * Requires that a specific value be present in the polled response content.
     * If the value is not present, or is different than expected,
     * the provided failureNotification will be used. If not provided, polling will continue.
     */
    export type RequiredResponseValue = {
        /**
         * The notification options to update the original polling notification,
         * If left undefined, polling will continue.
         */
        readonly failureNotification?: CommonUpdateOptions;
        /**
         * List of JSON-friendly keys pointinf to the location within polled response content where
         * the required property value can be found.
         *
         * @example
         *  exampleResponse1.content: {
         *      "name": "testName",
         *      "properties": {
         *          "desiredProp": "desiredValue"
         *      }
         *  };
         *
         *  exampleResponse2.content: {
         *      "name": "testName",
         *      "properties": {
         *          "desiredProp": "keep polling value"
         *      }
         *  };
         *
         *  requiredResponseValue = {
         *      location: [ "properties", "desiredProp" ],
         *      value: "desiredValue",
         *      pollingValues: ["keep polling value", "alternate polling value"],
         *  };
         *
         *  example content #1: Will find "desiredValue" from response.content using location keys and first compare it against "pollingValues".
         *  When it doesn't match, it will compare it against the "value". Since both contain "desiredValue", it passes and uses the "notification" to update.
         *
         *  example content #2: Will find "keep polling value" from response.content using location keys and first compare it against elements in "pollingValues".
         *  When it does match, the api will continue to poll.
         *
         *  If the location keys fail to find a matching "value" or "pollingValues", the contents of "failureNotification"
         *  are used to update the original polling notification and polling stops.
         *  If "failureNotification" is not provided, polling will continue until a match is found or the timeout condition is reached.
         */
        readonly location: ReadonlyArray<string>;
        /**
         * The required value to compare against the value to be found within the polling response content.
         * Can be set to anything other than undefined.
         */
        readonly value: any;
        /**
         * The values to compare against the value found within the polling response content, and if match is found, signals the api to keep polling.
         */
        readonly pollingValues?: (string | number | boolean)[];
    };
    /**
     * Optional amount of time to allow polling before timing out,
     * and the notification details to use in updating the original polling notification.
     */
    export type TimeoutDetails = {
        /**
         * The notification "update" options to update the original polling notification when polling times out.
         */
        readonly failureNotification: CommonUpdateOptions;
        /**
         * Amount of time in milliseconds to continue polling before falling back to the failureNotification.
         * The default is 24 hours, and only a pollingTimeout of less than 24 hours will be honored.
         */
        readonly timeoutInMs: number;
    };
    /**
     * Properties common to all types of operations involving polling details.
     */
    export type CommonPollingDetails = {
        /**
         * The notification "update" options to update the original polling notification for when the failure circumstances aren't known.
         */
        readonly defaultFailureNotification: CommonUpdateOptions;
        /**
         * The minimum amount of time in milliseconds to wait between each polling.
         * NOTE: default time between polling attempts starts out small and increases with time.
         * A custom delay will not shorten the space between polls, but will delay it when customDelayInMs is longer than the default.
         */
        readonly customDelayInMs?: number;
        /**
         * Amount of time in milliseconds to continue polling before falling back to a provided timeout notification.
         */
        readonly pollingTimeout?: TimeoutDetails;
    };
    /**
     * The record of notification instructions for updating an initial polling notification based on the polled response.
     * NOTE: Any non-empty string value is permitted as a record key, but "Succeeded", "Failed", and "Canceled" are required as per ARM docs.
     */
    export type ResponseNotificationByStatus = {
        Succeeded: PollingResponseDetails | string;
        Failed: PollingResponseDetails | string;
        Canceled: PollingResponseDetails | string;
        [key: string]: PollingResponseDetails | string;
    };
    /**
     * This property provides the polling notification api instructions unique to calling the executeAzureAsyncOperation api.
     * NOTE: If the responseNotificationByStatus and keepPollingStatuses don't have the status received,
     * polling will stop, and the defaultFailureNotification will be used to update the original notification.
     */
    export type AzureAsyncPollingDetails = CommonPollingDetails & {
        /**
         * List of AzureAsyncOperation statuses that are the anticipated responses signaling api to keep polling.
         */
        readonly keepPollingStatuses: ReadonlyArray<string>;
        /**
         * Details for updates to the original polling notification based on each of a number of possible
         * response content statuses received from the batch promise. Whether a success or failure,
         * the notification details are associated with a specific response content status.
         * NOTE: "Succeeded", "Failed", and "Canceled" are the minimum required keys according to ARM docs for terminal provisioningStates/statuses.
         *
         * @example
         * When a response content status of "Failed" is received, the details within "notification"
         * will be used to update the original notification.
         *  {
         *      "Failed": {
         *          notification: {...}
         *      }
         *  }
         * @example
         * When a response content status of "Canceled" is received, it will redirect to the "Failed" status and
         * the details within that "notification" will be used to update the original notification.
         *  {
         *      "Failed": {
         *          notification: {...}
         *      },
         *      "Canceled": "Failed"
         *  }
         */
        readonly responseNotificationByStatus: ResponseNotificationByStatus;
    };
    /**
     * This property provides the instructions on what to poll and
     * what notification properties to use in updating original polling notification for a given response to the polled url.
     * NOTE: If the responseNotificationByStatusCode and keepPollingCodes don't have the status code received,
     * polling will stop, and the defaultFailureNotification will be used to update the original notification.
     */
    export type PollingDetails = CommonPollingDetails & {
        /**
         * List of HTTP status codes that are the anticipated responses signaling api to keep polling.
         */
        readonly keepPollingCodes: ReadonlyArray<number>;
        /**
         * Details for updates to the original polling notification based on each of a number of possible
         * HTTP response codes received from the polled ARM/ARG uri. Whether a success or failure,
         * the notification details are associated with a specific HTTP Status Code.
         *
         * @example
         * When a response code of 200 is received, the details within "notification"
         * will be used to update the original notification.
         *  {
         *      "200": {
         *          notification: {...}
         *      }
         *  }
         * @example
         * When a response code of 202 is received, it will redirect to the "200" code and
         * the details within that "notification" will be used to update the original notification.
         *  {
         *      "200": {
         *          notification: {...}
         *      },
         *      "202": "200"
         *  }
         * @example
         * When any response code inclusively between 200 and 299 is received,
         * the details within that "notification" will be used to update the original notification.
         *  {
         *      "200-299": {
         *          notification: {...}
         *      }
         *  }
         * @example
         * When a response code of 300 is received, it will redirect to the ranged key "200-299" and
         * the details within that "notification" will be used to update the original notification.
         *  {
         *      "200-299": {
         *          notification: {...}
         *      },
         *      "300": "200-299"
         *  }
         */
        readonly responseNotificationByStatusCode: Record<string, PollingResponseDetails | string>;
        /**
         * The ARM/ARG uri the notification is expected to poll against.
         */
        readonly uri: string;
    };
    /**
     * Basic instructions for a given polling response scenario.
     * HTTP Status code matches the scenario to the given response,
     * and the notification provides the what-to-do when the scenario arises.
     * Will update the original polling notification with details contained in "notification" property.
     */
    export type PollingResponseDetails = {
        /**
         * The notification "update" options to update the original polling notification.
         */
        readonly notification: CompleteOptions;
        /**
         * Requires that a specific value be present in the polled response content.
         * If the value is not present, or is different than expected,
         * the provided failureNotification will be used to update the original polling notification.
         * If not provided, polling will continue.
         */
        readonly requiredResponseValue?: RequiredResponseValue;
    };
    /**
     * Defines the options required to create and publish a non-updateable notification.
     */
    export type Options = CommonOptions & {
        /**
         * The notification status - Information, Warning, Error, Success.
         */
        readonly status: CompletedStatus;
    };
    /**
     * Defines the options required to create and publish a polling notification.
     */
    export type PendingOptions = CommonOptions & {
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        readonly percentComplete?: number;
    };
    /**
     * Defines the options required to use the executeAzureAsyncOperation api.
     */
    export type AzureAsyncPollingOptions = CommonOptions & {
        /**
         * Defines the options necessary for the Portal to poll on behalf of the notification creator,
         * and how to update the initial notification once the poll attempts return.
         */
        readonly pollingDetails: AzureAsyncPollingDetails;
    };
    /**
     * Defines the options required to create and publish a polling notification.
     */
    export type PollingOptions = CommonOptions & {
        /**
         * Defines the options necessary for the Portal to poll on behalf of the notification creator,
         * and how to update the initial notification once the poll attempts return.
         */
        readonly pollingDetails: PollingDetails;
    };
    /**
     * Pending Notification contract returned when a notification is published. Can be updated multiple times, but completed only once.
     * Once completed, attempts to update will throw an error.
     */
    export type PendingNotification = {
        /**
         * The notification's unique id.
         * Can be used to follow the notification's lifecycle in telemetry.
         */
        readonly id: string;
        /**
         * Final update for this notification to the portal using the properties specified.
         *
         * @param options the notification properties to update for the last time.
         * @returns the date the notification was packaged for update and re-publication. Null if a vaidation error occurred.
         */
        complete: (options: CompleteOptions) => Date;
        /**
         * Updates a pending notification.
         * All update calls on notifications with a previous "complete" call will through an error.
         *
         * @param options the notification properties to update.
         * @returns the date the notification was packaged for update and re-publication. Null if a vaidation error occurred.
         */
        update: (options: PendingUpdateOptions) => Date;
    };
    /**
     * Describes an HTML view, defined in terms of an HTML template string later converted to HTML.
     */
    export type HtmlContent = NotificationTypes.HtmlContent;
    /**
     * Defines the arguments for opening a blade from an actionable notification.
     */
    export type OpenBladeArgs = NotificationTypes.OpenBladeArgs;
    /**
     * Defines the arguments for pinning a dashboard part from an actionable notification.
     */
    export type PinToDashboardArgs = NotificationTypes.PinToDashboardArgs;
    /**
     * Publishes a notification, and depending on whether an AzureAsyncOperation is returned from the batchPromise, that notification will either be a pending or polling notification.
     * Completed pending notification that is resolved when the batchPromise returns without an AzureAsyncOperation header, successfully or otherwise.
     * Polling notification is when an AzureAsyncOperation is returned, and polling against the resulting uri shall commence.
     * NOTE: Make sure to defined "Succeeded", "Failed", and "Canceled" cases in responseNotificationByStatus as these are the ARM-defined terminal cases of an AzureAsyncOperation.
     *
     * @param batchPromise the batch promise returned from the notification publisher's ajax call to ARM/ARG with an anticipated AzureAsyncOperation response.
     * @param azureAsyncNotificationOptions the instructions on how the Portal should update the original notification based on the results of both the batchPromise and the subsequent results of the AzureAsynOperation polling.
     * @returns the notification contract created from the passed in options.
     */
    export function executeAzureAsyncOperation(batchPromise: Promise<BatchResponseItem<any>>, azureAsyncNotificationOptions: AzureAsyncPollingOptions): Notification;
    /**
     * Publishes a non-updateable notification. No further updates are possible on this notification.
     *
     * @param options Options that modify the appearance and behavior of the notification.
     * @returns the notification contract created from the passed in options.
     */
    export function publishNotification(options: Options): Notification;
    /**
     * Publishes a pending notification. Update and Complete are possible here.
     *
     * @param options Options that modify the appearance and behavior of the notification.
     * @returns the notification contract created from the passed in options.
     */
    export function publishPendingNotification(options: PendingOptions): PendingNotification;
    /**
     * Publishes a polling notification. All updates after publishing will be handled internally as polling attempts return.
     *
     * @param options Options that modify the appearance and behavior of the notification.
     * @returns the notification contract created from the passed in options.
     */
    export function publishPollingNotification(options: PollingOptions): Notification;
}

// FILE: Fx\Notifications\IrisNotifications.d.ts
declare module "Fx/Notifications/IrisNotifications" {
    import IrisNotificationsCommon = Common.Notifications.IrisNotifications;
    /**
     * Signal information to send to Iris.
     */
    export type SignalOptions = IrisNotificationsCommon.SignalOptions;
    /**
     * Represents the processed Iris response for downstream consumption.
     * Maps placement id to the items and/or errors. Arrays could be empty.
     */
    export type IrisContent = IrisNotificationsCommon.IrisContent;
    /**
     * Arguments for calling the getIrisContent API.
     */
    export type GetIrisContentOptions = IrisNotificationsCommon.GetIrisContentOptions;
    /**
     * Gets Iris content for a list of placements.
     *
     * @param options the required options necessary to make IRIS content fetch call.
     * @returns A promise that resolves to a map which maps the placement id to its result (items/errors).
     */
    export function getIrisContent(options: GetIrisContentOptions): Promise<IrisContent>;
    /**
     * Sends signals (i.e. impressions or actions) to Iris for tracking, analysis and dashboards.
     * Impressions are usually sent when a message is shown/activated.
     * Actions are sent for other telemetires such as button clicks.
     *
     * @param options If action name specified, action signals will be sent. Otherwise impression signals will be sent.
     * @returns A promise that resolves after the Iris signal is sent and received by Iris.
     */
    export function sendIrisSignal(options: SignalOptions): Promise<void>;
}

// FILE: Fx\NotifyResourcesCreated.d.ts
declare module "Fx/NotifyResourcesCreated" {
    /**
     * The resource type whose set of resources for the user has created.
     */
    export const enum CreatedResourcesType {
        /**
         * Subscriptions.
         */
        Subscriptions = 1
    }
    /**
     * Notify FX that the set of resources of some type have created.
     *
     * @param createdResourcesType  The resource type whose set of resources for the user has created.
     */
    export function notifyResourcesCreated(createdResourcesType: CreatedResourcesType): void;
}

// FILE: Fx\PersistentStorage.d.ts
declare module "Fx/PersistentStorage" {
    /**
     * Writes persistent setting key-value pair to the storage API for the extension.
     *
     * @param key Key of a settings value.
     * @param value Value to store.
     * @param readers The set of extensions that are allowed to read the setting, or "*" for all extensions. Defaults to owning extension.
     * @returns A promise that resolves when the setting was saved to the backing storage.
     */
    export function writeSetting(key: string, value: string, readers?: string[] | "*"): Promise<void>;
    /**
     * Receives previously stored values that are retreived by provided keys.
     *
     * @param keys Keys of settings values to retrieve.
     * @returns A promise that resolves with settings map with existent key-value pairs.
     */
    export function readSettings<T extends string>(...keys: T[]): Promise<Record<T, string>>;
    /**
     * Receives previously stored values that are retreived by provided keys from the specified extension.
     *
     * @param extensionName the name of the extension that owns the setting
     * @param keys Keys of settings values to retrieve.
     * @returns A promise that resolves with settings map with existent key-value pairs.
     */
    export function readCrossExtensionSettings<T extends string>(extensionName: string, ...keys: T[]): Promise<Record<T, string>>;
    /**
     * Given a key removes the key/value pair stored in persistent storage.
     *
     * @param keys Keys of settings values to remove.
     * @returns A promise that resolves when the settings were removed from the backing storage.
     */
    export function removeSettings(...keys: string[]): Promise<void>;
    /**
     * Clears all stored keys and values, resetting the storage. Use with caution.
     *
     * @returns A promise that resolves when all previously saved settings were removed from the backing storage.
     */
    export function clear(): Promise<void>;
    /**
     * Returns all 'key' identifiers stored for the extension.
     *
     * @returns A promise that resolves with all keys stored.
     */
    export function getAllKeys(): Promise<ReadonlyArray<string>>;
}

// FILE: Fx\Pinner.d.ts
declare module "Fx/Pinner" {
    import FxRpc = FxImpl.Rpc;
    import FxComposition = MsPortalFx.Composition;
    /**
     * Options that can be passed when calling the pin function.
     */
    export interface Options {
        /**
         * The value to indicate whether to show a notification or not.
         */
        readonly notify: boolean;
    }
    export module Internal {
        /**
         * RPC endpoint to pin provided parts.
         */
        const pinEndPoint: FxRpc.FuncEndPointDefinition<PinParams, void>;
        /**
         * Options that must be passed when calling the pin function.
         */
        interface PinParams {
            /**
             * Parts to pin to the dashboard.
             */
            parts: (FxComposition.PartReference<any> | FxComposition.ResourcePartReference)[];
            /**
             * The value to indicate whether to show a notification or not.
             */
            options?: Options;
        }
    }
    /**
     * Pins the specified parts to the currently opened dashboard.
     *
     * @param parts Parts to pin to the dashboard.
     * @param options Optional arguments used by the function.
     * @returns A promise that resolves to completion of pinning.
     */
    export function pin(parts: (FxComposition.PartReference<any> | FxComposition.ResourcePartReference)[], options?: Options): Promise<void>;
}

// FILE: Fx\Redirect.d.ts
declare module "Fx/Redirect" {
    import { BladeReference } from "Fx/Composition";
    export type ForceSignInOptions = Omit<Common.Authentication.ForceSignInOptions, "bladeReference"> & {
        bladeReference?: BladeReference<unknown>;
    };
    /**
     * Forces the user to sign in.
     *
     * This is a highly privileged operation with a very limited set of permitted callers.
     *
     * @param options The options used to configure the forced reauthentication.
     * @returns A promise that will only ever be actionable in the failure case. If this function executes successfully, the browser will navigate and the caller will not receive the result. Otherwise, this promise will reject.
     */
    export function forceSignIn(options: ForceSignInOptions): Promise<void>;
}

// FILE: Fx\ResourceManagement.d.ts
declare module "Fx/ResourceManagement" {
    import { BrowseBladeReferenceOptions, BrowseBladeReference } from "Fx/ResourceManagement/BrowseBlade";
    import { Subscription as Subscription_, SubscriptionPolicies as SubscriptionPolicies_ } from "Fx/ResourceManagement/Subscriptions";
    import { Filter as GlobalResourceFilter } from "Fx/ResourceManagement/GlobalResourceFilters";
    /**
     * Data contract for a single Azure subscription.
     */
    export type Subscription = Subscription_;
    /**
     * Data contract for a Azure subscription policies.
     */
    export type SubscriptionPolicies = SubscriptionPolicies_;
    /**
     * Data contract for a single location.
     */
    export import Location = MsPortalFx.Azure.Location;
    /**
     * Data contract for a resource group
     */
    export import ResourceGroup = MsPortalFx.Azure.ResourceGroup;
    /**
     * The enum for which recommended group a location should appear in
     */
    export import RegionSegment = MsPortalFx.Azure.RegionSegment;
    /**
     * The ARM ID interface.
     */
    export interface ArmId {
        /**
         * The kind of ARM ID.
         */
        readonly kind: ArmId.Kind;
        /**
         * The subscription for the ARM ID.
         * Valid/required for these kinds:
         *      Subscription,
         *      SubscriptionProvider,
         *      SubscriptionResource,
         *      ResourceGroup,
         *      Provider,
         *      Resource,
         *      SubscriptionTag,
         *      SubscriptionTagValue
         */
        readonly subscription: string;
        /**
         * The resource group for the ARM ID.
         * Valid/required for these kinds:
         *      ResourceGroup,
         *      Provider,
         *      Resource
         */
        readonly resourceGroup: string;
        /**
         * The tag name for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionTag,
         *      SubscriptionTagValue
         */
        readonly tagName: string;
        /**
         * The tag value for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionTagValue
         */
        readonly tagValue: string;
        /**
         * The provider (namespace) for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionProvider,
         *      SubscriptionResource,
         *      Provider,
         *      Resource,
         *      TenantProvider,
         *      TenantResource
         */
        readonly provider: string;
        /**
         * The collection of resource IDs for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         *
         * @deprecated ArmId.resourceIds 05/06/2022 - Please use the ArmId.getResourceNames(armId) function instead.
         *
         * recipe: name = MsPortalFx.last(armId.resourceIds)
         *
         * becomes: name = MsPortalFx.last(ArmId.getResourceNames(armId))
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly resourceIds?: ReadonlyArray<string>;
        /**
         * The collection of resource types for the ARM ID.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         *
         * @deprecated ArmId.resourceTypes 05/06/2022 - Please use the ArmId.getResourceTypes(armId) function instead.
         *
         * recipe: type = MsPortalFx.last(armId.resourceTypes)
         *
         * becomes: type = MsPortalFx.last(ArmId.getResourceTypes(armId))
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly resourceTypes?: ReadonlyArray<string>;
        /**
         * The collection of resource types for the ARM ID in nested form.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly nestedResourceTypes?: ReadonlyArray<{
            readonly provider: string;
            readonly resourceTypes: ReadonlyArray<string>;
        }>;
        /**
         * Flag which indicates that the resource type is a nested resource type.
         * Valid/required for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly isNestedResourceType?: boolean;
        /**
         * The full resource name for the ARM ID.
         * Valid for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         */
        readonly resourceName: string;
        /**
         * The fully qualified resource type for the ARM ID which includes the namespace (provider).
         * Valid for these kinds:
         *      SubscriptionResource,
         *      Resource,
         *      TenantResource
         *
         * IMPORTANT: This property includes the provider for the resource type as a prefix, eg: Microsoft.Sql/servers/databases
         *            To get the resource type without the provider, please use:
         *                     ArmId.getResourceTypeWithoutProvider(armId);
         *            which will return a string without the provider, eg: servers/databases
         */
        readonly resourceType: string;
    }
    /**
     * An ARM resource.
     */
    export type ArmResource = Common.ResourceManagement.ArmResource;
    /**
     * ARM resource tags.
     */
    export type ArmResourceTags = Common.ResourceManagement.ArmResourceTags;
    /**
     * ARM resource properties.
     */
    export type ArmResourcePropertyBag = Common.ResourceManagement.ArmResourcePropertyBag;
    /**
     * Namespace with the functions and ancillary bits like the Kind.
     */
    export namespace ArmId {
        export import Kind = Common.ResourceManagement.ArmIdKind;
        /**
         * Parses the ID from ARM to the ARM ID.
         *
         * @param id The ID from ARM to parse.
         * @param parseNested Boolean true to parse the resource ID as a possible nested resource, otherwise false.
         * @returns The ARM ID.
         */
        const parse: (id: string, parseNested?: boolean) => ArmId;
        /**
         * Builds the ARM ID string from the ARM ID using the given desired kind.
         * Specify 'kind' here to generate an ARM ID string related to given 'armId' if there is a valid relationship.
         * As an example, given a resource group ARM ID 'armId' and a desired subscription ID 'kind', there is a valid
         * relationship (subscription is a parent of a resource group).
         * However, given a resource group ARM ID 'armId' and a desired resource ID 'kind', there is not a valid
         * relationship with the given information (can't convert from a resource group ID to a child resource ID).
         *
         * @param armId The ARM ID.
         * @param kind The desired ARM ID kind for the generated string.
         * @returns The ARM ID string representing the desired kind, empty string if not valid.
         */
        function stringify(armId: Partial<ArmId>, kind?: Kind): string;
        /**
         * Sanitizes an ID to prevent PI leakage.
         *
         * @param armId The ID to sanitize.
         * @returns The sanitized ID.
         */
        function sanitizeId(armId: ArmId): string;
        /**
         * Determines if the given ARM ID has a parent resource ID.
         *
         * @param armId The source ARM ID.
         * @returns Boolean true if the given ARM ID has a parent resource ID, else false.
         */
        const hasParentResourceId: (armId: ArmId) => boolean;
        /**
         * Gets the parent resource ARM ID for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @returns The parent resource ARM ID for the given ARM ID if available, otherwise null.
         */
        const getParentResourceArmId: (armId: ArmId) => ArmId;
        /**
         * Gets the parent resource ID (stringified) for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @returns The parent resource ID (stringified) for the given ARM ID if available, otherwise an empty string.
         */
        function getParentResourceId(armId: ArmId): string;
        /**
         * Gets the root resource ID for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @returns The root resource ID for the given ARM ID if available, otherwise null.
         */
        const getRootResourceArmId: (armId: ArmId) => ArmId;
        /**
         * Gets the root resource ID (stringified) for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @returns The root resource ID (stringified) for the given ARM ID if available, otherwise an empty string.
         */
        function getRootResourceId(armId: ArmId): string;
        /**
         * Gets an array of the resource types (optionally with provider at the head) for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @param includeProvider Optional value to include the provider at the head of the array.
         * @returns The array of resource types (optionally with provider at the head) for the given ARM ID for resource ARM ID, otherwise empty array.
         */
        function getResourceTypes(armId: ArmId, includeProvider?: true): string[];
        /**
         * Gets an array of the resource names for the given ARM ID.
         *
         * @param armId The source ARM ID.
         * @returns The array of resource names for the given ARM ID for resource ARM ID, otherwise empty array.
         */
        function getResourceNames(armId: ArmId): string[];
        /**
         * Gets the resource type for the given ARM ID without the provider prefix.
         *
         * @param armId The source ARM ID.
         * @returns The resource type for the given ARM ID without the provider prefix.
         */
        function getResourceTypeWithoutProvider(armId: ArmId): string;
    }
    /**
     * Namespace for the resource name utility function.
     */
    export namespace ResourceName {
        /**
         * The partial bits of a resource needed for the resource name.
         * This can be a resource, resource group or subscription.
         */
        interface PartialResource {
            /**
             * The ID for the resource.
             */
            id: string | KnockoutObservable<string>;
            /**
             * The name of the resource.
             */
            name?: string | KnockoutObservable<string>;
            /**
             * The tags for the resource.
             */
            tags?: StringMap<string> | KnockoutObservable<StringMap<string>>;
            /**
             * The ARM ID for the resource if already parsed.
             */
            armId?: ArmId;
        }
        /**
         * Gets the resource name formatted for the given resource.
         *
         * @param resource The resource for the name.
         * @param skipSplitName Optional boolean flag to skip splitting the resource.name property.
         * @returns The resource name formatted for the UX.
         */
        function getDisplayName(resource: PartialResource, skipSplitName?: boolean): string;
    }
    /**
     * Gets the browse blade reference for a given browse resource type.
     *
     * @param browseBladeReferenceOptions The browse blade reference options.
     * @returns Promise which resolves to the browse blade reference for the browse resource type or null if there is no available blade reference.
     */
    export function getBrowseBladeReference(browseBladeReferenceOptions: BrowseBladeReferenceOptions): Promise<BrowseBladeReference>;
    /**
     * Gets a reference to a dynamic dx blade. The runtime content of this blade will be resolved by shell using the getDynamicDxView RPC to your extension.
     *
     * @param dynamicDxBladeReferenceOptions The browse blade reference options. This only names the dynamic blade you want to open, the definition of the blade is resolved in the RPC call.
     * @returns Promise which resolves to the blade reference.
     */
    export function getDynamicDxBladeReference(dynamicDxBladeReferenceOptions: FxImpl.Extension.DynamicDxBladeReferenceOptions): FxImpl.Extension.DynamicDxBladeReference;
    /**
     * Executes the supplied callback method initially with the current set of selected subscriptions and each time thereafter
     * when the selected subscriptions change.
     *
     * @param lifetime The lifetime object that will notify when the data is no longer required.
     * @param callback The callback function to be executed when the selected subscriptions change.
     * @returns Promise which will resolve when complete.
     */
    export function onSelectedSubscriptionsChange(lifetime: MsPortalFx.Base.LifetimeManager, callback: (subscriptions: ReadonlyArray<Subscription>) => void): Promise<void>;
    /**
     * Adds a resource to the recent resources
     *
     * @param resource a resource that has been accessed by the user
     */
    export function addRecentResource(resource: ArmResource | Subscription): void;
    /**
     * Executes the supplied callback method initially with the current set of selected subscriptions and each time thereafter
     * when the selected subscriptions change.
     *
     * @param lifetime The lifetime object that will notify when the data is no longer required.
     * @param callback The callback function to be executed when the selected subscriptions change.
     */
    export function onGlobalResourceFilterChange(lifetime: MsPortalFx.Base.LifetimeManager, callback: (activeFilter: GlobalResourceFilter) => void): Promise<void>;
    export const DEV: {
        resetInSessionSelectedSubscriptions: () => void;
        resetGlobalResourceFilter: () => void;
    };
}

// FILE: Fx\ResourceManagement\BrowseBlade.d.ts
declare module "Fx/ResourceManagement/BrowseBlade" {
    /**
     * The browse blade reference options for the getBrowseBladeReference API.
     */
    export interface BrowseBladeReferenceOptions {
        /**
         * The resource type for the browse blade reference.
         */
        resourceType: string;
        /**
         * Optional resource type kind for the browse blade reference.
         */
        kind?: string;
        /**
         * Optional flag to indicate the browse blade reference should be for an in-menu blade browse.
         */
        inMenu?: boolean;
        /**
         * Optional flag to ignore the browse deep link supplied by the extension and to force navigation to the FX/default browse blade.
         */
        ignoreDeepLink?: boolean;
    }
    /**
     * The browse blade reference for open blade commands and getBrowseBlade() API.
     */
    export interface BrowseBladeReference {
        /**
         * The blade name.
         */
        readonly blade: string;
        /**
         * The extension name for the blade
         */
        readonly extension?: string;
        /**
         * The blade parameters.
         */
        readonly parameters?: StringMap<any>;
    }
}

// FILE: Fx\ResourceManagement\ControlPlaneValidators.d.ts
declare module "Fx/ResourceManagement/ControlPlaneValidators" {
    import * as FxBladeBase from "Fx/Composition/BladeBase";
    import { CustomV } from "Fx/Controls/Validations";
    import * as CustomHtml from "Fx/Controls/CustomHtml";
    import * as ResourceGroupDropDown from "Fx/Controls/ResourceGroupDropDown";
    import { Contract as FxFormBaseContract } from "Fx/Controls/FormBase";
    import PolicyDataCoreModels = Common.PolicyDataCoreModels;
    import ValueItemType = PolicyDataCoreModels.ValueItemType;
    import PolicyDataCoreOptions = PolicyDataCoreModels.PolicyDataCoreOptions;
    import PolicyDataCoreOptionsCommon = PolicyDataCoreModels.PolicyDataCoreOptionsCommon;
    /**
     * Policy Validator Options
     */
    export interface ControlPlanePolicyValidatorOptions<ControlItemType, PolicyItemType extends ValueItemType> extends PolicyDataCoreOptionsCommon {
        /**
         * function to convert component type to policy item type.
         */
        readonly convertValue?: (value: ControlItemType) => PolicyItemType;
        /**
         * Control that supports validations
         */
        readonly control: ValidatorControl<ControlItemType>;
    }
    /**
     * Policy Selector Options
     */
    export interface ControlPlanePolicySelectorOptions<ControlItemType, PolicyItemType extends ValueItemType> extends PolicyDataCoreOptionsCommon {
        /**
         * function to convert component type to policy item type.
         */
        readonly convertValue: (value: ControlItemType) => PolicyItemType;
        /**
         * Control that supports selections (Dropdown, Checkbox, OptionsGroup etc.)
         */
        readonly control: Selector<ControlItemType>;
    }
    /**
     * Policy Evaluator Options
     */
    export interface ControlPlanePolicyEvaluatorOptions<PolicyItemType> extends PolicyDataCoreOptions<PolicyItemType> {
        /**
         * The flag indicating whether blade is a context pane. If it is, the policy detail links are not surfaced.
         * Defaults to false.
         */
        readonly inContextPane?: boolean;
    }
    /**
     * Create scenario options to listen to scope at which policy checks would be performed
     */
    export interface ControlPlanePolicyCreateOptions extends ControlPlanePolicyOptionsBase {
        /**
         * Subscription Observable
         */
        readonly subscriptionObservable: KnockoutObservableBase<Subscription>;
        /**
         * Resource group Observable
         */
        readonly resourceGroupObservable: KnockoutObservableBase<ResourceGroupValue>;
    }
    /**
     * Managed scenario options to listen to scope at which policy checks would be performed
     */
    export interface ControlPlanePolicyManagedOptions extends ControlPlanePolicyOptionsBase {
        /**
         * Scope id, at which the policy checks need to be performed.
         */
        readonly scopeId: KnockoutObservable<string> | string;
    }
    /**
     * Subscription Interface for scope
     */
    export interface Subscription {
        /**
         * Subscription Id
         */
        readonly subscriptionId: string;
    }
    /**
     * Resource group interface for scope
     */
    export interface ResourceGroupValue {
        /**
         * The mode of the dropdown, create new or use existing.
         */
        readonly mode: ResourceGroupDropDown.SelectedMode;
        /**
         * The ARM value for the resource group.
         */
        readonly value: {
            /**
             * Resource group location.
             */
            readonly location: string;
            /**
             * Resource group name.
             */
            readonly name: string;
        };
    }
    /**
     * Validator Control Interface
     */
    export interface ValidatorControl<TValue> {
        /**
         * Value property to listen for changes, and perform policy checks on.
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * API to trigger validations
         */
        readonly triggerValidation: FxFormBaseContract["triggerValidation"];
    }
    /**
     * Selector Control Interface
     */
    export interface Selector<TValue> {
        /**
         * All Items of the selector control
         */
        readonly items: KnockoutObservableArray<SelectorItem<TValue>>;
        /**
         * selected value
         */
        readonly value: KnockoutObservableBase<TValue>;
        /**
         * state to change the sublabel
         */
        readonly subLabel: KnockoutObservableBase<CustomHtml.HtmlContent>;
        /**
         * property to change the disabled state of the component
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * Selector Item Interface
     */
    export interface SelectorItem<TValue> {
        /**
         * Value associated with the selector item
         */
        readonly value: TValue;
        /**
         * disabled property of the item
         */
        readonly disabled: KnockoutObservableBase<boolean>;
    }
    /**
     * The result type of the ControlPlane Policy Result.
     */
    export interface ControlPlanePolicyResult<PolicyItemType extends ValueItemType> {
        /**
         * Values 'denied' by the checkPolicy API (deny restrictions).
         */
        readonly deniedValues: PolicyItemType[];
        /**
         * Values 'allowed' by the checkPolicy API (required restrictions).
         */
        readonly allowedValues: PolicyItemType[];
        /**
         * Array of error results per vaildation line (Policy Assignment, and/or Policy Definition (in case of Policy Initiatives)).
         */
        readonly allErrorResults: ControlPlanePolicyErrorResult[];
        /**
         * The html representation of the validation error message to be rendered.
         */
        readonly customHtml: CustomHtml.HtmlContent;
    }
    /**
     * Error result per Policy Assignment, and/or Policy Definition (in case of Policy Initiatives).
     */
    export interface ControlPlanePolicyErrorResult {
        /**
         * Name of the policy assignment that threw a policy restriction on the values passed in.
         */
        readonly policyAssignmentName: string;
        /**
         * Callback to open the Policy Assignment Blade for the policy assignment id as context.
         * Used by "Policy Details" link.
         */
        readonly resourceLink: () => void;
        /**
         * Link display name for the hyperlink
         */
        readonly linkDisplayName: string;
        /**
         * Display name without the hyperlink (for context panes).
         */
        readonly noLinkDisplayName: string;
        /**
         * String that represents the non-complaince reason property on the Policy Assignment.
         * (For Policy Initiatives, we also use the referenceId to find an exact match, if multiple noncomplaince reasons are present).
         * If one is not present, this is defaulted to the display name of the Policy Assignment.
         */
        readonly reason: string;
    }
    /**
     * Common ControlPlanePolicy options
     */
    export interface ControlPlanePolicyOptionsBase {
        /**
         * Blade name to include in associated telemetry
         */
        readonly bladeName: string;
        /**
         * The flag indicating whether blade is a context pane. If it is, the policy detail links are not surfaced.
         * Defaults to false.
         */
        readonly inContextPane?: boolean;
        /**
         * In cases where the resource is already present, i.e. Managed, supply as 'resourceScopeId' the resource scope.
         * For e.g. `/subscriptions/${subscriptionId}/resourceGroups/${resourceGroupName}/providers/Microsoft.Storage/storageAccounts/${storageAccountName}`
         */
        readonly resourceScopeId?: string;
    }
    /**
     * ControlPlane Validators Class
     */
    export class ControlPlaneValidators {
        private _scopeId;
        private _resourceScopeId;
        private _inContextPane;
        private _container;
        private _bladeName;
        /**
         * returns a new instance of the ControlPlane Validators Class
         *
         * @param container container
         * @param options configuration options
         */
        constructor(container: FxBladeBase.Container, options: ControlPlanePolicyCreateOptions | ControlPlanePolicyManagedOptions);
        /**
         * Policy Evaluator API (to be used for custom scenarios where Validator and Selector cannot be used)
         *
         * @param container container
         * @param options configurations for the evaluator
         * @returns Policy Result promise
         */
        static policyEvaluator<PolicyItemType extends ValueItemType>(container: FxBladeBase.Container, options: ControlPlanePolicyEvaluatorOptions<PolicyItemType>): Promise<ControlPlanePolicyResult<PolicyItemType>>;
        /**
         * Policy Validator API
         *
         * @param options policy validator options
         * @returns a validator that performs policy checks, to be attached to the validator control
         */
        policyValidator<ControlItemType, PolicyItemType extends ValueItemType>(options: ControlPlanePolicyValidatorOptions<ControlItemType, PolicyItemType>): CustomV<ControlItemType>[];
        /**
         * Policy Selector API
         *
         * @param options policy selector options
         */
        policySelector<ControlItemType, PolicyItemType extends ValueItemType>(options: ControlPlanePolicySelectorOptions<ControlItemType, PolicyItemType>): void;
        private _getScopeIdForResourceGroupDeployment;
    }
}

// FILE: Fx\ResourceManagement\Deployments.d.ts
declare module "Fx/ResourceManagement/Deployments" {
    import { ArmError } from "Fx/Controls/ArmErrorList";
    import { BladeReference } from "Fx/Composition";
    import { BaseOptions as BaseInfoboxOptions, Options as InfoboxOptions, HtmlContent as InfoboxHtmlContent } from "Fx/Controls/InfoBox";
    import FxBase = MsPortalFx.Base;
    /**
     * Options for opening a blade identified by a resource ID.
     */
    export interface PartialResourceLink {
        /**
         * The resource ID.
         */
        readonly resourceId: string;
    }
    /**
     * Structure for options for opening a blade by clicking on a link.
     */
    export interface PartialBladeLink {
        /**
         * Blade reference of blade to be opened.
         */
        readonly bladeReference: BladeReference<any>;
        /**
         * Optionally specify if the blade should open in a context pane.
         */
        readonly openInContextPane?: boolean;
    }
    /**
     * Structure for navigating to a website by clicking on a link.
     */
    export interface UriLink {
        /**
         * The URI to navigate to.
         */
        readonly uri: string;
        /**
         * The window to load the page in.
         */
        readonly target: "_blank" | "_self";
    }
    /**
     * The allowed link types.
     */
    export type AllowedLinkType = PartialResourceLink | PartialBladeLink | UriLink | Function;
    /**
     * The allowed button types.
     */
    export type AllowedButtonType = PartialResourceLink | PartialBladeLink | Function;
    /**
     * Structure for binding link data to a template.
     */
    export interface Link {
        /**
         * The text to display.
         */
        readonly text: string;
        /**
         * The behavior to bind to the link's click event.
         */
        readonly onClick: AllowedLinkType;
    }
    /**
     * Enum of next step types.
     */
    export const enum NextStepTypes {
        /**
         * Next step type for actions which must be completed for the created resource to fully function.
         */
        Required = 0,
        /**
         * Next step type for suplemental creates.
         */
        Recommended = 1
    }
    /**
     * Interface for next step links in the blade shown after submitting a provisioning request.
     */
    export interface NextStepLink {
        /**
         * Type of suggestion in the suggested next steps section
         */
        readonly type: NextStepTypes;
        /**
         * The link to show in the "Next steps" list.
         */
        readonly link: Link;
    }
    /**
     * Options for the spotlight section on the post-create blade.
     */
    export interface SpotlightContent {
        /**
         * The icon to show.
         */
        readonly icon: FxBase.Image | KnockoutObservableBase<FxBase.Image>;
        /**
         * The title of the spotlight.
         */
        readonly title: string | KnockoutObservableBase<string>;
        /**
         * The description to show.
         */
        readonly description: string | KnockoutObservableBase<string>;
        /**
         * The link to show.
         */
        readonly link: Link;
    }
    /**
     * Available flags for showing customized post-provisioning sections based on specific conditions
     */
    export const enum InfoboxVisibilityConditions {
        /**
         * The deployment completed successfully.
         */
        DeploymentSucceeded = 1,
        /**
         * The deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * The deployment is still in progress. This option includes all non-terminal deployment states.
         */
        DeploymentInProgress = 4
    }
    /**
     * Options for the infobox on the post-create blade.
     */
    export interface InfoboxContent {
        /**
         * Aria label for the infobox.
         */
        ariaLabel?: BaseInfoboxOptions["ariaLabel"];
        /**
         * Clickable invoked when the InfoBox is clicked.
         *
         * If a function is specified, clicking the infobox will trigger a callback to the function.
         * If a clickable link is provided, then clicking the info box will open that external link.
         * If a blade-reference clickable is provided (BladeLink, or ResourceLink), then the respective
         * blade will get opened.
         */
        onClick?: InfoboxOptions["onClick"];
        /**
         * Style of the infobox, defaults to Info.
         */
        style?: BaseInfoboxOptions["style"];
        /**
         * The text or html to display in the control.
         */
        text: string | InfoboxHtmlContent | KnockoutObservableBase<string | InfoboxHtmlContent>;
        /**
         * An optional bitfield that allows for customizating when the infobox is displayed.
         * This option supports multiple values. For example, if the value provided is `InfoboxVisibilityConditions.DeploymentFailed | InfoboxVisibilityConditions.DeploymentInProgress` then the infobox will be visible only when the deployment is in a failed or ongoing state.
         */
        readonly visibilityConditions?: InfoboxVisibilityConditions;
    }
    /**
     * Options for buttons on the post-create blade.
     */
    export interface ButtonOptions {
        /**
         * The label for the button.
         */
        readonly text: string;
        /**
         * The action that is executed when the button is clicked.
         */
        readonly onClick: AllowedButtonType;
    }
    /**
     * Options for the custom button on the deployment overview blade.
     */
    export interface CustomButtonOptions extends ButtonOptions {
        /**
         * A flag indicating the button should be displayed even when the deployment failed.
         */
        readonly showForFailedDeployment?: boolean;
    }
    /**
     * The options passed to the extension blade when retrieving custom content shown on the blade launched after submitting a provisioning request.
     */
    export interface PostProvisioningOptions {
        /**
         * The root level deployment object.
         */
        readonly deployment: ArmDeployment;
        /**
         * A key or hash that encodes or corresponds to information about a provisioning request.
         * This must be a valid resource tag value to persist across sessions. View the tag value rules at https://go.microsoft.com/fwlink/?LinkID=2097613.
         * This is provided as a parameter in provisioning.deployTemplate called from TemplateBlade.DoesProvisioning blades.
         */
        readonly provisioningHash: string;
        /**
         * The marketplace ID for the deployment.
         */
        readonly marketplaceItemId: string;
        /**
         * The ID of the primary resource created by the deployment.
         * This is provided in TemplateBlade.DoesProvisioning.DeployTemplateOptions passed to the provisioner.
         */
        readonly primaryResourceId: string;
    }
    /**
     * Interface for customization of content shown on the blade launched after submitting a provisioning request.
     */
    export interface PostProvisioningContent {
        /**
         * The blade or specific resource blade that should open when the user clicks the "Go to resource" button.
         * The text option will be ignored.
         */
        readonly goToResourceButton?: ButtonOptions;
        /**
         * Options for a custom button to show when the deployment completes.
         */
        readonly customButton?: CustomButtonOptions;
        /**
         * Links to free tutorials related to the resource being created.
         */
        readonly tutorials?: ReadonlyArray<Link>;
        /**
         * Links to provide users with information on what to do next.
         * These links are only displayed after the deployment completes successfully.
         * Blade supports up to 4 links.
         */
        readonly nextSteps?: ReadonlyArray<NextStepLink>;
        /**
         * Options for the spotlight.
         */
        readonly spotlight?: SpotlightContent;
        /**
         * Options for the infobox.
         */
        readonly infobox?: InfoboxContent;
    }
    /**
     * The deployments array.
     */
    export interface ArmDeployments {
        /**
         * Deployment object.
         */
        readonly value: ReadonlyArray<ArmDeployment>;
        /**
         * The next link if the deployments array is too large.
         */
        readonly nextLink?: string;
    }
    /**
     * An ARM deployment.
     */
    export interface ArmDeployment {
        /**
         * Deployment id.
         */
        readonly id: string;
        /**
         * Deployment name.
         */
        readonly name: string;
        /**
         * Deployment properties;
         */
        readonly properties: ArmDeploymentProperties;
        /**
         * The tags associated with the deployment.
         */
        readonly tags?: ReadonlyStringMap<string>;
    }
    /**
     * Properties of an ARM deployment.
     */
    export interface ArmDeploymentProperties {
        /**
         * Correlation id.
         */
        readonly correlationId: string;
        /**
         * Deployment mode.
         */
        readonly mode: string;
        /**
         * Provisioning state.
         */
        readonly provisioningState: string;
        /**
         * Template link.
         */
        readonly templateLink: ArmLink;
        /**
         * Deployment timestamp.
         */
        readonly timestamp: Date;
        /**
         * Deployment duration.
         */
        readonly duration: string;
        /**
         * Deployment parameters.
         */
        readonly parameters?: ReadonlyStringMap<ArmParameter>;
        /**
         * Deployment outputs.
         */
        readonly outputs?: ReadonlyStringMap<ArmParameter>;
        /**
         * Deployment parameters link.
         */
        readonly parametersLink?: ArmLink;
        /**
         * Errors that occurred during deployment.
         */
        readonly error?: ArmError;
        /**
         * The list of resources affected by this deployment.
         */
        readonly outputResources?: ReadonlyArray<{
            id: string;
        }>;
    }
    export interface ArmParameter {
        /**
         * The type of parameter.
         */
        readonly type: string;
        /**
         * The value of the parameter.
         */
        readonly value: any;
    }
    export interface ArmLink {
        /**
         * Template content version.
         */
        readonly contentVersion?: string;
        /**
         * Template Uri.
         */
        readonly uri?: string;
        /**
         * A resource Id for the template spec
         */
        readonly id?: string;
    }
}

// FILE: Fx\ResourceManagement\Marketplace.d.ts
declare module "Fx/ResourceManagement/Marketplace" {
    /**
     * Marketplace offer plan.
     */
    export import OfferPlan = Common.Marketplace.OfferPlan;
    /**
     * Marketplace offer pricing details model.
     * Used to retrieve the pricing information for a Marketplace offer.
     */
    export import OfferPricingDetails = Common.Marketplace.OfferPricingDetails;
    /**
     * Marketplace product (offer).
     */
    export import Product = Common.Marketplace.Product;
    /**
     * Marketplace artifact.
     */
    export import Artifact = Common.Marketplace.Artifact;
    /**
     * The context from which a marketplace create is kicked off.
     */
    export import LaunchingContext = Common.Marketplace.LaunchingContext;
    /**
     * Marketplace item.
     */
    export import Item = Common.Marketplace.Item;
    /**
     * The interface of context supplied by marketplace
     */
    export import Context = Common.Marketplace.Context;
}

// FILE: Fx\ResourceManagement\Policies.d.ts
declare module "Fx/ResourceManagement/Policies" {
    import { CustomV } from "Fx/Controls/Validations";
    export type PolicyCheckRequest = Common.Policy.PolicyCheckRequest;
    export type ValueToField<TVal> = Common.Policy.ValueToField<TVal>;
    export type PendingValues<TVal> = Common.Policy.PendingValues<TVal>;
    export type PendingValuesGenerator<TVal> = Common.Policy.PendingValuesGenerator<TVal>;
    export type FieldValidationOptions<TVal> = Common.Policy.FieldValidationOptions<TVal>;
    export type AtLeastOne<T, U = {
        [K in keyof T]: Pick<T, K>;
    }> = Partial<T> & U[keyof U];
    /**
     * The contact for the policy validation factory to create a validation for a particular field
     */
    export type CreateFieldValidationOptions<TVal> = AtLeastOne<FieldValidationOptions<TVal>>;
    export type Options = Common.Policy.Options;
    export type ChildFactoryOptions = Common.Policy.ChildFactoryOptions;
    /**
     * The contract for the object returned from the policy validation factory
     */
    export interface FieldValidation<TVal> {
        /**
         * Used to receive the value to be validated, typically from an associated control. Two patterns are common:
         * Supply this observable as the 'value' option when creating the control.
         * Subscribe to the control's observable 'value' property and manually apply changes to the field validation's 'value' observable.
         */
        value: KnockoutObservable<TVal>;
        /**
         * The validation to be passed into a control
         */
        validation: CustomV<TVal>;
        /**
         * The results of the pending policy values
         * Only returned if pending values are supplied
         */
        pendingResultValues?: KnockoutSubscribable<{
            denied: string[];
            removed: string[];
            required: string[];
            getPolicyAssignments: (val: string) => string[];
        }>;
        /**
         * The results of the generated pending policy values
         * Only returned if generated pending values are supplied
         */
        generatedPendingResultValues?: KnockoutSubscribable<{
            [field: string]: {
                denied: string[];
                removed: string[];
                required: string[];
                getPolicyAssignments: (val: string) => string[];
            };
        }>;
    }
    /**
     * The contract for the policy validation factory
     *
     * @deprecated PolicyValidationFactory. New API projected early 2022.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export interface PolicyValidationFactory {
        /**
         * Set options for the policy validation factory
         *
         * @param options options for the policy validation factory
         * @deprecated PolicyValidationFactory.setOptions. New API projected early 2022.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        setOptions(options: Options): void;
        /**
         * Creates a policy validation
         *
         * @param options options to create the policy validation
         * @deprecated PolicyValidationFactory.createFieldValidation. New API projected early 2022.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        createFieldValidation<TVal>(options: CreateFieldValidationOptions<TVal>): FieldValidation<TVal>;
        /**
         * Create a child validation factory
         * If your create provisions multiple resources, you'll need one factory per
         * resource to evaluate policies on each
         *
         * @param options options to create a child factory
         * @deprecated PolicyValidationFactory.createChildFactory. New API projected early 2022.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        createChildFactory(options: ChildFactoryOptions): PolicyValidationFactory;
    }
    /**
     * Creates a PolicyValidationFactory
     *
     * @param lifetime The lifetime of the control.
     * @returns A policy validation factory to construct resource details and check if properties of those resources are in violation of policies
     * @deprecated createPolicyValidationFactory. New API projected early 2022.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export function createPolicyValidationFactory(lifetimeManager: MsPortalFx.Base.LifetimeManager): PolicyValidationFactory;
}

// FILE: Fx\ResourceManagement\Provisioning.d.ts
declare module "Fx/ResourceManagement/Provisioning" {
    import PartReference = MsPortalFx.Composition.PartReference;
    import FxResourceManager = MsPortalFx.Azure.ResourceManager;
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    export import TemplateDeploymentMode = FxResourceManager.TemplateDeploymentMode;
    /**
     * The response from ARM when a template validate call succeeds.
     */
    export import TemplateValidationResponse = FxResourceManager.TemplateValidationResponse;
    /**
     * The ARM template validation error.
     */
    export import TemplateValidationError = FxResourceManager.TemplateValidationError;
    export import AllDeployTemplateOptions = Common.AllDeployTemplateOptions;
    /**
     * Initial values for form initialization. Use those values to initialize the subscription,
     * resource group, and location drop down controls.
     */
    export import InitialValues = Common.InitialValues;
    /**
     * Options for the DeployTemplate method on provisioning context
     */
    export import DeployTenantLevelTemplateOptions = Common.DeployTenantLevelTemplateOptions;
    /**
     * Options for the DeployTemplate method at resource group level on provisioning context
     */
    export import DeployTemplateOptions = Common.DeployTemplateOptions;
    /**
     * Options for the DeployTemplate method at subscription level on provisioning context
     */
    export import DeploySubscriptionLevelTemplateOptions = Common.DeploySubscriptionLevelTemplateOptions;
    /**
     * Options for the DeployTemplate method at subscription level on provisioning context
     */
    export import DeployManagementGroupLevelTemplateOptions = Common.DeployManagementGroupLevelTemplateOptions;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperationProperties = Common.TemplateDeploymentOperationProperties;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperation = Common.TemplateDeploymentOperation;
    export import BaseDeployTemplateResults = Common.BaseDeployResults;
    export import DeployTemplateResults = Common.DeployTemplateResults;
    /**
     * The deployment status codes.
     */
    export enum DeploymentStatusCode {
        /**
         * Template preflight, validation or deployment failure (based on the operation performed).
         */
        Failure = -1,
        /**
         * Deployment was accepted or successful (based on the operation performed).
         */
        Success = 0,
        /**
         * ARM rejected the deployment request.
         */
        DeploymentRequestFailed = 1,
        /**
         * Deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * Deployment status unknown.
         */
        DeploymentStatusUnknown = 3,
        /**
         * An unexpected error occurred while provisioning the resource group.
         */
        ErrorProvisioningResourceGroup = 4,
        /**
         * An unexpected error occurred while submitting the deployment request.
         */
        ErrorSubmittingDeploymentRequest = 5,
        /**
         * An unexpected error occurred while getting the deployment status.
         */
        ErrorGettingDeploymentStatus = 6,
        /**
         * Invalid arguments.
         */
        InvalidArgs = 7,
        /**
         * An unexpected error occurred while registering the resource providers.
         */
        ErrorRegisteringResourceProviders = 8,
        /**
         * Deployment canceled.
         */
        DeploymentCanceled = 9,
        /**
         * Unknown error.
         */
        UnknownError = 10
    }
    /**
     * Options for the DeployCustom method on provisioning context
     */
    export interface DeployCustomOptions<TResult> {
        /**
         * A promise for when provisioning has finished
         */
        provisioningPromise: Promise<TResult>;
        /**
         * Function to provide a part reference based on the resourceId of a deployment.
         * Defaults to the part reference provided by the marketplace UI.Definition file
         * or null if no marketplace item was provieded to this provisioning blade.
         *
         * @param resource The result of the provisioning promise
         * @returns a part reference to pin to dashboard
         */
        supplyPartReference?(result: TResult): PartReference<any>;
    }
    /**
     * Options for validating the form prior to sending the preflight validation request to ARM.
     */
    export import FormValidationOptions = Common.FormValidationOptions;
}

// FILE: ResourceManagement.d.ts
declare module "Fx/Resources/ResourceManagement" {
    export = ResourceManagement;
    const ResourceManagement: {
        /**
         * The text "{0} ({1})"
         */
        readonly resourceTitleWithParts: string;
        /**
         * The text "- unknown -"
         */
        readonly resourceWithNoName: string;
    };
}

// FILE: Fx\Specs\DropDown.d.ts

// FILE: Fx\Telemetry.d.ts
declare module "Fx/Telemetry" {
    export type ActionModifier = "complete" | "cancel";
    export interface StartTelemetryEvent {
        /**
         * The source of the telemetry data e.g. navigation, blade.
         */
        readonly source: string;
        /**
         * The action being recorded.
         */
        readonly action: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        readonly assetType?: string;
        /**
         * A name associated with the event or item that was the target of the event (optional).
         */
        readonly name?: string;
        /**
         * Whether or not this event should be considered optional. Defaults to false.
         */
        readonly optional?: boolean;
    }
    export interface TelemetryEvent extends StartTelemetryEvent {
        readonly data?: any;
    }
    /**
     * Records a telemetry event.
     *
     * @param evt The telemetry event.
     */
    export const trace: (evt: TelemetryEvent) => void;
}

// FILE: Fx\TimeZones.d.ts
declare module "Fx/TimeZones" {
    export const enum TimeZoneId {
        /**
         * The fake timezone ID for the current (pseudo) timezone.
         */
        Current = "Current",
        /**
         * The timezone ID for 'Line Islands Standard Time'.
         */
        LineIslandsStandardTime = "Line Islands Standard Time",
        /**
         * The timezone ID for 'Samoa Standard Time'.
         */
        SamoaStandardTime = "Samoa Standard Time",
        /**
         * The timezone ID for 'Tonga Standard Time'.
         */
        TongaStandardTime = "Tonga Standard Time",
        /**
         * The timezone ID for 'UTC+13'.
         */
        UTCPlus13 = "UTC+13",
        /**
         * The timezone ID for 'Chatham Islands Standard Time'.
         */
        ChathamIslandsStandardTime = "Chatham Islands Standard Time",
        /**
         * The timezone ID for 'Fiji Standard Time'.
         */
        FijiStandardTime = "Fiji Standard Time",
        /**
         * The timezone ID for 'Kamchatka Standard Time'.
         */
        KamchatkaStandardTime = "Kamchatka Standard Time",
        /**
         * The timezone ID for 'New Zealand Standard Time'.
         */
        NewZealandStandardTime = "New Zealand Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 11'.
         */
        RussiaTimeZone11 = "Russia Time Zone 11",
        /**
         * The timezone ID for 'UTC+12'.
         */
        UTCPlus12 = "UTC+12",
        /**
         * The timezone ID for 'Bougainville Standard Time'.
         */
        BougainvilleStandardTime = "Bougainville Standard Time",
        /**
         * The timezone ID for 'Central Pacific Standard Time'.
         */
        CentralPacificStandardTime = "Central Pacific Standard Time",
        /**
         * The timezone ID for 'Magadan Standard Time'.
         */
        MagadanStandardTime = "Magadan Standard Time",
        /**
         * The timezone ID for 'Norfolk Standard Time'.
         */
        NorfolkStandardTime = "Norfolk Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 10'.
         */
        RussiaTimeZone10 = "Russia Time Zone 10",
        /**
         * The timezone ID for 'Sakhalin Standard Time'.
         */
        SakhalinStandardTime = "Sakhalin Standard Time",
        /**
         * The timezone ID for 'Lord Howe Standard Time'.
         */
        LordHoweStandardTime = "Lord Howe Standard Time",
        /**
         * The timezone ID for 'AUS Eastern Standard Time'.
         */
        AUSEasternStandardTime = "AUS Eastern Standard Time",
        /**
         * The timezone ID for 'E. Australia Standard Time'.
         */
        EAustraliaStandardTime = "E. Australia Standard Time",
        /**
         * The timezone ID for 'Vladivostok Standard Time'.
         */
        VladivostokStandardTime = "Vladivostok Standard Time",
        /**
         * The timezone ID for 'Tasmania Standard Time'.
         */
        TasmaniaStandardTime = "Tasmania Standard Time",
        /**
         * The timezone ID for 'West Pacific Standard Time'.
         */
        WestPacificStandardTime = "West Pacific Standard Time",
        /**
         * The timezone ID for 'AUS Central Standard Time'.
         */
        AUSCentralStandardTime = "AUS Central Standard Time",
        /**
         * The timezone ID for 'Cen. Australia Standard Time'.
         */
        CenAustraliaStandardTime = "Cen. Australia Standard Time",
        /**
         * The timezone ID for 'Korea Standard Time'.
         */
        KoreaStandardTime = "Korea Standard Time",
        /**
         * The timezone ID for 'North Korea Standard Time'.
         */
        NorthKoreaStandardTime = "North Korea Standard Time",
        /**
         * The timezone ID for 'Yakutsk Standard Time'.
         */
        YakutskStandardTime = "Yakutsk Standard Time",
        /**
         * The timezone ID for 'Tokyo Standard Time'.
         */
        TokyoStandardTime = "Tokyo Standard Time",
        /**
         * The timezone ID for 'Transbaikal Standard Time'.
         */
        TransbaikalStandardTime = "Transbaikal Standard Time",
        /**
         * The timezone ID for 'Aus Central W. Standard Time'.
         */
        AusCentralWStandardTime = "Aus Central W. Standard Time",
        /**
         * The timezone ID for 'China Standard Time'.
         */
        ChinaStandardTime = "China Standard Time",
        /**
         * The timezone ID for 'Singapore Standard Time'.
         */
        SingaporeStandardTime = "Singapore Standard Time",
        /**
         * The timezone ID for 'North Asia East Standard Time'.
         */
        NorthAsiaEastStandardTime = "North Asia East Standard Time",
        /**
         * The timezone ID for 'Taipei Standard Time'.
         */
        TaipeiStandardTime = "Taipei Standard Time",
        /**
         * The timezone ID for 'Ulaanbaatar Standard Time'.
         */
        UlaanbaatarStandardTime = "Ulaanbaatar Standard Time",
        /**
         * The timezone ID for 'W. Australia Standard Time'.
         */
        WAustraliaStandardTime = "W. Australia Standard Time",
        /**
         * The timezone ID for 'Altai Standard Time'.
         */
        AltaiStandardTime = "Altai Standard Time",
        /**
         * The timezone ID for 'N. Central Asia Standard Time'.
         */
        NCentralAsiaStandardTime = "N. Central Asia Standard Time",
        /**
         * The timezone ID for 'North Asia Standard Time'.
         */
        NorthAsiaStandardTime = "North Asia Standard Time",
        /**
         * The timezone ID for 'SE Asia Standard Time'.
         */
        SEAsiaStandardTime = "SE Asia Standard Time",
        /**
         * The timezone ID for 'Tomsk Standard Time'.
         */
        TomskStandardTime = "Tomsk Standard Time",
        /**
         * The timezone ID for 'W. Mongolia Standard Time'.
         */
        WMongoliaStandardTime = "W. Mongolia Standard Time",
        /**
         * The timezone ID for 'Myanmar Standard Time'.
         */
        MyanmarStandardTime = "Myanmar Standard Time",
        /**
         * The timezone ID for 'Bangladesh Standard Time'.
         */
        BangladeshStandardTime = "Bangladesh Standard Time",
        /**
         * The timezone ID for 'Central Asia Standard Time'.
         */
        CentralAsiaStandardTime = "Central Asia Standard Time",
        /**
         * The timezone ID for 'Omsk Standard Time'.
         */
        OmskStandardTime = "Omsk Standard Time",
        /**
         * The timezone ID for 'Nepal Standard Time'.
         */
        NepalStandardTime = "Nepal Standard Time",
        /**
         * The timezone ID for 'India Standard Time'.
         */
        IndiaStandardTime = "India Standard Time",
        /**
         * The timezone ID for 'Sri Lanka Standard Time'.
         */
        SriLankaStandardTime = "Sri Lanka Standard Time",
        /**
         * The timezone ID for 'Pakistan Standard Time'.
         */
        PakistanStandardTime = "Pakistan Standard Time",
        /**
         * The timezone ID for 'Qyzylorda Standard Time'.
         */
        QyzylordaStandardTime = "Qyzylorda Standard Time",
        /**
         * The timezone ID for 'Ekaterinburg Standard Time'.
         */
        EkaterinburgStandardTime = "Ekaterinburg Standard Time",
        /**
         * The timezone ID for 'West Asia Standard Time'.
         */
        WestAsiaStandardTime = "West Asia Standard Time",
        /**
         * The timezone ID for 'Afghanistan Standard Time'.
         */
        AfghanistanStandardTime = "Afghanistan Standard Time",
        /**
         * The timezone ID for 'Arabian Standard Time'.
         */
        ArabianStandardTime = "Arabian Standard Time",
        /**
         * The timezone ID for 'Astrakhan Standard Time'.
         */
        AstrakhanStandardTime = "Astrakhan Standard Time",
        /**
         * The timezone ID for 'Azerbaijan Standard Time'.
         */
        AzerbaijanStandardTime = "Azerbaijan Standard Time",
        /**
         * The timezone ID for 'Caucasus Standard Time'.
         */
        CaucasusStandardTime = "Caucasus Standard Time",
        /**
         * The timezone ID for 'Georgian Standard Time'.
         */
        GeorgianStandardTime = "Georgian Standard Time",
        /**
         * The timezone ID for 'Mauritius Standard Time'.
         */
        MauritiusStandardTime = "Mauritius Standard Time",
        /**
         * The timezone ID for 'Russia Time Zone 3'.
         */
        RussiaTimeZone3 = "Russia Time Zone 3",
        /**
         * The timezone ID for 'Saratov Standard Time'.
         */
        SaratovStandardTime = "Saratov Standard Time",
        /**
         * The timezone ID for 'Iran Standard Time'.
         */
        IranStandardTime = "Iran Standard Time",
        /**
         * The timezone ID for 'Arab Standard Time'.
         */
        ArabStandardTime = "Arab Standard Time",
        /**
         * The timezone ID for 'Arabic Standard Time'.
         */
        ArabicStandardTime = "Arabic Standard Time",
        /**
         * The timezone ID for 'Belarus Standard Time'.
         */
        BelarusStandardTime = "Belarus Standard Time",
        /**
         * The timezone ID for 'E. Africa Standard Time'.
         */
        EAfricaStandardTime = "E. Africa Standard Time",
        /**
         * The timezone ID for 'Jordan Standard Time'.
         */
        JordanStandardTime = "Jordan Standard Time",
        /**
         * The timezone ID for 'Russian Standard Time'.
         */
        RussianStandardTime = "Russian Standard Time",
        /**
         * The timezone ID for 'Turkey Standard Time'.
         */
        TurkeyStandardTime = "Turkey Standard Time",
        /**
         * The timezone ID for 'Volgograd Standard Time'.
         */
        VolgogradStandardTime = "Volgograd Standard Time",
        /**
         * The timezone ID for 'E. Europe Standard Time'.
         */
        EEuropeStandardTime = "E. Europe Standard Time",
        /**
         * The timezone ID for 'Egypt Standard Time'.
         */
        EgyptStandardTime = "Egypt Standard Time",
        /**
         * The timezone ID for 'FLE Standard Time'.
         */
        FLEStandardTime = "FLE Standard Time",
        /**
         * The timezone ID for 'GTB Standard Time'.
         */
        GTBStandardTime = "GTB Standard Time",
        /**
         * The timezone ID for 'Israel Standard Time'.
         */
        IsraelStandardTime = "Israel Standard Time",
        /**
         * The timezone ID for 'Libya Standard Time'.
         */
        LibyaStandardTime = "Libya Standard Time",
        /**
         * The timezone ID for 'Middle East Standard Time'.
         */
        MiddleEastStandardTime = "Middle East Standard Time",
        /**
         * The timezone ID for 'Namibia Standard Time'.
         */
        NamibiaStandardTime = "Namibia Standard Time",
        /**
         * The timezone ID for 'Kaliningrad Standard Time'.
         */
        KaliningradStandardTime = "Kaliningrad Standard Time",
        /**
         * The timezone ID for 'South Africa Standard Time'.
         */
        SouthAfricaStandardTime = "South Africa Standard Time",
        /**
         * The timezone ID for 'South Sudan Standard Time'.
         */
        SouthSudanStandardTime = "South Sudan Standard Time",
        /**
         * The timezone ID for 'Sudan Standard Time'.
         */
        SudanStandardTime = "Sudan Standard Time",
        /**
         * The timezone ID for 'Syria Standard Time'.
         */
        SyriaStandardTime = "Syria Standard Time",
        /**
         * The timezone ID for 'West Bank Standard Time'.
         */
        WestBankStandardTime = "West Bank Standard Time",
        /**
         * The timezone ID for 'Central Europe Standard Time'.
         */
        CentralEuropeStandardTime = "Central Europe Standard Time",
        /**
         * The timezone ID for 'Central European Standard Time'.
         */
        CentralEuropeanStandardTime = "Central European Standard Time",
        /**
         * The timezone ID for 'Romance Standard Time'.
         */
        RomanceStandardTime = "Romance Standard Time",
        /**
         * The timezone ID for 'W. Central Africa Standard Time'.
         */
        WCentralAfricaStandardTime = "W. Central Africa Standard Time",
        /**
         * The timezone ID for 'W. Europe Standard Time'.
         */
        WEuropeStandardTime = "W. Europe Standard Time",
        /**
         * The timezone ID for 'UTC'.
         */
        UTC = "UTC",
        /**
         * The timezone ID for 'GMT Standard Time'.
         */
        GMTStandardTime = "GMT Standard Time",
        /**
         * The timezone ID for 'Greenwich Standard Time'.
         */
        GreenwichStandardTime = "Greenwich Standard Time",
        /**
         * The timezone ID for 'Morocco Standard Time'.
         */
        MoroccoStandardTime = "Morocco Standard Time",
        /**
         * The timezone ID for 'Sao Tome Standard Time'.
         */
        SaoTomeStandardTime = "Sao Tome Standard Time",
        /**
         * The timezone ID for 'Azores Standard Time'.
         */
        AzoresStandardTime = "Azores Standard Time",
        /**
         * The timezone ID for 'Cape Verde Standard Time'.
         */
        CapeVerdeStandardTime = "Cape Verde Standard Time",
        /**
         * The timezone ID for 'Mid-Atlantic Standard Time'.
         */
        MidMinusAtlanticStandardTime = "Mid-Atlantic Standard Time",
        /**
         * The timezone ID for 'UTC-02'.
         */
        UTCMinus02 = "UTC-02",
        /**
         * The timezone ID for 'Argentina Standard Time'.
         */
        ArgentinaStandardTime = "Argentina Standard Time",
        /**
         * The timezone ID for 'Bahia Standard Time'.
         */
        BahiaStandardTime = "Bahia Standard Time",
        /**
         * The timezone ID for 'E. South America Standard Time'.
         */
        ESouthAmericaStandardTime = "E. South America Standard Time",
        /**
         * The timezone ID for 'Greenland Standard Time'.
         */
        GreenlandStandardTime = "Greenland Standard Time",
        /**
         * The timezone ID for 'Magallanes Standard Time'.
         */
        MagallanesStandardTime = "Magallanes Standard Time",
        /**
         * The timezone ID for 'Montevideo Standard Time'.
         */
        MontevideoStandardTime = "Montevideo Standard Time",
        /**
         * The timezone ID for 'SA Eastern Standard Time'.
         */
        SAEasternStandardTime = "SA Eastern Standard Time",
        /**
         * The timezone ID for 'Saint Pierre Standard Time'.
         */
        SaintPierreStandardTime = "Saint Pierre Standard Time",
        /**
         * The timezone ID for 'Tocantins Standard Time'.
         */
        TocantinsStandardTime = "Tocantins Standard Time",
        /**
         * The timezone ID for 'Newfoundland Standard Time'.
         */
        NewfoundlandStandardTime = "Newfoundland Standard Time",
        /**
         * The timezone ID for 'Atlantic Standard Time'.
         */
        AtlanticStandardTime = "Atlantic Standard Time",
        /**
         * The timezone ID for 'Central Brazilian Standard Time'.
         */
        CentralBrazilianStandardTime = "Central Brazilian Standard Time",
        /**
         * The timezone ID for 'Pacific SA Standard Time'.
         */
        PacificSAStandardTime = "Pacific SA Standard Time",
        /**
         * The timezone ID for 'Paraguay Standard Time'.
         */
        ParaguayStandardTime = "Paraguay Standard Time",
        /**
         * The timezone ID for 'SA Western Standard Time'.
         */
        SAWesternStandardTime = "SA Western Standard Time",
        /**
         * The timezone ID for 'Venezuela Standard Time'.
         */
        VenezuelaStandardTime = "Venezuela Standard Time",
        /**
         * The timezone ID for 'Cuba Standard Time'.
         */
        CubaStandardTime = "Cuba Standard Time",
        /**
         * The timezone ID for 'Eastern Standard Time'.
         */
        EasternStandardTime = "Eastern Standard Time",
        /**
         * The timezone ID for 'Eastern Standard Time (Mexico)'.
         */
        EasternStandardTimeMexico = "Eastern Standard Time (Mexico)",
        /**
         * The timezone ID for 'Haiti Standard Time'.
         */
        HaitiStandardTime = "Haiti Standard Time",
        /**
         * The timezone ID for 'SA Pacific Standard Time'.
         */
        SAPacificStandardTime = "SA Pacific Standard Time",
        /**
         * The timezone ID for 'Turks And Caicos Standard Time'.
         */
        TurksAndCaicosStandardTime = "Turks And Caicos Standard Time",
        /**
         * The timezone ID for 'US Eastern Standard Time'.
         */
        USEasternStandardTime = "US Eastern Standard Time",
        /**
         * The timezone ID for 'Canada Central Standard Time'.
         */
        CanadaCentralStandardTime = "Canada Central Standard Time",
        /**
         * The timezone ID for 'Central America Standard Time'.
         */
        CentralAmericaStandardTime = "Central America Standard Time",
        /**
         * The timezone ID for 'Central Standard Time'.
         */
        CentralStandardTime = "Central Standard Time",
        /**
         * The timezone ID for 'Central Standard Time (Mexico)'.
         */
        CentralStandardTimeMexico = "Central Standard Time (Mexico)",
        /**
         * The timezone ID for 'Easter Island Standard Time'.
         */
        EasterIslandStandardTime = "Easter Island Standard Time",
        /**
         * The timezone ID for 'Mountain Standard Time'.
         */
        MountainStandardTime = "Mountain Standard Time",
        /**
         * The timezone ID for 'Mountain Standard Time (Mexico)'.
         */
        MountainStandardTimeMexico = "Mountain Standard Time (Mexico)",
        /**
         * The timezone ID for 'US Mountain Standard Time'.
         */
        USMountainStandardTime = "US Mountain Standard Time",
        /**
         * The timezone ID for 'Yukon Standard Time'.
         */
        YukonStandardTime = "Yukon Standard Time",
        /**
         * The timezone ID for 'Pacific Standard Time'.
         */
        PacificStandardTime = "Pacific Standard Time",
        /**
         * The timezone ID for 'Pacific Standard Time (Mexico)'.
         */
        PacificStandardTimeMexico = "Pacific Standard Time (Mexico)",
        /**
         * The timezone ID for 'UTC-08'.
         */
        UTCMinus08 = "UTC-08",
        /**
         * The timezone ID for 'Alaskan Standard Time'.
         */
        AlaskanStandardTime = "Alaskan Standard Time",
        /**
         * The timezone ID for 'UTC-09'.
         */
        UTCMinus09 = "UTC-09",
        /**
         * The timezone ID for 'Marquesas Standard Time'.
         */
        MarquesasStandardTime = "Marquesas Standard Time",
        /**
         * The timezone ID for 'Aleutian Standard Time'.
         */
        AleutianStandardTime = "Aleutian Standard Time",
        /**
         * The timezone ID for 'Hawaiian Standard Time'.
         */
        HawaiianStandardTime = "Hawaiian Standard Time",
        /**
         * The timezone ID for 'UTC-11'.
         */
        UTCMinus11 = "UTC-11",
        /**
         * The timezone ID for 'Dateline Standard Time'.
         */
        DatelineStandardTime = "Dateline Standard Time"
    }
    /**
     * Interface for a specific TimeZone object.
     */
    export interface TimeZone {
        /**
         * ID of the TimeZone
         */
        readonly id: TimeZoneId;
        /**
         * Default offset in minutes of the timezone from UTC.
         */
        readonly defaultUtcOffset: number;
        /**
         * Standard name of the timezone, e.g. "Pacific Standard Time"
         */
        readonly standardName: string;
        /**
         * Daylight name of the timezone, e.g. "Pacific Daylight Time"
         */
        readonly daylightName: string;
        /**
         * Display string of the timezone, e.g. "(UTC-08:00) Pacific Time (US & Canada)"
         */
        readonly displayString: string;
    }
    /**
     * Gets the current timezone object. This has special properties and the name should typically not be used as that is a fake name.
     * @returns The current timezone object
     */
    export function getCurrentTimeZone(): TimeZone;
    /**
     * List of all available timezones sorted based on UTC offset
     * @returns The list of all available timezone objects
     */
    export function getTimeZones(): ReadonlyArray<TimeZone>;
    /**
     * Get the timezone object corresponding to a particular ID
     * @param timezoneId The ID of the timezone
     * @returns The timezone object corresponding to the ID
     */
    export function getTimeZoneById(timezoneId: TimeZoneId): TimeZone;
    /**
     * Get the timezone object corresponding to a particular standard name
     * @param timezoneName The name of the timezone
     * @returns The timezone object corresponding to the name
     */
    export function getTimeZoneByStandardName(timezoneName: string): TimeZone;
    /**
     * Get the timezone object corresponding to a particular standard name or daylight name
     * @param timezoneName The name of the timezone
     * @returns The timezone object corresponding to the name
     */
    export function getTimeZoneByName(timezoneName: string): TimeZone;
    /**
     * Get the timezone objects corresponding to a UTC offset for a given date
     * @param offset The UTC offset of the timezone
     * @param relativeDate The date for which the UTC offset is provided. If this is not provided, the offset is compared to the default UTC offset.
     * @returns The list of timezone objects with matching offsets
     */
    export function getTimeZonesByOffset(offset: number, relativeDate?: Date): ReadonlyArray<TimeZone>;
    /**
     * Converts a date/time in the local timezone to a date/time in the provided timezone, taking DST into account.
     * @param toTimeZoneId The ID of the timezone to convert the date/time to
     * @param date The date in local timezone to convert
     * @returns The date in the provided timezone
     */
    export function convertFromLocalTimeZone(toTimeZoneId: TimeZoneId, date: Date): Date;
    /**
     * Converts a date/time in the provided timezone to a date/time in the local timezone, taking DST into account.
     * @param fromTimeZoneId The ID of the timezone to convert the date/time from
     * @param date The date in the provided timezone to convert
     * @returns The date in the local timezone
     */
    export function convertToLocalTimeZone(fromTimeZoneId: TimeZoneId, date: Date): Date;
    /**
     * Gets the UTC offset of a given date/time in a given timezone. If no date is provided, this returns the default UTC offset for the timezone.
     * @param timezoneId The ID of the timezone to use for the calculation
     * @param date The relative date to use for offset calculation
     * @returns The UTC offset in minutes
     */
    export function getUtcOffsetForTimeZone(timezoneId: TimeZoneId, date?: Date): number;
}

// FILE: Fx\UriBuilder.d.ts
declare module "Fx/UriBuilder" {
    const _default: typeof MsPortalFx.Base.UriBuilder;
    export = _default;
}

// FILE: Fx\Weave.d.ts
declare module "Fx/Weave" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type OnResizeEventData = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type ResizeEventHandler = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type FxClickData = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const toComputation: Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const toValueOrComputation: Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const toObservable: Obsolete;
}

// FILE: Fx\Weave\ComponentHandle.d.ts
declare module "Fx/Weave/ComponentHandle" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type ComponentHandle = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const makeComponentHandle: Obsolete;
}

// FILE: Fx\Weave\Components\Accordion.d.ts
declare module "Fx/Weave/Components/Accordion" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type AccordionProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type AccordionSection = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Accordion: Obsolete;
}

// FILE: Fx\Weave\Components\Button.d.ts
declare module "Fx/Weave/Components/Button" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type ButtonStyle = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type ButtonProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Button: Obsolete;
}

// FILE: Fx\Weave\Components\FormattedFragment.d.ts
declare module "Fx/Weave/Components/FormattedFragment" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type FormattedFragmentProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const FormattedFragment: Obsolete;
}

// FILE: Fx\Weave\Components\Html.d.ts
declare module "Fx/Weave/Components/Html" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type HtmlProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Html: Obsolete;
}

// FILE: Fx\Weave\Components\LoadingIndicator.d.ts
declare module "Fx/Weave/Components/LoadingIndicator" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type Size = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type LoadingIndicatorProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const LoadingIndicator: Obsolete;
}

// FILE: Fx\Weave\Components\PcControl.d.ts
declare module "Fx/Weave/Components/PcControl" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type PcControlProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const PcControl: Obsolete;
}

// FILE: Fx\Weave\Components\Section.d.ts
declare module "Fx/Weave/Components/Section" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type SectionProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Section: Obsolete;
}

// FILE: Fx\Weave\Components\Splitter.d.ts
declare module "Fx/Weave/Components/Splitter" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type Orientation = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type CollapseKind = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type CollapseKindChangeEventData = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type SplitterProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type PaneOptions = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Splitter: Obsolete;
}

// FILE: Fx\Weave\Components\Tab.d.ts
declare module "Fx/Weave/Components/Tab" {
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type TabPage = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type ActiveIndexChangeEventData = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type TabPageRemoveEventData = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export type TabProps = Obsolete;
    /**
     * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    export const Tab: Obsolete;
}

// FILE: Fx\Weave\WeaveTypes.d.ts
/**
 * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
 * @see {@link https://aka.ms/portalfx/breaking} for more details.
 */
type WeaveSandboxModeCustomAttributes = Obsolete;
/**
 * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
 * @see {@link https://aka.ms/portalfx/breaking} for more details.
 */
type ImmutableWeaveContext = Obsolete;
/**
 * @deprecated Fx/Composition/TemplateBlade2 is obsolete.  Please use Fx/Composition/TemplateBlade or ReactViews.
 * @see {@link https://aka.ms/portalfx/breaking} for more details.
 */
type CssSpecification = Obsolete;

// Compiled with TypeScript 5.0

// FILE: Fx\Assets.d.ts
declare module "Fx/Assets" {
    import { Image } from "Fx/Images/Image";
    import { ViewModelLocator } from "Fx/Extension";
    import { ResourceRoutingType as ResourceRoutingType_ } from "Fx/Assets/ResourceRoutingType";
    export import CompositeDisplayName = Common.Assets.CompositeDisplayName;
    /**
     * The asset type interface which represents a fully qualified asset type (extension + asset type).
     */
    export interface AssetType {
        /**
         * The extension name for the fully qualified asset type.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset type.
         */
        assetType: string;
    }
    export import Link = Common.Assets.Link;
    export import AssetTypeBrowseCommandLayout = Common.Assets.AssetTypeBrowseCommandLayout;
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    export interface AssetTypeInformation extends AssetType {
        /**
         * The asset type's icon image if successful, null otherwise.
         */
        icon: Image;
        /**
         * The asset type's display name if successful, null otherwise.
         */
        compositeDisplayName: CompositeDisplayName;
        /**
         * The options for the asset type.
         */
        options?: AssetTypeOptions;
        /**
         * The browse type for the asset type.
         */
        browseType: BrowseType;
        /**
         * The browse link URI for the asset type.
         */
        browseLinkUri?: string;
        /**
         * The entry point of the view model.
         */
        viewModelLocator: ViewModelLocator;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel: string;
        /**
         * The name of the extension that contains the view model.
         */
        viewModelExtensionName?: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts: number;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
        /**
         * Optional flag to indicate the asset type is disabled by policy.
         * If this flag is not specified, the asset type is NOT disabled.
         */
        isDisabled?: boolean;
        /**
         * The create blade associated with the asset
         */
        noPdlCreateBlade?: string;
        /**
         * The extension with the create blade associated with the asset
         */
        noPdlCreateExtension?: string;
        /**
         * The parameters passed to the create blade associated with the asset
         */
        noPdlCreateParameters?: any;
        /**
         * The marketplace item id associated with the asset.
         */
        marketplaceItemId?: string;
        /**
         * The marketplace menu item id associated with the asset.
         */
        marketplaceMenuItemId?: string;
        /**
         * The blade that should be loaded after initiating a template deployment associated with the asset.
         */
        readonly postCreateBlade?: Common.Assets.PostCreateBladeReference;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         *
         * @deprecated Fx.Assets.AssetTypeInformation.privateBrowse 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        privateBrowse?: boolean;
        /**
         * The list of keywords.
         */
        keywords?: string[];
        /**
         * The description of asset type.
         */
        description?: string;
        /**
         * The documentation links for asset type.
         */
        links?: Link[];
        /**
         * The list of hidden commands for the asset type.
         */
        hiddenCommands?: ReadonlyArray<string>;
        /**
         * The flag to hide (or show) the browse info box (overrides PDL BrowseInfoBox).
         */
        hideBrowseInfoBox?: boolean;
        /**
         * The browse command layout experiments for a given asset type.
         */
        browseCommandExperiments?: ReadonlyStringMap<AssetTypeBrowseCommandLayout>;
        /**
         * The optional map of command id and respective api-versions to be used per resource type for a given asset type.
         * This is used to override default api-versions in extensible ARM bulk command definitions.
         */
        extensibleCommandsApiVersions?: ReadonlyStringMap<ReadonlyStringMap<string>>;
    }
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    export interface ResourceTypeAssetTypeInformation extends AssetTypeInformation {
        /**
         * The resource type.
         */
        resourceType: string;
        /**
         * The API resource type for ARM.
         * This is only valid for tenant-routing resources.
         */
        topLevelTenantAlias?: string;
        /**
         * The API resource type for ARM.
         * This is only valid for end-point-routing resources.
         */
        topLevelResourceTypeAlias?: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The flag to hide assets from the resource map.
         * THIS IS OBSOLETE AND WILL ALWAYS BE TRUE UNTIL THIS FLAG IS REMOVED.
         */
        hideOnResourceMap?: boolean;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: ResourceRoutingType;
        /**
         * The blade associated with the resource type.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type.
         */
        bladeExtensionName?: string;
        /**
         * The part associated with the resource type.
         */
        partName?: string;
        /**
         * Optional, an external extension that contains the resource part
         */
        partExtensionName?: string;
        /**
         * The static overview menu item.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: ResourceKindDefinition[];
        /**
         * The optional array of proxy routing filters for this resource type.
         */
        proxyRoutingFilters?: ProxyRoutingFilter[];
        /**
         * The optional option for ARM browse.
         */
        armBrowseOption?: ArmBrowseOptions;
        /**
         * The optional option for ARG browse.
         */
        argBrowseOption?: ArgBrowseOptions;
        /**
         * The optional deep link for browse.
         */
        browseDeepLink?: string;
        /**
         * The optional flag to show / hide columns for ARG browse.
         */
        showArgColumns?: ReadonlyStringMap<boolean>;
        /**
         * The optional feature card options for the ARG browse.
         */
        featureCardOptions?: ReadonlyArray<Common.Assets.BrowseFeatureCardReference>;
    }
    export import AssetTypeOptions = Common.AssetTypes.AssetTypeOptions;
    export import BrowseType = Common.AssetTypes.BrowseType;
    export import ProxyRoutingFilter = Common.Assets.ProxyRoutingFilter;
    export import ResourceRoutingType = ResourceRoutingType_;
    export import ColumnFormat = Common.Assets.ColumnFormat;
    export import SummaryVisualizations = Common.Assets.SummaryVisualizations;
    export import ArgBrowseOptions = Common.AssetTypes.ArgBrowseOptions;
    export import ArmBrowseOptions = Common.AssetTypes.ArmBrowseOptions;
    export import GetAllAssetTypesOptions = Common.AssetTypes.GetAllAssetTypesOptions;
    /**
     * The resource kind definition defines the resource kind information for a resource type.
     */
    export interface ResourceKindDefinition {
        /**
         * The name of the resource type kind.
         */
        name: string;
        /**
         * The is default flag of the resource type kind.
         */
        isDefault?: boolean;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        options?: AssetTypeOptions;
        /**
         * The visibility of the resource type kind.
         *
         * @deprecated Fx.Assets.ResourceKindDefinition.visibility 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        visibility?: Obsolete;
        /**
         * The singular display name of the resource type kind.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the resource type kind.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the resource type kind.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the resource type kind.
         */
        lowerPluralDisplayName?: string;
        /**
         * The service display name of the resource type kind.
         */
        serviceDisplayName?: string;
        /**
         * The blade associated with the resource type kind.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the resource type kind.
         */
        bladeExtensionName?: string;
        /**
         * Name of part to use for pinning
         */
        partName?: string;
        /**
         * Name of the extension that contains the part
         */
        partExtensionName?: string;
        /**
         * The icon of the resource type kind.
         */
        icon?: Image;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview.
         */
        isPreview?: boolean;
        /**
         * The is use resource menu flag of the resource type kind.
         */
        useResourceMenu?: boolean;
        /**
         * The static overview menu item of the resource type kind.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The name of the extension with the create blade.
         */
        noPdlCreateExtension?: string;
        /**
         * The parameters to the create blade.
         */
        noPdlCreateParameters?: any;
        /**
         * The create blade name.
         */
        noPdlCreateBlade?: string;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The list of keywords.
         * NOTE: comma separated list.
         */
        keywords?: string;
        /**
         * The service menu asset type reference.
         */
        serviceMenuBlade?: string;
        /**
         * The service menu asset type reference extension.
         */
        serviceMenuBladeExtension?: string;
        /**
         * The service menu ID.
         */
        serviceMenuItemId?: string;
        /**
         * The kinds (for filtering) for the kind.
         */
        kinds?: string[];
        /**
         * The filter map for the kind.
         */
        filterMap?: StringMap<boolean>;
        /**
         * This is an internal-only flag to pass config information to the browse query manifest to override this flag.
         */
        hideBrowseInfoBox?: boolean;
    }
    /**
     * The static overview definition defines the static overview menu item for an asset type or resource type kind.
     */
    export interface StaticOverviewDefinition {
        /**
         * The optional ID for the static overview menu item.
         */
        id?: string;
        /**
         * The optional display name of the static overview menu item.
         */
        displayName?: string;
        /**
         * The optional icon of the static overview menu item.
         */
        icon?: Image;
        /**
         * The optional keywords.
         */
        keywords?: string;
    }
    export import BrowseResourceSelection = Common.Assets.BrowseResourceSelection;
    export import ArmCommandOptionsManifest = Common.Assets.ArmCommandOptionsManifest;
    export import ArmCommandDefinition = Common.Assets.ArmCommandDefinition;
    export import AsyncOperationOptions = Common.Assets.AsyncOperationOptions;
    export import ConfirmationOptionsManifest = Common.Assets.ConfirmationOptionsManifest;
    export import BladeReferenceOptions = Common.Assets.BladeReferenceOptions;
    export import CommandVisibility = Common.Assets.CommandVisibility;
    export import CommandManifest = Common.Assets.CommandManifest;
    export import CommandSet = Common.Assets.CommandSet;
    export import BrowseManifest = Common.Assets.BrowseManifest;
    export import BrowseFeatureCardReference = Common.Assets.BrowseFeatureCardReference;
    export import BrowseInfoBoxStyle = Common.Assets.BrowseInfoBoxStyle;
    export import BrowseInfoBoxManifest = Common.Assets.BrowseInfoBoxManifest;
    export import BrowseColumnManifest = Common.Assets.BrowseColumnManifest;
    export import MergedResourceTypeManifest = Common.Assets.MergedResourceTypeManifest;
    export import ResourceColumnIds = Common.Assets.ResourceColumnIds;
    export import AssetTypeContracts = Common.Assets.AssetTypeContracts;
    export import FeatureCardManifest = Common.Assets.FeatureCardManifest;
    export import FeatureCard = Common.Assets.FeatureCard;
}

// FILE: Fx\Assets\AssetTypeOptions.d.ts
declare module "Fx/Assets/AssetTypeOptions" {
    module Main {
        const enum AssetTypeOptions {
            /**
             * The asset type does not provide any options.
             */
            NoOptions = 0,
            /**
             * The asset type is hidden from the browse menu, search and the resource filter types.
             */
            HideAssetType = 1,
            /**
             * The asset type's instances (actual resources) are by default hidden from the browse resource list and search results.
             */
            HideInstances = 2,
            /**
             * The asset type is shown in the browse menu, search and the resource filter types. This is used for kinds to override the parent asset type.
             */
            ShowAssetType = 4,
            /**
             * The asset type's instances (actual resources) are by default shown from the browse resource list and search results. This is used for kinds to override the parent asset type.
             */
            ShowInstances = 8,
            /**
             * The asset type's is marked as disabled. This should only be used internally, but is included for completeness.
             */
            Disabled = 16
        }
    }
    export = Main;
}

// FILE: Fx\Assets\BrowseType.d.ts
declare module "Fx/Assets/BrowseType" {
    module Main {
        const enum BrowseType {
            /**
             * Use the service view model (browse V1).
             *
             * @deprecated Fx.Assets.BrowseType.ServiceViewModel Browse V1 is no longer supported and at this point is not used by any teams
             *
             * Please refer to https://aka.ms/portalfx/breaking for more details.
             */
            ServiceViewModel = 0,
            /**
             * Use the resource type for browse.
             */
            ResourceType = 1,
            /**
             * Use the asset type blade for browse.
             */
            AssetTypeBlade = 2,
            /**
             * Service link into the classic portal for a service.
             */
            ServiceLink = 3,
            /**
             * Instance link into the classic portal for an instance of a service.
             *
             * @deprecated Fx.Assets.BrowseType.InstanceLink Instance link browse is no longer supported and at this point is not used by any teams
             *
             * Please refer to https://aka.ms/portalfx/breaking for more details.
             */
            InstanceLink = 4,
            /**
             * The asset type does not support browse (used only in typescript).
             */
            NoBrowse = -1
        }
    }
    export = Main;
}

// FILE: Fx\Assets\ColumnFormat.d.ts
declare module "Fx/Assets/ColumnFormat" {
    module Main {
        const enum ColumnFormat {
            /**
             * The column has no format (used only in typescript).
             */
            NoFormat = 0,
            /**
             * Simple string column direct from ARG results.
             */
            String = 1,
            /**
             * Resource column which is an ARM ID from ARG results.
             */
            Resource = 2,
            /**
             * Simple date column direct from ARG results.
             */
            Date = 3,
            /**
             * The result from ARG will be mapped as a number based on the user's current locale.
             */
            Number = 4,
            /**
             * The result from ARG will be mapped to a location display name.
             */
            Location = 5,
            /**
             * Simple string column direct from ARG results that will launch a blade using the Blade property of the column.
             */
            BladeLink = 6,
            /**
             * The result from ARG will be mapped to a tenant display name.
             */
            Tenant = 7,
            /**
             * The result from ARG will be the text for the column representing the resource status.
             */
            Status = 8,
            /**
             * Object column direct from ARG results that will launch a deep link.
             */
            DeepLink = 9,
            /**
             * Simple string column direct from ARG results that will launch a blade using the Blade property of the column.
             */
            QueryBladeLink = 10
        }
    }
    export = Main;
}

// FILE: Fx\Assets\ProxyRoutingFilter.d.ts
declare module "Fx/Assets/ProxyRoutingFilter" {
    module Main {
        const enum ProxyRoutingFilter {
            /**
             * Text proxy routing filter.
             */
            TextFilter = 1,
            /**
             * Resource group proxy routing filter.
             */
            ResourceGroupFilter = 2,
            /**
             * Location proxy routing filter.
             */
            LocationFilter = 3
        }
    }
    export = Main;
}

// FILE: Fx\Assets\ResourceRoutingType.d.ts
declare module "Fx/Assets/ResourceRoutingType" {
    module Main {
        enum ResourceRoutingType {
            /**
             * Default routing type, resource-group level resources.
             */
            Default = 0,
            /**
             * Tenant (provider) based resources.
             */
            Tenant = 1,
            /**
             * Extension based resources.
             */
            Extension = 2,
            /**
             * Provider proxy based resources.
             */
            ProviderProxy = 3
        }
    }
    export = Main;
}

// FILE: Fx\Assets\SummaryVisualizations.d.ts
declare module "Fx/Assets/SummaryVisualizations" {
    module Main {
        const enum SummaryVisualizations {
            /**
             * The summary has no visualizations.
             */
            NoVisualizations = 0,
            /**
             * The summary is available as a map visualization (must be location summary).
             */
            Map = 1,
            /**
             * The summary is available as a bar chart visualization.
             */
            BarChart = 2,
            /**
             * The summary is available as a donut chart visualization.
             */
            DonutChart = 4,
            /**
             * The summary is available as a grid (list) visualization.
             */
            Grid = 8,
            /**
             * The result from ARG will be mapped as a number based on the user's current locale.
             */
            Default = 2147483646,
            /**
             * The result from ARG will be mapped to a location display name.
             */
            DefaultWithMap = 2147483647
        }
    }
    export = Main;
}

// FILE: Fx\DependencyInjectionCore.d.ts
declare module "Fx/DependencyInjectionCore" {
    global {
        interface DependencyInjectionScope {
            "": undefined;
        }
    }
    /**
     * The generic construct signature.
     */
    export type Constructor<T> = new (...args: any[]) => T;
    /**
     * The signature of an interceptor function.
     */
    export type Interceptor<T> = (previous: T) => T | void;
    /**
     * A conditional type that maps the specified tuple type to only the types that
     * can be injected for the specified scope. The resulting type is a union type of
     * the mapped elements of the tuple type. For disallowed types in the tuple type,
     * the mapping produces a different type.
     */
    export type InjectableTypes<TScope extends keyof DependencyInjectionScope, TTuple> = {
        [K in keyof TTuple]: Container<TScope> extends TTuple[K] ? TTuple[K] : TTuple[K] extends Container<any> ? Container<TScope> : TTuple[K] extends object ? TTuple[K] : object;
    }[Extract<keyof TTuple, number>];
    /**
     * A decorator that registers the attributed class as a dependency injected class. The parameters of the
     * constructor of the attributed class can only be either an import("Fx/DependencyInjection").Container&lt;TScope&gt; type
     * where TScope is omitted or is the same scope of the Class decorator, or a class type.
     *
     * @param scope The scope of the registered class.
     */
    export function Class<TScope extends keyof DependencyInjectionScope = "">(scope?: TScope): <T, TArgs extends InjectableTypes<TScope, TArgs>[]>(target: new (...args: TArgs) => T) => void;
    /**
     * A decorator that registers the attributed method as a dependency injected factory method. The parameters of the
     * attributed method can only be either an import("Fx/DependencyInjection").Container&lt;TScope&gt; type
     * where TScope is omitted or is the same scope of the Factory decorator, or a class type.
     *
     * @param scope The scope of the registered class.
     */
    export function Factory<TScope extends keyof DependencyInjectionScope = "">(scope?: TScope): <T, TArgs extends InjectableTypes<TScope, TArgs>[]>(target: Constructor<T>, propertyKey: string, _descriptor: TypedPropertyDescriptor<(...args: TArgs) => T | PromiseLike<T>>) => void;
    /**
     * A decorator that registers the attributed class as a dependency injected value.
     *
     * @param scope The scope of the registered class.
     */
    export function Value(scope?: keyof DependencyInjectionScope): <T>(target: Constructor<T>) => void;
    /**
     * The dependency injection container.
     */
    export abstract class Container<TScope extends keyof DependencyInjectionScope = keyof DependencyInjectionScope> {
        /**
         * The scope of the container.
         */
        abstract readonly scope: TScope;
        /**
         * Creates a child container with the specified scope. The newly created container will be disposed when current container is being disposed.
         *
         * @param scope The scope.
         * @returns The child container.
         */
        abstract createChildContainer<UScope extends Exclude<keyof DependencyInjectionScope, "">>(scope: UScope): ConfigurableContainer<UScope>;
        /**
         * Returns whether the container is already disposed.
         */
        abstract isDisposed(): boolean;
        /**
         * Gets the instance associated with the registered type. Within a container, the same instance is always returned for the same type.
         *
         * @param type The type.
         * @returns The instance.
         */
        abstract get<T>(type: Constructor<T>): T;
        /**
         * The async version of get. Used to compose types that are registered with an async factory method.
         *
         * @param type The type.
         * @returns A promise that resolves to the instance.
         */
        abstract getAsync<T>(type: Constructor<T> | PromiseLike<Constructor<T>>): Promise<T>;
    }
    /**
     * The dependency injection container.
     */
    export interface ConfigurableContainer<TScope extends keyof DependencyInjectionScope = ""> extends Container<TScope> {
        /**
         * Registers the instance for the given type. Compositions for the given type will use the
         * instance instead. The container will not acquire lifetime ownership and therefore will not call
         * dispose on the instance when the container is disposed.
         *
         * @param type The type.
         * @param value The instance.
         * @returns The current 'this' context.
         */
        set<T>(type: Constructor<T>, value: T): this;
        /**
         * Registers an interceptor for the given type. Interceptors are invoked on newly composed instances and can be used to customize them.
         *
         * @param type The type.
         * @param interceptor The interceptor.
         * @returns The current 'this' context.
         */
        setInterceptor<T>(type: Constructor<T>, interceptor: Interceptor<T>): this;
        /**
         * Disposes the container. All composed instances will also be disposed. This method will wait for the completion
         * of any async factory methods that are still executing. Instances explicitly specified with the set method will
         * not be disposed.
         *
         * @returns A promise that resolves when all composed instances have been disposed.
         */
        disposeAsync(): Promise<void>;
    }
    /**
     * Use ConfigurableContainer type. Do not use this type.
     */
    export type RootContainer = ConfigurableContainer;
    /**
     * Create a new instance of the dependency injection container.
     */
    export function createContainer(): ConfigurableContainer<"">;
    /**
     * The global singleton dependency injection container.
     */
    export const container: ConfigurableContainer<"">;
}

// FILE: Fx\Diagnostics.d.ts
declare module "Fx/Diagnostics" {
    /**
     * A log message.
     */
    export type LogMessage = string | Error | JQueryXHRLike<any>;
    /**
     * Trace level.
     */
    export const enum LogEntryLevel {
        /**
         * Custom events.
         */
        Custom = -2,
        /**
         * Debug level.
         */
        Debug = -1,
        /**
         * Verbose level.
         */
        Verbose = 0,
        /**
         * Warning level.
         */
        Warning = 1,
        /**
         * Error level.
         */
        Error = 2
    }
    /**
     * A log.
     */
    export interface Log {
        /**
         * Log verbose information.
         *
         * @param entry The message to log.
         * @param restArgs Extra information to log with the message.
         */
        verbose(entry: string, ...restArgs: any[]): void;
        /**
         * Log warning information.
         *
         * @param entry The message to log.
         * @param code The message code.
         * @param restArgs Extra information to log with the message.
         */
        warning(entry: LogMessage, code?: number, ...restArgs: any[]): void;
        /**
         * Log error information.
         *
         * @param entry The message to log.
         * @param code The message code.
         * @param restArgs Extra information to log with the message.
         */
        error(entry: LogMessage, code?: number, ...restArgs: any[]): void;
        /**
         * Log debug information.
         *
         * @param entry The message to log.
         * @param restArgs Extra information to log with the message.
         */
        debug(entry: LogMessage, ...restArgs: any[]): void;
        /**
         * Log information.
         *
         * @param level Information level type.
         * @param entry The message to log.
         * @param code The message code.
         * @param args Extra information to log with the message.
         */
        writeEntry(level: LogEntryLevel, entry: LogMessage, code: number, args: any[]): void;
    }
    /**
     * Facilities to create logs and upload log entries.
     */
    export class Logging {
        /**
         * Logs event.
         *
         * @param level Information level type.
         * @param area Name of information area.
         * @param message Information that is to be logged.
         * @param code The message code.
         * @param restArgs Any other parameters that should be captured.
         */
        writeEntry(level: LogEntryLevel, area: string, message: LogMessage, code?: number, restArgs?: any[]): void;
        /**
         * Flushes any buffered log entries.
         */
        flush(): void;
        /**
         * Disables the log.
         */
        disable(): void;
        /**
         * Creates a log for a given area
         *
         * @param area The area
         * @returns The log
         */
        createLog(area: string): Log;
        createLog(localRequire: LocalRequire): Log;
    }
    export const createLog: (require: LocalRequire) => Log;
    /**
     * Stringifies the specified message.
     */
    export function getLogFriendlyMessage(message: any): string;
    interface JQueryXHRLike<T> extends XMLHttpRequestLike {
        always(alwaysCallback: () => void): void;
        state(): string;
        then(doneCallbacks: (data: T, textStatus: string, jqXHR: JQueryXHRLike<T>) => void, failCallbacks?: (jqXHR: JQueryXHRLike<T>, textStatus: string, errorThrown: any) => void, progressCallbacks?: () => void): void;
    }
    interface XMLHttpRequestLike {
        getResponseHeader(header: string): string;
        getAllResponseHeaders(): string;
        readyState: number;
        status: number;
        statusText: string;
        responseText?: string;
    }
    export {};
}

// FILE: Fx\Errors.d.ts
declare module "Fx/Errors" {
    /**
     * Defines the contract of an error within the Framework.
     */
    export interface ErrorContract {
        /**
         * Gets the proxyable name of the error.
         */
        type: string;
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: Error[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * Information associated with the error that is never proxied.
         */
        errorData?: any;
        /**
         * Information associated with the error that may be proxied.
         */
        data?: any;
    }
    export const enum ErrorLevel {
        /**
         * Do not log if unhandled.
         */
        None = 0,
        /**
         * Log as warning if unhandled.
         */
        Warning = 1,
        /**
         * Log as error if unhandled.
         */
        Error = 2
    }
    export interface ErrorType<E extends Error> {
        /**
         * Constructor.
         */
        new (...args: any[]): E;
        /**
         * Provides the unique type name for this error.
         */
        TypeName: string;
    }
    export interface ErrorOptions {
        /**
         * The error message.
         */
        message?: string;
        /**
         * The error code.
         */
        code?: number;
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel?: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel?: ErrorLevel;
        /**
         * Error source information.
         */
        source?: string;
        /**
         * Inner errors that caused this error.
         */
        innerErrors?: Error | Error[];
        /**
         * Indicates if the error has been handled.
         */
        handled?: boolean;
        /**
         * Time error occured.
         */
        timestamp?: number;
        /**
         * Call stack.
         */
        stack?: string;
        /**
         * The error name.
         */
        name?: string;
        /**
         * Information associated with the error.
         * (This error data is shielded from being proxied by a get accessor.)
         */
        errorData?: any;
        /**
         * Information associated with the error.
         * (This error data may be proxied.)
         */
        data?: any;
    }
    /**
     * Checks if the error is an instance of the specified error type.
     * Works across the proxied obserable layer for MsPortalFx.Errors.Error derived errors.
     *
     * @param error The error instance to check.
     * @param errorType The type of error to check for.
     * @returns Indicates if the error is an instance of the type.
     */
    export function isInstanceOfErrorType<E extends Error>(error: any, errorType: ErrorType<E>): error is E;
    /**
     * Helper to convert various param types to an options object.
     */
    export function getErrorOptions<T extends ErrorOptions>(message: string, defaultOptions?: T): T;
    export function getErrorOptions<T extends ErrorOptions>(options: T, defaultOptions?: T): T;
    /**
     * Framework Error object that can be thrown or
     * or derived from to make more specific errors.
     */
    export class FxError extends Error implements ErrorContract {
        /**
         * Stores the error type name.
         * Preferably derived errors should specify this to uniquely identify themselves.
         * However, if not provided the contructor name is used to set this at run-time.
         */
        static TypeName: string;
        /**
         * Checks that this error type is a base of the error.
         *
         * @param error The error to check.
         * @returns True if the error is of this error type.
         */
        static isBaseOf(error: any): error is FxError;
        /**
         * The error code.
         */
        code: number;
        /**
         * The error source information.
         */
        source: string;
        /**
         * The name of the extension that created the error.
         */
        extension: string;
        /**
         * The error type name.
         */
        type: string;
        /**
         * The error type names in the prototype chain.
         */
        baseTypes: string[];
        /**
         * The default error level for logging the error.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the errorLevel will determine how the unhandled rejection is logged.
         */
        errorLevel: ErrorLevel;
        /**
         * The error level for logging in the source iframe only.
         *
         * If this error is used to reject a promise and the rejection is unhandled
         * the _sourceErrorLevel will determine how the unhandled rejection is logged
         * within the source iframe.
         * If undefined the the errorLevel will be used instead.
         * The _sourceErrorLevel property will always be undefined in iframes besides the error source.
         */
        _sourceErrorLevel: ErrorLevel;
        /**
         * Inner error that caused this error.
         */
        innerErrors: Error[];
        /**
         * If true, indicates that no further handling is required.
         */
        handled: boolean;
        /**
         * Time error occured.
         */
        timestamp: number;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error name.
         */
        name: string;
        /**
         * The error call stack.
         */
        stack: string;
        /**
         * Information associated with the error that is never proxied.
         */
        private _errorData;
        /**
         * Information associated with the error that can be proxied.
         */
        data: any;
        /**
         * Constructs a generic Error.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a generic Error.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
        /**
         * Error specific data.
         */
        get errorData(): any;
    }
}

// FILE: Fx\Experimentation.d.ts
declare module "Fx/Experimentation" {
    /**
     * @deprecated Fx.Experimentation.getExtensionFlights Use extensionAssignments.getXXXValue() (ie: getStringValue/getNumberValue/getBooleanValue) for all *new* experiments. Note that the getXXXValue() APIs use feature gates (aka treatment variables) instead of flight names, so if an experiment is already running in production with flight names, it should not switch to the new API based on this warning. It is safe and advisable to ignore the warning for those existing and running cases. The Azure Portal team encourages the use of feature gates for all new experiments, and is deprecating the old APIs due to the confusion it generates when using the different flavors and having different and ambiguous terminology.
     * Represents the flights enabled for an extension
     */
    export interface ExtensionFlights {
        /**
         * @deprecated Fx.Experimentation.getExtensionFlights Use extensionAssignments.getXXXValue() (ie: getStringValue/getNumberValue/getBooleanValue) for all *new* experiments. Note that the getXXXValue() APIs use feature gates (aka treatment variables) instead of flight names, so if an experiment is already running in production with flight names, it should not switch to the new API based on this warning. It is safe and advisable to ignore the warning for those existing and running cases. The Azure Portal team encourages the use of feature gates for all new experiments, and is deprecating the old APIs due to the confusion it generates when using the different flavors and having different and ambiguous terminology.
         * Returns whether the flight is present for the logged in user.
         * @param flightName The name of the flight (this value is case insensitive).
         */
        has(flightName: string): boolean;
        /**
         * @deprecated Fx.Experimentation.getExtensionFlights Use extensionAssignments.getXXXValue() (ie: getStringValue/getNumberValue/getBooleanValue) for all *new* experiments. Note that the getXXXValue() APIs use feature gates (aka treatment variables) instead of flight names, so if an experiment is already running in production with flight names, it should not switch to the new API based on this warning. It is safe and advisable to ignore the warning for those existing and running cases. The Azure Portal team encourages the use of feature gates for all new experiments, and is deprecating the old APIs due to the confusion it generates when using the different flavors and having different and ambiguous terminology.
         * Gets a list of all the flights present for the extension.
         */
        getAll(): ReadonlyArray<string>;
    }
    /**
     * Represents the variant/flight assignments for this extension
     */
    export interface VariantAssignments {
        /**
         * @deprecated Fx.Experimentation.hasFlight is deprecated. Use getXXXValue() (ie: getStringValue/getNumberValue/getBooleanValue) for all *new* experiments. Note that the getXXXValue() APIs use feature gates (aka treatment variables) instead of flight names, so if an experiment is already running in production with flight names, it should not switch to the new API based on this warning. It is safe and advisable to ignore the warning for those existing and running cases. The Azure Portal team encourages the use of feature gates for all new experiments, and is deprecating the old APIs due to the confusion it generates when using the different flavors and having different and ambiguous terminology.
         * Returns whether the flight is present for the logged in user.
         * @param flightName The name of the flight (this value is case insensitive).
         */
        hasFlight(flightName: string): boolean;
        /**
         * Gets the string value of the specified feature gate (aka treatment variable). The comparison is case insensitive.
         *
         * @param variableName The treatment variable name (aka feature gate) without including the prefix. For backwards compatibility reasons,
         * if the variable name contains the "AzurePortal_" prefix, then "AzurePortal" will be considered the prefix, but please don't use this format
         * in new experiments, and use the second optional parameter instead.
         * @param variableNamePrefix The variable name prefix as specified in Control Tower. If omitted, it is assumed to be "AzurePortal", which is the default for most configurations.
         * Note that this prefix name cannot be changed easily, or on a per-experiment basis, and requires a manual ask to change it for the entire management group in ExP.
         * @returns The value of the variable, coerced to string, or undefined if not present.
         */
        getStringValue(variableName: string, variableNamePrefix?: string): string | undefined;
        /**
         * Gets the numeric value of the specified feature gate (aka treatment variable). The comparison is case insensitive.
         *
         * @param variableName The treatment variable name (aka feature gate) without including the prefix. For backwards compatibility reasons,
         * if the variable name contains the "AzurePortal_" prefix, then "AzurePortal" will be considered the prefix, but please don't use this format
         * in new experiments, and use the second optional parameter instead.
         * @param variableNamePrefix The variable name prefix as specified in Control Tower. If omitted, it is assumed to be "AzurePortal", which is the default for most configurations.
         * Note that this prefix name cannot be changed easily, or on a per-experiment basis, and requires a manual ask to change it for the entire management group in ExP.
         * @returns The value of the variable coerced to `Number`, `null` if the value can't be coerced, or `undefined` if not present.
         */
        getNumberValue(variableName: string, variableNamePrefix?: string): number | null | undefined;
        /**
         * Gets the boolean value of the specified feature gate (aka treatment variable). The comparison is case insensitive.
         *
         * @param variableName The treatment variable name (aka feature gate) without including the prefix. For backwards compatibility reasons,
         * if the variable name contains the "AzurePortal_" prefix, then "AzurePortal" will be considered the prefix, but please don't use this format
         * in new experiments, and use the second optional parameter instead.
         * @param variableNamePrefix The variable name prefix as specified in Control Tower. If omitted, it is assumed to be "AzurePortal", which is the default for most configurations.
         * Note that this prefix name cannot be changed easily, or on a per-experiment basis, and requires a manual ask to change it for the entire management group in ExP.
         * @returns The value of the variable coerced to `Boolean`, `null` if the value can't be coerced, or `undefined` if not present.
         */
        getBooleanValue(variableName: string, variableNamePrefix?: string): boolean | null | undefined;
        /**
         * Determines whether the assignments are available (the network call to ExP has completed and the assignments are ready to be used).
         * Note that even if this value is false, all calls to getXXXValue() will still work and return undefined, as if the flight isn't present.
         */
        readonly isAvailable: boolean;
        /**
         * This promise is resolved when the assignments are available (the network call to ExP has completed and the assignments are ready to be used).
         *
         * @param timeoutInMilliseconds The timeout in milliseconds. It's recommended that this is omitted unless there's a very strong reason not to.
         * If omitted, it will wait until the flights are actually available (or until the network times in exceptional cases).
         * Regardless of the explicit timeout, the promise will always be resolved in a relatively short timeframe to not impact perceived performance.
         */
        whenAvailable(timeoutInMilliseconds?: number): Promise<VariantAssignments>;
    }
    /**
     * Accesses the experimentation features that use ExP
     */
    export interface Experimentation {
        /**
         * @deprecated Fx.Experimentation.getExtensionFlights Please use extensionAssignments for all new experiments (or ignore this warning for existing flights).
         * Gets all the flights assigned to this extension.
         * The promise always succeeds even if the underlying call might fail. In this case there will be no flights assigned.
         * For more information on how to set up flights using the ExP platform see https://aka.ms/ibizaexperimentation
         * NOTE: there is no perf penalty to call this API multiple times, as the result is cached. Additionally the assignments
         * are retrieved very early in the extension initialization lifecycle and this cache is primed, so by the time any
         * extension-code calls this method, the assignments are very likely to be already primed and resolved immediately.
         * @returns An object that can be used for querying the existance of a particular flight.
         */
        getExtensionFlights(): Promise<ExtensionFlights>;
        /**
         * @deprecated Fx.Experimentation.getAssignments Please use extensionAssignments or shellAssignments as appropiate, depending on in whether the experiment is defined for Extension usage or Shell usage in Control Tower.
         * Gets all the flights and feature/treatment variables assigned to this extension.
         * The promise always succeeds even if the underlying call might fail. In this case there will be no flights or feature variables
         * assigned (except for those present in the querystring for testing, if any).
         * For more information on how to set up flights using the ExP platform see https://aka.ms/ibizaexperimentation
         * NOTE: there is no perf penalty to call this API multiple times, as the result is cached. Additionally the assignments
         * are retrieved very early in the extension initialization lifecycle and this cache is primed, so by the time any
         * extension-code calls this method, the assignments are very likely to be already primed and resolved immediately.
         * @returns An object that can be used for getting the values of the treatment variables or querying the existance of a particular flight.
         */
        getAssignments(): Promise<VariantAssignments>;
        /**
         * Gets all the feature/treatment variables assigned to the Shell (ie: experiments using the "Hubs and Shell" environment traffic filter in Control Tower).
         * The return value is always defined even if the underlying network call might fail. In this case there will be no feature variables
         * assigned (except for those present in the querystring for testing, if any).
         * The returned object is available synchronously, but the values of the variables may not be available until the promise returned by
         * whenAvailable() is resolved (or if isAvailable is true, then the values are available synchronously).
         * For more information on how to set up flights using the ExP platform see https://aka.ms/ibizaexperimentation
         *
         * @returns An object that can be used for getting the values of the treatment variables.
         */
        shellAssignments: VariantAssignments;
        /**
         * Gets all the feature/treatment variables assigned to the Extension (ie: experiments using an extension-specific environment traffic filter in Control Tower).
         * The return value is always defined even if the underlying network call might fail. In this case there will be no feature variables
         * assigned (except for those present in the querystring for testing, if any).
         * The returned object is available synchronously, but the values of the variables may not be available until the promise returned by
         * whenAvailable() is resolved (or if isAvailable is true, then the values are available synchronously).
         * For more information on how to set up flights using the ExP platform see https://aka.ms/ibizaexperimentation
         *
         * @returns An object that can be used for getting the values of the treatment variables.
         */
        extensionAssignments: VariantAssignments;
    }
    export class Experimentation {
    }
}

// FILE: Fx\Extension.d.ts
declare module "Fx/Extension" {
    export interface ViewModelLocator {
        /**
         * The name of the view model.
         */
        name: string;
        /**
         * The module that contains the entry point.
         */
        module?: string;
        /**
         * The export in the module that contains the entry point.
         */
        export?: string;
    }
}

// FILE: Fx\FxCoreBegin.d.ts
declare let executeInDevelopmentModeOnly: Action1<Action>;

// FILE: Fx\Images\Image.d.ts
declare module "Fx/Images/Image" {
    export import Image = Common.Images.Image;
    export import ImageOptions = Common.Images.ImageOptions;
    export import ImageBadge = Common.Images.ImageBadge;
}

// FILE: Fx\Lifetime.d.ts
declare module "Fx/Lifetime" {
    /**
     * An object that is disposable.
     */
    export interface Disposable {
        /**
         * A function called on the object when it is disposed.
         */
        dispose(): void;
    }
    export type ActionOrDisposable = Action | Disposable;
    /**
     * An object that can limit the lifetime of other objects. When a LifetimeManager object
     * is disposed, it will dispose all other objects that were registered for disposal.
     */
    export interface LifetimeManagerBase {
        /**
         * Registers an object to be disposed.  It will throw if the object doesn't have dispose method.
         *
         * @param disposable An object to be disposed once the LifetimeManager object itself is disposed.
         */
        registerForDispose(disposable: ActionOrDisposable | ReadonlyArray<ActionOrDisposable>): this;
    }
    export interface LifetimeManager extends LifetimeManagerBase {
        /**
         * Create a createChildLifetime to localize the LifetimeManager.
         * It will provide the function on tracking who create it and when it dispose, it will remove itself from Container's lifetimeManager
         *
         */
        createChildLifetime(): DisposableLifetimeManager;
        /**
         * A value indicating whether or not the lifetime is disposed.
         */
        isDisposed(): boolean;
    }
    export interface DisposableLifetimeManager extends Disposable, LifetimeManager {
    }
}

// FILE: Fx\Q\Q.d.ts
/**
 * Converts a value or promise for a value into a Q promise for the value.
 *
 * If value is a Q promise, returns the promise.
 * If value is a promise from another library it is coerced into a Q promise.
 * If value is not a promise, returns a promise that is fulfilled with value.
 *
 * @param value The value or promise to convert.
 * @returns A Q Promise.
 */
declare function Q<T = void>(value?: T | PromiseLike<T>): Q.Promise<T>;
declare module Q {
    type QPromiseState = "fulfilled" | "rejected" | "pending";
    interface PromiseState<T> {
        /**
         * "fulfilled", "rejected", "pending"
         */
        state: QPromiseState;
        value?: T;
        reason?: any;
    }
    interface Promise<T = void> extends globalThis.Promise<T> {
        /**
         * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected).
         * The resolved value cannot be modified from the callback.
         *
         * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
         * @returns A Promise for the completion of the callback.
         */
        finally(onfinally?: (() => void) | undefined | null): Q.Promise<T>;
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<TResult>(onFulfill: (value: T) => TResult | PromiseLike<TResult> | Q.Promise<never>, onReject?: (reason: any) => TResult | PromiseLike<TResult>, onProgress?: Function): Q.Promise<TResult>;
        then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value?: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null, onProgress?: Function): Q.Promise<TResult1 | TResult2>;
        /**
         * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
         *
         * This is especially useful in conjunction with all
         */
        spread<U>(onFulfilled: Function, onRejected?: Function): Q.Promise<U>;
        /**
         * A sugar method, equivalent to promise.then(undefined, onRejected).
         */
        catch(onRejected: (reason: any) => T | Q.Promise<T> | never | Q.Promise<never>): Q.Promise<T>;
        catch(onRejected: (reason: any) => void): Q.Promise<T>;
        catch<TResult>(onRejected: (reason: any) => TResult | PromiseLike<TResult> | Q.Promise<never>): Q.Promise<T | TResult>;
        catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Q.Promise<T | TResult>;
        /**
         * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
         */
        progress(onProgress: (progress: any) => any): Q.Promise<T>;
        /**
         * Generally, not needed in the Portal becasue the framework logs unhandled rejections.
         */
        done<U>(onFulfilled?: (value: T) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>, onProgress?: (progress: any) => any): void;
        /**
         * Returns a promise to get the named property of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return o[propertyName];
         * });
         */
        get<U>(propertyName: string): Q.Promise<U>;
        /**
         * Returns a promise to set the named property of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     o[propertyName] = value;
         * });
         */
        set(propertyName: string, value: any): Q.Promise<void>;
        /**
         * Returns a promise to delete the named property of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     delete o[propertyName];
         * });
         */
        delete(propertyName: string): Q.Promise<void>;
        /**
         * Returns a promise for the result of calling the named method of an object with the given array of arguments. The object itself is this in the function, just like a synchronous method call. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return o[methodName].apply(o, args);
         * });
         */
        post<U>(methodName: string, args: any[]): Q.Promise<U>;
        /**
         * Returns a promise for the result of calling the named method of an object with the given variadic arguments. The object itself is this in the function, just like a synchronous method call.
         */
        invoke<U>(methodName: string, ...args: any[]): Q.Promise<U>;
        /**
         * Returns a promise for an array of the property names of an object. Essentially equivalent to
         *
         * promise.then(function (o) {
         *     return Object.keys(o);
         * });
         */
        keys(): Q.Promise<string[]>;
        /**
         * A sugar method, equivalent to promise.then(function () { return value; }).
         */
        thenResolve<U>(value: U): Q.Promise<U>;
        /**
         * A sugar method, equivalent to promise.then(function () { throw reason; }).
         */
        thenReject(reason: any): Q.Promise<T>;
        /**
         * Returns a promise that will have the same result as promise, except that if promise is not fulfilled or rejected before ms milliseconds, the returned promise will be rejected with an Error with the given message. If message is not supplied, the message will be "Timed out after " + ms + " ms".
         */
        timeout(ms: number, message?: string | Error): Q.Promise<T>;
        /**
         * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
         */
        delay(ms: number): Q.Promise<T>;
        /**
         * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
         */
        isFulfilled(): boolean;
        /**
         * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
         */
        isRejected(): boolean;
        /**
         * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
         */
        isPending(): boolean;
        /**
         * Returns the fulfilled value of a promise
         */
        valueOf(): any;
        /**
         * Returns a "state snapshot" object, which will be in one of three forms:
         *
         * - { state: "pending" }
         * - { state: "fulfilled", value: <fulfllment value> }
         * - { state: "rejected", reason: <rejection reason> }
         */
        inspect(): PromiseState<T>;
    }
    interface PromiseArray2<T1, T2> extends Q.Promise<[T1, T2]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2) => U | PromiseLike<U>, onRejected?: Function): Q.Promise<U>;
    }
    interface PromiseArray3<T1, T2, T3> extends Q.Promise<[T1, T2, T3]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3) => U | PromiseLike<U>, onRejected?: Function): Q.Promise<U>;
    }
    interface PromiseArray4<T1, T2, T3, T4> extends Q.Promise<[T1, T2, T3, T4]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4) => U | PromiseLike<U>, onRejected?: Function): Q.Promise<U>;
    }
    interface PromiseArray5<T1, T2, T3, T4, T5> extends Q.Promise<[T1, T2, T3, T4, T5]> {
        spread<U>(onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => U | PromiseLike<U>, onRejected?: Function): Q.Promise<U>;
    }
    interface Deferred<T> {
        promise: Q.Promise<T>;
        resolve(value?: T | Q.Promise<T>): void;
        reject(reason?: any): void;
        notify(value?: any): void;
    }
    /**
     * Promisify a value and apply onFulfilled, onRejected and onProgress callbacks
     */
    function when<T>(value: PromiseLike<T>): Q.Promise<T>;
    function when<T>(value: T): Q.Promise<T>;
    function when<T, U>(value: PromiseLike<T>, onFulfilled: (val: T) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>, onProgress?: (progress: any) => any): Q.Promise<U>;
    function when<T, U>(value: T, onFulfilled: (val: T) => U | PromiseLike<U>): Q.Promise<U>;
    function when<T, U>(value: PromiseLike<T> | T, onFulfilled?: (val: T) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>, onProgress?: (progress: any) => any): any;
    /**
     * Function call
     */
    function fcall<T>(method: (...args: any[]) => T | PromiseLike<T>, ...args: any[]): Q.Promise<T>;
    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     */
    function any<T>(promises: PromiseLike<T>[]): Q.Promise<T>;
    /**
     * Returns the first resolved promise of an array. Prior rejected promises are
     * ignored.  Rejects only if all promises are rejected.
     */
    function any<T>(promises: any[]): Q.Promise<T>;
    /**
     * A sugar method, equivalent to promise.then(undefined, undefined, onProgress).
     */
    function progress<T>(promise: Q.Promise<T>, onProgress: (progress: any) => any): void;
    /**
     * Calls a method on a promise object
     */
    function post(promise: any, methodName: string, args: any[]): any;
    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     */
    function all<T1, T2>(promises: [PromiseLike<T1>, PromiseLike<T2>]): PromiseArray2<T1, T2>;
    function all<T1, T2, T3>(promises: [PromiseLike<T1>, PromiseLike<T2>, PromiseLike<T3>]): PromiseArray3<T1, T2, T3>;
    function all<T1, T2, T3, T4>(promises: [PromiseLike<T1>, PromiseLike<T2>, PromiseLike<T3>, PromiseLike<T4>]): PromiseArray4<T1, T2, T3, T4>;
    function all<T1, T2, T3, T4, T5>(promises: [PromiseLike<T1>, PromiseLike<T2>, PromiseLike<T3>, PromiseLike<T4>, PromiseLike<T5>]): PromiseArray5<T1, T2, T3, T4, T5>;
    function all<T>(promises: PromiseLike<T>[]): Q.Promise<T[]>;
    /**
     * Turns an array of promises into a promise for an array.  If any of
     * the promises gets rejected, the whole array is rejected immediately.
     */
    function all<T = void>(promises: any[]): Q.Promise<T[]>;
    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     */
    function allSettled<T>(promises: PromiseLike<T>[]): Q.Promise<PromiseState<T>[]>;
    /**
     * Turns an array of promises into a promise for an array of their states (as
     * returned by `inspect`) when they have all settled.
     */
    function allSettled<T>(promises: any[]): Q.Promise<PromiseState<T>[]>;
    /**
     * Waits for all promises to be settled, either fulfilled or
     * rejected.  This is distinct from `all` since that would stop
     * waiting at the first rejection.  The promise returned by
     * `allResolved` will never be rejected.
     */
    function allResolved<T>(promises: PromiseLike<T>[]): Q.Promise<Q.Promise<T>[]>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>], onFulfilled: (t1: T1, t2: T2) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>], onFulfilled: (t1: T1, t2: T2, t3: T3) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, T6, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T1, T2, T3, T4, T5, T6, T7, U>(promises: [T1 | PromiseLike<T1>, T2 | PromiseLike<T2>, T3 | PromiseLike<T3>, T4 | PromiseLike<T4>, T5 | PromiseLike<T5>, T6 | PromiseLike<T6>, T7 | PromiseLike<T7>], onFulfilled: (t1: T1, t2: T2, t3: T3, t4: T4, t5: T5, t6: T6, t7: T7) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Like then, but "spreads" the array into a variadic fulfillment handler. If any of the promises in the array are rejected, instead calls onRejected with the first rejected promise's rejection reason.
     * This is especially useful in conjunction with all.
     */
    function spread<T, U>(promises: (T | PromiseLike<T>)[], onFulfilled: (...args: T[]) => U | PromiseLike<U>, onRejected?: (reason: any) => U | PromiseLike<U>): Q.Promise<U>;
    /**
     * Returns a promise that will have the same result as promise, except that if promise is not fulfilled or rejected before ms milliseconds, the returned promise will be rejected with an Error with the given message. If message is not supplied, the message will be "Timed out after " + ms + " ms".
     */
    function timeout<T>(promise: Q.Promise<T>, ms: number, message?: string | Error): Q.Promise<T>;
    /**
     * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
     */
    function delay<T>(promise: Q.Promise<T> | number, ms?: number): Q.Promise<T>;
    /**
     * Returns a promise that will have the same result as promise, but will only be fulfilled or rejected after at least ms milliseconds have passed.
     */
    function delay<T>(value: T | number, ms?: number): Q.Promise<T>;
    /**
     * Returns a promise that will be fulfilled with undefined after at least ms milliseconds have passed.
     */
    function delay(ms: number): Q.Promise<void>;
    /**
     * Returns whether a given promise is in the fulfilled state. When the static version is used on non-promises, the result is always true.
     */
    function isFulfilled(promise: any): boolean;
    /**
     * Returns whether a given promise is in the rejected state. When the static version is used on non-promises, the result is always false.
     */
    function isRejected(promise: Q.Promise<any>): boolean;
    /**
     * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
     */
    function isPending(promise: Q.Promise<any>): boolean;
    /**
     * Returns whether a given promise is in the pending state. When the static version is used on non-promises, the result is always false.
     */
    function isPending(obj: any): boolean;
    /**
     * Returns a "deferred" object with a:
     * promise property
     * resolve(value) method
     * reject(reason) method
     * notify(value) method
     */
    function defer<T = void>(): Deferred<T>;
    /**
     * Returns a promise that is rejected with reason.
     */
    function reject<T = never>(reason?: any): Q.Promise<T>;
    /**
     * Apply callbacks to a new Q promise
     */
    function promise<T>(resolver: (resolve: (val: T | PromiseLike<T>) => void, reject: (reason: any) => void, notify: (progress: any) => void) => void): Q.Promise<T>;
    /**
     * Apply callbacks to a new Q promise
     */
    function Promise<T>(resolver: (resolve: (val: T | PromiseLike<T>) => void, reject: (reason: any) => void, notify: (progress: any) => void) => void): Q.Promise<T>;
    /**
     * Determines if the supplied object is a Q Promise.
     *
     * @param obj The object to check.
     * @returns Indication if obj is a Q Promise.
     */
    function isPromise<T = unknown>(obj: any | PromiseLike<T>): obj is Q.Promise<T>;
    /**
     * Determines if the supplied object is PromiseLike (has a .then() function).
     *
     * @param obj The object to check.
     * @returns Indication if obj is PromiseLike.
     */
    function isPromiseAlike<T = unknown>(obj: any | PromiseLike<T>): obj is PromiseLike<T>;
    /**
     * This is an experimental tool for converting a generator function into a deferred function. This has the potential of reducing nested callbacks in engines that support yield.
     */
    function nextTick(callback: Function): void;
    /**
     * Calling resolve with a pending promise causes promise to wait on the passed promise, becoming fulfilled with its fulfillment value or rejected with its rejection reason (or staying pending forever, if the passed promise does).
     * Calling resolve with a rejected promise causes promise to be rejected with the passed promise's rejection reason.
     * Calling resolve with a fulfilled promise causes promise to be fulfilled with the passed promise's fulfillment value.
     * Calling resolve with a non-promise value causes promise to be fulfilled with that value.
     */
    function resolve<T>(obj: PromiseLike<T> | T): Q.Promise<T>;
}
declare module FxImpl {
}

// FILE: Fx\ResourceManagement\GlobalResourceFilters.d.ts
declare module "Fx/ResourceManagement/GlobalResourceFilters" {
    /**
     * The available filter facet types.
     */
    export const enum FilterFacetTypes {
        /**
         * Filter on subscription ID.
         */
        SubscriptionId = "subscriptionId",
        /**
         * Filter on subscription name.
         */
        SubscriptionName = "subscriptionName",
        /**
         * Filter on subscription state.
         */
        SubscriptionState = "subscriptionState",
        /**
         * Filter on management group name.
         */
        ManagementGroupName = "managementGroupName"
    }
    /**
     * The possible facet operators for a global resource filter.
     */
    export const enum FilterFacetOperators {
        /**
         * The resource property type indicated by the facet type must exactly equal the value of this facet.
         * This facet operator supports a single value or multiple values.
         */
        EqualTo = "==",
        /**
         * The resource property type indicated by the facet type must not equal the value of this facet.
         * This facet operator supports a single value or multiple values.
         */
        NotEqualTo = "!=",
        /**
         * The resource property type indicated by the facet type must contain the value of this facet.
         * This facet operator supports a single value.
         */
        Contains = "contains",
        /**
         * The resource property type indicated by the facet type must not contain the value of this facet.
         * This facet operator supports a single value.
         */
        DoesNotContain = "!contains",
        /**
         * The resource property type indicated by the facet type must start with the value of this facet.
         * This facet operator supports a single value.
         */
        StartsWith = "startswith",
        /**
         * The resource property type indicated by the facet type must not start with the value of this facet.
         * This facet operator supports a single value.
         */
        DoesNotStartWith = "!startswith",
        /**
         * The resource property type indicated by the facet type must end with the value of this facet.
         * This facet operator supports a single value.
         */
        EndsWith = "endswith",
        /**
         * The resource property type indicated by the facet type must not end with the value of this facet.
         * This facet operator supports a single value.
         */
        DoesNotEndWith = "!endswith"
    }
    /**
     * A single facet of a global resource filter.
     */
    export interface FilterFacet {
        /**
         * The facet type.
         */
        readonly type: FilterFacetTypes;
        /**
         * The facet operator.
         */
        readonly operator: FilterFacetOperators;
        /**
         * The facet value. This should always be a string unless the 'operator' is '==' or '!='.
         */
        readonly value: string | ReadonlyArray<string>;
    }
    /**
     * A global resource filter.
     */
    export interface Filter {
        /**
         * The filter facets that should be used when querying the back end for resources when using this filter.
         */
        readonly facets: ReadonlyArray<FilterFacet>;
        /**
         * The filter ID. This should be unique per tenant for the user.
         */
        readonly id: string;
        /**
         * The filter display name as provided by the user.
         */
        readonly name: string;
    }
}

// FILE: Fx\ResourceManagement\ManagementGroups.d.ts
declare module "Fx/ResourceManagement/ManagementGroups" {
    /**
     * Data contract for a single Azure management group.
     */
    export interface ManagementGroup {
        /**
         * This property maps to the ARG ResourceContainers table's name field.
         */
        readonly id: string;
        /**
         * This property maps the ARG ResourceContainer table's property.displayName field.
         */
        readonly displayName: string;
        /**
         * The id of the parent management group;
         */
        readonly parentId: string;
        /**
         * Array of the child/direct ancestor management group ids.
         */
        readonly childManagementGroupIds?: string[];
        /**
         * Array of subscription ids that are direct descendents of the management group.
         */
        readonly childSubscriptionIds?: string[];
    }
}

// FILE: Fx\ResourceManagement\Subscriptions.d.ts
declare module "Fx/ResourceManagement/Subscriptions" {
    /**
     * Data contract for a single Azure subscription.
     */
    export interface Subscription {
        /**
         * Unique display name, that includes disabled state aswell as subscription id (if display name is not unique).
         */
        uniqueDisplayName: string;
        /**
         * Friendly name of the azure subscription.
         */
        displayName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionId: string;
        /**
         * Id of the Active Directory tenant containing this subscription.
         */
        tenantId: string;
        /**
         * The subscription state.
         */
        state: string;
        /**
         * The subscription policies. May be null.
         */
        subscriptionPolicies: SubscriptionPolicies;
        /**
         * The users authorization type for the subscriptions. Values are �Legacy�, �RoleBased�, �Legacy, RoleBased�.
         */
        authorizationSource: string;
        /**
         * The promotion information related to this subscription.
         * This will only show up on free trial and student subscriptions within their eligibility period.
         * It will also show up on PayAsYouGo subscriptions if those subscriptions are upgraded from a free trial or student subscription originally.
         */
        readonly promotions?: ReadonlyArray<SubscriptionPromotion>;
    }
    /**
     * Data contract for the Azure subscription promotion.
     */
    export interface SubscriptionPromotion {
        /**
         * The promotion end date and time in ISO string format.
         */
        readonly endDateTime: string;
        /**
         * The category of the promotion.
         */
        readonly category: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    export interface SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
        /**
         * The subscription spending limit Values "On", "Off", "CurrentPeriodOff"
         */
        spendingLimit?: string;
    }
}

// FILE: Fx\Security.d.ts
declare module "Fx/Security" {
    /**
     * Interface for authentication tokens received by the extension.
     */
    export interface AuthorizationToken {
        /**
         * The authorization header needed to make API calls to a service.
         */
        readonly header: string;
        /**
         * The time at which the token expires.
         */
        readonly expiresAt: number;
    }
    export interface UserInfo {
        /**
         * Email name of the identity.
         */
        readonly email: string;
        /**
         * Preferred username of the user.
         */
        readonly preferredUsername: string;
        /**
         * Boolean indicating if the user is an OrgID user.
         */
        readonly isOrgId: boolean;
        /**
         * The object id of the user.
         */
        readonly objectId: string;
        /**
         * The principal id of the user.
         */
        readonly principalId: string;
        /**
         * Whether or not the user is a Company Administrator.
         */
        readonly isTenantAdmin: boolean;
        /**
         * First name of the identity.
         */
        readonly givenName: string;
        /**
         * Last name of the identity.
         */
        readonly surname: string;
        /**
         * The identity's directory.
         */
        readonly directoryId: string;
        /**
         * The identity's directory name.
         */
        readonly directoryName: string;
        /**
         * The identity's unique directory name, that show both directory and domain name when directory name isn't unique.
         */
        readonly uniqueDirectoryName: string;
        /**
         * The tenant's domain name.
         */
        readonly domainName: string;
        /**
         * Whether the user is logged in with GitHub credential.
         */
        readonly isGitHubUser?: boolean;
        /**
         * The identity's country/region.
         */
        readonly countryCode: string;
        /**
         * The identity's tenant parity dependency.
         */
        readonly isTenantParityDependent: boolean;
        /**
         * The data boundary for the loggedin tenant. e.g.
         * "EU": EU Data Boundary is applicable to this tenant.
         * null: No boundary restrictions are applicable to this tenant.
         */
        readonly dataBoundary?: string;
    }
}

// FILE: Fx\Units.d.ts
declare module "Fx/Units" {
    /**
     * Defines units. This is internal Unit which has expanded/specific assigned enum values. Due to typescript compiler issue, another public Unit enum is exposed with sequential values.
     */
    export enum Unit {
        None = 0,
        Percentage = 1,
        Bytes = 256,
        Kilobytes = 257,
        Megabytes = 258,
        Gigabytes = 259,
        Terabytes = 260,
        Petabytes = 261,
        BytesPerDay = 1152,
        BytesPerHour = 1153,
        BytesPerMinute = 1154,
        BytesPerSecond = 1155,
        KilobytesPerSecond = 1156,
        MegabytesPerSecond = 1157,
        GigabytesPerSecond = 1158,
        TerabytesPerSecond = 1159,
        PetabytesPerSecond = 1160,
        Count = 512,
        Thousand = 513,
        Million = 514,
        Billion = 515,
        Trillion = 516,
        MicroSeconds = 768,
        MilliSeconds = 769,
        Seconds = 770,
        Minutes = 771,
        Hours = 772,
        Days = 773,
        CountPerDay = 1408,
        CountPerHour = 1409,
        CountPerMinute = 1410,
        CountPerSecond = 1411,
        ThousandPerSecond = 1412,
        MillionPerSecond = 1413,
        BillionPerSecond = 1414,
        TrillionPerSecond = 1415,
        Bytes_SI = 1536,
        Kilobytes_SI = 1537,
        Megabytes_SI = 1538,
        Gigabytes_SI = 1539,
        Terabytes_SI = 1540,
        Petabytes_SI = 1541,
        BytesPerDay_SI = 1920,
        BytesPerHour_SI = 1921,
        BytesPerMinute_SI = 1922,
        BytesPerSecond_SI = 1923,
        KilobytesPerSecond_SI = 1924,
        MegabytesPerSecond_SI = 1925,
        GigabytesPerSecond_SI = 1926,
        TerabytesPerSecond_SI = 1927,
        PetabytesPerSecond_SI = 1928
    }
}
// Compiled with TypeScript 5.0

// FILE: Weave.d.ts
declare module "Weave" {
    /**
     * The contract of an object whose lifetime must be explicitly managed.
     */
    export interface Disposable {
        /**
         * Indicate the end of the lifetime of this object.
         */
        dispose(): void;
    }
    export type ActionOrDisposable = (() => void) | Disposable;
    /**
     * An object that can limit the lifetime of other objects. When a LifetimeManager object
     * is disposed, it will dispose all other objects that were registered for disposal.
     */
    export interface LifetimeManager {
        /**
         * Create a child lifetime manager, disposing this lifetime manager will dispose all its children.
         */
        createChildLifetime(): DisposableLifetimeManager;
        /**
         * Return a boolean value indicating whether this lifetime manager has been disposed.
         */
        isDisposed(): boolean;
        /**
         * Register a function or disposable object for disposal. If a function is registered, it will be
         * invoked when this lifetime manager is disposed. If a disposable object is registered, its dispose
         * method will be invoked when this lifetime manager is disposed.
         *
         * @param toBeDisposed Function or object to register.
         */
        registerForDispose(toBeDisposed: ValueOrReadonlyArray<ActionOrDisposable>): this;
    }
    /**
     * A lifetime manager whose lifetime can be explicitly managed.
     */
    export interface DisposableLifetimeManager extends LifetimeManager, Disposable {
    }
    /**
     * The signature of the ErrorHandler callback function. The callback function can be passed to subscribe or subscribeAndRun to
     * receive errors raised during an evaluation of a computation graph as part of the subscription notification process.
     */
    export type ErrorHandler = (error: Error) => void;
    /**
     * An object that contains a value that is determined by executing the evaluation function associated with this
     * object. The value will change if the inputs of the evaluation function changes.
     */
    export interface ReadonlyComputation<T> {
        /**
         * Creates a new computation that represents the application of the specified function on this computation. This method
         * should be used when the specified function returns a non-array value. For functions that return arrays, the composeArray
         * method should be used instead.
         *
         * @param fn The function.
         * @returns A computation.
         */
        compose<U>(fn: (value: T) => ValueOrComputation<U>): ReadonlyComputation<U>;
        /**
         * Creates a new computation that represents the application of the specified function on this computation. This method
         * should be used when the specified function returns an array. For functions that return non-array values, the compose method
         * should be used instead.
         *
         * @param fn The function.
         * @returns An array computation.
         */
        composeArray<U>(fn: (value: T) => ValueOrComputation<ReadonlyArray<U>>): ReadonlyArrayComputation<U>;
    }
    export type ValueOrComputation<T> = ReadonlyComputation<T> | T;
    /**
     * A computation object that can read and written to. This object can be created using the makeWritableComputation function.
     */
    export interface WritableComputation<T> extends ReadonlyComputation<T> {
        /**
         * Sets the value of this computation.
         *
         * @param value The new value of this computation.
         */
        (value: T): void;
        /**
         * The value of this writable computation.
         */
        readonly value: T;
    }
    /**
     * A computation object whose value is an array. The contract extends ReadonlyComputation<ReadonlyArray<T>> but contains
     * additional methods for creating new computations that represent the application of common array functions.
     */
    export interface ReadonlyArrayComputation<T> extends ReadonlyComputation<ReadonlyArray<T>> {
        /**
         * Creates a new boolean computation whose value is true if all of the elements of this array computation
         * satisfies the specified predicate.
         *
         * @param fn The predicate.
         * @returns A boolean computation.
         */
        cEvery(fn: (value: T) => ValueOrComputation<boolean>): ReadonlyComputation<boolean>;
        /**
         * Creates a new array computation that represents the application the array filter function on the elements of
         * this array computation using the specified predicate.
         *
         * @param fn The predicate.
         * @returns An array computation.
         */
        cFilter(fn: (value: T) => ValueOrComputation<boolean>): ReadonlyArrayComputation<T>;
        /**
         * Creates a new computation that represents the application the array find function on the elements of
         * this array computation using the specified predicate.
         *
         * @param fn The predicate.
         * @returns A computation.
         */
        cFind(fn: (value: T) => ValueOrComputation<boolean>): ReadonlyComputation<T>;
        /**
         * Creates a new number computation that represents the application the array findIndex function on the elements of
         * this array computation using the specified predicate.
         *
         * @param fn The predicate.
         * @returns A number computation.
         */
        cFindIndex(fn: (value: T) => ValueOrComputation<boolean>): ReadonlyComputation<number>;
        /**
         * Creates a new array computation that represents the application the array flatMap function on the elements of
         * this array computation using the specified projection function.
         *
         * @param fn The projection function.
         * @returns An array computation.
         */
        cFlatMap<U>(fn: (value: T) => ValueOrComputation<ReadonlyArray<U>>): ReadonlyArrayComputation<U>;
        /**
         * Creates a new group by computation using the specified key selector projection function.
         *
         * @param keySelector A function that maps an element to the grouping key.
         * @returns A group by computation.
         */
        cGroupBy<TKey>(keySelector: (value: T) => ValueOrComputation<TKey>): ReadonlyGroupByComputation<TKey, T>;
        /**
         * Creates a new array computation that represents the application the array map function on the elements of
         * this array computation using the specified projection function.
         *
         * @param fn The projection function.
         * @returns An array computation.
         */
        cMap<U>(fn: (value: T) => ValueOrComputation<U>): ReadonlyArrayComputation<U>;
        /**
         * Creates a new boolean computation whose value is true if there exists an element of this array computation that
         * satisfies the specified predicate.
         *
         * @param fn The predicate.
         * @returns A boolean computation.
         */
        cSome(fn: (value: T) => ValueOrComputation<boolean>): ReadonlyComputation<boolean>;
    }
    /**
     * The common interface of a mutable array computation like object.
     */
    export interface ArrayComputationLike<T> {
        /**
         * Removes all elements from this array computation
         */
        clear(): void;
        /**
         * Inserts the specified element to this array computation at the specified index.
         *
         * @param index The index.
         * @param element The element.
         */
        insert(index: number, element: T): void;
        /**
         * Inserts all elements of the specified array to this array computation at the specified index.
         *
         * @param index The index.
         * @param elements The array containing the elements to insert.
         */
        insertAll(index: number, elements: ReadonlyArray<T>): void;
        /**
         * Removes the last element from this array computation.
         */
        pop(): void;
        /**
         * Appends a new element to the end of this array computation.
         *
         * @param element The element.
         */
        push(element: T): void;
        /**
         * Appends all elements of the specified array to the end of this array computation.
         *
         * @param elements The array containing the elements to insert.
         */
        pushAll(elements: ReadonlyArray<T>): void;
        /**
         * Removes the element at the specified index.
         *
         * @param index The index.
         */
        removeAt(index: number): void;
        /**
         * Reverses the elements of this array computation.
         */
        reverse(): void;
        /**
         * Sets the element at the specified index to the specified element. If an element already exists at the
         * specified index, it will be overwritten.
         *
         * @param index The index.
         * @param element The element.
         */
        set(index: number, element: T): void;
        /**
         * Clears the array computation and sets its elements to the elements of the specified array.
         *
         * @param elements The array containing the elements to set.
         */
        setAll(elements: ReadonlyArray<T>): void;
        /**
         * Removes the first element of this array computation.
         */
        shift(): void;
        /**
         * Removes elements from this array computation starting at the specified index.
         *
         * @param index The start index of the deletion.
         * @param deleteCount The numberof elements to delete.
         */
        splice(index: number, deleteCount: number): void;
        /**
         * Inserts the specified element to the beginning of the array computation.
         *
         * @param element The element.
         */
        unshift(element: T): void;
        /**
         * Inserts the elements of the specified array to the beginning of this array computation.
         *
         * @param elements The array containing the elements to insert.
         */
        unshiftAll(elements: ReadonlyArray<T>): void;
    }
    /**
     * An array computation object that can be directly modified. This object can be created using the makeArrayComputation function.
     */
    export interface ArrayComputation<T> extends ReadonlyArrayComputation<T>, ArrayComputationLike<T> {
        /**
         * Removes from this array computation the first occurrence of the specified element. If the array computation does not contain the element, it is unchanged.
         *
         * @param element The element to remove.
         */
        remove(element: T): void;
        /**
         * Removes from this array computation all of its elements that are contained in the specified array.
         *
         * @param elements The array containing the elements to remove.
         */
        removeAll(elements: ReadonlyArray<T>): void;
        /**
         * Removes from this array computation all of the elements that satisfy the specified predicate.
         *
         * @param fn The predicate.
         */
        removeIf(fn: (value: T) => boolean): void;
        /**
         * Sorts the elements of this array computation using the specified comparator function.
         *
         * @param compareFn The comparator function.
         */
        sort(compareFn?: (a: T, b: T) => number): void;
        /**
         * The value of this array computation.
         */
        readonly value: ReadonlyArray<T>;
    }
    /**
     * An array computation object that can be directly modified. Elements of this array computation that are computations
     * are individually evaluated during the evaluation of this array computation. This object can be created using the
     * makeLiftedArrayComputation function.
     */
    export interface LiftedArrayComputation<T> extends ReadonlyArrayComputation<T>, ArrayComputationLike<ValueOrComputation<T>> {
    }
    /**
     * A computation object that represents the grouping of an array according to a projection function.
     */
    export interface ReadonlyGroupByComputation<TKey, TValue> extends ReadonlyComputation<ReadonlyMap<TKey, ReadonlyArray<TValue>>> {
        /**
         * Get the array computation for the grouping associated with the specified key.
         *
         * @param key The key associated with the grouping.
         * @returns An array computation.
         */
        get(key: TKey): ReadonlyArrayComputation<TValue>;
    }
    /**
     * A computation object whose value is the value of the target computation. This object can be created using the
     * makeIndirectComputation function.
     */
    export interface IndirectComputation<T> extends ReadonlyComputation<T> {
        /**
         * Sets the target computation of this indirect computation.
         *
         * @param target The target computation.
         */
        reseat(target: ReadonlyComputation<T>): void;
    }
    type ValueOrComputationBaseType<T> = {
        [K in keyof T]: T[K] extends ValueOrComputation<infer U> ? U : never;
    };
    /**
     * Returns whether the specified argument is a computation object
     *
     * @param input The value to test
     * @returns A boolean value indicating whether the specified argument is a computation object.
     */
    export const isComputation: (input: any) => input is ReadonlyComputation<unknown>;
    /**
     * Returns the value or computation as a computation. If the value is not a computation, it is wrapped with a constant computation.
     *
     * @param input The value.
     * @returns A computation that corresponds to the specified value.
     */
    export const ensureComputation: <T>(input: ValueOrComputation<T>) => ReadonlyComputation<T>;
    /**
     * Creates a new computation whose value is always the specified value.
     *
     * @param value The value of the computation.
     * @returns A new computation.
     */
    export const makeConstantComputation: <T>(value: T) => ReadonlyComputation<T>;
    /**
     * Creates a new writable computation whose initial value is the specified value.
     *
     * @param initialValue The initial value of this computation.
     * @returns A new computation.
     */
    export const makeWritableComputation: <T>(initialValue?: T) => WritableComputation<T>;
    /**
     * Creates a new array computation whose initial value is a copy of the specified array.
     *
     * @param initialValue The initial value of this computation.
     * @returns A new computation.
     */
    export const makeArrayComputation: <T>(initialValue?: ReadonlyArray<T>) => ArrayComputation<T>;
    /**
     * Creates a new lifted array computation whose initial value is a copy of the specified array.
     *
     * @param initialValue The initial value of this computation.
     * @returns A new computation.
     */
    export const makeLiftedArrayComputation: <T>(initialValue?: ReadonlyArray<ValueOrComputation<T>>) => LiftedArrayComputation<T>;
    /**
     * Creates a new indirect computation whose initial target is the specified target.
     *
     * @param initialValue The initial target of this computation.
     * @returns A new computation.
     */
    export const makeIndirectComputation: <T>(initialTarget?: ValueOrComputation<T>) => IndirectComputation<T>;
    /**
     * Returns a promise that is resolved when all computation subscribers have been notified.
     *
     * @returns A promise.
     */
    export const waitForChangePropagation: () => Promise<void>;
    /**
     * Creates a new computation whose value is the evaluation of the specified function over the specified inputs.
     *
     * @param args The inputs of the evaluation function.
     * @param fn The evaluation function.
     * @returns A new computation.
     */
    export function composeComputation<T extends [unknown, ...unknown[]], R>(args: T, fn: (...args: ValueOrComputationBaseType<T>) => ValueOrComputation<R>): ReadonlyComputation<R>;
    /**
     * Creates a new computation whose value is the evaluation of the specified function over the specified inputs.
     *
     * @param args The inputs of the evaluation function.
     * @param fn The evaluation function.
     * @returns A new computation.
     */
    export function composeComputation<T, R>(args: ReadonlyArray<ValueOrComputation<T>>, fn: (...args: ReadonlyArray<T>) => ValueOrComputation<R>): ReadonlyComputation<R>;
    /**
     * Subscribes to the specified computations and invokes the specified subscription function when a value of the
     * computations change. The subscription function is not invoked with the current values of the computations.
     *
     * @param ltm The lifetime manager that limits the lifetime of the subscription.
     * @param args The array of computations to listen to.
     * @param subscriptionFn The subscription function to be invoked.
     * @param errorHandler The callback function that is invoked when an exception is raised during an evaluation of the computations. If no errorHandler is specified, errors will be raised on the global error handler.
     */
    export function subscribe<T extends [unknown, ...unknown[]]>(ltm: LifetimeManager, args: T, subscriptionFn: (...args: ValueOrComputationBaseType<T>) => void, errorHandler?: ErrorHandler): void;
    /**
     * Subscribes to the specified computations and invokes the specified subscription function when a value of the
     * computations change. The subscription function is not invoked with the current values of the computations.
     *
     * @param ltm The lifetime manager that limits the lifetime of the subscription.
     * @param args The array of computations to listen to.
     * @param subscriptionFn The subscription function to be invoked.
     * @param errorHandler The callback function that is invoked when an exception is raised during an evaluation of the computations. If no errorHandler is specified, errors will be raised on the global error handler.
     */
    export function subscribe<T>(ltm: LifetimeManager, args: ReadonlyArray<ValueOrComputation<T>>, subscriptionFn: (...value: ReadonlyArray<T>) => void, errorHandler?: ErrorHandler): void;
    /**
     * Subscribes to the specified computations and invokes the specified subscription function when a value of the
     * computations change. The subscription function is invoked with the current values of the computations before subscribeAndRun returns.
     *
     * @param ltm The lifetime manager that limits the lifetime of the subscription.
     * @param args The array of computations to listen to.
     * @param subscriptionFn The subscription function to be invoked.
     * @param errorHandler The callback function that is invoked when an exception is raised during an evaluation of the computations. If no errorHandler is specified, errors will be raised on the global error handler.
     */
    export function subscribeAndRun<T extends [unknown, ...unknown[]]>(ltm: LifetimeManager, args: T, subscriptionFn: (...args: ValueOrComputationBaseType<T>) => void, errorHandler?: ErrorHandler): void;
    /**
     * Subscribes to the specified computations and invokes the specified subscription function when a value of the
     * computations change. The subscription function is invoked with the current values of the computations before subscribeAndRun returns.
     *
     * @param ltm The lifetime manager that limits the lifetime of the subscription.
     * @param args The array of computations to listen to.
     * @param subscriptionFn The subscription function to be invoked.
     * @param errorHandler The callback function that is invoked when an exception is raised during an evaluation of the computations. If no errorHandler is specified, errors will be raised on the global error handler.
     */
    export function subscribeAndRun<T>(ltm: LifetimeManager, args: ReadonlyArray<ValueOrComputation<T>>, subscriptionFn: (...value: ReadonlyArray<T>) => void, errorHandler?: ErrorHandler): void;
    /**
     * Evaluates the value or computation. If the specified object is a computation, returns the value of the computation, otherwise, returns self.
     *
     * @param ltm The lifetime manager that activates the computation.
     * @param object The object to evaluate.
     * @returns The evaluated value.
     */
    export const evaluate: <T>(ltm: LifetimeManager, object: ValueOrComputation<T>) => T;
    /**
     * The contract of the object that is passed down the Weave TSX fragment, from parent to children. The object is
     * immutable. Use the GetContext native component to get the object at the current position in the Weave TSX fragment
     * tree. Use the SetContext native component to clone and modify the object that is passed down the Weave TSX fragment
     * tree starting from the current position.
     */
    export interface WeaveContext extends ImmutableWeaveContextInternal, MutableWeaveContext {
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface NativeElement {
        readonly type: "native";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface ValueElement {
        readonly type: "value";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface FragmentElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "fragment";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface IfElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "if";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface ForEachElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "forEach";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface HtmlElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "html";
        readonly data: HtmlElementData;
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface OnceElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "once";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface ExternalElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "external";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface GetContextElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "getcontext";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface SetContextElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "setcontext";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface LifetimeManagerScopedElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "ltmscoped";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export type AggregationResultsReceivers = {
        readonly [K in keyof AggregationDefinition]?: IndirectComputation<AggregationDefinition[K]>;
    };
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface AggregatedElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "aggr";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export type AggregationSources = {
        readonly [K in keyof AggregationDefinition]?: ValueOrComputation<AggregationDefinition[K]>;
    };
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface AggregatableElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "aggrsrc";
    }
    /**
     * This interface exists to support the API infrastructure and is not meant to be directly consumed.
     */
    export interface CssElement {
        /**
         * The type of the TSX node.
         */
        readonly type: "css";
    }
    /**
     * The type of an object that can be rendered by Weave.
     * This type is also the type of a Weave TSX fragment.
     */
    export type WeaveNode = string | boolean | number | ReadonlyComputation<WeaveNode> | NativeElement | ValueElement | FragmentElement | IfElement | ForEachElement | HtmlElement | OnceElement | ExternalElement | GetContextElement | SetContextElement | LifetimeManagerScopedElement | AggregatedElement | AggregatableElement | CssElement;
    export interface FragmentProps {
        /**
         * Children Weave nodes.
         */
        readonly children: ReadonlyArray<ValueOrReadonlyArray<WeaveNode>>;
    }
    /**
     * A virtual root node for a list of children nodes. This is primarily used to satisify the TypeScript language requirement
     * that all TSX fragments must have a single root.
     */
    export const Fragment: (props: FragmentProps) => WeaveNode;
    export type IfProps = {
        /**
         * The condition of the If native component. If the value of the computation is truthy, the Weave node returned by trueFn will be rendered,
         * otherwise, if the value is falsy, the Weave node returned by falseFn will be rendered.
         */
        readonly condition: ReadonlyComputation<unknown>;
        /**
         * Specifies how the rendered elements are hidden when condition changes, "remove" will remove the inner DOM, "hide" will
         * set the "display: none" style on the inner DOM. The default value is "hide".
         */
        readonly concealmentBehavior?: "remove" | "hide";
    } & (
    /**
     * The inner content factory functions. "trueFn" will be called when condition first become truthy and "falseFn" will be called when
     * condition first become falsy. Each factory function will be called only once and have their return values cached.
     */
    {
        readonly trueFn: () => WeaveNode;
    } | {
        readonly falseFn: () => WeaveNode;
    });
    /**
     * Render only when value of the condition computation is truthy.
     */
    export const If: (props: IfProps) => WeaveNode;
    export interface ForEachProps<T> {
        /**
         * The collection of the items to render.
         */
        readonly collection: ReadonlyComputation<ReadonlyArray<T>>;
        /**
         * The function that maps an item to the Weave node that is to be rendered for the item. The function will be called only once
         * for each item.
         */
        readonly fn: (options: {
            /**
             * The item in collection.
             */
            readonly item: T;
            /**
             * The index of the item in collection. The value of the computation changes when the position of the item changes.
             */
            readonly index: ReadonlyComputation<number>;
            /**
             * The total size of collection. The value of the computation changes when the size of the collection changes.
             */
            readonly length: ReadonlyComputation<number>;
        }) => WeaveNode;
    }
    /**
     * Renders the items in the collection by invoking "fn" on each item to collect their Weave nodes.
     */
    export const ForEach: <T>(props: ForEachProps<T>) => WeaveNode;
    export type OnceProps = {
        /**
         * The condition computation that is monitored. Once it becomes truthy, it will be deactivated and the UI won't react to future changes.
         */
        readonly condition: ReadonlyComputation<unknown>;
    } & (
    /**
     * The inner content factory functions, trueFn will be called when the value of the condition computation is truthy and falseFn will be called when
     * the value of the condition computation is falsy. Each factory function will be called only once and have their return values cached.
     */
    {
        readonly trueFn: () => WeaveNode;
    } | {
        readonly falseFn: () => WeaveNode;
    });
    /**
     * Renders the output from "falseFn" when "condition" is falsy. Renders the output from "trueFn" when "condition" is truthy.
     * When "condition" is truthy, the condition is no longer monitored and the UI no longer reacts to any future changes,
     * therefore truthy is the terminal state. Both "trueFn" and "falseFn" are invoked only once.
     * This component represents an one-way UI state switch from the falsy to truthy case.
     */
    export const Once: (props: OnceProps) => WeaveNode;
    export interface GetContextProps {
        /**
         * The function that returns the Weave node for the current context. This function is invoked only once
         * for a given context instance.
         */
        readonly fn: (context: WeaveContext) => WeaveNode;
    }
    /**
     * Get the context object at the current position in Weave TSX fragment. The object is immutable. To modify the object
     * that is passed down the Weave TSX fragment, use the SetContext native component function.
     */
    export const GetContext: (props: GetContextProps) => WeaveNode;
    export type SetContextProps = {
        readonly children?: WeaveNode | ReadonlyArray<ValueOrReadonlyArray<WeaveNode>>;
    } & MutableWeaveContext;
    /**
     * Clones the context object at the current position in the Weave TSX fragment and sets the specified properties
     * on the cloned object. The cloned object with the updated properties becomes the new context object passed down the Weave
     * TSX fragment starting from the current position.
     */
    export const SetContext: (props: SetContextProps) => WeaveNode;
    export interface LifetimeManagerScopedProps {
        /**
         * The function that returns the Weave node for the lifetime manager associated the current position in the Weave TSX fragment.
         * The function is invoked only once for a given lifetime manager instance. This component to can used to tie the lifetime of a
         * specific operation to the lifetime of a rendered DOM node. If this component is used inside an "If" component with
         * concealmentBehavior set to remove, the lifetime manager will be disposed when the condition of the "If" is falsy
         * and the factory function will be re-invoked with a new lifetime manager when the condition becomes "truthy".
         */
        readonly fn: (ltm: LifetimeManager) => WeaveNode;
    }
    /**
     * A native component that can get the lifetime manager of current position in the Weave TSX fragment.
     */
    export const LifetimeManagerScoped: (props: LifetimeManagerScopedProps) => WeaveNode;
    export interface PromiseFragmentProps {
        /**
         * The promise resolves with a Weave node.
         */
        readonly promise: PromiseLike<WeaveNode>;
        /**
         * The Weave nodes to render when the promise is still in a pending state.
         */
        readonly whilePending?: WeaveNode;
    }
    /**
     * A native component that renders the result of the specified promise. The whilePending property can be used
     * to specify the Weave node to render when the promise is still in a pending state.
     */
    export const PromiseFragment: (props: PromiseFragmentProps) => WeaveNode;
    export type AggregatedProps = AggregationResultsReceivers & {
        /**
         * Children Weave nodes.
         */
        readonly children: WeaveNode | ReadonlyArray<ValueOrReadonlyArray<WeaveNode>>;
    };
    /**
     * This function is not meant to be directly consumed.
     */
    export const Aggregated: (props: AggregatedProps) => WeaveNode;
    export type AggregatableProps = AggregationSources & {
        /**
         * Children Weave nodes.
         */
        readonly children?: WeaveNode | ReadonlyArray<ValueOrReadonlyArray<WeaveNode>>;
    };
    /**
     * This function is not meant to be directly consumed.
     */
    export const Aggregatable: (props: AggregatableProps) => WeaveNode;
    export interface CssProps {
        readonly css: CssSpecificationInternal;
    }
    /**
     * A native component that specifies the CSS object that should be loaded when the current position
     * of the Weave TSX fragment is rendered.
     */
    export const Css: (props: CssProps) => WeaveNode;
    export type BooleanAttribute = "true" | "false" | boolean;
    export type WeaveNodeChildren = WeaveNode | ReadonlyArray<ValueOrReadonlyArray<WeaveNode>>;
    export type ConvertToValueComputation<T> = {
        readonly [P in keyof T]: ValueOrComputation<T[P]>;
    };
    export type ValueOrReadonlyArray<T> = T | ReadonlyArray<T>;
    export type AutoCompleteAttribute = "off" | "on" | "name" | "honorific-prefix" | "given-name" | "additional-name" | "family-name" | "honorific-suffix" | "nickname" | "email" | "username" | "new-password" | "current-password" | "one-time-code" | "organization-title" | "organization" | "street-address" | "address-line1" | "address-line2" | "address-line3" | "address-level4" | "address-level3" | "address-level2" | "address-level1" | "country" | "country-name" | "postal-code" | "cc-name" | "cc-given-name" | "cc-additional-name" | "cc-family-name" | "cc-number" | "cc-exp" | "cc-exp-month" | "cc-exp-year" | "cc-csc" | "cc-type" | "transaction-currency" | "transaction-amount" | "language" | "bday" | "bday-day" | "bday-month" | "bday-year" | "sex" | "tel" | "tel-country-code" | "tel-national" | "tel-area-code" | "tel-local" | "tel-local-prefix" | "tel-local-suffix" | "tel-extension" | "impp" | "url" | "photo";
    export type InputElementCommonAttributes = ConvertToValueComputation<{
        autocomplete?: AutoCompleteAttribute;
        autofocus?: boolean;
        disabled?: boolean;
        form?: string;
        name?: string;
    }>;
    export interface HtmlTagAttributes {
        "a": ConvertToValueComputation<{
            download?: string;
            href?: string;
            hreflang?: string;
            media?: string;
            rel?: ValueOrReadonlyArray<"alternate" | "author" | "bookmark" | "help" | "license" | "next" | "nofollow" | "noreferrer" | "prefetch" | "prev" | "search" | "tag">;
            target?: "_blank" | "_self" | "_top" | "_parent";
            type?: string;
        }>;
        "area": ConvertToValueComputation<{
            alt?: string;
            coords?: ReadonlyArray<number>;
            download?: string;
            href?: string;
            hreflang?: string;
            media?: string;
            rel?: ValueOrReadonlyArray<"alternate" | "author" | "bookmark" | "help" | "license" | "next" | "nofollow" | "noreferrer" | "prefetch" | "prev" | "search" | "tag">;
            shape?: "default" | "rect" | "circle" | "poly";
            target?: "_blank" | "_self" | "_top" | "_parent";
        }>;
        "audio": ConvertToValueComputation<{
            autoplay?: boolean;
            controls?: boolean;
            crossorigin?: "anonymous" | "use-credentials" | "";
            loop?: boolean;
            muted?: boolean;
            preload?: "none" | "metadata" | "auto";
            src?: string;
        }>;
        "bdo": ConvertToValueComputation<{
            dir: "ltr" | "rtl";
        }>;
        "blockquote": ConvertToValueComputation<{
            cite?: string;
        }>;
        "button": ConvertToValueComputation<{
            autofocus?: boolean;
            disabled?: boolean;
            form?: string;
            formaction?: string;
            formenctype?: "application/x-www-form-urlencoded" | "multipart/form-data" | "text/plain";
            formmethod?: "get" | "post";
            formnovalidate?: boolean;
            formtarget?: "_blank" | "_self" | "_parent" | "_top";
            name?: string;
            type?: "button" | "submit" | "reset";
        }>;
        "canvas": ConvertToValueComputation<{
            height?: number;
            width?: number;
        }>;
        "col": ConvertToValueComputation<{
            span?: number;
        }>;
        "colgroup": ConvertToValueComputation<{
            span?: number;
        }>;
        "del": ConvertToValueComputation<{
            cite?: string;
            datetime?: string;
        }>;
        "details": ConvertToValueComputation<{
            open?: boolean;
        }>;
        "dialog": ConvertToValueComputation<{
            open?: boolean;
        }>;
        "embed": ConvertToValueComputation<{
            height?: number;
            src?: string;
            type?: string;
            width?: number;
        }>;
        "form": ConvertToValueComputation<{
            "accept-charset"?: ValueOrReadonlyArray<string>;
            action?: string;
            autocomplete?: AutoCompleteAttribute;
            enctype?: "application/x-www-form-urlencoded" | "multipart/form-data" | "text/plain";
            method?: "get" | "post";
            name?: string;
            novalidate?: boolean;
            target?: "_blank" | "_self" | "_top" | "_parent";
        }>;
        "img": ConvertToValueComputation<{
            alt?: string;
            crossorigin?: "anonymous" | "use-credentials" | "";
            height?: number;
            ismap?: boolean;
            src?: string;
            width?: number;
        }>;
        "input-checkbox": {
            readonly type: "checkbox";
        } & ConvertToValueComputation<{
            checked?: boolean;
            readonly?: boolean;
            required?: boolean;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-color": {
            type: "color";
            value?: ValueOrComputation<string>;
        } & InputElementCommonAttributes;
        "input-date": {
            readonly type: "date";
        } & ConvertToValueComputation<{
            list?: string;
            max?: string;
            min?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-datetime-local": {
            readonly type: "datetime-local";
        } & ConvertToValueComputation<{
            list?: string;
            max?: string;
            min?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-email": {
            readonly type: "email";
        } & ConvertToValueComputation<{
            list?: string;
            maxlength?: number;
            minlength?: number;
            multiple?: boolean;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-hidden": {
            type: "hidden";
        } & ConvertToValueComputation<{
            disabled?: boolean;
            form?: string;
            name?: string;
            value?: ValueOrComputation<string>;
        }>;
        "input-month": {
            readonly type: "month";
        } & ConvertToValueComputation<{
            list?: string;
            max?: string;
            min?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-number": {
            readonly type: "number";
        } & ConvertToValueComputation<{
            list?: string;
            max?: number;
            min?: number;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-password": {
            readonly type: "password";
        } & ConvertToValueComputation<{
            maxlength?: number;
            minlength?: number;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-radio": {
            readonly type: "radio";
        } & ConvertToValueComputation<{
            checked?: boolean;
            readonly?: boolean;
            required?: boolean;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-range": {
            readonly type: "range";
        } & ConvertToValueComputation<{
            list?: string;
            max?: number;
            min?: number;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-search": {
            readonly type: "search";
        } & ConvertToValueComputation<{
            list?: string;
            maxlength?: number;
            minlength?: number;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-tel": {
            readonly type: "tel";
        } & ConvertToValueComputation<{
            list?: string;
            maxlength?: number;
            minlength?: number;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-text": {
            readonly type: "text";
        } & ConvertToValueComputation<{
            list?: string;
            maxlength?: number;
            minlength?: number;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-time": {
            readonly type: "time";
        } & ConvertToValueComputation<{
            list?: string;
            max?: string;
            min?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-url": {
            readonly type: "url";
        } & ConvertToValueComputation<{
            list?: string;
            maxlength?: number;
            minlength?: number;
            pattern?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            size?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "input-week": {
            readonly type: "week";
        } & ConvertToValueComputation<{
            list?: string;
            max?: string;
            min?: string;
            readonly?: boolean;
            required?: boolean;
            step?: number;
            value?: string;
        }> & InputElementCommonAttributes;
        "ins": ConvertToValueComputation<{
            cite?: string;
            datetime?: string;
        }>;
        "label": ConvertToValueComputation<{
            for?: string;
            form?: string;
        }>;
        "map": ConvertToValueComputation<{
            name?: string;
        }>;
        "meter": ConvertToValueComputation<{
            form?: string;
            high?: number;
            low?: number;
            max?: number;
            min?: number;
            optimum?: number;
            value?: number;
        }>;
        "ol": ConvertToValueComputation<{
            reversed?: boolean;
            type?: "1" | "A" | "a" | "I" | "i";
            start?: number;
        }>;
        "optgroup": ConvertToValueComputation<{
            disabled?: boolean;
            label?: string;
        }>;
        "option": ConvertToValueComputation<{
            disabled?: boolean;
            label?: string;
            value?: string;
        }>;
        "output": ConvertToValueComputation<{
            for?: string;
            form?: string;
            name?: string;
        }>;
        "progress": ConvertToValueComputation<{
            max?: number;
            value?: number;
        }>;
        "q": ConvertToValueComputation<{
            cite?: string;
        }>;
        "source": ConvertToValueComputation<{
            src?: string;
            media?: string;
            type?: string;
        }>;
        "textarea": ConvertToValueComputation<{
            autofocus?: boolean;
            cols?: number;
            disabled?: boolean;
            form?: string;
            maxlength?: number;
            minlength?: number;
            name?: string;
            placeholder?: string;
            readonly?: boolean;
            required?: boolean;
            rows?: number;
            value?: ValueOrComputation<string>;
            wrap?: "hard" | "soft";
        }>;
        "td": ConvertToValueComputation<{
            colspan?: number;
            headers?: ValueOrReadonlyArray<string>;
            rowspan?: number;
        }>;
        "th": ConvertToValueComputation<{
            abbr?: string;
            colspan?: number;
            headers?: ValueOrReadonlyArray<string>;
            rowspan?: number;
            scope?: "col" | "colgroup" | "row" | "rowgroup" | "auto";
        }>;
        "time": ConvertToValueComputation<{
            datetime?: string;
        }>;
        "track": ConvertToValueComputation<{
            default?: boolean;
            kind?: "captions" | "chapters" | "descriptions" | "metadata" | "subtitles";
            label?: string;
            src?: string;
            srclang?: string;
        }>;
        "video": ConvertToValueComputation<{
            autoplay?: boolean;
            controls?: boolean;
            crossorigin?: "anonymous" | "use-credentials" | "";
            height?: number;
            loop?: boolean;
            muted?: boolean;
            preload?: "none" | "metadata" | "auto";
            poster?: string;
            src?: string;
            width?: number;
        }>;
    }
    export type TextInputAttributesBase = HtmlTagAttributes["input-color"] | HtmlTagAttributes["input-date"] | HtmlTagAttributes["input-datetime-local"] | HtmlTagAttributes["input-email"] | HtmlTagAttributes["input-month"] | HtmlTagAttributes["input-number"] | HtmlTagAttributes["input-password"] | HtmlTagAttributes["input-range"] | HtmlTagAttributes["input-search"] | HtmlTagAttributes["input-tel"] | HtmlTagAttributes["input-text"] | HtmlTagAttributes["input-time"] | HtmlTagAttributes["input-url"] | HtmlTagAttributes["input-week"];
    export type CheckboxInputAttributesBase = HtmlTagAttributes["input-checkbox"] | HtmlTagAttributes["input-radio"];
    export type ClassName = string | ReadonlyComputation<string> | ReadonlyStringMap<ValueOrComputation<boolean | number | string | object>> | ReadonlyArray<ClassName>;
    export type CommonProperties = ConvertToValueComputation<{
        "aria-atomic"?: BooleanAttribute;
        "aria-autocomplete"?: "inline" | "list" | "both" | "none";
        "aria-checked"?: BooleanAttribute;
        "aria-controls"?: string;
        "aria-current"?: string | BooleanAttribute;
        "aria-describedby"?: string;
        "aria-disabled"?: BooleanAttribute;
        "aria-errormessage"?: string;
        "aria-expanded"?: BooleanAttribute;
        "aria-grabbed"?: BooleanAttribute;
        "aria-haspopup"?: BooleanAttribute | "menu" | "listbox" | "tree" | "grid" | "dialog";
        "aria-hidden"?: BooleanAttribute;
        "aria-invalid"?: BooleanAttribute;
        "aria-label"?: string;
        "aria-labelledby"?: string;
        "aria-level"?: number;
        "aria-live"?: "assertive" | "off" | "polite";
        "aria-multiline"?: BooleanAttribute;
        "aria-orientation"?: "horizontal" | "vertical";
        "aria-owns"?: string;
        "aria-posinset"?: number;
        "aria-readonly"?: BooleanAttribute;
        "aria-required"?: BooleanAttribute;
        "aria-selected"?: BooleanAttribute;
        "aria-setsize"?: number;
        "aria-valuemin"?: number;
        "aria-valuemax"?: number;
        "aria-valuenow"?: number;
        dir?: "ltr" | "rtl";
        hidden?: boolean;
        id?: string;
        lang?: string;
        spellcheck?: boolean;
        role?: string;
        tabindex?: "0" | "-1" | number;
        title?: string;
        translate?: "yes" | "no";
    }> & {
        /**
         * Class name attribute. Available options:
         * 1) string, which represents class names, separated by empty space.
         * 2) Computation of string or string array, represents dynamic class names, that can change over time.
         * 3) map of class names to computations as their toggle condition.
         * 4) an array of any combination of above 1-3
         */
        readonly className?: ClassName;
        /**
         * The element ref assigned to this TSX element. The element ref can be used to set focus on the rendered DOM element.
         */
        readonly ref?: ElementRef;
        /**
         * A map of dynamic css style, the key is the css style name in string
         * The value should be a computation of style value in string.
         */
        readonly style?: ReadonlyStringMap<ValueOrComputation<string>>;
        /**
         * The attribute that specifies whether the element is visible. If the computation evaluates to false, the "display-none" style
         * will be applied to the element.
         */
        readonly visible?: ReadonlyComputation<boolean | string | number | object>;
    };
    export interface KeyboardEventData {
        readonly alt: boolean;
        readonly ctrl: boolean;
        readonly keyCode: number;
        readonly shift: boolean;
    }
    export interface TextInputOnValueChangeEventData {
        readonly value: string;
    }
    export interface CheckboxInputOnCheckedChangeEventData {
        readonly checked: boolean;
    }
    /**
     * An object that can manipulate its associated rendered DOM elements. To form the association, set the object to the "ref" property of the TSX elements that correspond to the rendered DOM elements.
     */
    export class ElementRef {
        /**
         * Focus at i-th element this element ref points to. We use the DOM order returned by getElementsByClassName.
         * Focus waits on computation change propagation before firing.
         *
         * @param index The index of element to focus. The default value is zero.
         */
        focus(index?: number): void;
    }
    /**
     * The read-only fascade of a plain JavaScript object.
     */
    export type ReadonlyStringMap<T> = {
        readonly [key: string]: T;
    };
    export type ExcludeFields<T, U> = Pick<T, Exclude<keyof T, U>>;
    export {};
}

// FILE: Weave\SandboxMode.d.ts
declare module "Weave/SandboxMode" {
    import { CommonProperties as BaseCommonProperties, WeaveNode, WeaveNodeChildren, ReadonlyStringMap, KeyboardEventData, LifetimeManager, HtmlTagAttributes, CheckboxInputOnCheckedChangeEventData, TextInputOnValueChangeEventData, TextInputAttributesBase, CheckboxInputAttributesBase, ExcludeFields } from "Weave";
    const SandboxModeWeave: (nodeType: string | ((props: ReadonlyStringMap<any>, children: ReadonlyArray<WeaveNode>) => WeaveNode), props: ReadonlyStringMap<any>, ...children: (WeaveNode | WeaveNode[])[]) => WeaveNode;
    module SandboxModeWeave {
        type EventData<WeaveEventData> = WeaveCustomEventData & WeaveEventData & {
            readonly ltm: LifetimeManager;
        };
        type EventDataMap = {
            onClick: EventData<object>;
            onFocusIn: EventData<object>;
            onFocusOut: EventData<object>;
            onKeyDown: EventData<KeyboardEventData>;
            onKeyPress: EventData<KeyboardEventData>;
            onKeyUp: EventData<KeyboardEventData>;
            onMouseEnter: EventData<object>;
            onMouseLeave: EventData<object>;
        };
        type EventProperties = {
            readonly [T in keyof EventDataMap]?: (data: EventDataMap[T]) => void;
        };
        type CommonProperties = ExcludeFields<BaseCommonProperties & EventProperties, keyof WeaveSandboxModeCustomAttributesInternal> & WeaveSandboxModeCustomAttributesInternal;
        type NodeWithChildrenProperties = CommonProperties & {
            children?: WeaveNodeChildren;
        };
        type TextInputAttributes = TextInputAttributesBase & {
            onValueChange?: (data: EventData<TextInputOnValueChangeEventData>) => void;
        };
        type CheckboxInputAttributes = CheckboxInputAttributesBase & {
            onCheckedChange?: (data: EventData<CheckboxInputOnCheckedChangeEventData>) => void;
        };
        type TextAreaAttributes = HtmlTagAttributes["textarea"] & {
            onValueChange?: (data: EventData<TextInputOnValueChangeEventData>) => void;
        };
        module JSX {
            interface IntrinsicElements extends WeaveCustomElements {
                a: NodeWithChildrenProperties & HtmlTagAttributes["a"];
                abbr: NodeWithChildrenProperties;
                address: NodeWithChildrenProperties;
                area: CommonProperties & HtmlTagAttributes["area"];
                article: NodeWithChildrenProperties;
                aside: NodeWithChildrenProperties;
                audio: NodeWithChildrenProperties & HtmlTagAttributes["audio"];
                b: NodeWithChildrenProperties;
                bdi: NodeWithChildrenProperties;
                bdo: NodeWithChildrenProperties & HtmlTagAttributes["bdo"];
                blockquote: NodeWithChildrenProperties & HtmlTagAttributes["blockquote"];
                br: CommonProperties;
                button: NodeWithChildrenProperties & HtmlTagAttributes["button"];
                canvas: NodeWithChildrenProperties & HtmlTagAttributes["canvas"];
                caption: NodeWithChildrenProperties;
                cite: NodeWithChildrenProperties;
                code: NodeWithChildrenProperties;
                col: CommonProperties & HtmlTagAttributes["col"];
                colgroup: NodeWithChildrenProperties & HtmlTagAttributes["colgroup"];
                dd: NodeWithChildrenProperties;
                del: NodeWithChildrenProperties & HtmlTagAttributes["del"];
                details: NodeWithChildrenProperties & HtmlTagAttributes["details"];
                dfn: NodeWithChildrenProperties;
                dialog: NodeWithChildrenProperties & HtmlTagAttributes["dialog"];
                div: NodeWithChildrenProperties;
                dl: NodeWithChildrenProperties;
                dt: NodeWithChildrenProperties;
                em: NodeWithChildrenProperties;
                embed: NodeWithChildrenProperties & HtmlTagAttributes["embed"];
                fieldset: NodeWithChildrenProperties;
                figcaption: NodeWithChildrenProperties;
                figure: NodeWithChildrenProperties;
                footer: NodeWithChildrenProperties;
                form: NodeWithChildrenProperties & HtmlTagAttributes["form"];
                header: NodeWithChildrenProperties;
                hgroup: NodeWithChildrenProperties;
                h1: NodeWithChildrenProperties;
                h2: NodeWithChildrenProperties;
                h3: NodeWithChildrenProperties;
                h4: NodeWithChildrenProperties;
                h5: NodeWithChildrenProperties;
                h6: NodeWithChildrenProperties;
                hr: CommonProperties;
                i: NodeWithChildrenProperties;
                img: CommonProperties & HtmlTagAttributes["img"];
                input: CommonProperties & (HtmlTagAttributes["input-hidden"] | TextInputAttributes | CheckboxInputAttributes);
                ins: NodeWithChildrenProperties & HtmlTagAttributes["ins"];
                kbd: NodeWithChildrenProperties;
                label: NodeWithChildrenProperties & HtmlTagAttributes["label"];
                legend: NodeWithChildrenProperties;
                li: NodeWithChildrenProperties;
                main: NodeWithChildrenProperties;
                map: NodeWithChildrenProperties & HtmlTagAttributes["map"];
                mark: NodeWithChildrenProperties;
                meter: NodeWithChildrenProperties & HtmlTagAttributes["meter"];
                nav: NodeWithChildrenProperties;
                ol: NodeWithChildrenProperties & HtmlTagAttributes["ol"];
                optgroup: NodeWithChildrenProperties & HtmlTagAttributes["optgroup"];
                option: NodeWithChildrenProperties & HtmlTagAttributes["option"];
                output: NodeWithChildrenProperties & HtmlTagAttributes["output"];
                p: NodeWithChildrenProperties;
                picture: NodeWithChildrenProperties;
                pre: NodeWithChildrenProperties;
                progress: NodeWithChildrenProperties & HtmlTagAttributes["progress"];
                q: NodeWithChildrenProperties & HtmlTagAttributes["q"];
                rp: NodeWithChildrenProperties;
                rt: NodeWithChildrenProperties;
                ruby: NodeWithChildrenProperties;
                s: NodeWithChildrenProperties;
                samp: NodeWithChildrenProperties;
                section: NodeWithChildrenProperties;
                small: NodeWithChildrenProperties;
                source: CommonProperties & HtmlTagAttributes["source"];
                span: NodeWithChildrenProperties;
                strong: NodeWithChildrenProperties;
                sub: NodeWithChildrenProperties;
                summary: NodeWithChildrenProperties;
                sup: NodeWithChildrenProperties;
                svg: NodeWithChildrenProperties;
                table: NodeWithChildrenProperties;
                tbody: NodeWithChildrenProperties;
                textarea: CommonProperties & TextAreaAttributes;
                td: NodeWithChildrenProperties & HtmlTagAttributes["td"];
                tfoot: NodeWithChildrenProperties;
                th: NodeWithChildrenProperties & HtmlTagAttributes["th"];
                thead: NodeWithChildrenProperties;
                time: NodeWithChildrenProperties & HtmlTagAttributes["time"];
                tr: NodeWithChildrenProperties;
                track: CommonProperties & HtmlTagAttributes["track"];
                u: NodeWithChildrenProperties;
                ul: NodeWithChildrenProperties;
                var: NodeWithChildrenProperties;
                video: NodeWithChildrenProperties & HtmlTagAttributes["video"];
                wbr: CommonProperties;
            }
            interface ElementChildrenAttribute {
                children: {};
            }
            type Element = WeaveNode;
        }
    }
    export = SandboxModeWeave;
}

// FILE: Weave\Types.d.ts
/**
 * This interface exists to support the API infrastructure and is not meant to be directly consumed.
 */
interface WeaveSandboxModeCustomAttributesInternal {
}
/**
 * This interface exists to support the API infrastructure and is not meant to be directly consumed.
 */
interface WeaveDirectModeCustomAttributes {
}
/**
 * This interface exists to support the API infrastructure and is not meant to be directly consumed.
 */
interface AggregationDefinition {
}
/**
 * This interface exists to support the API infrastructure and is not meant to be directly consumed.
 */
interface WeaveCustomInstruction {
}
/**
 * This interface exists to support the API infrastructure and is not meant to be directly consumed.
 */
interface WeaveCustomNotification {
}
/**
 * The shape of the immutable portion of the Weave context, you should extend this type based on your usage.
 */
interface ImmutableWeaveContextInternal {
}
/**
 * The shape of the mutable portion of the Weave context, you should extend this type based on your usage.
 */
interface MutableWeaveContext {
}
/**
 * The shape of "data" field of HtmlElement. In sandbox mode, this data will sent to the main thread via postMessage
 * therefore it needs to be postMessage friendly.
 */
interface HtmlElementData {
}
/**
 * The type of the css property of the Css native component. You should extend this type based on your usage.
 */
interface CssSpecificationInternal {
}
/**
 * The type of the extended event data. You should extend this type based on your usage.
 * You should also implement customEventDataProvider to provide declared data in RenderAgent
 */
interface WeaveCustomEventData {
}
/**
 * The interface that contains the typings for additions to JSX.IntrinsicElements that are not built
 * into the browser. These declarations can be used to define the typings for web components.
 */
interface WeaveCustomElements {
}