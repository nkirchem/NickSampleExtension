/// <reference path="./FxEnvironment.d.ts" />
/// <reference path="./FxReactCommon.d.ts" />
/// <reference path="./Html5.d.ts" />
/// <reference path="./jquery.d.ts" />
/// <reference path="./redux.d.ts" />
/// <reference path="./require.d.ts" />

// Compiled with TypeScript 5.0

// FILE: MsPortalFx\Assets\Assets.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxImage = FxBase.Image;
    import FxComposition = FxImpl.Composition.Selectable;
    import DynamicSelection = MsPortalFx.ViewModels.DynamicSelection;
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    /**
     * Represents a set of flags for the browse requirements for the asset view model.
     */
    const enum BrowseRequirements {
        /**
         * Indicates no permissions are required
         */
        None = 0,
        /**
         * Indicates that co-admin permissions are required.
         */
        CoAdmin = 1
    }
    /**
     * Determines if the given contracts flag set supports a given contract.
     *
     * @param contracts The contracts flag set which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @returns Boolean true if the contracts flag set supports the given contract, else false.
     */
    function supportsContract(contracts: number, contract: AssetContracts): boolean;
    /**
     * Determines if the given asset type information supports a given contract.
     *
     * @param assetTypeInformation The asset type information which contains all the supported contracts.
     * @param contract The asset contract to check.
     * @returns Boolean true if there is an asset type information, a view model and the contracts supports the given contract, else false.
     */
    function assetTypeInformationSupportsContract(assetTypeInformation: AssetTypeInformation, contract: AssetContracts): boolean;
    type CompositeDisplayName = import("Fx/Assets").CompositeDisplayName;
    type AssetType = import("Fx/Assets").AssetType;
    type Link = import("Fx/Assets").Link;
    type AssetTypeInformation = import("Fx/Assets").AssetTypeInformation;
    type ResourceTypeAssetTypeInformation = import("Fx/Assets").ResourceTypeAssetTypeInformation;
    type GetAllAssetTypesOptions = import("Fx/Assets").GetAllAssetTypesOptions;
    /**
     * The asset triplet interface which represents a fully qualified asset ID.
     */
    interface AssetTriplet {
        /**
         * The extension name for the fully qualified asset ID.
         */
        extensionName: string;
        /**
         * The asset type for the fully qualified asset ID.
         */
        assetType: string;
        /**
         * The asset ID for the fully qualified asset ID.
         */
        assetId: any;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface AssetInformation extends AssetTypeInformation {
        /**
         * The asset ID if successful, null otherwise.
         */
        assetId: any;
        /**
         * The dynamic selection if successful, null otherwise.
         */
        dynamicSelection: DynamicSelection;
    }
    /**
     * The asset information interface which represents an asset ID and asset type information for a given resource ID.
     */
    interface ResourceAssetInformation extends AssetInformation {
        /**
         * The resource ID.
         */
        resourceId: string;
    }
    /**
     * The asset type information interface which represents the registered asset types and indicates if the set is complete or not.
     */
    interface RegisteredAssetTypesInformation {
        /**
         * Asset type information.
         */
        assetTypesInformation: ResourceTypeAssetTypeInformation[];
        /**
         * Indicates whether the Asset type data is complete i.e. from all the loaded extensions or is partial.
         */
        isPartialSet?: boolean;
    }
    /**
     * The asset blade reference provides the extension and blade name for a blade.
     */
    interface AssetBladeReference {
        /**
         * The name of the blade.
         */
        blade: string;
        /**
         * The name of the extension.
         */
        extension: string;
    }
    /**
     * The dynamic selection and icon interface provides a wrapper for dynamic selection and icon.
     */
    interface DynamicSelectionAndIcon {
        /**
         * The selection.
         */
        selection: DynamicSelection;
        /**
         * The icon.
         */
        icon: FxImage;
        /**
         * Optional flag to indicate the asset type is from a preview extension.
         * If this flag is not specified, the asset type is NOT from a preview.
         */
        isPreview?: boolean;
    }
    /**
     * The resource blade inputs contract provides the inputs for all resource and asset blades.
     */
    interface ResourceBladeInputs {
        /**
         * The ID of the resource or asset for the blade.
         */
        id: any;
    }
    /**
     * Maps a dynamic blade selection to a blade reference.
     *
     * @param bladeSelection The dynamic blade selection.
     * @param onClosed The onClosed callback for the blade.
     * @returns The promise that resolves to the blade reference.
     */
    function mapDynamicBladeSelectionToBladeReference<T>(bladeSelection: DynamicBladeSelection, onClosed?: FxImpl.CompositionCore.BladeClosedWithDataHandler<T>): Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps an asset ID to a resource ID using the asset type system.
     * Note that this will reject if the asset type does not support mapping to resource ID.
     *
     * @deprecated MsPortalFx.Assets.mapAssetIdToResourceId 2020/04/30 - All asset ID's should be resource ID's and this should no longer be used.
     * The MappingViewModel is no longer implemented by any assets and this can be removed and just use the
     * resource ID directly which includes the resource type.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * @param assetId The fully qualified asset ID.
     * @returns A promise that resolves to the resource ID string for the fully qualified asset ID.
     */
    function mapAssetIdToResourceId(assetId: AssetTriplet): Obsolete;
    /**
     * Maps a resource ID to an asset ID using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @returns A promise that resolves to the fully qualified asset ID for the resource ID.
     */
    function mapResourceIdToAssetId(resourceId: string): Promise<AssetTriplet>;
    /**
     * Maps an asset triplet to a blade reference and an icon using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @returns A promise that resolves to the fully qualified blade reference and the icon for the asset ID.
     */
    function mapAssetIdToDynamicSelectionAndIcon(assetId: AssetTriplet, forceBladeSelection?: boolean): Promise<DynamicSelectionAndIcon>;
    /**
     * Maps an asset triplet to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @returns A promise that resolves to the fully qualified dynamic selection for the asset ID.
     */
    function mapAssetIdToDynamicSelection(assetId: AssetTriplet, forceBladeSelection?: boolean): Promise<DynamicSelection>;
    /**
     * Maps an asset triplet to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found.
     *
     * @param assetId The fully qualified asset ID.
     * @returns A promise that resolves to the fully qualified blade reference for the asset ID.
     */
    function mapAssetIdToBladeReference(assetId: AssetTriplet): Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Maps a resource ID to a dynamic selection and an icon using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @returns A promise that resolves to the fully qualified dynamic selection and the icon for the resource ID.
     */
    function mapResourceIdToDynamicSelectionAndIcon(resourceId: string, forceBladeSelection?: boolean): Promise<DynamicSelectionAndIcon>;
    /**
     * Maps a resource ID to a dynamic selection using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param forceBladeSelection Boolean true to force the selection to be a dynamic blade selection, else false.
     * @returns A promise that resolves to the fully qualified dynamic selection for the resource ID.
     */
    function mapResourceIdToDynamicSelection(resourceId: string, forceBladeSelection?: boolean): Promise<DynamicSelection>;
    /**
     * Maps a resource ID to blade reference using the asset type system.
     * Note that this will reject if an asset type is not found for the resource type.
     *
     * @param resourceId The resource ID string.
     * @param onClosed The onClosed callback for the blade.
     * @returns A promise that resolves to the fully qualified blade reference for the resource ID.
     */
    function mapResourceIdToBladeReference(resourceId: string, onClosed?: FxImpl.CompositionCore.BladeClosedWithDataHandler<any>): Promise<FxComposition.BladeReference<ResourceBladeInputs>>;
    /**
     * Gets an asset type's information for a given asset type using the asset type system.
     * Note that this will reject if the asset type is not found.
     *
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetType The name of the asset type.
     * @returns A promise that resolves to the asset type information structure for the asset type.
     */
    function getAssetTypeInformation(extensionName: string, assetType: string): Promise<AssetTypeInformation>;
    /**
     * Gets an asset type information for an array of resource types using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the
     * assetTypeInformation will be null for that resource type.
     *
     * @param resourceTypes The array of names of the resource types.
     * @returns A promise that resolves to the asset type information structure for the resource type.
     */
    function getResourceTypeAssetTypeInformation(resourceTypes: string[]): Promise<ResourceTypeAssetTypeInformation[]>;
    /**
     * Gets the asset information for an array of resource IDs using the asset type system.
     * Note that this will not reject if an asset type is not found for the resource type, but the assetId and
     * assetTypeInformation will be null for that resource ID.
     *
     * @param resourceIds An array of resource IDs.
     * @returns A promise that resolves to an array of asset information packets, one for each source resource ID.
     */
    function getResourceAssetInformation(resourceIds: string[]): Promise<ResourceAssetInformation[]>;
    /**
     * Signals that resources of the specified type have changed and cache for these resources should be updated.
     *
     * @deprecated MsPortalFx.Assets.signalResourcesChanged Do not use, no longer supported. This API has for a long time not executed any code in FX, it is
     * safe to remove this call.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * @param resourceIds An array of resource IDs.
     * @returns The promise that resolves when the operation has completed.
     */
    function signalResourcesChanged(_resourceIds: string[]): Obsolete;
}
declare module FxImpl.Assets {
    type ResourceTypeAssetTypeInformation = import("FxInternal/Assets").ResourceTypeAssetTypeInformation;
    type AssetTypeSearchAssetTypeCriteria = import("FxInternal/Assets").AssetTypeSearchAssetTypeCriteria;
    type AssetTypeSearchResourceTypeCriteria = import("FxInternal/Assets").AssetTypeSearchResourceTypeCriteria;
    type AssetTypeSearchCriteria = import("FxInternal/Assets").AssetTypeSearchCriteria;
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param extensionName the extension name
     * @param typeName the type name, could be asset type or resource type
     * @returns The the unique id.
     */
    function getAssetTypeOrResourceTypeId(extensionName: string, typeName: string): string;
    /**
     * Gets the unique id of an asset type/resource type.
     *
     * @param windowId The window id of the extension.
     * @param typeName the type name, could be asset type or resource type.
     * @returns The unique id.
     */
    function getAssetTypeOrResourceTypeIdByWindowId(windowId: string, typeName: string): string;
}
declare namespace MsPortalFx.Assets {
    const AssetContracts: typeof import("Fx/Assets").AssetTypeContracts;
    type AssetContracts = import("Fx/Assets").AssetTypeContracts;
}

// FILE: MsPortalFx\Assets\Assets.BrowseConfig.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * The column to describe a column in the browse grid.
     */
    interface Column {
        /**
         * The column ID.
         */
        id: string;
        /**
         * The column display name (shows up in UI).
         */
        name: KnockoutObservable<string>;
        /**
         * The column description (shows up in UI).
         */
        description?: KnockoutObservable<string>;
        /**
         * The the item key (source property) for the column.
         */
        itemKey: string;
        /**
         * The format for the column.
         */
        format?: Grid.Format;
        /**
         * The format options for the column.
         */
        formatOptions?: Grid.FormatOptions;
        /**
         * The width for the column.
         */
        width?: KnockoutObservable<string>;
        /**
         * The CSS class for the column.
         */
        cssClass?: string;
        /**
         * Hides the column.
         */
        isHidden?: KnockoutObservableBase<boolean>;
        /**
         * Makes the column activatable.
         */
        activatable?: boolean;
        /**
         * If the column is activatable, this provides the dynamic selection.
         */
        dynamicSelectionProvider?: KnockoutObservableBase<(id: any, item: any) => Promise<FxViewModels.DynamicSelection>>;
    }
    /**
     * The browse config contains the information for a non-default browse such as columns.
     */
    interface BrowseConfig {
        /**
         * The array of column config definitions.
         */
        columns: Column[];
        /**
         * The array of column IDs for the default columns for the browse grid.
         */
        defaultColumns: (string | ResourceColumnIds)[];
        /**
         * The array of column IDs for additional filter pills displayed by default.
         * Filter pills for columns specified here will be displayed with initial "all selected" value.
         */
        defaultFilters?: (string | ResourceColumnIds)[];
        /**
         * The array of column IDs to exclude from the browse grid.
         */
        excludeColumns?: ResourceColumnIds[];
        /**
         * Any additional properties used in HTML templates which will be provided by supplemental data.
         */
        properties?: string[];
        /**
         * Optional command group reference for the item context menu.
         */
        contextMenu?: CommandGroupReference;
        /**
         * Optional info box to display custom text.
         */
        infoBox?: BrowseInfoBox;
    }
    /**
     * The command group reference interface which references a command group by name and optional extension.
     */
    interface CommandGroupReference {
        /**
         * The command group name.
         */
        commandGroup: string;
        /**
         * The optional command group owner extension.  If not specified, the asset type extension is used.
         */
        commandGroupOwner?: string;
    }
    /**
     * The browse info box interface which extensions can provide to display custom information on their browse blades.
     */
    interface BrowseInfoBox {
        /**
         * The image on the info box.
         */
        image: FxBase.Image;
        /**
         * The text.
         */
        text: string;
        /**
         * The link to launch from info box.
         */
        uri?: string;
        /**
         * The blade detail to open from info box.
         */
        blade?: FxViewModels.DynamicBladeSelection;
    }
    /**
     * The contract for the asset type's browse config.
     */
    interface BrowseConfigContract {
        /**
         * Gets the browse config.
         *
         * @returns A promise which will be resolved with the browse config.
         */
        getBrowseConfig(): Promise<BrowseConfig>;
    }
}
declare namespace MsPortalFx.Assets {
    const ResourceColumnIds: typeof import("Fx/Assets").ResourceColumnIds;
    type ResourceColumnIds = import("Fx/Assets").ResourceColumnIds;
}

// FILE: MsPortalFx\Assets\Assets.ProvidesResources.d.ts
declare module MsPortalFx.Assets {
    /**
     * The contract for the asset type's provides resources.
     */
    interface ProvidesResourcesContract {
        /**
         * Gets a resource.
         *
         * @param id The resource ID.
         * @returns A promise which will be resolved with the resource.
         */
        getResource(id: string): Promise<HubsExtension.Azure.Resource>;
    }
}

// FILE: MsPortalFx\Assets\Assets.ResourceMenuConfig.d.ts
declare module MsPortalFx.Assets {
    import FxSubscription = MsPortalFx.Azure.Subscription;
    import BladeReference = FxImpl.Composition.Selectable.BladeReference;
    /**
     * The group IDs for the build-in menu groups.
     */
    const AutomationGroupId = "automation_group";
    const ManagementGroupId = "management_group";
    const SupportGroupId = "support_group";
    const QuickAccessGroupId = "quickaccess_group";
    const MonitoringGroupId = "monitoring_group";
    /**
     * The item IDs for the build-in menu items.
     */
    const EventLogsItemId = "eventlogs";
    const ExportTemplateItemId = "exporttemplate";
    const MyAccessItemId = "access";
    const ResourceProvidersItemId = "resourceproviders";
    const ResourceHealthItemId = "resourcehealth";
    const ResourceGroupsItemId = "resourceGroups";
    const ResourcesItemId = "resources";
    const PreviewFeaturesItemId = "previewfeatures";
    const SubscriptionCertsItemId = "subcerts";
    const SubscriptionQuotasItemId = "quotas";
    const SupportHelpRequestItemId = "supportrequest";
    const TagsItemId = "tags";
    const LocksItemId = "locks";
    const TroubleshootItemId = "troubleshoot";
    const UsersItemId = "users";
    const PropertiesItemId = "properties";
    const AlertsItemId = "alerts";
    const DiagnosticsItemId = "diagnostics";
    const MetricsItemId = "metrics";
    const LogSearchItemId = "logsearch";
    const ResourceAdvisorItemId = "resourceadvisor";
    const AnalyticsItemId = "analytics";
    const AutomationApisId = "automationapis";
    /**
     * Defines an item in a group of the menu.
     */
    interface MenuItem {
        /**
         * Gets the ID for the item.
         */
        id: string;
        /**
         * The display text for the item.
         */
        displayText: string | KnockoutObservableBase<string>;
        /**
         * A space-delimited list of keywords associated to the item.
         */
        keywords?: string | string[];
        /**
         * The icon associated to the menu item.
         */
        icon: MsPortalFx.Base.Image | KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * A value indicating whether or not the item is enabled.
         */
        enabled?: KnockoutObservableBase<boolean>;
        /**
         * A value indicating whether or not the item should be visible in the menu.
         */
        visible?: KnockoutObservableBase<boolean>;
        /**
         * The tooltip for the menu item.
         */
        tooltip?: string | KnockoutObservableBase<string>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * in response to a user-invoked navigation.
         *
         * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReference?: () => BladeReference<any>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * asynchronously in response to a user-invoked navigation.
         *
         * @returns A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReferenceAsync?: () => Promise<BladeReference<any>>;
        /**
         * The menu items in the tab list.
         */
        tabItems?: TabMenuItem[];
    }
    /**
     * Defines a tab item under a menu item.
     */
    interface TabMenuItem {
        /**
         * Gets the ID for the item.
         */
        id: string;
        /**
         * The display text for the item.
         */
        displayText: string | KnockoutObservableBase<string>;
        /**
         * A space-delimited list of keywords associated to the item.
         */
        keywords?: string | string[];
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * in response to a user-invoked navigation.
         *
         * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReference?: () => BladeReference<any>;
        /**
         * This callback is invoked by the portal when a new blade is to be opened
         * asynchronously in response to a user-invoked navigation.
         *
         * @returns A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
         */
        supplyBladeReferenceAsync?: () => Promise<BladeReference<any>>;
    }
    /**
     * Defines a group in the menu.
     */
    interface MenuGroup {
        /**
         * Gets the ID for the item.
         */
        id: string;
        /**
         * The display text for the item.
         */
        displayText: string | KnockoutObservableBase<string>;
        /**
         * A space-delimited list of keywords associated to the item.
         */
        keywords?: string | string[];
        /**
         * The menu items in the group.
         */
        items: MenuItem[];
        /**
         * Gets or sets if the menu group should be elevated in the menu blade.
         */
        elevated?: boolean;
    }
    /**
     * Defines a group extension in the menu.
     * This is used to extend the built-in groups with additional items.
     *
     * NOTE: The resourceId must be one of the constants for group IDs in this file.
     *       Using a different ID will result in a load rejection.
     */
    interface MenuGroupExtension {
        /**
         * Gets the ID for the built-in group.
         */
        referenceId: string;
        /**
         * The menu items in the group.
         */
        items: MenuItem[];
    }
    type ExtensionResource = FxSubscription | HubsExtension.Azure.ResourceGroup | HubsExtension.Azure.Resource;
    /**
     * The resource information for the resource menu.
     */
    interface ResourceInformation extends ResourceInfo {
        /**
         * The resource or resource group or subscription.
         */
        resource: ExtensionResource;
        /**
         * The resource's subscription information (only valid for non-tenant resources).
         */
        subscription?: FxSubscription;
    }
    /**
     * The information passed to the extension to load the resource.
     */
    interface ResourceInfo {
        /**
         * The resource ID.
         */
        resourceId: string;
    }
    /**
     * The options of the resource menu config.
     */
    interface ResourceMenuOptions {
        /**
         * Disables the automation tasks option from appearing in the automation group.
         */
        disableAutomationTasks?: boolean;
        /**
         * Disables the resource explorer option from appearing in the automation group.
         */
        disableResourceExplorer?: boolean;
        /**
         * Enables the setting exporting a template from resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         *
         * @deprecated ResourceMenuOptions.enableSupportTroubleshoot will soon be removed from the SDK. Please use the enableSupportTroubleshootV2 option instead.
         */
        enableSupportTroubleshoot?: Obsolete;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables the setting for standard properties blade.
         */
        enableProperties?: boolean;
        /**
         * Enables the settings for alerts.
         */
        enableAlerts?: boolean;
        /**
         * Enables the settings for diagnostics.
         */
        enableDiagnostics?: boolean;
        /**
         * Enables the settings for metrics.
         */
        enableMetrics?: boolean;
        /**
         * Enables the settings for log analytics.
         */
        enableLogAnalytics?: boolean;
        /**
         * Enables the settings for log search. Disabled if enable logs is enabled.
         */
        enableLogSearch?: boolean;
        /**
         * Enables the settings for locks.
         */
        enableLocks?: boolean;
        /**
         * Enables the settings for resource advisor support.
         */
        enableSupportResourceAdvisor?: boolean;
        /**
         * Enables the settings for Event Grid Publisher support.
         */
        enableEventGridPublisher?: boolean;
        /**
         * Enables workbooks blade in the resource ToC
         */
        enableWorkbooks?: boolean;
        /**
         * Enables analytics blade for logs in the resource ToC
         */
        enableLogs?: boolean;
        /**
         * Enables insights blade in the resource ToC
         * TODO, 12938313, Mark this member deprecated during the next breaking change window.
         * Please see https://aka.ms/azmonwog to enable insights
         */
        enableInsights?: boolean;
        /**
         * Enables view for CLI/Powershell blade in the resource ToC
         */
        enableAutomationApis?: boolean;
    }
    /**
     * The menu group instance type (either a menu group or a menu group extension).
     */
    type MenuGroupInstance = MenuGroup | MenuGroupExtension;
    /**
     * The resource menu configuration.
     */
    interface ResourceMenuConfig {
        /**
         * The resource menu item (overview item).
         */
        overview: MenuItem;
        /**
         * The menu item groups.
         */
        groups: MenuGroupInstance[];
        /**
         * The ID of the default menu item.
         * If this is not provided, the overview item will be the default item.
         */
        defaultItemId?: string;
        /**
         * Optional set of resource menu options.
         */
        options?: ResourceMenuOptions;
        /**
         * Optional observable to return a handled error message or entire error options for showing an "expected" or
         * "handled" error in the blade.
         *
         * Use this method when encountering an expected error state transition which has been designed as part of the
         * user experience and is not the indication of a product bug.
         *
         * This can be set late (after the getMenuConfig call has resolved) to indicate an "expected" error blade with
         * error information such as resource not found or unauthorized where the entire resource menu blade should
         * switch to the handled error UX. This works similar to the handledError() function on a blade.
         *
         * @see fail An observable that logs the errors for diagnostics. Use for an unexpected error.
         * @example <caption>Using handledError to switch to handled error UX</caption>
         *
         * public getResourceMenuConfig(resourceId: string): Promise<FxAssets.ResourceMenuConfig> {
         *     const handledError = ko.observable<MsPortalFx.ViewModels.ErrorOptions>();
         *     const fail = ko.observable<void | MsPortalFx.ViewModels.ErrorOptions>();
         *     const menuConfig: FxAssets.ResourceMenuConfig = {
         *         overview: getPrinterOverviewItem(),
         *         options: {
         *             enableRbac: true,
         *             enableTags: true,
         *         },
         *         groups: [],
         *         handledError,
         *         fail,
         *     };
         *
         *     // Load the resource and update the menu items in the background.
         *     // In the case of this asset type, the ResourceProvidedBy for the resource menu is marked as
         *     // "NoResource". In this case, the AJAX call to retrieve the printer resource from ARM should
         *     // not be part of the menu config. In this case, the menu config should be returned as
         *     // quickly as possible with as many options completed as possible without the resource (such
         *     // as the overview menu item) and then the menu will be updated with the printer resource
         *     // when loaded. Therefore, the getResource() call is not being included in the returned
         *     // promise below to avoid blocking the UX. The UX can reveal the overview blade and partial
         *     // menu and when the printer is loaded and the menu is updated, the blade will adapt.
         *     dataContext.printerData.getResource(resourceId, "resource menu").then((printerData) => {
         *         // In production code, this code would make changes to the menu (add items, etc).
         *     }).catch((error) => {
         *         // IMPORTANT: Handle the late-failure errors using the common helper.
         *         if (error && error.status === HttpStatusCode.NotFound) {
         *             // Nice notice blade for 404 (not found).
         *             resourceId = MsPortalFx.encodeHtml(resourceId);
         *             const statusMessage = MsPortalFx.encodeHtml((error && (<any>error).content && (<any>error).content.message) || ResourceMenuNotice.unknownResponse);
         *             handledError({
         *                 message: ResourceMenuNotice.notFoundHeader.format(assetTypeName),
         *                 code: error.status,
         *                 details: ResourceMenuNotice.notFoundDescription.format(assetTypeName, resourceId, statusCode, statusMessage).replaceAll("\n", "<br />"),
         *             });
         *         } else {
         *             // Other errors fail the blade.
         *             fail((error && error.message) || error);
         *         }
         *     });
         *
         *     return Q(menuConfig);
         * }
         */
        readonly handledError?: KnockoutReadOnlyObservableBase<string | MsPortalFx.ViewModels.ErrorOptions>;
        /**
         * Optional error to return an async failure to the resource menu blade. This will cause the blade to
         * "sad cloud".
         *
         * This can be set late (after the getMenuConfig call has resolved) to indicate a fatal error where the entire
         * resource menu blade should switch to the fail (sad cloud) UX.
         *
         * @see handledError An observable that doesn't log the error to diagnostics. Use for expected error.
         *
         * (see handledError above for example)
         */
        readonly fail?: KnockoutReadOnlyObservableBase<string | MsPortalFx.ViewModels.ErrorOptions>;
    }
    /**
     * The resource provided by the extension for the resource menu blade.
     */
    interface ExtensionSuppliedResourceInfo {
        /**
         * The resource, subscription or resource group object provided by the extension.
         */
        resource: ExtensionResource;
        /**
         * The resource menu configuration.
         */
        menuConfig: ResourceMenuConfig;
    }
    /**
     * The contract for the asset type's resource menu config.
     */
    interface ResourceMenuWithCallerSuppliedResourceContract {
        /**
         * Gets the resource menu configuration.
         *
         * @param resourceInfo The resource ID and resource|resource group for the menus.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @returns A promise which will be resolved with the resource menu configuration.
         */
        getMenuConfig(resourceInfo: ResourceInformation, menuContext?: string): Promise<ResourceMenuConfig>;
    }
    /**
     * The contract for the asset type's resource menu where the resource is provided by the extension.
     */
    interface ResourceMenuWithExtensionProvidedResourceContract {
        /**
         * Gets the resource and the resource menu configuration.
         *
         * @param resourceInfo The resource ID for the menu.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @returns A promise which will be resolved with the resource and resource menu configuration information.
         */
        getResourceAndMenuConfig(resourceInfo: ResourceInfo, menuContext?: string): Promise<ExtensionSuppliedResourceInfo>;
    }
    /**
     * The contract for the asset type's resource menu where no resource is provided.
     */
    interface ResourceMenuWithNoResourceContract {
        /**
         * Gets the resource menu configuration.
         *
         * @param resourceInfo The resource ID and resource|resource group for the menus.
         * @param menuContext This is the value for the 'menucontext' blade parameter supplied via a BladeReference when the ResourceMenuBlade was opened.
         * @returns A promise which will be resolved with the resource menu configuration.
         */
        getResourceMenuConfig(resourceId: string, menuContext?: string): Promise<ResourceMenuConfig>;
    }
}
declare module FxImpl.Assets {
    import FxBase = MsPortalFx.Base;
    import BladeReference = FxImpl.Composition.Selectable.BladeReference;
    import FxExtension = FxImpl.Extension;
    /**
     * Supplies the blade reference for the detail blade opened by a menu item on the resource menu blade.
     *
     * @param lifetime The lifetime of the menu item.
     * @param extensionDescriptor The descriptor of the extension that provided the menu item.
     * @param item The menu item.
     * @returns A promise for the blade reference.
     */
    function supplyMenuDetailBladeReferenceAsync(lifetime: FxBase.LifetimeManager, extensionDescriptor: FxExtension.ExtensionDescriptor, item: MsPortalFx.Assets.MenuItem | MsPortalFx.Assets.TabMenuItem): Promise<BladeReference<any>>;
}

// FILE: MsPortalFx\Assets\Assets.SupplementalData.d.ts
declare module MsPortalFx.Assets {
    import FxBase = MsPortalFx.Base;
    /**
     * The supplemental data provides the supplemental data for a single resource.
     */
    interface SupplementalData extends StringMap<any> {
        /**
         * The resource ID for the resource.
         */
        resourceId: string;
        /**
         * Optional command group reference override for the item context menu.
         */
        contextMenu?: CommandGroupReference;
    }
    /**
     * The contract for the asset type's supplemental data.
     */
    interface SupplementalDataContract {
        /**
         * The supplemental data stream observable array is used to stream supplemental data.
         */
        supplementalDataStream: KnockoutObservableArray<SupplementalData>;
        /**
         * Gets the supplemental data for the array of resource IDs.
         * Optionally, a refresh flag will be passed and if its set to true, extension must refresh the cache for supplemental data for the
         * given resource IDs and latest data must be provided.
         * Note: For refresh scenario, extension should also make sure the refresh data is updated in supplemental data stream before resolving
         * the getSupplementalData method's promise.
         *
         * @param resourceIds The array of resource IDs for the supplemental data.
         * @param columns The array of columns for the supplemental data that is required.
         * @param refresh Optionally specify if the supplemental data needs to be refreshed for the specified resource IDs.
         * @returns A promise which will be resolved when data is ready to be streamed.
         */
        getSupplementalData(resourceIds: string[], columns: string[], refresh?: boolean): Promise<any>;
        /**
         * A callback to indicate that extension must clear out any cached data and should provide latest data when the next getSupplementalData call is made.
         * Typically this callback is invoked when user clicks the "Refresh" button in the browse blade and portal user explicitly conveys the intent to have the latest data.
         *
         * @returns A promise indicating the completion of the refresh operation.
         */
        refreshCache?(): Promise<any>;
    }
    /**
     * Namespace for the supplemental data stream handling.
     */
    module SupplementalDataStreamHelper {
        /**
         * Connects a query view to a supplemental data stream.
         *
         * @param lifetimeManager The lifetime manager for this supplemental data stream.
         * @param view The quey view source for the connection.
         * @param destination The supplemental data stream for the connection.
         * @param isRequestedCallback The callback to determine if the item was requested.
         * @param buildDataCallback The callback to build the supplemental data for the item.
         */
        function ConnectView<TModel, TId>(lifetimeManager: FxBase.LifetimeManager, view: MsPortalFx.Data.QueryView<TModel, TId>, destination: KnockoutObservableArray<SupplementalData>, isRequestedCallback: (item: TModel) => boolean, buildDataCallback: (item: TModel) => SupplementalData): void;
    }
}

// FILE: MsPortalFx\Azure\ArmErrors.d.ts
declare module FxImpl.Azure {
    /**
     * A simplified version of the JQueryXHR error.
     */
    interface SimplifiedError extends Error {
        /**
         * The error ready state.
         */
        readyState: number;
        /**
         * The error status (HTTP code).
         */
        status: MsPortalFx.Base.Net2.HttpStatusCode;
        /**
         * The error status text (HTTP code text).
         */
        statusText: string;
        /**
         * The error code from the response JSON if it exists.
         */
        code: string;
        /**
         * The error stack.
         */
        stack: string;
    }
    /**
     * Error detail returned from ARM
     */
    interface ArmErrorDetails {
        /**
         * The error code.
         */
        code: string;
        /**
         * The error message.
         */
        message: string;
        /**
         * The target entity.
         */
        target: string;
        /**
         * The details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * The error info
     */
    interface ArmError extends ArmErrorDetails {
        /**
         * The error details.
         */
        details?: ArmErrorDetails[];
    }
    /**
     * Mapped error object with details.
     */
    interface MappedArmError {
        /**
         * The top level error with code.
         */
        error: string;
        /**
         * The nested errors with code if any.
         */
        details: (string | MappedArmError)[];
    }
    /**
     * Parses error object returned from ARM.
     *
     * @param errorObj error object returned from ARM.
     * @param codesOnly optional value that specifies whether to return only error codes or full error messages.
     * @param flattenAtLevel optional value that specifies level to flatten error details at, defaults to 1.
     * NOTE: This parameter indicates number of nested levels to be returned in the output object and not the number of nested levels to parse.
     *       Remaining nested details are flattened at this level.
     * @returns mapped error object.
     */
    function parseArmError(errorObj: ArmError, codesOnly?: boolean, flattenAtLevel?: number): MappedArmError;
    /**
     * Parses error object returned from ARM to a concatenated string.
     *
     * @param error error object returned from ARM.
     * @param message A base message to use at the beginning of the returned message.
     * @returns string containing the concatenated errors returned from ARM.
     */
    function parseArmErrorToMessage(error: ArmError, message?: string): string;
    /**
     * Builds a simplified error object out of a JQueryXHR error. Useful if you're returning errors
     * over the PO-layer.
     *
     * @param jqxhr The JQueryXHR error object.
     * @returns The simplified error object.
     */
    function buildSimplifiedError<T>(jqxhr: JQueryXHR<T> | Common.Ajax.BatchResponseItem<any>): SimplifiedError;
    /**
     * Scrubs error objects.
     * param message The object to scrub.
     * returns The scrubbed object.
     *
     * @param obj The object to scrub.
     * @returns The scrubbed object.
     */
    function scrubError(obj: any): any;
}

// FILE: MsPortalFx\Azure\BaseResourceDropDown.d.ts
declare module MsPortalFx.Azure {
    /**
     * Options for validating required permissions.
     */
    export import RequiredPermissions = Common.ArmRequiredPermissions;
    interface CreatorAndDropdDownValue<T> {
        /**
         * Specifies if the value returned should be created
         */
        createNew: boolean;
        /**
         * The value returned from the dropdown
         */
        value: T;
    }
}
declare module FxImpl.Azure {
    /**
     * FxImpl.Azure.BaseResourceDropDown is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    module BaseResourceDropDown {
        /**
         * FxImpl.Azure.BaseResourceDropDown.FilterOptions is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type FilterOptions = Obsolete;
        /**
         * FxImpl.Azure.BaseResourceDropDown.HierarchicalFormOption is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type HierarchicalFormOption = Obsolete;
        /**
         * FxImpl.Azure.BaseResourceDropDown.Options is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type Options = Obsolete;
        /**
         * FxImpl.Azure.BaseResourceDropDown.FilterComboBoxResult is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type FilterComboBoxResult = Obsolete;
        /**
         * FxImpl.Azure.BaseResourceDropDown.Config is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type Config = Obsolete;
    }
    /**
     * FxImpl.Azure.BaseResourceDropDown is obsolete. Use Fx/Controls/BaseResourceDropDown instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const BaseResourceDropDown: any;
}

// FILE: MsPortalFx\Azure\Legal\Legal.d.ts
declare module MsPortalFx.Azure.Legal {
    /**
     * Input/configuration data used by the Legal Terms V2 blade. In PCLegalTermsV2Blade, this is the type of the config
     * accepted by the parameter provider (via the supplyProviderConfig callback from the parameter collector).
     *
     * For solution
     */
    interface LegalTermsConfig {
        /**
         * Indicates what kind of marketplace item we are displaying legal terms language for.
         */
        legalTermsLanguage: LegalTermsLanguageEnum;
        /**
         * If true, a 'pin to startboard' checkbox will be displayed on the action bar.
         */
        showPinToStartboardCheckbox?: boolean;
        /**
         * The ID of the subscription which is being used to provision the marketplace item.
         */
        subscriptionId: string;
        /**
         * Details of the gallery item whose legal terms are being displayed. Obtain this value from
         * MsPortalFx.Azure.ResourceManager.ArmProvisioner<T>.armProvisioningConfig.galleryCreateOptions.galleryItem.
         * This value may be ommitted only if legalTermsLanguage == LegalTermsLanguageEnum.TemplateDeployment.
         */
        galleryItem?: any;
        /**
         * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
         * For gallery items which do not have pricing or plans (such as solution templates), omit this value
         * and the legal terms blade will display the products extracted from galleryItem.
         */
        productPurchases?: ProductPurchase[];
    }
    /**
     * Describes the plan, promotion code, and other purchase details for each of the 3rd party products the user is buying.
     */
    interface ProductPurchase {
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.publisherId.
         */
        publisherId: string;
        /**
         * The publisherId (also called publisher namespace) for the product. This corresponds to
         * GalleryCreateOptions.galleryItem.products[i].offerDetails.offerId.
         */
        offerId: string;
        /**
         * The ID of the plan (or VM SKU) which the user has chose for this product.
         */
        planId: string;
        /**
         * The promotion code which the user is using to purchase this 3rd party product. If no promotion code is being
         * applied then omit this value or set it to null.
         */
        promotionCode?: string;
        /**
         * The IDs of the third-party meters which apply to the plan that the user has purchased. If third party meters don't
         * apply to this type of product or no meters apply to the selected plan then omit this property or set it to an empty array.
         */
        meterIds?: string[];
        /**
         * For app services and data services, this should be set to the localized display name of the selected plan (corresponding to planId),
         * This value will be displayed alongside the offer name at the top of the legal terms blade. For other types of offers (virtual machines, etc)
         * this value should be ommitted.
         */
        servicePlanName?: string;
        /**
         * When the 3rd party product is a VM image this should be set to a FirstPartyVirtualMachinePurchase which describes the SKU / VM size chosen.
         * If the product is not a VM image this value should be omitted.
         */
        firstPartyVirtualMachine?: FirstPartyVirtualMachinePurchase;
    }
    /**
     * Describes the Azure VM SKU/size on which a VM image runs.
     */
    interface FirstPartyVirtualMachinePurchase {
        /**
         * The display name of this VM size/SKU, as it was presented to the user in the VM size picker control.
         */
        skuDisplayName: string;
        /**
         * The type of operating system on which the VM runs.
         */
        operatingSystem: FirstPartyOperatingSystem;
        /**
         * The parameters needed to get the per-unit (hourly) price of this VM SKU using the getSpecsCosts RPC exposed by the
         * billing extension.
         */
        hourlyCost: FirstPartyVirtualMachineCost;
    }
    /**
     * Describes the inputs needed to query the cost of a 1st party virtual machine SKU using the getSpecsCosts RPC
     * exposed by the billing extension.
     */
    interface FirstPartyVirtualMachineCost {
        /**
         * The resource ID of the resource corresponding to this VM in the billing system.
         * This value corresponds to HubsExtension.Azure.Pricing.FirstPartyResource.resourceId.
         */
        resourceId: string;
        /**
         * This is the quantity of the resource which should be used when estimating the resource's
         * cost using the getSpecsCosts RPC. This value corresponds to
         * HubsExtension.Azure.Pricing.FirstPartyResource.quantity.
         */
        quantity: number;
    }
    /**
     * Enumerates the operating systems on which an Azure VM may run.
     */
    enum FirstPartyOperatingSystem {
        Windows = 0,
        Linux = 1
    }
    /**
     * The type of the result returned by the parameter provider in PCLegalTermsV2Blade.
     */
    interface LegalTermsAcceptanceResult {
        /**
         * True if the user consented to the legal terms displayed, and false if the user closed the legal terms
         * blade without consenting.
         */
        isAccepted: boolean;
    }
    /**
     * Pricing tier selection model.
     */
    interface PricingTierSelection {
        /**
         * The spec resource set.
         */
        specResourceSet: SpecResourceSet;
        /**
         * The specs allowed to have zero as a possible cost amount.
         */
        specsToAllowZeroCost: string[];
    }
    /**
     * Data contract for a resource quota set.
     */
    interface SpecResourceSet {
        /**
         * The spec id.
         */
        id: string;
        /**
         * The third party quotas.
         */
        thirdParty?: ThirdPartyResource[];
    }
    /**
     * Data contract for a third party resource.
     */
    interface ThirdPartyResource {
        /**
         * The round-tripped Id.
         */
        id?: string;
        /**
         * The resource publisher Id.
         */
        publisherId: string;
        /**
         * The resource offer Id.
         */
        offerId: string;
        /**
         * The resource offer display name.
         */
        offerDisplayName: string;
        /**
         * The resource plan Id.
         */
        planId: string;
        /**
         * The promotion code.
         */
        promotionCode: string;
        /**
         * The third party meters.
         */
        meters: ThirdPartyMeter[];
    }
    /**
     * Data contract for a third party meter.
     */
    interface ThirdPartyMeter {
        /**
         * The meter ID
         */
        meterId: string;
        /**
         * The meter Name
         */
        meterDisplayName: string;
        /**
         * The meter quantity
         */
        quantity: number;
    }
    /**
     * Used to retrieve the product (offer) information from the gallery.
     */
    interface Product {
        /**
         * Publisher id for the product.
         */
        publisherId: string;
        /**
         * Offer id for the product.
         */
        offerId: string;
        /**
         * Plan id for the product.
         */
        planId: string;
    }
    /**
     * Used in cases where a real gallery product doesn't exists
     * but still product information needs to be shown in the legal terms page.
     */
    interface InlineProductDescription {
        /**
         * Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Offer display name.
         */
        offerDisplayName: string;
        /**
         * Tells if the product has a free trial.
         */
        hasFreeTrial: boolean;
        /**
         * Tells if the product requires an external license.
         */
        requiresExternalLicense: boolean;
        /**
         * The legal terms HTML.
         */
        legalTerms: string;
        /**
         * The privacy policy HTML.
         */
        privacyPolicy: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
    }
    /**
     * Input data used by the LegalTermsSubscriptionProgrammaticAccessBlade blade.
     */
    interface SubscriptionProgrammaticAccessDataModel {
        /**
         * Subscription Id.
         */
        subscriptionId: string;
    }
    /**
     * Input data used by the LegalTermsSkuProgrammaticAccessBlade blade.
     */
    interface SkuProgrammaticAccessDataModel {
        /**
         * A gallery product.
         */
        product: Product;
    }
    /**
     * Used to switch the legal terms language in the LegalTermsV2 blade.
     */
    enum LegalTermsLanguageEnum {
        /**
         * Displays the default legal text which applies to single-VM products
         * and dev services.
         */
        Default = 0,
        /**
         * Displays the legal text which applies to solution templates (i.e. multi-VM offers) and
         * custom ARM templates (i.e. via the Template Deployment gallery item).
         */
        TemplateDeployment = 1,
        /**
         * Displays the legal text which applies when enabling / disabling programmatic access to deploy a product.
         * Only the LegalTermsSkuProgrammaticAccessBlade should pass this value.
         */
        ProgrammaticAccess = 3
    }
}

// FILE: MsPortalFx\Azure\Locations.d.ts
declare module FxImpl.Azure {
    import FxAzure = MsPortalFx.Azure;
    import FxRpc = FxImpl.Rpc;
    /**
     * The inputs to the getLocationsForCreateEndPoint function definition.
     */
    interface GetLocationsForCreateEndPointArgs {
        /**
         * The subscription id.
         */
        subscriptionId?: string;
        /**
         * The scope at which to get locations.
         */
        scope?: string;
        /**
         * The list of resource types.
         */
        resourceTypes?: string[];
    }
    /**
     * Internal RPC endpoint to get the display names for locations.
     * This is now implemented in the 'FxInternal/ResourceManagement/LocationsCore' module and set prior to loading this containing script.
     */
    const getLocationDisplayNamesEndPoint: typeof import("FxInternal/ResourceManagement/LocationsCore").getLocationDisplayNamesEndPoint;
    /**
     * Internal RPC endpoint to get locations for create.
     */
    const getLocationsAndResourceTypesForCreate: FxRpc.FuncEndPointDefinition<GetLocationsForCreateEndPointArgs, {
        locations: readonly FxAzure.Location[];
        resourceTypeApis: StringMap<string[]>;
    }>;
    /**
     * Internal RPC endpoint to get locations.
     */
    const getLocationsEndPoint: FxRpc.FuncEndPointDefinition<void, FxAzure.Location[]>;
    /**
     * The user settings key to store the list of last used locations in deployments.
     */
    const lastUsedLocationsKey: `deployments_lastUsed_locations`;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @param args Inputs required by the RPC endpoint.
     * @returns A promise that resolves with a list of locations.
     */
    function getLocationsForCreate(rpcClient: FxRpc.Client, args: GetLocationsForCreateEndPointArgs): Promise<{
        locations: readonly FxAzure.Location[];
        resourceTypeApis: StringMap<string[]>;
    }>;
    /**
     * Returns the list of locations as a dictionary.
     *
     * @param rpcClient The RPC client.
     * @returns A promise that resolves with a dictionary of location ids mapped to display names.
     */
    function getLocationDisplayNames(rpcClient: FxRpc.Client): Promise<StringMap<string>>;
    /**
     * Returns a sorted list of the most recently used locations in create.
     *
     * @param rpcClient The RPC client.
     * @returns A promise that resolves with a sorted list of the most recently used locations in create.
     */
    function getLastUsedLocations(rpcClient: FxRpc.Client): Promise<string[]>;
    /**
     * Locations comparer for sorting (uses display name).
     *
     * @param locA Location A.
     * @param locB Location B.
     * @returns Comparison result.
     */
    function locationsComparer(locA: FxAzure.Location, locB: FxAzure.Location): number;
}
declare module MsPortalFx.Azure {
    /**
     * Returns the list of locations as a dictionary.
     *
     * @returns A promise that resolves to a dictionary of locations.
     */
    function getLocations(): Promise<StringMap<string>>;
    /**
     * The enum for which recommended group a location should appear in
     */
    const enum RegionSegment {
        /**
         * Service Provided
         */
        ServiceProvided = "ServiceProvided",
        /**
         * The first group and largest type of locations with the most resource types supported.
         */
        Recommended = "Recommended",
        /**
         * Other locations including RP specific locations
         */
        Other = "Other"
    }
    /**
     * The interface interface for edge locations' metadata
     */
    interface EdgeLocationMetadata {
        /**
         * The home location of the edge location.
         */
        homeLocation: string;
    }
    /**
     * Data contract for metadata on Logical Locations
     */
    interface LogicalLocationMetadata {
        /**
         * The geography group of the location.
         */
        geographyGroup?: string;
    }
    /**
     * Data contract for metadata on Manifest Locations
     */
    interface ManifestLocationMetadata {
        /**
         * The geography group of the location.
         */
        geographyGroup?: string;
    }
    /**
     * Data contract for metadata on Physical Locations
     */
    interface PhysicalLocationMetadata {
        /**
         * The geography group of the location.
         */
        geographyGroup?: string;
        /**
         * The physical location of the location.
         */
        physicalLocation?: string;
        /**
         * The paired region of the location.
         */
        pairedRegion?: {
            /**
             * The normalized name of the paired location.
             */
            name: string;
            /**
             * The id of the paired location.
             */
            id: string;
        }[];
    }
    /**
     * Data contract for metadata of a single location.
     */
    interface LocationMetadata {
        /**
         * The region type of the location.
         */
        regionType: "Logical" | "Manifest" | "Physical";
        /**
         * The region category of the location.
         */
        regionCategory: keyof typeof RegionSegment;
        /**
         * The latitude of the location.
         */
        latitude?: number | string;
        /**
         * The longitude of the location.
         */
        longitude?: number | string;
    }
    /**
     * The interface interface for region locations' metadata
     * 'metadata.regionType' will determine which interface is returned from ARM
     * If 'metadata.regionType' is "Physical", then 'metadata' can be casted to type 'PhysicalLocationMetadata'.
     * If 'metadata.regionType' is "Logical", then 'metadata' can be casted to type 'LogicalLocationMetadata'.
     * If 'metadata.regionType' is "Manifest", then 'metadata' can be casted to type 'ManifestLocationMetadata'.
     */
    type RegionLocationMetadata = LocationMetadata & Partial<PhysicalLocationMetadata> & Partial<LogicalLocationMetadata> & Partial<ManifestLocationMetadata>;
    /**
     * The interface interface for EdgeZone locations' metadata
     * 'metadata.regionType' will determine which interface is returned from ARM
     * If 'metadata.regionType' is "Physical", then 'metadata' can be casted to type 'EdgeLocationMetadata'.
     */
    type EdgeZoneLocationMetadata = LocationMetadata & Partial<EdgeLocationMetadata>;
    /**
     * Data contract for a single location.
     */
    interface Location {
        /**
         * The display name of the location.
         */
        displayName: string;
        /**
         * The normalized name of the location.
         */
        name: string;
        /**
         * The fully qualified ID of the location.
         */
        id?: string;
        /**
         * The display name with the Region included
         */
        regionalDisplayName?: string;
        /**
         * Metadata about the location
         * 'type' will determine which interface is returned from ARM
         * If 'type' is "Region", then 'metadata can be casted to type 'RegionLocationMetadata'.
         * If 'type' is "EdgeZone", then 'metadata can be casted to type 'EdgeZoneLocationMetadata'.
         */
        metadata?: EdgeZoneLocationMetadata & RegionLocationMetadata;
        /**
         * The type of the location
         */
        type?: "EdgeZone" | "Region";
    }
}

// FILE: MsPortalFx\Azure\ResourceFilter.d.ts
declare module MsPortalFx.Internal {
    /**
     * The options to create the resource filter control.
     */
    interface ResourceFilterOptions extends MsPortalFx.Azure.ResourceFilter.Options {
        /**
         * Indicates whether the changes made to the subscription filter are persistent or not.
         */
        isPersistentSubscriptionFilter: boolean;
        /**
         * Indicates whether the subscription dropdown is open and can be used to toggle the state of the dropdown.
         */
        isSubscriptionPopupOpen?: KnockoutObservable<boolean>;
        /**
         * if set, all subscriptions will be shown in the subscription dropdown.
         */
        showAllSubscriptions?: boolean;
        /**
         * Value indicating whether to show the directory dropdown.
         */
        showDirectoryFilter?: boolean;
        /**
         * Indicates whether to update the selected subscriptions( which in case is the list of selected subscriptions in the portal and not the subsription dropdown value) when user clicks on the apply button on the browse dialog pill and not on the subscription dropdown popup close.
         * This is used specifically for Browse scenarios which use dialog pill control for subscriptions.
         */
        deferSelectedSubscriptionsUpdate?: boolean;
        /**
         * if set, the control will be placed inside of a section built using the provided options
         */
        sectionOptions?: {
            /**
             * The name of the section.
             * This will be displayed as a tab header if the section is inside a tab control.
             */
            name?: string;
            /**
             * The disabled state of the control.
             */
            disabled?: boolean | KnockoutObservableBase<boolean>;
            /**
             * The width of the left label in px.
             * Setting this property implies leftLabelPosition = true.
             */
            leftLabelWidth?: number;
            /**
             * A custom css class to apply to the control.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * The visible state of the control.
             */
            visible?: boolean | KnockoutObservableBase<boolean>;
            /**
             * Align labels by available size of the blade. (left or above the control).
             */
            smartAlignLabel?: boolean;
        };
    }
}
declare module MsPortalFx.Azure {
    import FxAssets = MsPortalFx.Assets;
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * The resource filter control.
     */
    module ResourceFilter {
        /**
         * The options to create resource filter control.
         */
        interface Options {
            /**
             * Value indicating whether to show the filter text box.
             */
            showTextFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the resource type drop down.
             */
            showTypeFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription drop down.
             */
            showSubscriptionFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the resource groups drop down.
             */
            showResourceGroupFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription drop down.
             */
            showLocationFilter?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary.
             */
            showSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Value indicating whether to show the subscription summary as tenant-level.
             */
            showTenantLevelSubscriptionSummary?: KnockoutObservableBase<boolean>;
            /**
             * Optional value for selected subscription id.
             */
            selectedSubscriptionId?: KnockoutObservableBase<string>;
            /**
             * Optional value for text filter place holder.
             */
            textFilterPlaceholder?: KnockoutObservableBase<string>;
            /**
             * Optional value for asset types for type filter. This is needed for merged asset types.
             */
            assetTypes?: KnockoutObservableArray<FxAssets.ResourceTypeAssetTypeInformation>;
            /**
             * The telemetry context of the control e.g. extension/shell
             */
            context?: KnockoutObservableBase<string>;
            /**
             * The flag indicates whether the control should auto-select all resource groups, defaults to true.
             * When set to false, the control will update the RG list but keep selection intact.
             */
            autoSelectAllResourceGroups?: KnockoutObservableBase<boolean>;
        }
        /**
         * The view model for resource filter control.
         */
        class ViewModel extends FxViewModels.Controls.Base.ViewModel implements Options {
            showTextFilter: KnockoutObservableBase<boolean>;
            showTypeFilter: KnockoutObservableBase<boolean>;
            showSubscriptionFilter: KnockoutObservableBase<boolean>;
            showResourceGroupFilter: KnockoutObservableBase<boolean>;
            showLocationFilter: KnockoutObservableBase<boolean>;
            /**
             * The value indicating whether subscriptions are filtered or not.
             */
            subscriptionsFiltered: KnockoutObservable<boolean>;
            /**
             * The See interface.
             */
            showSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The See interface.
             */
            showTenantLevelSubscriptionSummary: KnockoutObservableBase<boolean>;
            /**
             * The list of selected resource types.
             */
            selectedTypes: KnockoutObservable<string[]>;
            /**
             * The list of selected subscriptions.
             */
            selectedSubscriptions: KnockoutObservable<ReadonlyArray<MsPortalFx.Azure.Subscription>>;
            /**
             * The list of selected resource groups.
             */
            selectedResourceGroups: KnockoutObservable<string[]>;
            /**
             * The flag indicating whether to use ne or eq operator while quering for resource groups.
             * This is to avoid hitting ARM query limit when user has more than 200 resource groups.
             */
            invertResourceGroupFilter: KnockoutObservable<boolean>;
            autoSelectAllResourceGroups: KnockoutObservableBase<boolean>;
            /**
             * The list of selected subscriptions.
             */
            selectedLocations: KnockoutObservable<string[]>;
            /**
             * The text filter value.
             */
            filterText: KnockoutObservable<string>;
            selectedSubscriptionId: KnockoutObservableBase<string>;
            textFilterPlaceholder: KnockoutObservableBase<string>;
            assetTypes: KnockoutObservableArray<FxAssets.ResourceTypeAssetTypeInformation>;
            context: KnockoutObservableBase<string>;
            /**
             * A flag to determine whether or not the selected subscriptions are loaded and valid.
             * This is initially false, but will be set to true after all subscriptions are retrieved and the selected subscriptions collection is set as a result.
             */
            subscriptionsLoaded: KnockoutReadOnlyObservable<boolean>;
            private _msPortalFxSectionOptions;
            /**
             * A flag to indicate whether the subscription selection changes made to a specific
             * subscription filter control must be saved to the subscription settings.
             * Note: Any value supplied here is used only when the 'showSubscriptionsFilter' property is supplied as 'true'.
             */
            isPersistentSubscriptionFilter?: boolean;
            /**
             * Indicates whether the subscription dropdown is open and can be used to toggle the state of the dropdown.
             */
            isSubscriptionPopupOpen: KnockoutObservable<boolean>;
            /**
             * If set, all subscriptions will be shown in the subscription dropdown.
             * Note: Any value supplied here is used only when the 'showSubscriptionsFilter' property is supplied as 'true'.
             */
            showAllSubscriptions?: boolean;
            /**
             * Value indicating whether to show the directory dropdown.
             */
            showDirectoryFilter: boolean;
            /**
             * Indicates whether to update the selected subscriptions on the specific action and not on the subscription dropdown popup close.
             * This is used specifically for Browse scenarios which use dialog pill control for subscriptions.
             */
            deferSelectedSubscriptionsUpdate?: boolean;
            /**
             * Constructs a resource filter view model.
             *
             * @param lifetimeManager Lifetime manager for this view model.
             * @param options The options for the resource filter view model.
             */
            constructor(container: FxBase.LifetimeManager, options?: Options | MsPortalFx.Internal.ResourceFilterOptions);
        }
    }
}

// FILE: MsPortalFx\Azure\ResourceGroups.d.ts
declare module FxImpl.Azure {
    import FxRpc = FxImpl.Rpc;
    import ResourceGroup = MsPortalFx.Azure.ResourceGroup;
    interface GetResourceGroupsFromSubscriptionArgs {
        subscriptionIds: string[];
        uniqueResourceGroups?: boolean;
    }
    /**
     * Internal RPC endpoint to get the resource groups under a list of subscriptions.
     */
    const getResourceGroupsFromSubscriptionEndPoint: FxRpc.FuncEndPointDefinition<GetResourceGroupsFromSubscriptionArgs, ResourceGroup[]>;
    /**
     * Returns the list of resource groups under a list of subscriptions.
     *
     * @param rpcClient The RPC client.
     * @param subscriptionIds The list of subscription ids.
     * @returns A promise that resolves to the list of resource groups.
     */
    function getResourceGroupsFromSubscription(rpcClient: FxRpc.Client, subscriptionIds: string[], uniqueResourceGroups?: boolean): Promise<ResourceGroup[]>;
}
declare module MsPortalFx.Azure {
    /**
     * Data contract for a single resource group.
     */
    interface ResourceGroup {
        /**
         * Resource group location.
         */
        location: string;
        /**
         * Resource group name.
         */
        name: string;
        /**
         * Resource group provisioning state.
         */
        provisioningState?: string;
        /**
         * The resource id of the resource group. e.g. /subscriptions/123/resourceGroups/${this.name}
         * Available with the fx resource group dropdown.
         */
        resourceId?: string;
    }
    module ResourceGroups {
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * The mode of the dropdown
         */
        enum Mode {
            UseExisting = 0,
            CreateNew = 1
        }
        /**
         * The allowed mode of the dropdown
         */
        enum AllowedMode {
            UseExisting = 0,
            CreateNew = 1,
            Both = 2
        }
        /**
         * The max number of characters allowed for a resource group name.
         */
        const NameMaxLength = 90;
        module Internal {
            /**
             * Validates a resource group name. If a subscription is provided, the function will check if
             * a resource group with that name exists for the given subscription.
             *
             * @param resourceGroupName The resource group name.
             * @param subscription The subscription
             * @param existingResourceGroups An optional array of resource groups to do an existence check
             * @param existenceCheckCallback An optional async callback to get existing resource groups
             * @returns The ValidationResult object.
             */
            function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<Promise<FxViewModels.ValidationResult>>, hasPermissions?: Promise<FxViewModels.ValidationResult>): Promise<FxViewModels.ValidationResult>;
        }
        /**
         * Validates a resource group name. If a subscription is provided, the function will check if
         * a resource group with that name exists for the given subscription.
         *
         * @param resourceGroupName The resource group name.
         * @param subscriptionId The subscription
         * @param existingResourceGroups An optional array of resource groups to do an existence check
         * @param existenceCheckCallback An optional async callback to get existing resource groups
         * @returns The ValidationResult object.
         */
        function validateResourceGroupName(resourceGroupName: string, subscriptionId: string, existingResourceGroups?: string[], existenceCheckCallback?: Func<Promise<FxViewModels.ValidationResult>>, hasPermissions?: Promise<FxViewModels.ValidationResult>): Promise<FxViewModels.ValidationResult>;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager {
    import Gallery = Services.Gallery;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxPropertiesPart = FxViewModels.Parts.Properties;
    /**
     * The Gallery-create configuration options.
     */
    interface GalleryCreateOptions {
        /**
         * Gallery item information extracted from the gallery item and passed over to the extension.
         */
        galleryItem: GalleryItemExtract;
        /**
         * The context in which the gallery item was launched.
         */
        launchingContext: LaunchingContext;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The subscription display name.
         */
        subscriptionDisplayName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * The resource group location display name.
         */
        resourceGroupLocationDisplayName?: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The list of URIs for the CSM template files.
         */
        deploymentTemplateFileUris: StringMap<string>;
        /**
         * The list of URIs for the deployment fragments.
         */
        deploymentFragmentFileUris?: StringMap<string>;
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     */
    interface GalleryItemExtract {
        /**
         * The identity of the gallery item.
         */
        id: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * Gallery item products.
         */
        products: GalleryItemProduct[];
        /**
         * Gallery item products with no pricing information.
         */
        productsWithNoPricing: GalleryItemProduct[];
        /**
         * The absolute URI of the medium icon for the Marketplace item.
         */
        mediumIconUri?: string;
        /**
         * The item additional artifacts.
         */
        specialArtifacts?: Gallery.Artifact[];
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
        /**
         * The privateStore property to to be used to check if privateStore is enabled or not.
         */
        isPrivateStore?: boolean;
    }
    /**
     * Gallery product (offer) model.
     */
    interface GalleryItemProduct {
        /**
         * The product (offer) display name.
         */
        displayName: string;
        /**
         * The publisher display name.
         */
        publisherDisplayName: string;
        /**
         * The uri to the legal terms HTML.
         */
        legalTermsUri: string;
        /**
         * The uri to the privacy policy HTML.
         */
        privacyPolicyUri: string;
        /**
         * The other pricing details URI.
         */
        pricingDetailsUri: string;
        /**
         * The pricing details. Optional.
         * If the product doesn't contain pricing details, then we won't fetch pricing information
         * for it.
         */
        offerDetails?: GalleryItemOfferPricingDetails;
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     */
    interface GalleryItemOfferPricingDetails {
        /**
         * The offer id.
         */
        offerId: string;
        /**
         * The publisher id.
         */
        publisherId: string;
        /**
         * The offer plans provided by the publisher.
         */
        plans: GalleryItemOfferPlan[];
    }
    /**
     * Gallery offer plan.
     */
    interface GalleryItemOfferPlan {
        /**
         * The plan id.
         */
        planId: string;
        /**
         * The plan display name.
         */
        displayName: string;
        /**
         * The summary text for the plan.
         */
        summary: string;
        /**
         * The description HTML for the plan.
         */
        description: string;
        /**
         * The plan labels
         */
        planLabels?: string[];
    }
    /**
     * The context from which a gallery create is kicked off.
     */
    interface LaunchingContext extends StringMap<any> {
        /**
         * The gallery item id.
         */
        galleryItemId: string;
        /**
         * The source entity launching the create flow (blade name, control, etc.). Used for telemetry logging.
         */
        source: string[];
        /**
         * The gallery menu item id.
         */
        menuItemId?: string;
        /**
         * The gallery sub menu item id.
         */
        subMenuItemId?: string;
        /**
         * The gallery item index from the source grid.
         */
        itemIndex?: number;
        /**
         * Unique id for tracking a deployment.
         */
        telemetryId?: string;
        /**
         * Extension version.
         */
        extVersion?: string;
        /**
         * The name of the create blade.
         */
        createBlade?: string;
        /**
         * Indicates if this is a create flow that uses the PCv1/v2 API.
         */
        oldCreateApi?: boolean;
        /**
         * The blade instance id.
         */
        bladeInstanceId?: string;
    }
    /**
     * Represents types of resource move operations supported in the system.
     */
    const enum MoveType {
        /**
         * Move resources across subscriptions and resource groups excluding current subscription.
         */
        Subscription = 0,
        /**
         * Move resources across resource groups only.
         */
        ResourceGroup = 1,
        /**
         * Move resources across subscriptions and resource groups including current subscription.
         */
        SubscriptionAndResourceGroup = 3,
        /**
         * Move resource is not supported.
         */
        None = 4
    }
    /**
     * Returns the move resource blade for editing resource group/subscription properties.
     *
     * @param resourceId resource Id of the resource to be moved.
     * @param moveType supported move types by the resource RP.
     * @returns An edit blade for the moving resources across subscriptions/resource groups.
     */
    function getMoveResourceBlade(resourceId: string, moveType: MoveType): FxPropertiesPart.OpenBlade;
    module Internal {
        /**
         * Indicates a gallery item create availability.
         */
        enum GalleryItemAccess {
            /**
             * If the access is not set it means the default rules should be followed.
             */
            NotSet = 0,
            /**
             * This means the item was curated to be allowed regardless of categories.
             * For example in the case of dream spark an item may be allowed if specified in the curation.
             */
            Allowed = 1,
            /**
             * This means the item was curated to not be allowed.
             */
            NotAllowed = 2
        }
        /**
         * Galley item with extended options used by the create flow.
         */
        interface ExtendedGalleryItem extends Gallery.GalleryItem {
            /**
             * Represents a value indicating if an item is allowed or not by the subscription quota according to the curation.
             */
            galleryItemAccess?: GalleryItemAccess;
        }
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Deployments.d.ts
declare module FxImpl.Azure.ResourceManager {
    import RpcCore = FxImpl.Rpc;
    /**
     * The max number of items tracked in the list of last deployed gallery items in user settings.
     */
    let lastDeployedGalleryItemsMaxCount: number;
    /**
     * The max number of locations tracked in the list of last used locations in user settings.
     */
    let lastUsedLocationsMaxCount: number;
    /**
     * Internal RPC endpoint to read uset settings from HubsExtension.
     */
    const readUserSettingsEndPoint: RpcCore.FuncEndPointDefinition<string[], StringMap<any>>;
}
declare module MsPortalFx.Azure.ResourceManager {
    /**
     * The deployment stages.
     */
    enum DeploymentStages {
        /**
         * Initial set up of the template deployment options.
         */
        InitialSetup = 0,
        /**
         * Sanity check for the template deployment options.
         */
        SanityCheck = 1,
        /**
         * Fulfills the prerequisites for a deployment (provisioning a resource group, registering the
         * resource providers, and getting a deployment name).
         */
        FulfillPrerequisites = 2,
        /**
         * Makes sure the resource group exists, and creates one otherwise.
         */
        ProvisionResourceGroup = 3,
        /**
         * Registers the resource providers with the subscription.
         */
        RegisterResourceProviders = 4,
        /**
         * Gets a valid deployment name.
         */
        GetDeploymentName = 5,
        /**
         * Validate a deployment template using ARM's preflight validation API.
         */
        ValidateTemplate = 6,
        /**
         * Submits a deployment request to ARM.
         */
        SubmitDeploymentRequest = 7,
        /**
         * Gets the deployment status from ARM (polling).
         */
        GetDeploymentStatus = 8
    }
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    module DeploymentStates {
        /**
         * Deployment accepted.
         */
        const Accepted = "accepted";
        /**
         * Deployment initialized.
         */
        const Initializing = "initializing";
        /**
         * Deployment succeeded.
         */
        const Succeeded = "succeeded";
        /**
         * Deployment failed.
         */
        const Failed = "failed";
        /**
         * Deployment canceled.
         */
        const Canceled = "canceled";
        /**
         * Deployment running.
         */
        const Running = "running";
        /**
         * Deployment deploying.
         */
        const Deploying = "deploying";
        /**
         * Deployment waiting.
         */
        const Waiting = "waiting";
        /**
         * Deployment deleting.
         */
        const Deleting = "deleting";
        /**
         * Deployment deleted.
         */
        const Deleted = "deleted";
    }
    /**
     * ARM template deployment API arguments.
     */
    interface DeploymentApiArgs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The management group id.
         */
        managementGroupId?: string;
        /**
         * The deployment name.
         */
        deploymentName: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The resource id. Supply this to link the notifications to the asset or if the deployment
         * results in a startboard part.
         */
        resourceId?: string;
        /**
         * The asset type associated with the deployment. Used to customize the post-deployment experience.
         */
        readonly assetType?: string;
        /**
         * The context from which a gallery create is kicked off. Used for telemetry logging.
         */
        launchingContext?: LaunchingContext;
        /**
         * Debug info.
         */
        debug?: string;
        /**
         * A key or hash that encodes or corresponds to information about a provisioning request.
         * This must be a valid resource tag value to persist across sessions.
         * View the tag value rules at https://go.microsoft.com/fwlink/?LinkID=2097613.
         */
        provisioningHash?: string;
    }
    /**
     * The link to the ARM template. Specify this or the templateJson property, but not both.
     */
    interface TemplateLink {
        /**
         * The URI of the template to deploy. Use either the uri or id property, but not both.
         */
        uri?: string;
        /**
         * The resource id of a Template Spec. Use either the id or uri property, but not both.
         */
        id?: string;
        /**
         * Applicable only if this template link references a Template Spec.
         * This relativePath property can optionally be used to reference a
         * Template Spec artifact by path.
         */
        relativePath?: string;
    }
    /**
     * ARM template deployment options.
     */
    interface TemplateDeploymentOptions extends DeploymentApiArgs {
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource providers to be registered for the subscription.
         */
        resourceProviders: string[];
        /**
         * The parameters for the template deployment (name and value pairs).
         */
        parameters?: StringMap<string | number | boolean | Object>;
        /**
         * The reference parameters for the template deployment.
         */
        referenceParameters?: StringMap<Object>;
        /**
         * The URI for the parameters file. Use this to link to an existing parameters file. Specify
         * this or the parameters and/or referenceParameters properties, but not both.
         */
        parametersLinkUri?: string;
        /**
         * The URI for the ARM template. Specify this or the templateJson property, but not both.
         * will soon be deprecated use templateLink.uri
         */
        templateLinkUri?: string;
        /**
         * The link to the ARM template. Specify this or the templateJson property, but not both.
         */
        templateLink?: TemplateLink;
        /**
         * The inline deployment template JSON. Specify this or the templateLinkUri property, but not both.
         */
        templateJson?: string;
        /**
         * Flag indicating whether to suppress default deployment notifications or not. Defaults to
         * false. This applies only to intermediate local notifications (initialization, submitting
         * the deployment, and starting the deployment). Success and failures will still show as they
         * arrive from the events service.
         */
        suppressDefaultNotifications?: boolean;
        /**
         * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
         */
        deploymentMode?: TemplateDeploymentMode;
        /**
         * Flag indicating that we should run ARM's preflight validation before submitting the template
         * deployment request to ARM. Defaults to false.
         */
        validateTemplate?: boolean;
        /**
         * ARM template validation result.
         */
        validationResult?: TemplateValidationResponse;
    }
    /**
     * ARM template deployment polling options.
     */
    interface TemplateDeploymentPollingOptions extends DeploymentApiArgs {
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * Report all ARM operations as progress. Defaults to false.
         */
        getAllOperations?: boolean;
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp: Date;
    }
    /**
     * ARM template deployment result.
     */
    interface TemplateDeploymentResult extends DeploymentApiArgs {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: Common.DeploymentStatusCode;
        /**
         * The correlation id (aka tracking id).
         */
        correlationId: string;
        /**
         * The provisioning state.
         */
        provisioningState: string;
        /**
         * The timestamp when the operation was completed.
         */
        timestamp: Date;
        /**
         * The list of deployment operations.
         */
        operations?: TemplateDeploymentOperation[];
        /**
         * Timestamp when the deployment request was initiated.
         */
        requestTimestamp?: Date;
    }
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperation = Common.TemplateDeploymentOperation;
    /**
     * ARM template deployment operation.
     */
    export import TemplateDeploymentOperationProperties = Common.TemplateDeploymentOperationProperties;
    /**
     * ARM template deployment error.
     */
    interface TemplateDeploymentError extends FxImpl.Azure.SimplifiedError {
        /**
         * The deployment status code.
         */
        deploymentStatusCode: DeploymentStatusCode;
        /**
         * The ARM template deployment options used in the deployment operation.
         */
        templateDeploymentOptions: TemplateDeploymentOptions;
        /**
         * The correlation id.
         */
        correlationId?: string;
        /**
         * Timestamp when the last notification was published.
         */
        notificationTimestamp: Date;
    }
    /**
     * The ARM template.
     */
    interface DeploymentTemplate {
        /**
         * The template schema URI.
         */
        $schema: string;
        /**
         * The content version for the template.
         */
        contentVersion: string;
        /**
         * The template parameters.
         */
        parameters?: StringMap<TemplateParameter>;
        /**
         * The template variables.
         */
        variables?: StringMap<string>;
        /**
         * The template resources.
         */
        resources: TemplateResource[];
        /**
         * The template outputs.
         */
        outputs?: StringMap<TemplateOutput>;
    }
    /**
     * The template output.
     */
    export import TemplateOutput = Common.TemplateOutput;
    /**
     * The template parameter.
     */
    interface TemplateParameter {
        /**
         * The parameter type.
         */
        type: string;
        /**
         * The list of allowed values for the parameter.
         */
        allowedValues?: any[];
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The parameter metadata.
         */
        metadata?: TemplateParameterMetadata;
        /**
         * The minimum value for the parameter.
         */
        minValue?: number;
        /**
         * The max value for the parameter.
         */
        maxValue?: number;
        /**
         * The minimum lenght for the parameter.
         */
        minLength?: number;
        /**
         * The max length for the parameter.
         */
        maxLength?: number;
    }
    /**
     * The template paramteter metadata.
     */
    interface TemplateParameterMetadata {
        /**
         * The description for the parameter shown in an infoballoon.
         */
        description?: string;
        /**
         * The description for the parameter shown in an infoballoon.
         */
        Description?: string;
        /**
         * The display text for the parameter.
         */
        label?: string;
        /**
         * Sublabel for the parameter.
         */
        sublabel?: string;
        /**
         * The parameter group. Allows parameters to be grouped on the form.
         * If set to 'BasicGroup', the parameter will be added above sub/rg/location dropdowns
         */
        group?: string;
    }
    /**
     * The template resource.
     */
    export import TemplateResource = Common.TemplateResource;
    /**
     * The response that ARM returns when a template validate call succeeds.
     */
    export import TemplateValidationResponse = Common.TemplateValidationResponse;
    /**
     * ARM template validation result.
     */
    interface TemplateValidationError {
        /**
         * The error code.
         */
        code: DeploymentStatusCode;
        /**
         * The error message.
         */
        message: string;
        /**
         * The error object.
         */
        error?: any;
        /**
         * The error status.
         */
        status?: number;
    }
    /**
     * The template deployment operation mode. Defaults to 'RequestDeploymentOnly'.
     */
    export import TemplateDeploymentMode = Common.TemplateDeploymentMode;
    /**
     * The deployment status codes.
     */
    enum DeploymentStatusCode {
        /**
         * Template preflight, validation or deployment failure (based on the operation performed).
         */
        Failure = -1,
        /**
         * Deployment was accepted or successful (based on the operation performed).
         */
        Success = 0,
        /**
         * ARM rejected the deployment request.
         */
        DeploymentRequestFailed = 1,
        /**
         * Deployment failed.
         */
        DeploymentFailed = 2,
        /**
         * Deployment status unknown.
         */
        DeploymentStatusUnknown = 3,
        /**
         * An unexpected error occurred while provisioning the resource group.
         */
        ErrorProvisioningResourceGroup = 4,
        /**
         * An unexpected error occurred while submitting the deployment request.
         */
        ErrorSubmittingDeploymentRequest = 5,
        /**
         * An unexpected error occurred while getting the deployment status.
         */
        ErrorGettingDeploymentStatus = 6,
        /**
         * Invalid arguments.
         */
        InvalidArgs = 7,
        /**
         * An unexpected error occurred while registering the resource providers.
         */
        ErrorRegisteringResourceProviders = 8,
        /**
         * Deployment canceled.
         */
        DeploymentCanceled = 9,
        /**
         * Unknown error.
         */
        UnknownError = 10
    }
    /**
     * Deploys an ARM deployment template.
     *
     * @param options The template deployment options.
     * @returns A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function deployTemplate(options: TemplateDeploymentOptions): Promise<TemplateDeploymentResult>;
    /**
     * Polls for an ARM deployment updates.
     *
     * @param options The template deployment polling options.
     * @returns A promise resolved with the template deployment result, and possibly reports progress
     *      (based on the options).
     */
    function pollForDeployment(options: TemplateDeploymentPollingOptions): Promise<TemplateDeploymentResult>;
    /**
     * Validates an ARM template.
     *
     * @param options The template deployment options.
     * @returns A promise resolved with the template deployment result.
     */
    function validateTemplate(options: TemplateDeploymentOptions): Promise<TemplateDeploymentOptions>;
    /**
     * The ARM deployments APIs.
     */
    module Deployments {
        /**
         * Deploys an ARM deployment template.
         *
         * NOTE: The returned promise will resolve with the template deployment result when it succeeds.
         * If deployment failed, the promise will be rejected with a template deployment error (expected
         * failure) or an unexpected failure.
         *
         * @param options The template deployment options.
         * @returns A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function deployTemplate(options: TemplateDeploymentOptions): Promise<TemplateDeploymentResult>;
        /**
         * Polls for an ARM deployment updates.
         *
         * NOTE: The returned promise will resolve with the template deployment result when it succeeds.
         * If deployment failed, the promise will be rejected with a template deployment error (expected
         * failure) or an unexpected failure.
         *
         * @param options The template deployment polling options.
         * @returns A promise resolved with the template deployment result, and possibly reports progress
         *      (based on the options).
         */
        function pollForDeployment(options: TemplateDeploymentPollingOptions): Promise<TemplateDeploymentResult>;
        /**
         * Validates an ARM template.
         *
         * @param options The template deployment options.
         * @returns A promise with the template validation result.
         */
        function validateTemplate(options: TemplateDeploymentOptions): Promise<TemplateDeploymentOptions>;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\LocationPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Location {
    /**
     * The data model used by the location picker.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
     */
    interface DataModel {
        /**
         * The display name of the location.
         */
        displayName: KnockoutObservableBase<string>;
        /**
         * The normalized name of the location.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The latitude of the location.
         */
        latitude: KnockoutObservableBase<number>;
        /**
         * The longitude of the location.
         */
        longitude: KnockoutObservableBase<number>;
    }
    /**
     * The config used by the location picker.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
     */
    interface Config {
        /**
         * The subscription id used to filter locations.
         */
        subscriptionId: string;
        /**
         * The list of resource types used to filter locations.
         */
        resourceTypes: string[];
        /**
         * Optional, location filters.
         */
        filter?: LocationFilter;
    }
    /**
     * The location filters.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
     */
    interface LocationFilter {
        /**
         * List of allowed locations.
         * Either this or the disallowed locations can be specified.
         */
        allowedLocations?: AllowedLocations;
        /**
         * List of disallowed locations.
         * Either this or the allowed locations can be specified.
         */
        disallowedLocations?: DisallowedLocation[];
    }
    /**
     * The allowed locations.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
     */
    interface AllowedLocations {
        /**
         * The list of allowed location names.
         */
        locationNames: string[];
        /**
         * @deprecated Locations.Dropdown.AllowedLocations.disabledMessage is deprecated http://aka.ms/portalfx/breaking
         * Optional, disabled message to show for the disabled locations.
         */
        disabledMessage?: string;
    }
    /**
     * The disallowed location.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/LocationDropDown";` http://aka.ms/portalfx/breaking
     */
    interface DisallowedLocation {
        /**
         * The location to disable.
         */
        name: string;
        /**
         * Optional, disabled message to show for the disabled location.
         */
        disabledMessage?: string;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\ResourceGroupPicker.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.ResourceGroup {
    /**
     * The data model used by the resource group picker.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/ResourceGroupDropDown";` http://aka.ms/portalfx/breaking
     */
    interface DataModel {
        /**
         * The id of the resource group.
         */
        id: KnockoutObservableBase<string>;
        /**
         * The name of the resource group.
         */
        name: KnockoutObservableBase<string>;
        /**
         * The resource group location.
         */
        location: KnockoutObservableBase<string>;
    }
    /**
     * The config used by the resource group picker.
     *
     * @deprecated MsPortalFx.Azure.Locations.DropDown. Please use `import { create } from "Fx/Controls/ResourceGroupDropDown";` http://aka.ms/portalfx/breaking
     */
    interface Config {
        /**
         * The subscription id used to filter resource groups.
         */
        subscriptionId: string;
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\Specs\Common.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    /**
     * Configuration data for a spec picker blade
     */
    interface InitialData extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromCollector {
    }
    /**
     * Spec data returned from the spec picker blade
     */
    interface Result extends SpecPickerTypes.SpecPickerProviderCollectorParameterFromProvider {
    }
}
declare module FxImpl.Azure.ResourceManager.Pickers.Specs {
    import FxViewModels = MsPortalFx.ViewModels;
    import SpecPicker = MsPortalFx.Azure.ResourceManager.Pickers.Specs;
    import SpecPickerTypes = HubsExtension.Azure.SpecPicker.ParameterCollectionV3;
    import OriginControl = HubsExtension.Azure.SpecPicker.OriginControl;
    /**
     * Options to pass into the CollectorControl
     */
    interface Options {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @returns Initial data for the child blade.
         */
        supplyInitialData(): SpecPicker.InitialData;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         */
        receiveResult?(result: SpecPicker.Result): void;
    }
    /**
     * Base class which interfaces with a spec picker blade.
     */
    class CollectorControl {
        /**
         * ParameterCollector created to interface with the spec picker blade ParameterProvider
         */
        collector: FxViewModels.ParameterCollector<SpecPickerTypes.SpecPickerProviderCollectorParameter>;
        protected controlType: OriginControl;
        /**
         * Constructs a control which launches a spec picker blade and a collector that recieves a spec
         *
         * @param container The container associated with the part or other composition item hosting this parameter collector.
         * @param selectable The selectable associated with the <BladeAction> connected to this Control.
         * @param value The observable to place the Result from the spec picker blade.
         * @param options The options object which contains callbacks for providing initial data and receiving results.
         */
        constructor(container: FxViewModels.ContainerContract, selectable: FxViewModels.Selectable<FxViewModels.DynamicBladeSelection>, value: KnockoutObservableBase<SpecPicker.Result>, options: Options);
    }
}

// FILE: MsPortalFx\Azure\ResourceManager\Pickers\Specs\Selector.d.ts
declare module MsPortalFx.Azure.ResourceManager.Pickers.Specs {
    module Selector {
        /**
         * @deprecated MsPortalFx.Azure.ResourceManager.Pickers.Specs.Selector.Options is no longer a supported navigation/layout model. Use `Fx/Controls/DropDown` instead.
         * @see {@link https://aka.ms/portalfx/breaking} for further information.
         */
        type Options = Obsolete;
    }
    /**
     * MsPortalFx.Azure.ResourceManager.Pickers.Specs.Selector.Options is no longer a supported navigation/layout model. Use `Fx/Controls/DropDown` instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Selector: Obsolete;
}

// FILE: MsPortalFx\Azure\ResourceManager\Provisioner.d.ts
declare module FxImpl.Azure.Provisioner {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ParameterCollection = FxViewModels.ParameterCollectionV3;
    import Pricing = HubsExtension.Azure.Pricing;
    import ProvisioningTelemetry = FxImpl.ProvisioningTelemetry;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    import PartReference = MsPortalFx.Composition.PartReference;
    import TemplateDeploymentOptions = MsPortalFx.Azure.ResourceManager.TemplateDeploymentOptions;
    import TemplateDeploymentResult = MsPortalFx.Azure.ResourceManager.TemplateDeploymentResult;
    import GalleryCreateOptions = MsPortalFx.Azure.ResourceManager.GalleryCreateOptions;
    export let armValidateFeatureForced: boolean;
    export interface UIConfig {
        /**
         * (Optional) Prevents the provisioner from discarding the journey. Defaults to false.
         */
        dontDiscardJourney?: boolean;
        /**
         * Given a resourceId, return a part reference for a dashboard part
         */
        supplyDashboardPartReference?: (resourceId: string) => PartReference<any>;
    }
    interface ProvisioningTelemetry {
        readonly correlationId: string;
        readonly resourceId: string;
        readonly deploymentId: string;
        readonly provisioningState: string;
    }
    /**
     * Internal Provisioner implementation
     */
    export class Provisioner<TData> extends FxImpl.ViewModels.Provisioning.Provisioner<TData> {
        private _diContainer;
        /**
         * The selectable to activate the pricing summary blade.
         */
        pricingSelectable: FxViewModels.Selectable<FxViewModels.DynamicBladeSelection>;
        /**
         * The selectable to activate the ARM errors blade.
         */
        errorsSelectable: FxViewModels.Selectable<FxViewModels.DynamicBladeSelection>;
        readonly deploymentStartedPromise: KnockoutObservable<Promise<ProvisioningTelemetry>>;
        protected _armOptions: Provisioner.Options<TData>;
        protected _deploymentOptions: TemplateDeploymentOptions;
        protected _skipDeploy: boolean;
        private _legalTermsBladeShown;
        private _legalTermsCommitId;
        private _pricingSummaryCommitId;
        private _purchaseInProgress;
        private _showPricingSummary;
        private _showAutomationOptions;
        private _parameterProvider;
        /**
         * Constructs a new instance of an ARM provisioner.
         *
         * @param _diContainer The dependency injection container.
         * @param container The container into which the part containing the provisioner is being placed.
         * @param initialState Initial state of the containing view model.
         * @param options The ARM provisioner options.
         */
        constructor(_diContainer: import("Fx/DependencyInjection").Container, container: FxViewModels.ContainerContract, initialState: any, options: Provisioner.Options<TData>);
        /**
         * The ARM provisioner configuration passed originally from the collector, to the provisioner,
         * to this provisioning part.
         *
         * @returns The ARM provisioner configuration.
         */
        get armProvisioningConfig(): Provisioner.Config;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @returns A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): Promise<any>;
        /**
         * Validates an ARM template.
         *
         * @param templateDeploymentOptions The template deployment options.
         * @returns A promise with the template validation result.
         */
        validateTemplate(templateDeploymentOptions: TemplateDeploymentOptions): Promise<TemplateDeploymentOptions>;
        protected _deployTemplate(templateDeploymentOptions: TemplateDeploymentOptions, container: FxViewModels.ContainerContract): Promise<TemplateDeploymentResult>;
        protected _validateTemplate(templateDeploymentOptions: TemplateDeploymentOptions): Promise<TemplateDeploymentOptions>;
        _supplyProvisioningPromise(data: TData, container: FxViewModels.ContainerContract): Promise<any>;
        private _supplyStartboardInfo;
        private _setUpActionBarValidation;
        private _setActionBarProgress;
        protected _getPinToDashboardArgs(data: TData, templateDeploymentOptions: TemplateDeploymentOptions): FxImpl.Hubs.Notifications.PinToDashboardArgs;
        private _setUpActionBarWatcher;
        private _launchTemplateViewerBlade;
        private _launchPricingSelectable;
        private _getPricingBladeInputs;
        protected _traceProvisioningStarted(): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean): Telemetry.TelemetryEvent;
    }
    export module Provisioner {
        let armValidationTimeout: number;
        /**
         * Azure resource manager provisioning part definition.
         * This is the default part when ARM provisioning is invoked.
         */
        let azureResourceManagerProvisioningPart: ParameterCollection.ExtensionElement;
        /**
         * Interface that defines why the supplyTemplateDeploymentOptions is being called
         */
        const enum GetTemplateDeploymentOptionsMode {
            /**
             * The function is being called to do a create.
             */
            Create = 0,
            /**
             * The function is being called to export the template.
             * No create is being performed.
             */
            ExportTemplate = 1,
            /**
             * The function is being called for validating the options.
             * No create is being performed.
             */
            Validate = 2
        }
        /**
         * ARM provisioning part options.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the template deployment options that will be used in provisioning
             * the deployment of the ARM template.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @param mode The mode for why the function is being called. This function can be
             *      called when a user wants to export the deployment template or when doing an actual create.
             *      Extensions can use the mode for their own logging purposes. The output of the function
             *      *should* not change based on the mode.
             * @returns A promise resolved with the template deployment options.
             */
            supplyTemplateDeploymentOptions: (data: TData, mode: GetTemplateDeploymentOptionsMode) => Promise<TemplateDeploymentOptions>;
            /**
             * A callback that supplies the provisioner with the startboard info (which provisioning part
             * to use, and which startboard part to mutate into). Use this callback if you want to override
             * the startboard part info defined in the UI definition file of the gallery package.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned will be used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @returns A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo?: (data: TData) => any;
            /**
             * A callback that supplies the provisioner with the gallery create config options. This is
             * only required when provisioning is manually triggered (config usually comes from the collector
             * in the automatic trigger case).
             *
             * @returns The gallery create config options.
             */
            supplyGalleryCreateOptions?: () => GalleryCreateOptions;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
            /**
             * The features added to a create experience.
             */
            createFeatures?: CreateFeatures;
            /**
             * A callback that supplies the pricing config required by the pricing summary and/or the
             * legal terms blade. This is required if the 'createFeatures' specifies the
             * 'ShowPricingSummary' and/or 'ShowLegalTerms' flags.
             *
             * @returns The pricing config required by the pricing blades.
             */
            supplyPricingConfig?: () => Provisioner.PricingConfig;
            /**
             * A callback that gets called if ARM validation succeeds.
             * Allows extensions to run additional validations on the ARM response.
             * This is only called if CreateFeatures.EnableArmValidation is set.
             *
             * @param armValidationResult The ARM validation result.
             * @returns A promise that returns a validation result.
             */
            postValidationCallback?: (armValidationResult: any) => Promise<FxViewModels.ValidationResult>;
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface Config extends FxImpl.ViewModels.Provisioning.Provisioner.Config {
            /**
             * Gallery-create config options.
             */
            galleryCreateOptions: GalleryCreateOptions;
        }
        /**
         * The features that can be added to a create experience.
         */
        const enum CreateFeatures {
            /**
             * None (default).
             */
            None = 0,
            /**
             * Shows the pricing summary. This adds a "Pricing summary" link next to the create button
             * on the action bar. Clicking the link launches the pricing summary blade.
             */
            ShowPricingSummary = 1,
            /**
             * Shows the legal terms. This launches the legal terms blade once the create button on
             * the create action bar is clicked. Clicking "Buy" on the legal terms blade will kick
             * off create.
             */
            ShowLegalTerms = 2,
            /**
             * Shows the automation options. This cannot be set if the show pricing summary link is also set.
             * This adds a "Automation options" link next to the create button on the action bar.
             * Clicking the link launches the template viewer blade where users can download
             * automation scripts for creating resources
             */
            ShowAutomationOptions = 4,
            /**
             * Do not show the export template option. If explicity opting out of showing export template, this flag should be set.
             * This removes the "Automation options" link next to the create button on the action bar.
             */
            HideExportTemplate = 8,
            /**
             * Opts out of ARM validation.
             */
            DisableArmValidation = 16,
            /**
             * Opts in for ARM validation.
             */
            EnableArmValidation = 32
        }
        /**
         * The ARM provisioner configuration that a collector can pass to the provider part.
         */
        interface PricingConfig {
            /**
             * A callback to supply the pricing info required by the pricing summary and/or legal terms
             * blades.
             */
            supplyPricingInfo: () => Pricing.PricingInfo;
            /**
             * Optional. A boolean observable that shows/hides the pricing summary link. If not supplied,
             * the pricing summary link will always be visible if the 'createFeatures' on the ARM
             * provisioner options specifies the 'ShowPricingSummary' flags.
             */
            showPricingSummaryLink?: KnockoutObservableBase<boolean>;
        }
    }
    export {};
}
declare module FxImpl.Azure.ResourceManager {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxAzure = FxImpl.Azure;
    import Internal = FxImpl.ViewModels.ParameterCollectionV3;
    import FxProvisioner = FxAzure.Provisioner.Provisioner;
    import ProvisionerOptions = FxProvisioner.Options;
    import ValidationEvent = FxImpl.ViewModels.Provisioning.ValidationEvent;
    /**
     * Internal version of the Provisioner to prevent exposing unnecessary APIs.
     */
    class Provisioner<TData> extends FxProvisioner<TData> implements Internal.Provisioner<TData> {
        constructor(diContainer: import("Fx/DependencyInjection").Container, container: FxViewModels.ContainerContract, initialState: any, options: ProvisionerOptions<TData>);
        /**
         * Trace a validation event.
         *
         * @param eventType event to trace
         */
        traceValidation(eventType: ValidationEvent): void;
    }
}

// FILE: MsPortalFx\Azure\Storage.d.ts
declare module FxImpl {
    import FxRpc = FxImpl.Rpc;
    module InternalAzure {
        /**
         * Internal RPC endpoint to get a sas uri for a storage account's queue.
         */
        const getSasUriForQueueEndPoint: FxRpc.FuncEndPointDefinition<Azure.Storage.GetSasUriForQueueOptions, string>;
    }
    module Azure.Storage {
        /**
         * Bit-wise OR permissions attached to the generated sas token.
         */
        const enum SharedAccessQueuePermissions {
            /**
             * Can do nothing to the storage queue.
             */
            None = 0,
            /**
             * Can read from the storage queue.
             */
            Read = 1,
            /**
             * Can add to the storage queue.
             */
            Add = 2,
            /**
             * Can update the storage queue.
             */
            Update = 4,
            /**
             * Can process messages for the storage queue.
             */
            ProcessMessages = 8
        }
        /**
         * Parameters that must be passed when calling the GetQueueSasUri function.
         */
        interface GetSasUriForQueueOptions {
            /**
             * The shared access expiry time, in seconds.
             */
            durationInSeconds: number;
            /**
             * The permissions for the sas token.
             */
            permissions: SharedAccessQueuePermissions;
            /**
             * The storage account name.
             */
            accountName: string;
            /**
             * The primary key for the storage account.
             */
            accountKey: string;
            /**
             * The name of the storage queue for which a sas token will be generated.
             */
            queueName: string;
        }
        /**
         * Returns a sas token uri for the requested queue.
         *
         * @param args Parameters required by the function.
         * @returns A promise that resolves to the sas uri string.
         */
        function getSasUriForQueue(args: GetSasUriForQueueOptions): Promise<string>;
    }
}
declare module "MsPortalFx/Azure/Storage" {
    import Impl = FxImpl.Azure.Storage;
    export = Impl;
}

// FILE: MsPortalFx\Azure\Subscriptions.d.ts
declare module FxImpl.Azure {
    import FxRpc = FxImpl.Rpc;
    import FxGalleryItem = MsPortalFx.Services.Gallery.GalleryItem;
    import Subscription = MsPortalFx.Azure.Subscription;
    /**
     * Validate subscription object, used to validate a list of subscriptions against a gallery item
     * through the Marketplace.
     */
    interface ValidateSubscription {
        /**
         * The gallery item.
         */
        galleryItem: FxGalleryItem;
        /**
         * The subscriptions to validate.
         */
        subscriptions: Subscription[];
    }
    /**
     * Inputs to validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationInputs {
        /**
         * The gallery item to validate against.
         */
        galleryItem: FxGalleryItem;
    }
    /**
     * Result of validating whether a set of subscriptions can perform operations on a given gallery item.
     */
    interface SubscriptionValidationResult {
        /**
         * Failure details for subscriptions that did not validate successfully.
         */
        invalidSubscriptions: SubscriptionValidationFailure[];
        /**
         * Error blade to launch if there no valid subscriptions
         */
        noValidSubscriptionsErrorBlade?: MsPortalFx.ViewModels.DynamicBladeSelection;
    }
    /**
     * Failure details for subscriptions that did not validate successfully.
     */
    interface SubscriptionValidationFailure {
        /**
         * Id of the subscription that failed to validate
         */
        subscriptionId: string;
        /**
         * Text to display for the validation failure
         */
        displayText: string;
    }
    /**
     * Inputs to for the canRegisterSubscriptionWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsInputs {
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The list of resource providers.
         */
        resourceProviders: string[];
    }
    /**
     * Result for the canRegisterSubscriptionWithRPs endpoint.
     */
    interface CanRegisterSubWithRPsResult {
        /**
         * True if the subscription is already registered or can register with all given resource
         * providers. False otherwise.
         */
        success: boolean;
        /**
         * The list of resource providers that the subscription failed to register with. Empty if
         * success is true.
         */
        failedRPs: string[];
        /**
         * The list of resource providers that the subscription is not allowed to register with.
         */
        disallowedRPs: string[];
    }
    interface ObsoleteSubscription extends MsPortalFx.Azure.Subscription {
        /**
         * Friendly name of the azure subscription.
         */
        subscriptionName: string;
        /**
         * Id of the azure subscription.
         */
        subscriptionID: string;
        /**
         * Id of the Active Directory tenant containing this subscription.
         */
        tenantID: string;
        /**
         * The subscription status.
         */
        status: string;
        /**
         * The subscriptions requires rdfe.
         */
        requireRdfe: boolean;
    }
    /**
     * Interface containing the subscription search results.
     */
    interface SubscriptionSearchResults {
        /**
         * The subscriptions that matched the search string.
         */
        readonly subscriptions: ReadonlyArray<Subscription>;
        /**
         * Indicates if more results were found than the maximum number of results displayed.
         */
        readonly overflow: boolean;
        /**
         * The search text.
         */
        readonly searchString: string;
    }
    /**
     * Internal RPC endpoint to get the detailed info for a subscription.
     * This is now implemented in the 'FxInternal/ResourceManagement/SubscriptionsCore' module and set prior to loading this containing script.
     */
    const getSubscriptionInfoEndPoint: typeof import("FxInternal/ResourceManagement/SubscriptionsCore").getSubscriptionInfoEndPoint;
    /**
     * Internal RPC endpoint to get the list of selected subscriptions.
     * This is now implemented in the 'FxInternal/ResourceManagement/SubscriptionsCore' module and set prior to loading this containing script.
     */
    const getInSessionSelectedSubscriptionsEndPoint: typeof import("FxInternal/ResourceManagement/SubscriptionsCore").getInSessionSelectedSubscriptionsEndPoint;
    /**
     * Internal RPC endpoint to set the list of selected subscriptions.
     */
    const setInSessionSelectedSubscriptionsEndPoint: FxRpc.ActionEndPointDefinition<readonly string[]>;
    /**
     * Internal RPC endpoint to search for subscription by name.
     */
    const searchForSubscriptionsEndPoint: FxRpc.FuncEndPointDefinition<string, SubscriptionSearchResults>;
    /**
     * Checks if the subscription can register with a list or resource providers (if not already registered).
     *
     * @param subscriptionId The subscription id.
     * @param resourceProviders The resource types.
     * @returns Resolves with a list of resource providers that the subscription can't register with
     *     (or an empty array otherwise).
     */
    function canRegisterSubscriptionWithRPs(subscriptionId: string, resourceProviders?: string[]): Promise<CanRegisterSubWithRPsResult>;
    /**
     * Returns a value indicating whether the subscription is a free trial subscription.
     *
     * @param subscription The subscription to check.
     * @returns Boolean true if the subscription is a free trial subscription.
     */
    let isFreeTrialSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a DreamSpark subscription.
     *
     * @param subscription The subscription to check.
     * @returns Boolean true if the subscription is a DreamSpark subscription.
     */
    let isDreamSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a BizSpark subscription.
     *
     * @param subscription The subscription to check.
     * @returns Boolean true if the subscription is a BizSpark subscription.
     */
    let isBizSparkSubscription: (subscription: Subscription) => boolean;
    /**
     * Returns a value indicating whether the subscription is a ZeroCap subscription.
     *
     * @param subscription The subscription to check.
     * @returns Boolean true if the subscription is a ZeroCap subscription.
     */
    let isZeroCapSubscription: (subscription: Subscription) => boolean;
}
declare module MsPortalFx.Azure {
    type Subscription = import("Fx/ResourceManagement/Subscriptions").Subscription;
    type SubscriptionPolicies = import("Fx/ResourceManagement/Subscriptions").SubscriptionPolicies;
    /**
     * Subscriptions namespace.
     */
    module Subscriptions {
        function filterObjectByName(item: Subscription, name: string): boolean;
        function itemToHierarchicalFormOption(item: Subscription): {
            text: KnockoutObservable<string>;
            value: string;
        };
    }
    /**
     * Returns the detailed info for a subscription.
     *
     * @param subscriptions Id of the subscription.
     * @returns A promise that resolves to the detailed info for the subscription.
     */
    function getSubscriptionInfo(subscriptionId: string): Promise<Subscription>;
    /**
     * Returns the list of selected subscription.
     *
     * @returns A promise that resolves to the list of selected subscriptions.
     */
    function getSelectedSubscriptions(): Promise<ReadonlyArray<Subscription>>;
}

// FILE: MsPortalFx\Azure\Validators.d.ts
declare module MsPortalFx.Azure {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxCustomValidation = FxViewModels.CustomValidation;
    /**
     * The options returned by the required permissions callback.
     */
    interface RequiredPermissionsValidatorOptions {
        /**
         * The entity to check the permissions for (must be a resource id, a subscription id, or a
         * resource group id).
         */
        entityId: string;
        /**
         * The actions being to checked.
         */
        actions: string[];
        /**
         * Optional. The message that is shown to the user if the validation fails.
         */
        message?: string;
    }
    /**
     * The required permissions validator callback definition.
     *
     * @param value The value from the control to be validated.
     * @returns A promise resolved with the required permission validator options.
     */
    type RequiredPermissionsValidatorCallback = ((value: string) => Promise<RequiredPermissionsValidatorOptions>);
    /**
     * The required permissions validator. Used to check if the current user has permissions to perform
     * a set of actions against an entity.
     */
    class RequiredPermissionsValidator extends FxCustomValidation {
        /**
         * Constructs a required permissions validator.
         *
         * @param callback The required permissions validator callback function. The function takes
         *                 the value to be validated as an input, and returns a promise resolved with
         *                 the required permission validator options as an output.
         */
        constructor(callback: RequiredPermissionsValidatorCallback);
    }
    /**
     * The reserved resource name validator. Used to check whether the specified name is permitted
     * for a given resource (validated against ARM).
     */
    class ReservedResourceNameValidator extends FxCustomValidation {
        /**
         * Constructs a reserved resource name validator.
         *
         * @param resourceType The resource type. Example "microsoft.resources/subscriptions/resourcegroups".
         * @param message The message that is shown to the user if the validation fails.
         * @param endpoint The ARM endpoint.
         */
        constructor(resourceType: string, message?: string, endpoint?: string);
    }
}

// FILE: MsPortalFx\BackCompat.d.ts

// FILE: MsPortalFx\Base\Base.Callbacks.d.ts
declare module MsPortalFx.Base {
    /**
     * The function that will be invoked when a callback is fired.
     */
    interface Callback<T> {
        (arg: T): void;
    }
    /**
     * Defines a collection of functions that can be invoked in order when an event occurs.
     */
    class Callbacks<T> {
        private _entries;
        private _names;
        /**
         * Constructs a callback list.
         */
        constructor();
        /**
         * Adds a callback to the collection.
         *
         * @param entry The callback to be added.
         * @param name Optional name of the callback (for use in removal).
         * @returns The current instance.
         */
        add(entry: Callback<T>, name?: string): Callbacks<T>;
        /**
         * Removes a callback from the collection.
         *
         * @param entry The callback to be removed.
         * @returns The current instance.
         */
        remove(entry: Callback<T>): Callbacks<T>;
        remove(entry: string): Callbacks<T>;
        /**
         * Clears all callbacks from the collection.
         *
         * @returns The current instance.
         */
        clear(): Callbacks<T>;
        /**
         * Fires the callbacks in order with the given parameter.
         *
         * @returns The current instance.
         */
        fire(arg: T): Callbacks<T>;
        private _init;
    }
}

// FILE: MsPortalFx\Base\Base.Constants.d.ts
declare module MsPortalFx.Base.Constants {
    /**
     * Shell/framework name.
     */
    const Shell = "fx";
    /**
     * Extension names for specialized extensions.
     */
    module ExtensionNames {
        /**
         * The name of the well-known hubs extension.
         */
        const Hubs = "HubsExtension";
        /**
         * The name of the billing extension.
         */
        const Billing = "Microsoft_Azure_Billing";
        /**
         * The name of the Azure expert extension.
         */
        const AzureExpert = "Microsoft_Azure_Expert";
        /**
         * The name of the Azure insights extension.
         */
        const AzureInsights = "Microsoft_Azure_Insights";
        /**
         * The name of the Azure monitoring extension.
         */
        const AzureMonitoring = "Microsoft_Azure_Monitoring";
        /**
         * The name of the Azure Active Directory extension.
         */
        const ActiveDirectory = "Microsoft_Azure_AD";
        /**
         * The name of the ClassicResources extension.
         */
        const ClassicResources = "Microsoft_Azure_ClassicResources";
        /**
         * The name of the Marketplace extension.
         */
        const Marketplace = "Microsoft_Azure_Marketplace";
        /**
         * The name of the Resources extension.
         */
        const Resources = "Microsoft_Azure_Resources";
        /**
         * The name of the Support extension.
         */
        const Support = "Microsoft_Azure_Support";
        /**
         * The name of the Websites extension.
         */
        const Websites = "WebsitesExtension";
    }
    /**
     * Asset type names for global asset types.
     */
    module AssetNames {
        /**
         * The resource groups asset type name.
         */
        const ResourceGroups = "ResourceGroups";
        /**
         * The browse "all" asset type name. This is the new ARG browse blade.
         */
        const BrowseAllBlade = "BrowseAll";
        /**
         * The browse resources asset type name. This is the new ARG browse blade.
         */
        const BrowseResourceBlade = "BrowseResource";
        /**
         * The browse resources asset type name. This is the new ARG browse blade.
         * This was an alias to the "Browse" blade that was deprecated.
         *
         * @deprecated AssetNames.BrowseBlade Please use BrowseResourceBlade (which has the same value, one-to-one swap).
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const BrowseBlade = "BrowseResource";
        /**
         * The browse "all resources" asset type name.
         */
        const BrowseAllResources = "BrowseAllResources";
        /**
         * The browse "recent resources" asset type name.
         */
        const BrowseRecentResources = "BrowseRecentResources";
        /**
         * The browse "all" asset type name with a default type.
         */
        const BrowseAllBladeWithType = "BrowseAllWithType";
        /**
         * The browse resource groups asset type name.
         */
        const BrowseResourceGroupBlade = "BrowseResourceGroup";
        /**
         * The gallery asset type name.
         */
        const Gallery = "Gallery";
        /**
         * The store provided gallery asset type name.
         */
        const StoreGallery = "StoreGallery";
        /**
         * The deployments asset type name.
         */
        const Deployments = "Deployments";
        /**
         * The arm explorer asset type name.
         */
        const ArmExplorer = "ArmExplorer";
        /**
         * The whats new asset type name.
         */
        const WhatsNew = "WhatsNew";
        /**
         * The browse dynamic resource asset type name.
         */
        const BrowseDynamicResource = "BrowseDynamicResource";
        /**
         * The browse dynamic asset asset type name.
         */
        const BrowseDynamicAsset = "BrowseDynamicAsset";
        /**
         * The subscriptions asset type name.
         */
        const SubscriptionDetail = "Subscription";
        /**
         * The asset type name for a non-asset resource (resource fallback).
         */
        const NonAssetResource = "NonAssetResource";
    }
    /**
     * Resource type names for global resource types.
     */
    module ResourceTypes {
        /**
         * The subscriptions resource type name.
         */
        const Subscriptions = "Microsoft.Resources/subscriptions";
        /**
         * The resource groups resource type name.
         */
        const ResourceGroups = "Microsoft.Resources/subscriptions/resourcegroups";
        /**
         * The placeholder for all resources supported in the portal.
         */
        const AllResources = "Microsoft.Resources/resources";
        /**
         * The placeholder for recent resources supported in the portal.
         */
        const RecentResources = "Microsoft.Resources/recent";
    }
    /**
     * Part names for global parts.
     */
    module PartNames {
        /**
         * Part names for hubs extension parts.
         */
        module Hubs {
            /**
             * The browse resource pinned part which launches browse V2 for a particular resource type.
             */
            const BrowseResourcePinnedPart = "BrowseResourcePinnedPart";
            /**
             * The browse resource group pinned part which launches browse V2 for resource groups.
             */
            const BrowseResourceGroupPinnedPart = "BrowseResourceGroupPinnedPart";
        }
    }
    /**
     * Blade names for global parts.
     */
    module BladeNames {
        /**
         * Blades names for Billing.
         */
        module Billing {
            /**
             * The create subscriptions blade.
             */
            const SubscriptionsBlade = "SubscriptionsBlade";
        }
        /**
         * Blades names for hubs.
         */
        module Hubs {
            /**
             * The create hub blade.
             */
            const CreateHubBlade = "PlusNewBlade";
            /**
             * The browse link blade.
             */
            const BrowseLinkBlade = "BrowseLinkBlade";
            /**
             * The browse resource blade.
             */
            const BrowseResourceBlade = "BrowseResourceBlade";
            /**
             * The browse all resources blade.
             */
            const BrowseAllResourcesBlade = "BrowseAllResourcesBlade";
            /**
             * The browse resource group blade.
             */
            const BrowseResourceGroupBlade = "BrowseResourceGroupBlade";
            /**
             * The browse recent resources blade.
             */
            const BrowseRecentResourcesBlade = "BrowseRecentResourcesBlade";
            /**
             * The asset menu blade.
             */
            const AssetMenuBlade = "AssetMenuBlade";
            /**
             * The unauthorized asset blade.
             */
            const UnauthorizedAssetBlade = "UnauthorizedAssetBlade";
            /**
             * The not found asset blade.
             */
            const NotFoundAssetBlade = "NotFoundAssetBlade";
            /**
             * The unavailable asset blade.
             */
            const UnavailableAssetBlade = "UnavailableAssetBlade";
            /**
             * The resource menu blade.
             */
            const ResourceMenuBlade = "ResourceMenuBlade";
            /**
             * The resource properties blade.
             */
            const ResourceProperties = "ResourceProperties";
            /**
             * The resource group blade.
             */
            const ResourceGroupMapBlade = "ResourceGroupMapBlade";
        }
        /**
         * Blades names for Marketplace.
         */
        module Marketplace {
            /**
             * The create hub blade.
             */
            const GalleryFeaturedMenuItemBlade = "GalleryFeaturedMenuItemBlade";
            /**
             * The create results blade.
             */
            const GalleryResultsListBlade = "GalleryResultsListBlade";
            /**
             * The name of version 2 of the legal terms blade.
             */
            const LegalTermsV2Blade = "PCLegalTermsV2Blade";
        }
    }
    /**
     * Telemetry common constants.
     */
    module Telemetry {
        /**
         * Feature adoption telemetry source.
         */
        const FeatureAdoption = "FeatureAdoption";
        /**
         * Feature obsolete telemetry source.
         */
        const FeatureObsolete = "FeatureObsolete";
    }
    module TelemetrySharing {
        /**
         * Register an extension to receive shell telemetry.
         */
        const RegisterExtension = "TelemetrySharing.registerExtension";
        /**
         * Receives shell telemetry.
         */
        const TraceTelemetry = "TelemetrySharing.traceTelemetry";
    }
    /**
     * Gallery Menu item types.
     */
    module GalleryMenuItems {
        /**
         * Home (everything) menu item id.
         */
        const HomeMenuItem = "home";
    }
    module BladeParameterNames {
        /**
         * Blade input used to identify the edit scope.
         */
        const EditScopeId = "editScopeId";
        /**
         * Optional blade input containing additional config from the component which opened the blade.
         */
        const ReferrerInfo = "referrerInfo";
    }
}

// FILE: MsPortalFx\Base\Base.Debouncer.d.ts
declare module MsPortalFx.Base {
    import FxBase = MsPortalFx.Base;
    import FxBaseNet = FxBase.Net2;
    /**
     * If you need to implement DebouncerDataMerger, you need to handle both T|T[].
     * default is to use MsPortalFx.merge which call array.prototype.concat to do things correctly.
     */
    interface DebouncerDataMerger<T> {
        (oldData: T | T[], newData: T | T[]): T[];
    }
    interface DebouncerExecutor<T> {
        (data: T[] | string): Promise<any>;
    }
    interface DebouncerOptions {
        /**
         * The time period after which each batch of optional data should be processed.
         */
        optionalDataInterval?: number;
        /**
         * The maximum batch size suported by the execution method. It combines both required data and optional data.
         */
        maxBatchSize?: number;
        /**
         * Optional. Returns whether the items should be flushed immediately.
         * This can be used for example if the size of the payload can be proactively calculated / estimated, then if it's above a certain
         * threshold, it can be flushed right away if it's approach the request's max size.
         */
        shouldFlush?: (data: unknown[], optionalData: unknown[]) => boolean;
    }
    interface DebouncerPostOptions {
        uri: string;
        headers?: StringMap<string>;
        isBackgroundTask?: boolean;
        performRetry?: boolean;
        setAuthHeader?: boolean | FxBaseNet.AuthorizationOptions;
        skipTelemetry?: boolean;
    }
    interface IDebouncer<T> {
        execute: (data: T[], optionalData?: boolean, resolve?: () => void, reject?: (reason?: any) => void) => void;
        flush: () => Promise<void>;
    }
    /**
     * Allows multiple async-operations to be sequenced and batched, while processing only one batch at a time.
     */
    class Debouncer<T> implements IDebouncer<T> {
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @returns A DebouncerDataMerger function.
         */
        static getMergeIntoArrayDataMerger(): DebouncerDataMerger<any>;
        /**
         * Returns a function that can be used to merge two sets of data in the debouncer into an array.
         * New data is appended to existing data to return a new array.
         *
         * @param uri The URI where the data is to be posted.
         * @param isBackgroundTask Specifies if the deboncer should make background calls.
         * @returns A DebouncerExecutor function.
         */
        static getPostArrayExecutor(options: DebouncerPostOptions): DebouncerExecutor<any>;
        /**
         * Updates the data in the queue.
         */
        execute: (data: T[], optionalData?: boolean, resolve?: () => void, reject?: (reason?: any) => void) => void;
        /**
         * Resolves all tasks in the queue.
         *
         * @returns The promise of the last task in the queue.
         */
        flush: () => Promise<void>;
        /**
         * Initializes a new instance of the Debouncer class.
         *
         * @param mergeFunc A function that is invoked to merge two batches of data.
         * This function is invoked when a second batch comes in before the first has been dispatched.
         * It is also invoked when there is an error processing the first batch and a second one is enqueued.
         * This allows the first batch to be piggy-backed with the second.
         * @param executor The function that processes a batch of data.
         * @param interval The time period after which each batch should be processed.
         * @param resetTimerOnUpdate True if it resets timer of calling the update method.
         * @param options Options.
         */
        constructor(mergeFunc: DebouncerDataMerger<T>, executor: DebouncerExecutor<T>, interval?: number, resetTimerOnUpdate?: boolean, options?: DebouncerOptions);
    }
}
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    import FxBaseNet = FxBase.Net2;
    /** Options for the standard debouncer */
    interface StandardDebouncerOptions {
        /** The uri for uploading data. */
        readonly uri: string;
        /** When true, skip the telemetry for the network call. */
        readonly skipTelemetry?: boolean;
        /** The name of the extension uploading its events */
        readonly extensionName?: string;
        /** The time period after which each batch should be processed. */
        readonly interval?: number;
        /** The maximum number of items in batch before it gets processed. */
        readonly maxBatchSize?: number;
        /** Whether to retry on failure */
        readonly performRetry?: boolean;
        /** When true, sanitizes the data after serializing it. */
        readonly sanitizeData?: boolean;
        /** The name of the authorization token to be added on the AJAX request. */
        readonly setAuthorizationHeader?: boolean | FxBaseNet.AuthorizationOptions;
    }
    /**
     * Returns an instance of the Standard Debouncer.
     *
     * @param options for configuring the standard debouncer.
     */
    function getStandardDebouncer<T>(options: StandardDebouncerOptions): FxBase.IDebouncer<T>;
    /**
     * Returns the standard FX HTTP request headers to be used in any upload.
     *
     * @param extensionName The name of the extension for which the upload is being done.
     * @param extensionVersion The version of the extension.  Defaults to the 'version' value from the environment if not supplied.
     * @returns The HTTP request headers.
     */
    function getStandardHeaders(extensionName: string, extensionVersion?: string): ReadonlyStringMap<string>;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.d.ts
declare module MsPortalFx {
    module Base.Diagnostics {
        function setWriter(func?: WriteEntryHelperFunc): WriteEntryHelperFunc;
        /**
         * This method registers callbacks to be invoked when errors are logged.
         * This is intended to be used for monitoring purposes only.
         *
         * @param errorCallback Appends a callback to be invoked when a error is logged to the console
         * @param warningCallback Appends a callback to be invoked when a working is logged to the console
         */
        function setupErrorDetection(errorCallback: (entry: LogEntry) => void, warningCallback: (entry: LogEntry) => void): void;
        /**
         * This type defines the shape of the callback method. Parameters are
         * per Base.Diagnostics.Log.error(), the default method that is used.
         */
        type LogFunc = (entry: LogMessage, code?: number, ...restArgs: any[]) => void;
        /**
         * Logging facilities.
         */
        class Log {
            private readonly _area;
            private readonly _type;
            /**
             * Set this value to true if you want failed assertions to break in the debugger.
             */
            debugBreak: boolean;
            /**
             * Creates the logger instance.
             *
             * @param logArea The name of the information area.
             */
            constructor(logArea: string);
            /**
             * Logs event.
             *
             * @param level Information level type.
             * @param area Name of information area.
             * @param message Information that is to be logged.
             * @param restArgs Any other parameters that should be captured.
             */
            static writeEntry(level: LogEntryLevel, area: string, message: LogMessage, ...restArgs: any[]): void;
            /**
             * Logs event.
             *
             * @param level Information level type.
             * @param area Name of information area.
             * @param message Information that is to be logged.
             * @param code The message code.
             * @param restArgs Any other parameters that should be captured.
             */
            static writeEntry2(level: LogEntryLevel, area: string, message: LogMessage, code: number, restArgs?: any[]): void;
            /**
             * Gets the logged entries buffer.
             *
             * @param level The level of entries to return. All entries greater than or equal to this level will be returned.
             * @returns An array of log entries.
             */
            static getEntries: (level: LogEntryLevel) => LogEntry[];
            /**
             * Clears the log buffer.
             */
            static clear: () => void;
            /**
             * Flushes the buffer and calls _setBufferFullCallback.
             */
            static flush: () => void;
            /**
             * Specify logging level of messages to console and remotely.
             *
             * @param consoleLevel The level which is to be enabled for the console. If not specified, all levels are enabled.
             * @param remoteLevel The level which is to be enabled for remote logging. If not specified, it will be the same as the console level.
             */
            static initialize(consoleLevel?: LogEntryLevel, remoteLevel?: LogEntryLevel): void;
            /**
             * Disables the log.
             */
            static disable(): void;
            /**
             * Log verbose information.
             *
             * @param entry The message to log.
             * @param restArgs[] Extra information to log with the message.
             */
            verbose(entry: string, ...restArgs: any[]): void;
            /**
             * Log warning information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            warning(entry: LogMessage, code?: number, ...restArgs: any[]): void;
            /**
             * Log error information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            error(entry: LogMessage, code?: number, ...restArgs: any[]): void;
            /**
             * Log debug information.
             *
             * @param entry The message to log.
             * @param restArgs[] Extra information to log with the message.
             */
            debug(entry: LogMessage, ...restArgs: any[]): void;
            /**
             * Log custom information.
             *
             * @param entry The message to log.
             * @param code The message code.
             * @param restArgs[] Extra information to log with the message.
             */
            custom(entry: string, code?: number, ...restArgs: any[]): void;
            /**
             * Asserts in debug mode.
             *
             * @param assertion A boolean value or a function that returns a boolean value.
             * @param entry The message to log if the assertion is falsy.
             * @param code The message code.
             * @param arg Extra information to log with the message.
             */
            assert(assertion: boolean | Func<boolean>, entry: string, code?: number, arg?: any): void;
            /**
             * Log information.
             *
             * @param level Information level type.
             * @param entry The message to log.
             * @param code The message code.
             * @param args[] Extra information to log with the message.
             */
            writeEntry(level: LogEntryLevel, entry: LogMessage, code: number, args: any[]): void;
            static _setBufferFullCallback: (callback?: LogBufferFullCallback) => void;
        }
    }
}
declare module FxImpl.Base.Diagnostics {
    function setObjectIdToScrub(objectId: string): void;
    const loggingDiValue: import("Fx/Diagnostics").Logging;
    const logHelper: typeof import("FxInternal/Diagnostics").logHelper;
    const logFunctions: typeof import("FxInternal/Diagnostics").logFunctions;
    const extractErrorDetails: typeof import("FxInternal/ErrorSerialization").extractErrorDetails;
    const isError: typeof import("FxInternal/ErrorSerialization").isError;
    const isXMLHttpRequestLike: typeof import("FxInternal/ErrorSerialization").isXMLHttpRequestLike;
    const isArmErrorResponse: typeof import("FxInternal/ErrorSerialization").isArmErrorResponse;
    /**
     * Fx-internal means of writing a log entry with a previously-generated timestamp.
     *
     * @param args Standard 'writeEntry' arguments along with a trailing 'timestamp' argument.
     */
    let writeEntry: (...args: [...Parameters<MsPortalFx.Base.Diagnostics.WriteEntryHelperFunc>, number]) => void;
}
declare namespace MsPortalFx {
    function sanitizeMessage(text: string): string;
    const getLogFriendlyMessage: typeof import("Fx/Diagnostics").getLogFriendlyMessage;
    namespace Base.Diagnostics {
        type LogEntryLevel = import("Fx/Diagnostics").LogEntryLevel;
        const LogEntryLevel: typeof import("Fx/Diagnostics").LogEntryLevel;
        type LogMessage = import("Fx/Diagnostics").LogMessage;
        type LogBufferFullCallback = import("FxInternal/Diagnostics").LogBufferFullCallback;
        type LogEntry = import("FxInternal/Diagnostics").LogEntry;
        type WriteEntryHelperFunc = import("FxInternal/Diagnostics").WriteEntryHelperFunc;
    }
}

// FILE: MsPortalFx\Base\Base.Diagnostics.ErrorReporter.d.ts
declare module FxImpl {
    module Boot {
        const enum MessageKind {
            Initialize = 3,
            UnhandledError = 4,
            ScriptError = 6
        }
    }
}
declare module MsPortalFx.Base.Diagnostics {
    import FxErrors = MsPortalFx.Errors;
    import FxError = FxErrors.Error;
    /**
     * Creates an instance of the logger.
     *
     * @param localRequire The require variable injected in an AMD module. This is defined by TypeScript.
     * If not using AMD, use the Log class constructor to create a log instance directly.
     * @returns The Log instance to use for logging.
     */
    function createLog(localRequire: LocalRequire): Log;
    /**
     * Helper function to create Error object to ignore unhandled promise rejection will only log as warning instead of error in the current Frame
     * Note that if this exception throw across the RPC, the other side will still log as Error. Thus will reflect to ErrorTracker.
     *
     * @param message Error object message
     * @param stack Optional stack, if not provided, current stack will be used.
     * @returns Error object
     */
    function createIgnoreUnhandledRejectionError(error: FxError, data?: StringMap<any>): FxError;
    function createIgnoreUnhandledRejectionError(message: string, stack?: string, data?: StringMap<any>): FxError;
    module ErrorReporter {
        let lastError: Error;
        /**
         * Logs the error
         */
        function handleError(evt: ErrorEvent): void;
    }
}
declare namespace MsPortalFx.Base.Diagnostics {
    namespace ErrorReporter {
        /**
         * Initializes the error handler
         *
         * @param postLogCallback Function to run after error is logged.
         * @param resetCounter Boolean to reset the special message counter..
         */
        function initialize(postLogCallback?: () => void, forTest?: boolean, additionalInfoCallback?: () => any): void;
    }
}
declare namespace FxImpl {
    const errorHandlingImpl: Pick<typeof import("FxInternal/ErrorHandling"), "preinitialize" | "handleError">;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    /**
     * A start telemetry event to be sent to the server.
     */
    interface StartTelemetryEvent {
        /**
         * The timestamp of the event. Automatically filled in by the framework.
         */
        timestamp?: number;
        /**
         * The extension that is logging the event. Automatically filled in by the framework.
         */
        extension?: string;
        /**
         * The source of the telemetry data e.g. navigation, blade.
         */
        source: string;
        /**
         * The action being recorded.
         */
        action: string;
        /**
         * A modifier for the action.
         */
        actionModifier?: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        assetType?: string;
        /**
         * The elapsed time in milliseconds for the event being recorded (optional).
         */
        duration?: number;
        /**
         * A name associated with the event or item that was the target of the event (optional).
         */
        name?: string;
        /**
         * Any additional context.  Automatically added by the framework.
         */
        context?: any;
        /**
         * Whether or not this event should be considered optional. Defaults to false.
         */
        optional?: boolean;
        journeyId?: string;
        /**
         * The service tree id, currently it is logged for consumption by SLO (optional)
         */
        serviceTreeId?: string;
        /**
         * When true increases buffering time of event (optional).
         */
        lowPriority?: boolean;
    }
    /**
     * A telemetry event to be sent to the server.
     */
    interface TelemetryEvent extends StartTelemetryEvent {
        /**
         * Any additional information for the event being recorded (optional).
         */
        data?: any;
    }
    /**
     * Trace processor interface for pluggable telemetry service.
     */
    interface TelemetryEventProcessor {
        /**
         * Sends a telemetry data event to the data store.
         */
        trace(evt: TelemetryEvent): void;
        /**
         * Flushes all current telemetry events.
         */
        flush(): Promise<unknown>;
    }
    /**
     * List of constants to be used for Telemetry data points.
     */
    module ActionModifier {
        const Start = "start";
        const Complete = "complete";
        const Reset = "reset";
        const Cancel = "cancel";
        const Mark = "mark";
    }
    module Internal {
        interface Options {
            /**
             * The name of the current extension.
             */
            extensionName: string;
            /**
             * The query string that the user set for the Portal session. This value doesn't have a leading question mark.
             */
            userQuery?: string;
            /**
             * The trace processors to use. The default processors are used if none is specified.
             */
            processors?: ReadonlyArray<TelemetryEventProcessor>;
        }
        /**
         * Initializes the telemetry system with the built-in event processor.
         *
         * @returns The previous processor or processors, if any existed.
         */
        function initialize(options: Options): TelemetryEventProcessor[];
        function getTelemetryPrivacySerializer(): (evt: TelemetryEvent) => string;
    }
    /**
     * Initializes the telemetry system with the built-in event processor.
     *
     * @param extensionName The name of the current extension.
     * @returns The previous processor or processors, if any existed.
     */
    function initialize(extensionName: string): TelemetryEventProcessor[];
    /**
     * Registers an extension to receive shell telemetry.  Extensions can either specify a custom TelemetryEventProcessor
     * or use the current telemetry configuration.
     *
     * @param processor The optional processor to use when receiving telemetry.
     */
    function registerForShellTelemetry(processor?: TelemetryEventProcessor): void;
    /**
     * Records a telemetry event.
     *
     * @param evt The telemetry event.
     */
    function trace(evt: TelemetryEvent): void;
    /**
     * Starts a timed telemetry data event but does not record it.
     * The end/complete/cancel trace methods will still be logged.
     * This is preferred over startTrace since it has less impact
     * on the network.
     *
     * @param evt The telemetry event.
     */
    function start(evt: StartTelemetryEvent): string;
    /**
     * Starts a timed telemetry data event.
     *
     * @param evt The telemetry event.
     */
    function startTrace(evt: TelemetryEvent): string;
    /**
     * Cancels a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function cancelTrace(key: string, data?: any): number;
    /**
     * Completes a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function completeTrace(key: string, data?: any): number;
    /**
     * Ends a timed telemetry data event with a provided action modifier.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     * @param actionModifier One of the action modifiers of the event.
     * @param data Any additional context information for the event being recorded (optional).
     */
    function endTrace(key: string, actionModifier: string | boolean, data?: any): number;
    /**
     * Resets the stopwatch for a timed telemetry data event.
     *
     * @param key The key for the started timed telemetry data event returned by startTrace.
     */
    function resetTrace(key: string): void;
    /**
     * Flushes all current telemetry events.
     */
    function flush(): Promise<unknown>;
    function addProcessor(processor: TelemetryEventProcessor): void;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.Context.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry.Context {
    /**
     * Base class for providing ambient context information.
     */
    interface ContextValue {
        /**
         * User defined identifier to correlate logical activities through async and component boundaries.
         */
        id: string;
    }
    interface CompositionContext extends ContextValue {
        instanceId: string;
    }
    interface PartContext extends CompositionContext {
        bladeId: string;
        bladeInstanceId: string;
        onBlade: boolean;
        onStartBoard: boolean;
        bladeCustomized: boolean;
    }
    const getPartContext: Func<PartContext>;
    const getBladeContext: Func<CompositionContext>;
    const getJourneyContext: () => ContextValue;
    const getCompositionItemContext: Func<ContextValue>;
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Telemetry.Helpers.d.ts
declare module MsPortalFx.Base.Diagnostics.Telemetry {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * Adds a watcher to the activated items of the given selectable data and calls the appropriate callbacks.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param selectionActivated The callback called when a selection is activated.
     * @param selectionDeactivated The callback called when a selection is deactivated.
     */
    function addActivatedItemsWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, selectionActivated: (selection: U) => void, selectionDeactivated?: (selection: U) => void): void;
    /**
     * Adds a telemetry trace watcher to the activated items of the given selectable data and traces with the
     * appropriate source action. This takes a callback to prepare the base properties which are then merged into
     * the result telemetry event to be traced.
     *
     * @param lifetimeManager The lifetime manager for the watcher.
     * @param selectableData The selectable data that we are going to watch.
     * @param source The source for the telemetry trace.
     * @param activatedAction The action for the telemetry trace when a selection is activated.
     * @param deactivatedAction The action for the telemetry trace when a selection is deactivated.
     * @param prepareTelemetryBase Callback used internally to prepare the base properties for the telemetry trace.
     */
    function addActivatedItemsTelemetryWatcher<T, U>(lifetimeManager: FxBase.LifetimeManager, selectableData: FxViewModels.SelectableSet<T, U>, source: string, activatedAction: string, deactivatedAction: string, prepareTelemetryBase: (selection: U) => ActivatedItemsTelemetryBase): void;
    interface ActivatedItemsTelemetryBase {
        /**
         * The extension that is logging the event. Automatically filled in by the framework.
         */
        extension?: string;
        /**
         * The asset type for the telemetry data (optional).
         */
        assetType?: string;
        /**
         * Any additional context information for the event being recorded (optional).
         */
        data?: any;
    }
}

// FILE: MsPortalFx\Base\Base.Diagnostics.Upload.d.ts
declare module MsPortalFx.Base.Diagnostics.Upload {
    /**
     * Initializes the uploading of client traces.
     * The traces are posted periodically to the specified server URI.
     * If a null or empty URI is specified the upload is skipped.
     * and the traces are just discarded.
     *
     * @param uploadUri The URI where the buffered messages will be posted.
     */
    function initialize(uploadUri?: string): void;
    function upload(): void;
    /**
     * Immediately execute outstanding data.
     */
    function flush(): Promise<any>;
}

// FILE: MsPortalFx\Base\Base.Disposable.d.ts
declare namespace FxImpl {
    type TriggerableLifetimeManager = import("FxInternal/Lifetime").TriggerableLifetimeManager;
    const TriggerableLifetimeManager: typeof import("FxInternal/Lifetime").TriggerableLifetimeManager;
}

// FILE: MsPortalFx\Base\Base.Factory.d.ts
declare module MsPortalFx.Base {
    /**
     * The interface of generic factory class, without any arguments in the creation method.
     *
     * Example: if it is needed to new up an instance of a certain class during the execution of a method,
     * the recommended approach is to inject the factory instance in the constructor,
     * and use the factory to create the instance of interest, in order to achieve the loose coupling
     * with the concrete implementation of the instance of interest.
     * Ref: http://msdn.microsoft.com/en-us/library/ee817667.aspx
     */
    interface ObjectFactory<TProduct> {
        /**
         * Create a product.
         *
         * @returns The instance of the product of the specified type.
         */
        create(): TProduct;
    }
    /**
     * The interface of generic factory class, with arguments in the creation method.
     */
    interface ParameterObjectFactory<TProduct, TParam> {
        /**
         * Create a product.
         *
         * @param param The arguments provided for the creation of the product.
         * @returns The instance of the product of the specified type.
         */
        create(param: TParam): TProduct;
    }
}

// FILE: MsPortalFx\Base\Base.Helpers.d.ts
declare module MsPortalFx.Helpers {
    interface XMLHttpRequestLike {
        getResponseHeader(header: string): string;
        getAllResponseHeaders(): string;
        readyState: number;
        status: number;
        statusText: string;
        responseText?: string;
        responseJSON?: any;
    }
    function isXMLHttpRequestLike(jqXHR: any): boolean;
    interface JQueryXHRLike<T> extends XMLHttpRequestLike {
        always(alwaysCallback: () => void): void;
        state(): string;
        then(doneCallbacks: (data: T, textStatus: string, jqXHR: JQueryXHRLike<T>) => void, failCallbacks?: (jqXHR: JQueryXHRLike<T>, textStatus: string, errorThrown: any) => void, progressCallbacks?: () => void): void;
    }
}

// FILE: MsPortalFx\Base\Base.Image.d.ts
declare module MsPortalFx.Base {
    type Image = import("Fx/Images/Image").Image;
    type ImageOptions = import("Fx/Images/Image").ImageOptions;
    type ImageBadge = import("Fx/Images/Image").ImageBadge;
    const enum ImagePalette {
        None = 0,
        White = 1,
        Black = 2,
        Blue = 3,
        Green = 4,
        Gray = 5,
        Inherit = 99,
        Disabled = 100
    }
}

// FILE: MsPortalFx\Base\Base.Images.d.ts
declare module MsPortalFx.Base.Images {
    import FxBase = MsPortalFx.Base;
    import ImageOptions = FxBase.ImageOptions;
    import FxBaseImages = MsPortalFx.Base.Images;
    type ImageFunc = (options?: ImageOptions | number) => Image;
    function CustomImageWithBadge(customImage: FxBase.Image, badge: FxBase.ImageBadge): Image;
    function CustomImageWithOptions(customImage: FxBase.Image, options: ImageOptions): Image;
    /**
     * Generates a properly formatted image datatype from a image's URI.
     * For use with the 'image' custom data-binding & custom png/jpeg/gifs/etc.
     *
     * @param URI to image resource.
     * @returns properly formatted image datatype for consumtion by the 'image' data-binding.
     */
    function ImageUri(uri: string): Image;
    /**
     * Generates a circle svg with the provided number inside.
     * Supports values 0 - 99.
     *
     * @param value to display in the SVG.
     * @returns circular svg with a number sized to fit inside..
     */
    function Number(value: number, options?: ImageOptions): Image;
    const Add: ImageFunc;
    /** @deprecated Images.AddAlternate Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const AddAlternate: Obsolete;
    /** @deprecated Images.AddBoxed Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const AddBoxed: Obsolete;
    const AddTeamMember: ImageFunc;
    const AddTile: ImageFunc;
    const Alert: ImageFunc;
    const AllServices: ImageFunc;
    const ArrowDown: ImageFunc;
    const ArrowLeft: ImageFunc;
    const ArrowRight: ImageFunc;
    const ArrowUp: ImageFunc;
    const Attachment: ImageFunc;
    const AvatarDefault: ImageFunc;
    const AvatarUnknown: ImageFunc;
    const AzurePortal: ImageFunc;
    const AzureQuickstart: ImageFunc;
    const Backlog: ImageFunc;
    const Blank: ImageFunc;
    const BlankDashboard: ImageFunc;
    const Book: ImageFunc;
    const Canceled: ImageFunc;
    const Capture: ImageFunc;
    const CaretDown: ImageFunc;
    const CaretUp: ImageFunc;
    const Check: ImageFunc;
    const Clock: ImageFunc;
    /** @deprecated Images.Clone Use Images.Copy instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Clone: Obsolete;
    const CloudUpload: ImageFunc;
    const Code: ImageFunc;
    const Collapse: ImageFunc;
    const Columns: ImageFunc;
    const Commit: ImageFunc;
    /** @deprecated Images.Commits Use Images.Commit instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Commits: Obsolete;
    const Connect: ImageFunc;
    const Console: ImageFunc;
    const Copy: ImageFunc;
    const Customize: ImageFunc;
    const Delete: ImageFunc;
    const Diagnostics: ImageFunc;
    const DirectoryFilter: ImageFunc;
    const DirectoryFilteredSet: ImageFunc;
    const Disable: ImageFunc;
    /** @deprecated Images.Disabled Use Images.Disable instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Disabled: Obsolete;
    const Discard: ImageFunc;
    const Disconnect: ImageFunc;
    const DoubleChevron: ImageFunc;
    const Download: ImageFunc;
    const Edit: ImageFunc;
    /** @deprecated Images.EditInverted Use Images.Edit instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const EditInverted: Obsolete;
    const Ellipsis: ImageFunc;
    const Error: ImageFunc;
    const Expand: ImageFunc;
    const Favorite: ImageFunc;
    const Feedback: ImageFunc;
    const File: ImageFunc;
    const Filter: ImageFunc;
    const FilterRemove: ImageFunc;
    const FolderAlternate: ImageFunc;
    /** @deprecated Images.ForPlacementOnly Use Images.Disable instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const ForPlacementOnly: Obsolete;
    const Gear: ImageFunc;
    /** @deprecated Images.GearAlternate Use Images.Gear instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GearAlternate: Obsolete;
    const GetMoreLicense: ImageFunc;
    const GetStarted: ImageFunc;
    const Globe: ImageFunc;
    const Go: ImageFunc;
    const Guide: ImageFunc;
    const Hamburger: ImageFunc;
    const HeartPulse: ImageFunc;
    const Help: ImageFunc;
    const HideItems: ImageFunc;
    const History: ImageFunc;
    const Hyperlink: ImageFunc;
    const Inactive: ImageFunc;
    const Info: ImageFunc;
    const Insert: ImageFunc;
    /** @deprecated Images.InstallVisualStudio Use Images.Download instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const InstallVisualStudio: Obsolete;
    const Json: ImageFunc;
    const Key: ImageFunc;
    const LaunchCurrent: ImageFunc;
    const Line: ImageFunc;
    const Link: ImageFunc;
    const Lock: ImageFunc;
    const Log: ImageFunc;
    const Mail: ImageFunc;
    const Message: ImageFunc;
    const Monitoring: ImageFunc;
    const MonochromeHome: ImageFunc;
    const Move: ImageFunc;
    const MoveAcrossResourceGroups: ImageFunc;
    const MoveAcrossSubscriptions: ImageFunc;
    const MoveAcrossRegions: ImageFunc;
    /** @deprecated Images.NotificationBell Use Images.Polychromatic.NotificationBell instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NotificationBell: Obsolete;
    const Notifications: ImageFunc;
    /** @deprecated Images.NumberError Use Images.Error instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NumberError: Obsolete;
    /** @deprecated Images.NumberSuccess Use Images.Check instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const NumberSuccess: Obsolete;
    const OpenInMobile: ImageFunc;
    const Paste: ImageFunc;
    const Paused: ImageFunc;
    const Pending: ImageFunc;
    const Person: ImageFunc;
    const PersonWithFriend: ImageFunc;
    const Pin: ImageFunc;
    /** @deprecated Images.Plus Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Plus: Obsolete;
    const Postpone: ImageFunc;
    const PowerUp: ImageFunc;
    const Print: ImageFunc;
    const Properties: ImageFunc;
    const Publish: ImageFunc;
    const Query: ImageFunc;
    const Question: ImageFunc;
    const Queued: ImageFunc;
    /** @deprecated Images.QuickStart Use Images.AzureQuickstart instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const QuickStart: Obsolete;
    const Redo: ImageFunc;
    const Refresh: ImageFunc;
    const Reimage: ImageFunc;
    const Release: ImageFunc;
    const Request: ImageFunc;
    const ResourceFlat: ImageFunc;
    const Retain: ImageFunc;
    const Save: ImageFunc;
    const SaveAll: ImageFunc;
    const Search: ImageFunc;
    /** @deprecated Images.Settings Use Images.Gear instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Settings: Obsolete;
    const ShowItems: ImageFunc;
    const Signout: ImageFunc;
    const SmileyHappy: ImageFunc;
    const SmileyNeutral: ImageFunc;
    const SmileySad: ImageFunc;
    const Star: ImageFunc;
    const Start: ImageFunc;
    const StatusUpsell: ImageFunc;
    const Stop: ImageFunc;
    const Subtract: ImageFunc;
    const Support: ImageFunc;
    const Swap: ImageFunc;
    /** @deprecated Images.Tag Use Images.Tags instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Tag: Obsolete;
    const Tags: ImageFunc;
    const Tasks: ImageFunc;
    const Tools: ImageFunc;
    /** @deprecated Images.Tour Use Images.Info instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const Tour: Obsolete;
    const TrendDown: ImageFunc;
    const TrendUp: ImageFunc;
    const Triangle: ImageFunc;
    const Undo: ImageFunc;
    const Unlock: ImageFunc;
    const Unpin: ImageFunc;
    const Unshare: ImageFunc;
    const Upload: ImageFunc;
    const Variables: ImageFunc;
    const View: ImageFunc;
    const Warning: ImageFunc;
    const WebHostingPlan: ImageFunc;
    const Wrench: ImageFunc;
    const Chevron: ImageFunc;
    const Close: ImageFunc;
    const ShellCustomize: ImageFunc;
    const Dots: ImageFunc;
    const ExitPeekMode: ImageFunc;
    const Fullscreen: ImageFunc;
    const ShellGear: ImageFunc;
    const HeaderDots: ImageFunc;
    const Maximize: ImageFunc;
    const Mini: ImageFunc;
    const Minimize: ImageFunc;
    const PeekMode: ImageFunc;
    const Restore: ImageFunc;
    const Share: ImageFunc;
    const Trash: ImageFunc;
    const TrashOutline: ImageFunc;
    const TripleArrow: ImageFunc;
    /** @deprecated Images.GitLogo Use Images.Logos.Git instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GitLogo: Obsolete;
    /** @deprecated Images.GitLogoBox Please refer to https://aka.ms/portalfx/breaking for more details. */
    const GitLogoBox: Obsolete;
    /** @deprecated Images.VisualStudio Use Images.Logos.VisualStudio instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
    const VisualStudio: Obsolete;
    /** @deprecated Images.VisualStudioLogoBox Please refer to https://aka.ms/portalfx/breaking for more details. */
    const VisualStudioLogoBox: Obsolete;
    /**
     * Logos icons.
     */
    module Logos {
        const Bitbucket: ImageFunc;
        /** @deprecated Images.Logos.BitbucketBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const BitbucketBox: Obsolete;
        const Channel9: ImageFunc;
        /** @deprecated Images.Logos.CodePlex Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CodePlex: Obsolete;
        /** @deprecated Images.Logos.CodePlexBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CodePlexBox: Obsolete;
        const Dropbox: ImageFunc;
        /** @deprecated Images.Logos.DropboxBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DropboxBox: Obsolete;
        const ExternalRepositoryBox: ImageFunc;
        const Git: ImageFunc;
        /** @deprecated Images.Logos.GitBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GitBox: Obsolete;
        const GitHub: ImageFunc;
        /** @deprecated Images.Logos.GitHubBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GitHubBox: Obsolete;
        /** @deprecated Images.Logos.Microsoft Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Microsoft: Obsolete;
        const MicrosoftSquares: ImageFunc;
        const Redis: ImageFunc;
        const StackOverflow: ImageFunc;
        const VisualStudio: ImageFunc;
        /** @deprecated Images.Logos.VisualStudioBox Please refer to https://aka.ms/portalfx/breaking for more details. */
        const VisualStudioBox: Obsolete;
    }
    /**
     * Animated loading indicators.
     */
    module Loading {
        const EllipsisSquare: FxBaseImages.ImageFunc;
        const Spinner: () => Image;
        /** @deprecated Images.Loading.Loader Use Images.Loading.Spinner instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Loader: Obsolete;
    }
    /**
     * Emoticon icons.
     *
     * @deprecated Images.Emoticon is deprecated
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module Emoticon {
        /** @deprecated Images.Emoticon.Happy Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Happy: Obsolete;
    }
    /**
     * Themes
     */
    module Themes {
        const Azure: FxBaseImages.ImageFunc;
        const Blue: FxBaseImages.ImageFunc;
        const Dark: FxBaseImages.ImageFunc;
        const Light: FxBaseImages.ImageFunc;
    }
    /**
     * Multicolor/Polychromatic images.
     */
    module Polychromatic {
        const ActiveDirectory: ImageFunc;
        const Advisor: ImageFunc;
        const AllServices: ImageFunc;
        const ApiManagement: ImageFunc;
        const AppInsights: ImageFunc;
        const Automation: ImageFunc;
        const AvailabilitySet: ImageFunc;
        const AzurePortal: ImageFunc;
        const Backlog: ImageFunc;
        const Backup: ImageFunc;
        const BillingHub: ImageFunc;
        const BizTalk: ImageFunc;
        const BlobBlock: ImageFunc;
        const BlobPage: ImageFunc;
        const SuccessCheckmark: ImageFunc;
        const Branch: ImageFunc;
        const Browser: ImageFunc;
        const Bug: ImageFunc;
        const Builds: ImageFunc;
        const Cache: ImageFunc;
        const Cdn: ImageFunc;
        const Certificate: ImageFunc;
        const Chart: ImageFunc;
        const ClearDBDatabase: ImageFunc;
        const Clock: ImageFunc;
        const CloudService: ImageFunc;
        const Code: ImageFunc;
        const Commit: ImageFunc;
        const Controls: ImageFunc;
        const ControlsHorizontal: ImageFunc;
        const CostAlerts: ImageFunc;
        const CostAnalysis: ImageFunc;
        const CostBudgets: ImageFunc;
        const Counter: ImageFunc;
        const Cubes: ImageFunc;
        const CustomDomain: ImageFunc;
        const Dashboard: ImageFunc;
        const Database: ImageFunc;
        const DevConsole: ImageFunc;
        const Discs: ImageFunc;
        const Download: ImageFunc;
        const ErrorIcon: ImageFunc;
        const EventGrid: ImageFunc;
        const EventHub: ImageFunc;
        const Extensions: ImageFunc;
        const File: ImageFunc;
        const Files: ImageFunc;
        const FolderBlank: ImageFunc;
        const FolderCube: ImageFunc;
        const FolderWebsite: ImageFunc;
        const Ftp: ImageFunc;
        const Functions: ImageFunc;
        const Gear: ImageFunc;
        const Globe: ImageFunc;
        const GlobeError: ImageFunc;
        const GlobeSuccess: ImageFunc;
        const GlobeWarning: ImageFunc;
        const Grid: ImageFunc;
        const Guide: ImageFunc;
        const Heart: ImageFunc;
        const Image: ImageFunc;
        const Info: ImageFunc;
        const InputOutput: ImageFunc;
        const Insights: ImageFunc;
        const IpAddress: ImageFunc;
        const JourneyHub: ImageFunc;
        const Key: ImageFunc;
        const LaunchPortal: ImageFunc;
        const Learn: ImageFunc;
        const LoadBalancer: ImageFunc;
        const LoadTest: ImageFunc;
        const Location: ImageFunc;
        const Log: ImageFunc;
        const LogAnalytics: ImageFunc;
        const LogDiagnostics: ImageFunc;
        const LogStreaming: ImageFunc;
        const ManagementPortal: ImageFunc;
        const Media: ImageFunc;
        const MediaFile: ImageFunc;
        const Mobile: ImageFunc;
        const MobileEngagement: ImageFunc;
        const Module: ImageFunc;
        const Monitoring: ImageFunc;
        const NetworkInterfaceCard: ImageFunc;
        const Notification: ImageFunc;
        const NotificationBell: ImageFunc;
        const OperationalInsights: ImageFunc;
        const Owl: ImageFunc;
        const Power: ImageFunc;
        const Powershell: ImageFunc;
        const PowerUp: ImageFunc;
        const Preview: ImageFunc;
        const ProcessExplorer: ImageFunc;
        const ProductionReadyDb: ImageFunc;
        const QuickStart: ImageFunc;
        const RemoteApp: ImageFunc;
        const ResourceDefault: ImageFunc;
        const ResourceGroup: ImageFunc;
        const ResourceGroupList: ImageFunc;
        const ResourceLinked: ImageFunc;
        /** @deprecated Images.Polychromatic.ResourceList Use Images.Polychromatic.ResourceGroupList instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ResourceList: Obsolete;
        const ResourceRole: ImageFunc;
        const Scale: ImageFunc;
        const Scheduler: ImageFunc;
        const Search: ImageFunc;
        const SearchGrid: ImageFunc;
        const ServerFarm: ImageFunc;
        const ServiceBus: ImageFunc;
        const SiteRecovery: ImageFunc;
        const SqlDatabase: ImageFunc;
        const SqlDataBaseServer: ImageFunc;
        const SSD: ImageFunc;
        const SslCustomDomains: ImageFunc;
        const Storage: ImageFunc;
        const StorageAzureFiles: ImageFunc;
        const StorageContainer: ImageFunc;
        const StorageQueue: ImageFunc;
        const Store: ImageFunc;
        const StorSimple: ImageFunc;
        const StreamAnalytics: ImageFunc;
        const Support: ImageFunc;
        const Table: ImageFunc;
        const Tags: ImageFunc;
        const TeamProject: ImageFunc;
        const TfsVcRepository: ImageFunc;
        const Toolbox: ImageFunc;
        const TrafficManager: ImageFunc;
        const Versions: ImageFunc;
        const VirtualMachine: ImageFunc;
        const VirtualNetwork: ImageFunc;
        const WebEnvironment: ImageFunc;
        const WebHosting: ImageFunc;
        const WebJobs: ImageFunc;
        const Website: ImageFunc;
        const WebsitePower: ImageFunc;
        const WebsiteStaging: ImageFunc;
        const WebSlots: ImageFunc;
        const WebTest: ImageFunc;
        const Workbooks: ImageFunc;
        const Workflow: ImageFunc;
        const AddSubscription: ImageFunc;
        const AzureGithub: ImageFunc;
        const ContentErrorGeneric: ImageFunc;
        const ContentErrorNotFound: ImageFunc;
        const ContentErrorUnauthorized: ImageFunc;
        const CornerCheck: ImageFunc;
        const DefaultBlade: ImageFunc;
        const FreeTrialVariant1: ImageFunc;
        const FreeTrialVariant2: ImageFunc;
        const FreeTrialVariant3: ImageFunc;
        const ManageAccess: ImageFunc;
        const StudentTools: ImageFunc;
        const PolyTrafficManagerDisabled: FxBaseImages.ImageFunc;
        const PolyTrafficManagerEnabled: FxBaseImages.ImageFunc;
        const TrafficManagerDisabled: FxBaseImages.ImageFunc;
        const TrafficManagerEnabled: FxBaseImages.ImageFunc;
    }
    /**
     * Shell icons module
     *
     * @deprecated Images.Shell is deprecated, all icons within can be found in Images.* or Images.Polychromatic.*
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module Shell {
        /** @deprecated Images.Shell.Chevron This icon has been moved to Images.Chevron. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Chevron: Obsolete;
        /** @deprecated Images.Shell.Close This icon has been moved to Images.Close. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Close: Obsolete;
        /** @deprecated Images.Shell.Customize This icon has been moved to Images.ShellCustomize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Customize: Obsolete;
        /** @deprecated Images.Shell.Dots This icon has been moved to Images.Dots. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Dots: Obsolete;
        /** @deprecated Images.Shell.ExitPeekMode This icon has been moved to Images.ExitPeekMode. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ExitPeekMode: Obsolete;
        /** @deprecated Images.Shell.Fullscreen This icon has been moved to Images.Fullscreen. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Fullscreen: Obsolete;
        /** @deprecated Images.Shell.Gear This icon has been moved to Images.ShellGear. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Gear: Obsolete;
        /** @deprecated Images.Shell.HeaderDots This icon has been moved to Images.HeaderDots. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const HeaderDots: Obsolete;
        /** @deprecated Images.Shell.Maximize This icon has been moved to Images.Maximize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Maximize: Obsolete;
        /** @deprecated Images.Shell.Mini This icon has been moved to Images.Mini. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Mini: Obsolete;
        /** @deprecated Images.Shell.Minimize This icon has been moved to Images.Minimize. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Minimize: Obsolete;
        /** @deprecated Images.Shell.PeekMode This icon has been moved to Images.PeekMode. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const PeekMode: Obsolete;
        /** @deprecated Images.Shell.Restore This icon has been moved to Images.Restore. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Restore: Obsolete;
        /** @deprecated Images.Shell.Share This icon has been moved to Images.Share. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Share: Obsolete;
        /** @deprecated Images.Shell.Trash This icon has been moved to Images.Trash. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Trash: Obsolete;
        /** @deprecated Images.Shell.TrashOutline This icon has been moved to Images.TrashOutline. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const TrashOutline: Obsolete;
        /** @deprecated Images.Shell.TripleArrow This icon has been moved to Images.TripleArrow. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const TripleArrow: Obsolete;
        /** @deprecated Images.Shell.AddSubscription This icon has been moved to Images.Polychromatic.AddSubscription. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const AddSubscription: Obsolete;
        /** @deprecated Images.Shell.ContentErrorGeneric This icon has been moved to Images.Polychromatic.ContentErrorGeneric. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorGeneric: Obsolete;
        /** @deprecated Images.Shell.ContentErrorNotFound This icon has been moved to Images.Polychromatic.ContentErrorNotFound. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorNotFound: Obsolete;
        /** @deprecated Images.Shell.ContentErrorUnauthorized This icon has been moved to Images.Polychromatic.ContentErrorUnauthorized. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ContentErrorUnauthorized: Obsolete;
        /** @deprecated Images.Shell.CornerCheck This icon has been moved to Images.Polychromatic.CornerCheck. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CornerCheck: Obsolete;
        /** @deprecated Images.Shell.DefaultBlade This icon has been moved to Images.Polychromatic.DefaultBlade. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DefaultBlade: Obsolete;
        /** @deprecated Images.Shell.ManageAccess This icon has been moved to Images.Polychromatic.ManageAccess. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ManageAccess: Obsolete;
        /** @deprecated Images.Shell.StudentTools This icon has been moved to Images.Polychromatic.StudentTools. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const StudentTools: Obsolete;
        /** @deprecated Images.Shell.Add Use Images.Add instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Add: Obsolete;
        /** @deprecated Images.Shell.Filter Use Images.Filter instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Filter: Obsolete;
        /** @deprecated Images.Shell.Pin Use Images.Pin instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Pin: Obsolete;
        /** @deprecated Images.Shell.Save Use Images.Save instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Save: Obsolete;
        /** @deprecated Images.Shell.ArrowWideDown Use Images.ArrowDown instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ArrowWideDown: Obsolete;
        /** @deprecated Images.Shell.ArrowWideUp Use Images.ArrowUp instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ArrowWideUp: Obsolete;
        /** @deprecated Images.Shell.Collapse Use Images.CaretDown instead. Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Collapse: Obsolete;
        /**
         * Shell.JumpBar icons module
         *
         * @deprecated Images.Shell.JumpBar is deprecated.
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        module JumpBar {
            /** @deprecated Images.JumpBar.Home Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Home: Obsolete;
            /** @deprecated Images.JumpBar.Alerts Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Alerts: Obsolete;
            /** @deprecated Images.JumpBar.Journey Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Journey: Obsolete;
            /** @deprecated Images.JumpBar.Browse Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Browse: Obsolete;
            /** @deprecated Images.JumpBar.Billing Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Billing: Obsolete;
            /** @deprecated Images.JumpBar.Create Please refer to https://aka.ms/portalfx/breaking for more details. */
            const Create: Obsolete;
        }
    }
    /**
     * Status badges.
     */
    module StatusBadge {
        const Canceled: FxBaseImages.ImageFunc;
        const Critical: FxBaseImages.ImageFunc;
        const Disabled: FxBaseImages.ImageFunc;
        const Error: FxBaseImages.ImageFunc;
        const Failed: FxBaseImages.ImageFunc;
        const Info: FxBaseImages.ImageFunc;
        const None: FxBaseImages.ImageFunc;
        const Pending: FxBaseImages.ImageFunc;
        const Stopped: FxBaseImages.ImageFunc;
        const Success: FxBaseImages.ImageFunc;
        const Unknown: FxBaseImages.ImageFunc;
        const Update: FxBaseImages.ImageFunc;
        const Upsell: FxBaseImages.ImageFunc;
        const Warning: FxBaseImages.ImageFunc;
        module Outline {
            const Canceled: FxBaseImages.ImageFunc;
            const Critical: FxBaseImages.ImageFunc;
            const Disabled: FxBaseImages.ImageFunc;
            const Error: FxBaseImages.ImageFunc;
            const Failed: FxBaseImages.ImageFunc;
            const Info: FxBaseImages.ImageFunc;
            const None: FxBaseImages.ImageFunc;
            const Pending: FxBaseImages.ImageFunc;
            const Stopped: FxBaseImages.ImageFunc;
            const Success: FxBaseImages.ImageFunc;
            const Unknown: FxBaseImages.ImageFunc;
            const Update: FxBaseImages.ImageFunc;
            const Upsell: FxBaseImages.ImageFunc;
            const Warning: FxBaseImages.ImageFunc;
        }
        module Solid {
            const Error: FxBaseImages.ImageFunc;
            const Info: FxBaseImages.ImageFunc;
            const Warning: FxBaseImages.ImageFunc;
            const Unknown: FxBaseImages.ImageFunc;
        }
    }
    /**
     * Part gallery
     *
     * @deprecated Images.PartGallery is deprecated.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module PartGallery {
        /** @deprecated Images.PartGallery.CollectionPartWithRollup Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CollectionPartWithRollup: Obsolete;
        /** @deprecated Images.PartGallery.CollectionSummary Please refer to https://aka.ms/portalfx/breaking for more details. */
        const CollectionSummary: Obsolete;
        /** @deprecated Images.PartGallery.DonutChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DonutChart: Obsolete;
        /** @deprecated Images.PartGallery.DonutChartPartial Please refer to https://aka.ms/portalfx/breaking for more details. */
        const DonutChartPartial: Obsolete;
        /** @deprecated Images.PartGallery.Extensions Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Extensions: Obsolete;
        /** @deprecated Images.PartGallery.GridWithMoreData Please refer to https://aka.ms/portalfx/breaking for more details. */
        const GridWithMoreData: Obsolete;
        /** @deprecated Images.PartGallery.Map Please refer to https://aka.ms/portalfx/breaking for more details. */
        const Map: Obsolete;
        /** @deprecated Images.PartGallery.MultiLineChartMultiTrendLine Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiLineChartMultiTrendLine: Obsolete;
        /** @deprecated Images.PartGallery.MultiScatterChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiScatterChart: Obsolete;
        /** @deprecated Images.PartGallery.MultiStackedBarChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MultiStackedBarChart: Obsolete;
        /** @deprecated Images.PartGallery.MutliLineChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const MutliLineChart: Obsolete;
        /** @deprecated Images.PartGallery.PricingTier Please refer to https://aka.ms/portalfx/breaking for more details. */
        const PricingTier: Obsolete;
        /** @deprecated Images.PartGallery.QuotaGauge Please refer to https://aka.ms/portalfx/breaking for more details. */
        const QuotaGauge: Obsolete;
        /** @deprecated Images.PartGallery.ResourceMap Please refer to https://aka.ms/portalfx/breaking for more details. */
        const ResourceMap: Obsolete;
        /** @deprecated Images.PartGallery.SingleAreaChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChart: Obsolete;
        /** @deprecated Images.PartGallery.SingleAreaChartSingleThreshold Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChartSingleThreshold: Obsolete;
        /** @deprecated Images.PartGallery.SingleAreaChartSingleTrendline Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleAreaChartSingleTrendline: Obsolete;
        /** @deprecated Images.PartGallery.SingleBarChartLarge Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleBarChartLarge: Obsolete;
        /** @deprecated Images.PartGallery.SingleBarChartSmall Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleBarChartSmall: Obsolete;
        /** @deprecated Images.PartGallery.SingleLineChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleLineChart: Obsolete;
        /** @deprecated Images.PartGallery.SingleScatterChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleScatterChart: Obsolete;
        /** @deprecated Images.PartGallery.SingleScatterSingleThreshold Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleScatterSingleThreshold: Obsolete;
        /** @deprecated Images.PartGallery.SingleValueGauge Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SingleValueGauge: Obsolete;
        /** @deprecated Images.PartGallery.SplitBarChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const SplitBarChart: Obsolete;
        /** @deprecated Images.PartGallery.StackedAreaChart Please refer to https://aka.ms/portalfx/breaking for more details. */
        const StackedAreaChart: Obsolete;
    }
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.d.ts
interface KnockoutFxExt<T> {
    /**
     * Waits for the observable to change value once. Automatically unsubscribes to the observable after the single value change.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The subscription callback.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     * @returns The subscription. Can be manually unsubscribed before the next change.
     */
    fxOnce(this: KnockoutSubscribable<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (val: T) => void, predicate?: (val: T) => boolean): KnockoutSubscription<T>;
    /**
     * Async awaits for the observable to change value once
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     * @returns The promise that is used for setting up the binding with a subscription attached. This promise will throw
     *         if the subscription is disposed before the promise gets resolved.
     */
    fxAwait(this: KnockoutSubscribable<T>, lifetime: MsPortalFx.Base.LifetimeManager, predicate?: (val: T) => boolean): Promise<T> & {
        subscription: KnockoutSubscription<T>;
    };
}
interface KnockoutObservableBase<T> extends KnockoutFxExt<T> {
}
interface KnockoutSubscribable<T> extends KnockoutFxExt<T> {
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    subscribeArrayEdits(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add and delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    subscribeArrayChanges(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array bulk changes.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param callback The callback that will be invoked once with all the adds and deletes corresponding to an array change.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    subscribeArrayBulkChanges(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, callback: (addedItems: T[], deletedItems: T[]) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array add notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param addedCallback The callback that will be invoked when an item is added to the array.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    subscribeArrayAdds(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, addedCallback: (addedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Subscribes to observable array delete notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param deletedCallback The callback that will be invoked when an item is deleted from the array.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    subscribeArrayDeletes(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, deletedCallback: (deletedItem: T) => void, context?: any): KnockoutSubscription<T[]>;
    /**
     * Maps the array into the destination array.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param mapping The callback that will be invoked to map a source item to a destination item.
     * @param destination The observable array that the source array is mapped into.  If not provided a new array is created.
     * @returns The destination array is returned.
     */
    mapInto<U>(this: KnockoutReadOnlyObservableArray<T>, lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, item: T) => U, destination?: KnockoutObservableArray<U>): KnockoutObservableArray<U>;
}
interface KnockoutObservableArrayDisposable<T> extends KnockoutObservableArray<T>, KnockoutDisposable {
}
interface KnockoutArraySplice<T> {
    /**
     * The start index for the splice.
     */
    start: number;
    /**
     * The count of items to be deleted by the splice.
     */
    deleteCount: number;
    /**
     * The items to be added by the splice.
     */
    items: T[];
    /**
     * Indicates that the deleted and added items of this splice are simply moving within the array.
     * When not set the deleted items are being removed and the added items are newly added.
     * This flag is undefined unless the splices are created with the identifyMoves option.
     */
    move?: boolean;
}
declare module ko.utils {
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @returns A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    function adjustArrayEdits<T>(edits: KnockoutArrayEdit<T>[]): KnockoutArrayEdit<T>[];
    /**
     * Creates edits with adjusted indexes for sequenced application.
     *
     * @param edits The original unadjusted edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @returns A new set of edits with adjusted indexes for sequential insertion/deletion.
     */
    function adjustArrayEdits<T, U>(edits: KnockoutArrayEdit<T>[], target: U[], mapFunc: (value: T) => U): KnockoutArrayEdit<U>[];
    /**
     * Merges the knockout array edits into splices that can be applied to a target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param identifyMoves Creates seperate splices for items that are moved within the array.
     * @returns Returns an array of splices that can be applied to a target array.
     */
    function createArraySplices<T>(edits: KnockoutArrayEdit<T>[], identifyMoves?: boolean): KnockoutArraySplice<T>[];
    /**
     * Merges the knockout array edits into splices that can be applied to the target array.
     * This does the work of adjusting the indexes similar to adjustArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param target The array to target.
     * @param mapFuns Maps edit items to target array items when creating new entries for the target array.
     * @returns Returns an array of splices that can be directly applied to the target array.
     */
    function createArraySplices<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target: U[], mapFunc: (value: T) => U): KnockoutArraySplice<U>[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @returns Returns an array of the removed items.
     */
    function applyArraySplices<T>(target: T[], splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @returns Returns an array of the removed items.
     */
    function applyArraySplices<T>(target: KnockoutObservableArray<T>, splices: KnockoutArraySplice<T>[]): T[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @returns Returns an array of the removed items.
     */
    function applyArraySplices<T, U>(target: U[], splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Applies splices to the target array.
     * If the splices are created with identifyMoves the returned deletions will not include moved items.
     *
     * @param target The array to modify.
     * @param splices The splices to apply.
     * @param mapFunc Maps splice items to target items.
     * @returns Returns an array of the removed items.
     */
    function applyArraySplices<T, U>(target: KnockoutObservableArray<U>, splices: KnockoutArraySplice<T>[], mapFunc: (value: T) => U): U[];
    /**
     * Establishes a two-way binding between the specified observables.
     *
     * @param lifetimeManager
     * @param The first observable whose initial value take precedence while setting up the binding.
     * @param The second observable.
     * @returns The subscriptions that are used for setting up the binding. Dispose these subscriptions to disconnect
     * the binding.
     */
    function twoWayBinding<T>(lifetime: MsPortalFx.Base.LifetimeManager, source: KnockoutObservableBase<T>, destination: KnockoutObservableBase<T>): MsPortalFx.Base.DisposableLifetimeManager;
    /**
     * Wraps a value (not an array) in an observable or return the value if it already was observable
     *
     * @param value The value to wrap.
     */
    function wrap<T>(value: T | KnockoutObservableBase<T>): KnockoutObservableBase<T>;
    /**
     * Wraps an array in an observable or return the value if it already was an observable array
     *
     * @param value The array to wrap.
     */
    function wrapArray<T>(array: T[] | KnockoutObservableArray<T>): KnockoutObservableArray<T>;
    /**
     * Unwraps a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param unwrapLast Indicates if the last value of the path should be unwrapped.  The default is true.
     * @returns The value of the property or undefined if not evaluated.
     */
    function unwrapObservablePath(value: any, path: string, unwrapLast?: boolean): any;
    /**
     * Peeks a property value specified by a path.
     * Stops evaluation if any intermediate property in the path returns a falsey value.
     *
     * @param value The value to read the property from.
     * @param path The property path using . delimeters.
     * @param peekLast Indicates if the last value of the path should be peeked.  The default is true.
     * @returns The value of the property or undefined if not evaluated.
     */
    function peekObservablePath(value: any, path: string, peekLast?: boolean): any;
}
declare module FxImpl {
    import FxBase = MsPortalFx.Base;
    /**
     * Internal high performance ApplyArrayEdits.  Apply minimum amount splice call given arrayEdits.
     *
     * @param underlyingArray The array to target.
     * @param edits ArrayEdits return by ko.utils.compareArray.
     * @param Options addition argument.
     *          spliceFunc: allow custom splice-like function to be pass in.  Othersize, Array.splice is the default to perform on the array.
     *          inplaceFixup: if the arrayEdits index haven't fix up yet.  pass true to adjust arrayEditIndex while look for the minimum splice to called.  It will not change arrayEdit.index
     * @returns spliceCalls : return the number of splice performed on target Array.
     */
    let quickApplyArrayEdits: <T>(underlyingArray: T[], arrayEdits: KnockoutArrayEdit<T>[], options?: {
        spliceFunc?: typeof Array.prototype.splice;
        inplaceFixup?: boolean;
    }) => number;
    /**
     * Merges the knockout array edits into splices that can be applied to the target array.
     * This does the work of adjusting the indexes similar to fixupArrayEdits.
     *
     * @param edits The knockout array edits.
     * @param identifyMoves Creates seperate splices for items that are moved within the array.
     * @param target The array to target.
     * @param mapFunc Maps edit items to target array items when creating new entries for the target array.
     * @returns Returns an array of splices that can be directly applied to the target array.
     */
    function createArraySplicesInternal<T, U>(edits: KnockoutArrayEdit<T>[], identifyMoves: boolean, target?: U[], mapFunc?: (value: T[]) => U[]): KnockoutArraySplice<U>[];
    /**
     * Subscribes to observable array edit notifications.
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param source The array to subscribe to.
     * @param callback The callback that will be invoked when edits are made to the array.
     * @param context The optional this context for the callback.
     * @returns The knockout subscription.
     */
    function subscribeArrayEdits<T>(lifetime: FxBase.LifetimeManager, source: KnockoutReadOnlyObservableArray<T> | KnockoutProjectableComputedArray<T>, callback: (edits: KnockoutArrayEdit<T>[]) => void, context?: any): KnockoutSubscription<T>;
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.d.ts
declare module ko {
    import LifetimeManager = MsPortalFx.Base.LifetimeManager;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    function explicitComputed<T, U>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    function explicitComputed<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Sets up a reactor, i.e., something that watches for changes to a set of observables
     * or computeds, and takes some action each time any of them changes.
     *
     * @param lifetime The lifetime of the reactor, meaning that it will automatically be disposed when the lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param evaluator A callback function that reads one or more observables/computeds and takes some action.
     *                  This will be invoked once initially, and then any time any dependency changes.
     *                  The set of dependencies may change arbitrarily on each evaluation.
     */
    function reactor<T>(lifetime: LifetimeManager, dependency: KnockoutObservableBase<T>, evaluator: (dependencyValue?: T) => void): void;
    function reactor<T>(lifetime: LifetimeManager, dependencies: KnockoutObservableBase<any> | KnockoutObservableBase<any>[], evaluator: (...dependenciesValues: any[]) => void): void;
    function reactor<T>(lifetime: LifetimeManager, evaluator: () => void): void;
}

// FILE: MsPortalFx\Base\Base.KnockoutExtensions.Lifetime.ambient.d.ts
interface KnockoutSubscribable<T> {
    /**
     * Subscribes to receive notification when the observable/computed changes value.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @returns A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribe(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
    /**
     * Subscribes to receive notification when the observable/computed changes value and run subscription once.
     *
     * @param lifetime The lifetime of the subscription, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param callback The callback to be invoked when the observable/computed changes value.
     * @param target If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param topic If specified, determines which kind of change notification to respond to.
     *              You can omit this if you simply want notifications when the observable/computed changes value.
     *              See Knockout documentation for more details.
     * @returns A subscription instance. Note that you don't need to dispose this manually if the 'lifetime' object will itself get disposed.
     */
    subscribeAndRun(lifetime: MsPortalFx.Base.LifetimeManager, callback: (newValue: T) => void, target?: any, topic?: string): KnockoutSubscription<T>;
    /**
     * Waits for the observable to change value once. Automatically unsubscribes to the observable after the single value change.
     *
     * @param lifetime The lifetime manager for the subscription, and will run if the current value meets the predicate
     * @param callback The subscription callback.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     *        Defaults to (val) => !!val
     * @returns The subscription. Can be manually unsubscribed before the next change.
     */
    fxOnceAndRun(lifetime: MsPortalFx.Base.LifetimeManager, callback: (val: T) => void, predicate?: (val: T) => boolean): KnockoutSubscription<T>;
    /**
     * Async awaits for the observable to change value once, and will resolve if the current value meets the predicate
     *
     * @param lifetime The lifetime manager for the subscription.
     * @param predicate An optional function which will determine if the value should run the callback or wait for the next value.
     *        Defaults to (val) => !!val
     * @returns The promise that is used for setting up the binding with a subscription attached. This promise will throw
     *         if the subscription is disposed before the promise gets resolved.
     */
    fxAwaitAndRun(lifetime: MsPortalFx.Base.LifetimeManager, predicate?: (val: T) => boolean): Promise<T> & {
        subscription: KnockoutSubscription<T>;
    };
}
interface KnockoutComputedStatic {
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T, U>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<U>, func: (dependencyValue?: U) => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     *             The arguments of that function are the unwrapped dependencies in order, e.g. ko.explicitComputed(lifetime, [dep1, dep2], (val1, val2) => { ... });
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], func: ((...dependenciesValues: any[]) => T) | (() => T), context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with a single dependency.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependency A dependency for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependency: KnockoutObservableBase<any>, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates an explicit Knockout computed instance with multiple dependencies.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param dependencies An array of dependencies for the explicit computed to watch.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, dependencies: KnockoutObservableBase<any>[], options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param func A callback that gives the value of the computed. This is invoked whenever any of its dependencies changes.
     * @param context If specified, gives a 'this' value to be used when invoking the callback. This is not usually needed when using TypeScript.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, func: () => T, context?: any, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
    /**
     * Creates a Knockout computed instance.
     *
     * @param lifetime The lifetime of the computed, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param options See Knockout documentation.
     * @returns A Knockout computed instance.
     */
    <T>(lifetime: MsPortalFx.Base.LifetimeManager, options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @returns A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @returns A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}
interface KnockoutProjectableComputedArray<T> extends KnockoutComputed<T[]> {
    /**
     * Produces a new array by mapping each item in the source array.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the mapped array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param mapping A function that transforms input array entries to output array entries.
     * @returns A computed array value representing the mapping result.
     */
    map<TResult>(lifetime: MsPortalFx.Base.LifetimeManager, mapping: (itemLifetime: MsPortalFx.Base.LifetimeManager, value: T) => TResult): KnockoutProjectableComputedArray<TResult>;
    /**
     * Produces a new array by filtering the source array according to a predicate.
     * The resulting array updates observably as the source array changes.
     *
     * @param lifetime The lifetime of the filtered array, meaning that it will automatically be disposed when this lifetime object is disposed.
     *                 Typically this should be the 'container' supplied to a UI component such as a part.
     * @param predicate A predicate that determines which entries should be included in the output array.
     * @returns A computed array value representing the mapping result.
     */
    filter(lifetime: MsPortalFx.Base.LifetimeManager, predicate: (value: T) => boolean): KnockoutProjectableComputedArray<T>;
}

// FILE: MsPortalFx\Base\Base.Net.d.ts
declare module FxImpl {
    /**
     * The lowercased base domain of ARM. Used to handle scenarios in which Portal is using an ARM subdomain.
     */
    let baseArmAuthorityLowerCase: string;
    let authTokenDomainValidator: ReturnType<typeof getDomainValidator>;
    let extensionName: string;
    const enum HeaderNames {
        AcceptLanguage = "Accept-Language",
        ArmBreakGlassInternal = "x-ms-arm-internal-break-glass",
        AuthN = "Authorization",
        CacheControl = "Cache-Control",
        CacheTag = "x-ms-cache-tag",
        EffectiveLocale = "x-ms-effective-locale",
        ExtensionFlags = "x-ms-extension-flags",
        FailureCause = "x-ms-failure-cause",
        LoggedOut = "x-ms-force-login",
        PathAndQuery = "x-ms-path-query",
        Pragma = "Pragma",
        SessionId = "x-ms-client-session-id",
        Version = "x-ms-version",
        VersionMismatch = "x-ms-version-mismatch",
        CommandName = "x-ms-command-name",
        RequestId = "x-ms-client-request-id",
        WwwAuthenticate = "WWW-Authenticate",
        RequestCorrelationId = "x-ms-correlation-request-id",
        GraphRequestCorrelationId = "client-request-id",
        XmsFeatureFlags = "x-ms-feature-flags"
    }
    /**
     * The resource name alias for the non-CAE ARM resource.
     */
    const nonCaeArmAliasLowerCase = "noncaearm";
    /**
     * The error code returned when a sensitive operation is cancelled using the confirmation dialog.
     * Do not change this string without coordinating with IaaS.
     */
    const ameCancelledErrorCode = "AmeCancelled";
    /**
     * Gets the ARM endpoint.
     *
     * @returns The ARM endpoint.
     */
    function getArmEndpoint(): string;
    /**
     * A simple helper function for hashing a string.
     *
     * @param str The string to hash.
     * @returns a number representing the string.
     */
    function getHashCode(str: string): number;
    /**
     * Gets a domain validator with the specified set of trusted domains.
     *
     * @param trustedDomains The list of trusted domains provided by the extension.
     * @param logFailures An optional flag indicating failures should be logged to ExtEvents.
     * @returns A function that can validate trusted domains.
     */
    function getDomainValidator(trustedDomains: readonly string[], logFailures?: boolean): {
        validateDomain: (uriOrDomain: string) => boolean;
        trustedDomainsList: string;
    };
    /**
     * Validates that the specified domain is trusted.
     *
     * @param domainLowerCase The domain to validate.
     * @returns A boolean indicating if the domain is trusted or not.
     */
    function validateDomain(domainLowerCase: string): boolean;
    /**
     * Returns the sensitive resource IDs from the request.
     * "Sensitive" is defined as any resource that could disrupt production services if created or deleted.
     *
     * @param uri The URI being called.
     * @param httpMethod The HTTP method of the request.
     * @param content The request body.
     * @returns the set of sensitive resource IDs from the request.
     */
    function getSensitiveResourceIdsFromAjaxRequest(uri: string, httpMethod: string, content?: any): string[];
    /**
     * Returns the highly-sensitive resource IDs from the request.
     * "Highly-sensitive" is defined as any resource that could disrupt production services if deleted.
     *
     * @param uri The URI being called.
     * @param httpMethod The HTTP method of the request.
     * @param content The request body.
     * @returns the set of highly-sensitive resource IDs from the request.
     */
    function getHighlySensitiveResourceIdsFromAjaxRequest(uri: string, httpMethod: string, content?: any): string[];
}
declare module MsPortalFx.Base {
    import FxHelpers = MsPortalFx.Helpers;
    import FxImplExtension = FxImpl.Extension;
    import FxBase = MsPortalFx.Base;
    import FxErrors = MsPortalFx.Errors;
    import ErrorLevel = FxErrors.ErrorLevel;
    module Net2 {
        /**
         * Ajax XHR.
         */
        export import JQueryXHRLike = FxHelpers.JQueryXHRLike;
        /**
         * Ajax function.
         *
         * @param settings The Ajax request settings.
         * @returns The Ajax XHR.
         */
        type AjaxFunc<T> = (settings: JQueryAjaxSettings<T>) => JQueryXHRLike<T>;
        export import HttpStatusCode = Common.Ajax.HttpStatusCode;
        function isRetryable(xhr: FxHelpers.XMLHttpRequestLike): boolean;
        /**
         * Contract for parameters returned by the cachedAjax function
         */
        interface AjaxCachedResult<T> {
            cachedAjax?: boolean;
            data?: T;
            modified?: boolean;
            textStatus?: string;
            cacheTagValue?: string;
            jqXHR?: JQueryXHR<T>;
        }
        /**
         * Authorization options for targeted tokens.
         */
        interface AuthorizationOptions {
            /**
             * The resource name to get the token for.
             */
            resourceName: string;
        }
        /**
         * The contract of a JQueryPromise that is returned by Base.Net2.ajax.
         */
        interface NetAjaxSettings<T> extends JQueryAjaxSettings<T> {
            /**
             * Determines whether the ajax request is part of a background task.
             * If true the request is executed one at a time so only one background task is in flight at a time.
             */
            isBackgroundTask?: boolean;
            /**
             * @deprecated The checkVersion flag is no longer supported since the portal framework always returned compatibility as true.
             */
            checkVersion?: boolean;
            /**
             * Determines whether to retry the ajax call if one of the following conditions is met:
             *  1. Failure appears to be coming from an intermediary proxy
             *  2. Request times out
             *  3. Response status code is 500
             *  By default it use fibonacci to make sure fast initial retries. with times, it waits will be longer. (for default,  12 retries)
             *  1, 1, 2, 3, 5, 8, 13, ... the max wait time: sum(fibonacci (0 -11)) is 232.  232 * 400ms =  92800 (about 1.5 minutes.)
             */
            performRetry?: boolean;
            /**
             *  If performRetry === true, this is the maximum duration that it will retried if the ajax (Date.now() - ajaxStartRequest) < maxRetryDuration.
             */
            maxRetryDuration?: number;
            /**
             * If this option is set to a string (typically "api/invoke") and the input URI is an absolute URI,
             * the URI is parsed and the path and query is set on the x-ms-path-query header that is used when talking to
             * external services (ARM). Using this header instead of the path and query string of the URI helps amortize
             * the overhead of the CORS OPTIONS calls. Typically we can get down to 1 OPTIONS call for all calls to ARM
             * down from the typical of one per request.
             */
            invokeApi?: string;
            /**
             * Determines whether to automatically obtain and append an authorization header.
             * If undefined, the authorization header is appendended automatically for all relative URIs,
             * but skipped for absolute URIs.
             *
             * Set to true to append the default authorization header.
             * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
             */
            setAuthorizationHeader?: boolean | AuthorizationOptions;
            /**
             * Data to append a request header as x-ms-command-name for ARM calls.
             *
             * Set to a non-empty string to append the header. The value should be 60 characters or less and will be trimmed
             * if longer.  This data will also used as AjaxError's additional data for diagnostic purpose.
             */
            setTelemetryHeader?: string;
            /**
             * If this option is undefined or false and the response returns 403 containing 'x-ms-failure-cause: gateway' header,
             * will result in retrying the request with 'cache-control: none' header. This is done to bypass server side caching
             * by external services (ARM).
             */
            skipRetryOnForbidden?: boolean;
            /**
             * Determines whether to avoid all headers that are included by the framework.
             */
            useRawAjax?: boolean;
            /**
             * Determines whether to return the detailed error (this is set to true) or the simple string error.
             */
            detailedError?: boolean;
            /**
             * The response type of the request
             */
            responseType?: string;
            /**
             * Determines whether to skip telemetry collection from the network request. The default is false.
             */
            skipTelemetry?: boolean;
            /**
             * The original URI which will be set if we switch the uri to use invokeApi.
             */
            originalUri?: string;
            /**
             * The URI to make the request to.
             */
            uri: string;
            /**
             * Optional boolean flag to use the FX ARM endpoint if the URI above is a relative URI.
             */
            useFxArmEndpoint?: boolean;
            /**
             * Skips the domain validation check. This should not be set to true unless you are sure that the domain
             * you are using is known to be a trusted domain.
             */
            skipDomainValidation?: boolean;
            /**
             * Disable the network connection error dialog when there is an unknown network error. An unknown network
             * is usually raised when the browser surfaces a status code 0.
             */
            ignoreUnknownNetworkError?: boolean;
        }
        /**
         * The contract for the detailed error values when the detailedError flag is set on the AJAX settings. This
         * replaces the simple string error value with a composite object which includes the simple error value and
         * the response text.
         */
        interface NetAjaxDetailedError {
            /**
             * The error which would have been the simple error value.
             */
            error: string;
            /**
             * The response text in the case of an error.
             */
            responseText: string;
            /**
             * The error level for logging the error.
             *
             * If this error is used to reject a promise and the rejection is unhandled
             * the errorLevel will determine how the unhandled rejection is logged.
             */
            errorLevel?: ErrorLevel;
        }
        /**
         * The base contract for extended information provided by responses of ajax calls.
         */
        interface BaseResponse<T> {
            /**
             * The XHR of the response.
             */
            jqXHR: JQueryXHR<T>;
            /**
             * The text status.
             */
            textStatus?: string;
        }
        /**
         * The contract for extended information provided by responses of succeeded ajax calls.
         */
        interface Response<T> extends BaseResponse<T> {
            /**
             * The content of the response.
             */
            content: T;
        }
        /**
         * The contract for extended information provided by responses of failed ajax calls.
         */
        interface ErrorResponse<T> extends BaseResponse<T> {
            errorThrown: string;
        }
        /**
         *  Extensions can opt out of the automatic ajax version check if their data APIs are not
         *  compatible for some reason.
         */
        function disableAjaxServerVersionCheck(): void;
        /**
         * Extensions can set a callback which will be called when an Ajax call that results
         * in a server error response. This method allows the callback method to be set.
         * The callback method shoud be of type AjaxLogFunc which matches the same shape as
         * Base.Diagnostics.Log.error().
         *
         * @param callback The function called when an Ajax call results in a server error response.
         * @param sanitizeCallback Custom callback to sanitize uri and pathAndQuery. The default sanitizer
         * uses MsPortalFx.sanitizeMessage.
         */
        function setAjaxLogFunc(callback: FxBase.Diagnostics.LogFunc, sanitizeCallback?: (input: string) => string): void;
        /**
         * Extensions can set a the function that will be called for executing Ajax call.
         *
         * @param func The function called to invoke an Ajax call. Passing null will restore the default ajax function.
         * @returns The default ajax function that func parameter replaces.
         */
        function setAjaxFunc<T>(func: AjaxFunc<T>): AjaxFunc<T>;
        module Internal {
            interface Environment {
                betweenRetry: number;
            }
            let environment: Environment;
            /**
             * Internal helper function for getting the ARM endpoint.
             * Use getEndpoints() in Fx/Ajax to get well known endpoints.
             *
             * @returns ARM endpoint
             */
            function getArmEndpoint(): string;
            /**
             * Performs an ajax request with the appropriate headers set. (Internal use only.)
             *
             * @param settings The settings that are to be passed to the ajax call.
             * @returns A promise for the ajax call.
             */
            function ajaxExtended<T>(settings: NetAjaxSettings<T>): Promise<Response<T>>;
            /**
             * Internal class. Do not use.
             */
            class AjaxCaller {
                ajaxStatus: KnockoutObservable<FxImplExtension.ExtensionStatus>;
                unknownErrorStatusCode: number;
                skipVersionCheck: boolean;
                private _initialized;
                private _acceptLanguage;
                private _effectiveLocale;
                private _getAuthTokenFunc;
                private _extensionFlags;
                private _stall;
                private _unknownErrors;
                private _backgroundTask;
                private _blockUntrustedDomains;
                private _version;
                private _salFeatureFlagEnabled;
                private _salEffectiveValue;
                initialize(getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => Promise<string>, extensionFlags?: any, effectiveLocale?: string): void;
                postJSON<T>(settings: NetAjaxSettings<T>, data: any): Promise<T>;
                ajaxExtended<T>(settings: NetAjaxSettings<T>): Promise<Response<T>>;
                ajax<T>(settings: NetAjaxSettings<T>): Promise<T>;
                private _getSalExpValue;
                private _ajaxFuncImpl;
                private _execAjaxWithGetAuth;
                private _executeAjaxCall;
                cachedAjax<T>(settings: NetAjaxSettings<T>): Promise<AjaxCachedResult<T>>;
                private _worker;
            }
            /**
             * Internal function. Do not use.
             */
            function reset(): void;
        }
        /**
         * Performs an ajax request with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @param data The data to be sent to the server. The data will be run through JSON.stringify before posting (even if it is alaready a string).
         * @returns A promise for the ajax call.
         */
        function postJSON<T>(settings: NetAjaxSettings<T>, data: any): Promise<T>;
        /**
         * Performs an ajax request using caching with the appropriate headers set.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @returns A promise for the ajax call.
         */
        function ajax<T>(settings: NetAjaxSettings<T>): Promise<T>;
        /**
         * Performs an ajax request using caching with the appropriate headers set and returns XML Http Response.
         *
         * @param settings The settings that are to be passed to the ajax call.
         * @returns A promise for the ajax call including XML Http Response.
         */
        function ajaxExtended<T>(settings: NetAjaxSettings<T>): Promise<Response<T>>;
        /**
         * Internal. Do not use.
         *
         * @returns Ajax caller
         */
        function getSingleton(): Net2.Internal.AjaxCaller;
        /**
         * Performs an ajax POST request.
         *
         * @param settings The settings that are to be passed to the ajax call.
         *                 uri is the only required parameter in settings.
         *                 The contentType, data, and type properties of the settings will be overwritten with the right values for posting JSON.
         * @returns A promise for the ajax call.
         */
        function cachedAjax<T>(settings: NetAjaxSettings<T>): Promise<AjaxCachedResult<T>>;
        /**
         * Invalidate the cache header for cachedAjax.
         *
         * @param headers Set of ajax headers.
         */
        function invalidateCacheHeader(headers: any): void;
        /**
         * Set the cache header value for cachedAjax.
         *
         * @param headers Set of ajax headers.
         * @param cacheTagValue The cache tag value.
         * @returns mutated result with cache tag header set.
         */
        function setCacheHeader(headers: any, cacheTagValue: string): any;
        /**
         * Initialize the Base.Net module.
         *
         * @param getAuthorizationTokenFunc The callback that returns the authorization token.
         */
        function initialize(getAuthorizationTokenFunc: (options?: FxImplExtension.GetAuthorizationTokenOptions) => Promise<string>): void;
        /**
         * Gets the logged out promise.
         *
         * @returns The status of the Ajax (logged out, or .
         */
        let status: KnockoutComputed<FxImplExtension.ExtensionStatus>;
        /**
         * Disables AJAX version checking.
         *
         */
        function disableVersionCheck(): void;
    }
}

// FILE: MsPortalFx\Base\Base.Promises.d.ts
declare module MsPortalFx.Base.Promises {
    import CanceledError = MsPortalFx.Errors.CanceledError;
    /**
     * Promise states constants.
     */
    module PromiseStates {
        /**
         * Fulfilled.
         */
        const fulfilled = "fulfilled";
        /**
         * Rejected.
         */
        const rejected = "rejected";
    }
    /**
     * Wraps a promise to make to make it cancelable.
     * Calls catch and finally handlers when canceled.
     *
     * Creates a deferred promise that wraps the underlying promise results.  The returned
     * promise is a native promise.  The promise will return similarly cancelable promises
     * for each fulfillment or progress handler that is attached.  Catch and finally handlers
     * will not be cancelable and stop the cancelable promise chain.
     *
     * This method aggresively cancels promises.  When canceled all pending chained promises
     * are immediately rejected with a cancelation error.  Work that is pending will keep running
     * to completion or failure but will not change the promise resolution.
     *
     * Here are the semantics in code form:
     *
     * makeCancelable(promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     * or
     * makeCancelable(() => promise, token).then((value) => {
     *     // Work that will not be called if the cancelationToken is canceled before it
     * }).then((value) => {
     *     // More work that will not be called if the cancelationToken is canceled before it
     * }).catch((error) => {
     *     // Error handling that will be called if there is a failure or cancelation.
     *     // When canceled the error will be an MsPortalFx.Errors.CanceledError as specified by token.cancel(error)
     * }).finally(() => {
     *     // Cleanup that will always be called
     * });
     *
     * If you have cleanup where you need to do one thing if successful and another if failed/canceled you can
     * attach a then(fulfill, reject) with both fulfill and reject handlers.  Specifying the reject handler will
     * terminate the cancelable chain.
     *
     * @param promiseOrTaskToExecuate
     *     If type is a Promise to add cancelation to.
     *     If Type is a function < taskToExecute () => Promise> to add cancelation to.  Note: If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param cancelationToken Cancellation token.
     * @returns Cancelable promise.
     */
    const makeCancelable: <T>(promiseOrTaskToExecute: PromiseLike<T> | (() => PromiseLike<T> | T), cancelationToken: MsPortalFx.Base.Promises.CancelationToken) => Promise<T>;
    /**
     * Cancels the promise if the lifetime is disposed or null prior to resolution or rejection.
     *
     * If canceled the promise will be rejected with MsPortalFx.Errors.CancelationError.
     *
     * @param lifetime The lifetime that causes cancelation.  May be null indicating the lifetime was already disposed.
     * @param promiseOrTaskToExecuate
     *     If type is a Promise to add cancelation to.
     *     If Type is a function <taskToExecute: () => PromiseV<T>> to add cancelation to.  If cancelation token is already canceled, it make sure taskToExecute will not be executed.
     * @param message The cancelation error message.
     * @returns Promise that will be rejected with a CancelationError if disposed before the promise parameter is resolved or rejected.
     */
    function cancelOnDispose<T>(lifetime: MsPortalFx.Base.LifetimeManager, promiseOrTaskToExecute: PromiseLike<T> | (() => PromiseLike<T> | T), message?: string): Promise<T>;
    /**
     * An object that defines whether or not its associated CancelablePromise instances
     * have been canceled. Once the 'canceled' flag is set, it cannot be unset.
     */
    class CancelationToken {
        /**
         * Gets the cancellation reason.
         */
        cancelation: KnockoutReadOnlyObservable<CanceledError>;
        /**
         * True if the associated CancelablePromise instances have been canceled; false otherwise.
         */
        get canceled(): boolean;
        /**
         * Ensures the CancelationToken has been set so that associated CancelablePromise instances have been canceled.
         *
         * @param cancelation Optional error for specifying the cancelation when using makeCancelable.
         * @returns The first cancelation applied.
         */
        cancel(cancelation?: CanceledError): CanceledError;
    }
}

// FILE: MsPortalFx\Base\Base.ProxiedObservables.d.ts
declare module MsPortalFx.Base.ProxiedObservables {
    /**
     * Gets an object to used to store data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @returns An object.  Can be null if metadataContainer is null;
     */
    const dataContainer: (obj: any) => StringMap<any>;
    /**
     * Gets an object to used to store disposable data for the given object. Returns undefined if no object can be provided.
     *
     * @param obj The object with which the returned object is associated.
     * @returns An object.  Can be null if metadataContainer is null;
     */
    const disposableDataContainer: (obj: any) => StringMap<Disposable>;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @returns The value.
     */
    const data: (obj: any, key: string, value?: any) => any;
    /**
     * Returns data from the given object with the given key.
     * Or Set value for the given object with the given key.
     *
     * @param obj The object with which the returned object is associated.
     * @param key The key for the data.
     * @param value The value to write.
     * @returns The value.
     */
    const disposableData: <T extends Disposable>(obj: any, key: string, value?: T) => T;
    /**
     * Marks an object as non-serializable. An error is raised for non-serializable objects that are proxied across.
     *
     * @param obj The object to be marked non-serializable.
     */
    function markNonSerializable(obj: Object): void;
}

// FILE: MsPortalFx\Base\Base.ProxiedObservablesV2.d.ts
declare module FxImpl.Po {
    import FxBase = MsPortalFx.Base;
    export interface ObservableMutation {
        count: number;
        history?: ChangeDescriptor[];
    }
    export const enum PropertyFreezeLevel {
        None = 0,
        NotDeletable = 1,
        ReadOnly = 2
    }
    export interface MetadataContainerBase {
        /**
         * When this property is been set, the corresponding object cannot be serialize.
         */
        isNonSerializableCallStack?: string;
        /**
         * This flag indicates whether remote mutation is disallowed.
         */
        disallowRemoteMutations?: boolean;
    }
    /**
     * Specifies the promise state.
     */
    export const enum PromiseState {
        Pending = 0,
        Resolved = 1,
        Rejected = 2,
        Max = 3
    }
    /**
     * Specifies the data type of the serialized data.
     */
    const enum DataType {
        Observable = 0,
        ObservableArray = 1,
        Error = 2,
        Object = 3,
        Date = 4,
        RegExp = 5,
        Promise = 6,
        Deferred = 7,
        Function = 10,
        Array = 11,
        Computed = 12,
        ArrayBuffer = 13,
        Removed = 14,
        Max = 15
    }
    /**
     * Specifies how an array element was modified with respect to the array.
     */
    export const enum ArrayChangeKind {
        /**
         * The element was added.
         */
        Added = 0,
        /**
         * The element was deleted.
         */
        Deleted = 1
    }
    /**
     * Defines the metadata data structure.
     * In one iframe, one object have only one metadata.
     *
     */
    export interface Metadata extends MetadataContainerBase {
        /**
         * Metadata also been used to store original array. When serializing observable array, Po will
         * shallow clone its underlying array and save it to metadata, we call it original array, the
         * original array will be used when handle array change.
         *   For example:
         *   1. var arr1 = ko.observableArray([1, 2]);
         *   2. When serializing arr1, Po will save [1, 2] to its metadata:
         *        metadata[poManager.arrayId] = originalArray;
         *   3. When observableArray been updated:
         *        arr1.push(3);
         *   4. PoManager will compare arr1.peek() with originalArray and get the differences
         *   5. PoManager will send the differences to another po:
         *        [{ k: add, i: 2, v: ["3"]]
         */
        [key: string]: any | any[];
        /**
         * The id that identifies this proxied object. One object have unique id within browser.
         */
        id: string;
        /**
         * The desired value when apply observable change.
         */
        desiredValue?: any;
        disallowRemoteMutations?: boolean;
        /**
         * This map is used to store all array's owners. When an array been set to observable, the observable become the owner of that array.
         * One array can belong to multiple observables, one observable can only own one array.
         *
         * For example:
         *   const arr = [];
         *   const ob = ko.observable(arr); // ob is the owner of arr
         *
         * This property is only applicable in development mode and only applies to arrays.
         */
        arrayOwners?: StringMap<string>;
    }
    /**
     * Defines serialization result.
     */
    export interface SerializationResult extends Array<any> {
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     *
     * The lifecycle of gc:
     *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
     *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
     *  3. Secondary Po dispose objects and sends cIds to Primary Po.
     *  4. Primary Po disposes pending disposed objects.
     */
    export interface ReleaseEventDescriptor {
        /**
         * The root object id.
         * This property being used to release the single root object, when
         * this property set, all other property will be undefined. for example: {rId:"00-0.content.title"}
         */
        rId?: string;
        /**
         * The initial ids.
         */
        iIds?: string[];
        /**
         * The confirmed ids.
         */
        cIds?: string[];
    }
    /**
     * Defines release event descriptor.
     * Use abbreviations because this object been sent across iframes
     * The description of a change of an array, this interface been used inside ChangeDescriptor.
     */
    export interface ArrayChange {
        /**
         * The array change kind
         * How the array element was changed.
         */
        k: ArrayChangeKind;
        /**
         * The index indicate where the array element was changed.
         */
        i: number;
        /**
         * The new value of the array element if the element was added.
         */
        v?: SerializationResult;
    }
    /**
     * Defines a change of an observable/observableArray.
     * Use abbreviations because this object been sent across iframes
     */
    export interface ChangeDescriptor {
        /**
         * The proxied observable object id, this value is unique within browser.
         */
        id: string;
        /**
         * The new object change (set to observable), this property being used when observable updated.
         */
        o?: SerializationResult;
        /**
         * The array changes, this property being used when observable array updated.
         */
        a?: ArrayChange[];
        /**
         * The full array, this property being used to recover observable array after simultaneous changes.
         */
        fa?: SerializationResult[];
        /**
         * The change number of the observable/observable array.
         */
        cn: number;
        /**
         * The serial number of the observable array.
         * It's undefined by default, this number will incremental update when there is simultaneous change
         */
        sn?: number;
    }
    /**
     * Defines promise event descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    export interface PromiseEventDescriptor {
        /**
         * The promise id, this value is unique within browser
         */
        id: string;
        /**
         * The promise state
         */
        s: PromiseState;
        /**
         * The promise value
         */
        v?: SerializationResult;
    }
    /**
     * Defines function invocation descriptor.
     * Use abbreviations because this object been sent across iframes
     */
    export interface ProxyFunctionInvocationDescriptor {
        /**
         * The function call id.
         * One function can be called multiple times in a short period of time, use funcCallId to identify the different calls.
         */
        cid: string;
        /**
         * The function id, this value is unique within browser
         */
        fid: string;
        /**
         * "this" pointer of the function call.
         */
        t: SerializationResult;
        /**
         * The function call arguments.
         */
        a: SerializationResult[];
    }
    /**
     * The common interface that all promise implementations share
     */
    export interface AnyPromise<T = void> {
        /**
         * Like a finally clause, allows you to observe either the fulfillment or rejection of a promise, but to do so without modifying the final value. This is useful for collecting resources regardless of whether a job succeeded, like closing a database connection, shutting a server down, or deleting an unneeded key from an object.
         * finally returns a promise, which will become resolved with the same fulfillment value or rejection reason as promise. However, if callback returns a promise, the resolution of the returned promise will be delayed until the promise returned from callback is finished.
         */
        finally(finallyCallback: () => any): AnyPromise<T>;
        /**
         * The then method from the Promises/A+ specification, with an additional progress handler.
         */
        then<TResult>(onFulfill: (value: T) => TResult | AnyPromise<never>, onReject?: (reason: any) => TResult): AnyPromise<TResult>;
        then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value?: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): AnyPromise<TResult1 | TResult2>;
        /**
         * A sugar method, not avaiable on native promises
         */
        progress?(onProgress: (progress: any) => any): AnyPromise<T>;
    }
    /**
     * The common interface that any deferred implementation exposes
     */
    export interface AnyDeferred<T> {
        promise: AnyPromise<T>;
        resolve(value?: T | AnyPromise<T>): void;
        reject(reason?: any): void;
        /**
         * Native promises do not implement notify so this is a optional property
         */
        notify?(value?: any): void;
    }
    export const enum PromiseImplementationType {
        NativePromise = 0,
        Q = 1,
        JQuery = 2
    }
    export interface PromiseAdapter {
        /**
         * The data type
         */
        type: DataType.Deferred | DataType.Promise;
        /**
         * The implementation type
         * This is used to recreate the same promise implementation in the client
         */
        implementation: PromiseImplementationType;
        deferred: AnyDeferred<any>;
        promise: AnyPromise<any>;
        getState(): PromiseState;
        getValue(): any;
        always(finallyCallback: (value: any) => any): void;
    }
    export const enum ExceptionCode {
        UnsupportedPromiseCompleteState = 100,
        UnsupportedPromiseState = 101,
        UnsupportedAdapterPromiseState = 102,
        UnsupportedFunctionResultKind = 103,
        UnsupportedReferenceDataType = 104,
        UnsupportedDataTypeForSerialization = 105,
        UnsupportedArrayChangeKind = 106,
        UnsupportedFixupDataType = 107,
        UnsupportedDataTypeForDeserialization = 108,
        FailedToReleaseRootObject = 202,
        FailedToGetPromiseValue_CannotFindMetadata = 203,
        FailedToApplyObservableChange_InvalidDescriptor = 204,
        FailedToApplyRelease_InvalidDescriptor = 205,
        FailedToReleaseRootObject_TheInputIsNotARootObjectId = 206,
        FailedToGetObject_ObjectHasBeenFreed = 207,
        FailedToInvokeFunction_DeserializeThisFailed = 209,
        FailedToDecide_PrimaryLocalWindowIdEqualsToRemoteWindowId = 210,
        FailedToReset_SomePoNotBeenDispose = 211,
        FailedToDeserialize_ObjectHasBeenReleased = 212,
        FailedToDeserialize_CircularReferenceDetected = 213,
        FailedToDeserialize_CannotFindPrototype = 214,
        FailedToApplyObservableChange_DisallowRemoteMutations = 216,
        FailedToSerialize_ObjectIsNonSerializable = 217,
        FailedToDeserialize_InputIsNotValid = 218,
        FailedToSerialize_ObjectMetadataIsNotClean = 219,
        CannotFindObject_onFunctionPromise = 220,
        CannotFindObject_ApplyPromiseChanges = 221,
        CannotFindObject_ProxyFunction = 222,
        CannotFindObject_ApplyChange = 224,
        CannotFindObject_InvokeFunction = 225,
        CannotFindObject_IsDisallowRemoteMutations = 226,
        FailedToSerialize_ObjectUsedReservedCharacterAsKey = 227,
        FailedToSerialize_ObjectUsedReservedCharacterAsValue = 228,
        FailedToSerialize_DisallowRemoteMutationsCannotBeChangedFromTrueToFalse = 229,
        FailedToMoveObject_ConfirmSecondaryPoGc = 231,
        CannotFindObject_FixupObject = 232,
        CannotFindObject_FixupObservableOrObservableArray = 233,
        CannotFindObject_FixupDeferredOrPromise = 234,
        CannotFindMetadata_HandleUnderlyingArrayChanges = 235,
        CannotFindMetadata_PromiseProgress = 236,
        CannotFindMetadata_PromiseAlways = 237,
        CannotFindMetadata_ApplyPromiseChanges = 238,
        CannotFindMetadata_Release = 239,
        CannotFindMetadata_ApplyObservableArrayChanges = 240,
        FailedToSerialize_EncounteredException = 241,
        FailedToApplyPromiseChange_DisallowRemoteMutations = 242,
        CannotFindObject_FixupArray = 243,
        FailedToApplyPromiseChange_PromiseHasBeenResolvedOrRejected = 244,
        CannotFindObject_DeserializeObject = 245,
        CannotFindMetadata_RecordObservableChange = 246,
        DetectedSimultaneousChange = 301,
        DetectedCycleSubscription = 302,
        DetectedNonArrayValueInObservableArray = 303,
        DetectedProxyBufferedChangesDidNotBeenCalled = 305,
        DetectedProxiedArrayBeenModified = 306,
        DetectedObservableMutatedInefficiently = 307,
        DetectedArrayOwnersIsNull = 308
    }
    /**
     * The serialization result contains all data, which including password as well
     * Use this function to remove all strings from serialization result. The result can be safely log
     *
     * @param serializationResult
     */
    function removeUserStringValues(serializationResult: SerializationResult): SerializationResult;
    function isIgnoredSimultaneousErrorBucketId(bucketId: string): boolean;
    function handleException(exceptionCode: ExceptionCode, detailMessage: string, parameter?: any, logOnly?: boolean): void;
    function hasFreed(poManager: ProxiedObjectManager, id: string): boolean;
    export interface FunctionCallMetadata {
        promise: PromiseAdapter;
        objs: any[];
    }
    /**
     * Execute garbage collect in primary po manager.
     *
     * The lifecycle of gc:
     *  1. Primary Po starts gc process, loops map and finds out all objects which doesn't referenced by rootObject.
     *  2. Primary Po sends pending disposed object ids (iIds) to secondary Po.
     *  3. Secondary Po dispose objects and sends cIds to Primary Po.
     *  4. Primary Po disposes pending disposed objects.
     */
    function executeGc(poManager: ProxiedObjectManager, immediate?: boolean): void;
    /**
     * Provides functions that serialize and deserialize object.
     * - One iframe can have multiple poManager instances.
     * - One connection must have two poManager instance, one in each iframe.
     * - In one iframe, one object can belong to multiple poManagers.
     */
    export class ProxiedObjectManager {
        /**
         * The new reference count. This property is only valid in primary PO.
         * This number increase after every object/array/function being added to the PO, it will be set to 0 after gc.
         */
        nc: number;
        /**
         * The disposed root object count. This property is only valid in primary PO.
         * This number increase after every root object been disposed, it will be set to 0 after gc.
         */
        dc: number;
        disposed: boolean;
        /**
         * One ProxiedObjectManager has one id, and the id is unique across the entire web browser.
         * It's also the prefix of all object ids which serialized by this ProxiedObjectManager.
         */
        id: string;
        /**
         * The changeNumberId, one ProxiedObjectManager has one changeNumberId, and the changeNumberId is unique across the entire web browser.
         * The changeNumberId be used to get/set observable changeNumber, the usage is like: metadata[poManager.changenumber];
         *
         * For example:
         *  1. There are two ProxiedObjectManagers in one iframe, po1 and po2
         *  2. The po1.changeNumberId = "c-1", po2.changeNumberId = "c-2".
         *  3. One knockout observable belongs to both po1 and po2. Mostly, this observable have different change numbers in different po Managers.
         *  3. This observable's metadata will look like metadata = {id:"13","c-1":19,"c-2":3}.
         *  4. metadata[po1.changeNumberId] will return its changeNumber in po1, metadata[po2.changeNumberId] will return its changeNumber in po2.
         */
        cnId: string;
        /**
         * The serialId, one ProxiedObjectManager has one serialId, and the serialId is unique across the entire web browser.
         * The serialId be used to get/set the observable serial number, the usage is: metadata[poManager.lostSyncId] = true;
         */
        sId: string;
        /**
         * The arrayId, one ProxiedObjectManager has one arrayId, and the arrayId is unique across the entire web browser.
         * The arrayId be used to get/set original array from metadata
         */
        aId: string;
        /**
         * The knockout subscription id, one ProxiedObjectManager has one koSubId, and the koSubId is unique across the entire web browser.
         * The koSubId be used to get/set knockout subscription to pureComputed object
         */
        kId: string;
        /**
         * The promise subscription id, one ProxiedObjectManager has one promise self inflicted number id, and the promiseSId is unique across the entire web browser.
         * The promise subscription id be used to get/set promise self inflicted number. The self inflicted number design is the same as POv1.
         */
        pId: string;
        /**
         * Indicate whether current poManager is primary. One connection must have two poManagers, one is primary and another is secondary.
         *
         * The differences between primary poManager and secondary poManager:
         *   1. Only primary poManager triggers gc() and logs GC telemetry
         *   2. When there is a simultaneous change, apply the value from primary poManager, discard the value from secondary poManager
         */
        isPrimary: boolean;
        raiseRemoteException: Action1<string | Error>;
        /**
         * The change listener
         */
        onChange: Action1<ChangeDescriptor>;
        /**
         * The promise listener
         */
        onPromise: Action1<PromiseEventDescriptor>;
        /**
         * The proxy function invocation listener
         */
        onFunction: Action1<ProxyFunctionInvocationDescriptor>;
        /**
         * The release listener
         */
        onRelease: Action2<ReleaseEventDescriptor, void>;
        /**
         * The operation history
         */
        ops: any[];
        /**
         * A hash-table to have one to one mapping between objectId and object.
         * Object won't be collected by WebBorwser when it belongs to map. The purpose of ProxiedObjectManager.gc() is to remove unused objects from map.
         */
        map: StringMap<any>;
        pending: StringMap<any>;
        roots: StringMap<any>;
        receivedChanges: StringMap<number>;
        funcCalls: StringMap<FunctionCallMetadata>;
        freedIds: string[];
        revivedIds: StringMap<any>;
        /**
         * The remote window id, used for log
         */
        rWinId: string;
        /**
         * The local window id
         */
        lWinId: string;
        /**
         * Generate id function
         */
        gId: Func<string>;
        /**
         * Generate function call id function
         */
        gFuncCallId: Func<string>;
        /**
         * The gc interval handle.
         * This property is only been set in primary PO.
         */
        gcH: number;
        /**
         * The gc initialIds from primary po
         * This property is only been set in secondary po
         */
        gcIIds: string[];
        /**
         * A map to have gc initialIds
         * This property is only been set in secondary po
         */
        gcIIdMap: StringMap<boolean>;
        /**
         * The last GC timer.
         * This property is only been set in primary PO, the timer start when GC completed.
         */
        gcLt: Func<number>;
        /**
         * Indicate whether current gc is immediate GC, this value will be log to GC telemetry
         * This property is only been set in primary PO.
         */
        gcI: boolean;
        /**
         * The telemetry trace key, this property is only valid in primary PO.
         * This property is only been set in primary PO.
         */
        gcTk: string;
        constructor();
        /**
         * Serialize the input data.
         * Below is the required pattern to call serialize() function
         *    1. const result = poManager.serialize(data);
         *    2. proxy(result)
         *    3. poManager.proxyingBufferedChanges()
         *
         * @param data The input data to be serialized
         * @param disallowRemoteMutations Indicate whether the knockout observable updates can come from the remote object.
         * @param fullFreezeInDevMode Indicate whether full freeze the object. When this property set to true, PO will execute Object.preventExtensions(data).
         *        The "fullFreezeInDevMode" only been used in dev mode. Below is the pseudo code in PO:
         *          if (developmentMode && enableDiagnostics) {
         *              if (fullFreezeInDevMode) {
         *                  Object.freeze(data);
         *                  Object.preventExtensions(data);
         *              } else {
         *                  Object.freeze(data);
         *              }
         *           }
         */
        serialize(data: any, disallowRemoteMutations?: boolean, fullFreezeInDevMode?: boolean): SerializationResult;
        /**
         * Proxy buffered changes. This function must be called after serialization completed.
         * Serialization may trigger chanegs, those changes will be buffered. e.g.
         *    var object = {
         *        observable: ko.observable(1),
         *        computed: ko.pureComputed(() => {
         *            object.observable(2); // object.observable will be updated during serialization
         *        })
         *    };
         *
         *   serialize(object)
         */
        proxyBuffer(): void;
        deserialize(encodedData: SerializationResult, remoteWindowId?: string): any;
        applyPromise(descriptor: PromiseEventDescriptor): void;
        applyChange(descriptor: ChangeDescriptor): void;
        applyRelease(descriptor: ReleaseEventDescriptor): void;
        invoke(descriptor: ProxyFunctionInvocationDescriptor): void;
        /**
         * Release an input object. In Pov2, release function can only release rootObject.
         * For example: after user closed a blade, this method will been called multiple times to release all PartViewModels.
         *
         * @param object The input object to be released
         */
        release(object: any): void;
        /**
         * Dispose poManager and its references
         */
        dispose(): void;
    }
    function decidePrimary(localWindowId: string, remoteWindowId: string): boolean;
    export function createPoMgr(metadataIdPrefix: string, raiseRemoteException: Action1<MsPortalFx.Errors.Error>, changeListener: Action2<ChangeDescriptor, void>, promiseEventListener: Action2<PromiseEventDescriptor, void>, proxyFunctionInvocationListener: Action2<ProxyFunctionInvocationDescriptor, void>, releaseListener: Action2<ReleaseEventDescriptor, void>, localWindowId: string, remoteWindowId: string, notScheduleGc?: boolean): ProxiedObjectManager;
    /**
     * Once an object been serialized/deseialized. poManager will generate a metadata and save the
     * entire entry to metdataMap. This function allows external module get metadata by object
     *
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    export function getMetadata(obj: any): Metadata;
    export function getMetadataId(obj: any): string;
    /**
     * Get or create empty metadata
     *
     * @param obj The input object.
     * @returns The metadata of input object.
     */
    export function getOrCreateMetadata(obj: any): Metadata;
    /**
     * Marks that the given object is disallowed from being mutated by its remote copy.
     */
    export function disallowRemoteMutations(obj: any): void;
    export interface Options {
        enableCompatibilityMode?: boolean;
        enableDiagnostics?: boolean;
        periodicGcIntervalInMs?: number;
        periodicGcThreshold?: number;
        immediateGcThreshold?: number;
        enableGcTelemetry?: boolean;
        disableObservableMutationPerformanceCheck?: boolean;
    }
    export const exportForDevMode: {
        bucketIdRegex: RegExp;
        bucketIdReplacement: string;
        splitter: string;
        removeUserStringValues: typeof removeUserStringValues;
        log: FxBase.Diagnostics.Log;
        hasFreed: typeof hasFreed;
        handleException: typeof handleException;
        isIgnoredSimultaneousErrorBucketId: typeof isIgnoredSimultaneousErrorBucketId;
        gc: typeof executeGc;
        decidePrimary: typeof decidePrimary;
        observableMutationWarningLimit: number;
        options: {
            enableCompatibilityMode: boolean;
            enableDiagnostics: boolean;
            periodicGcIntervalInMs: number;
            periodicGcThreshold: number;
            immediateGcThreshold: number;
            enableGcTelemetry: boolean;
        };
        createPromiseAdapter: (promiseOrDeferred: any) => PromiseAdapter;
        getMetadataByPoManager: (obj: any, poManager: Po.ProxiedObjectManager) => Metadata;
        override: (options: Options) => void;
        resetOptions: () => void;
        reset: () => void;
        isDisallowRemoteMutations: (object: any) => boolean;
        getObservableMutationsInCurrentTick: () => StringMap<ObservableMutation>;
    };
    /**
     * Return some objects and variables for diagnostics purpose.
     */
    export function getDiagnostics(): {
        compatibilityMode: boolean;
        diagnostics: boolean;
        metadataMap: WeakMap<Object, Metadata>;
        managers: ProxiedObjectManager[];
    };
    export {};
}

// FILE: MsPortalFx\Base\Base.QExtensions.d.ts
interface Promise<T> {
    /**
     * Catches errors that are instances of the specified error type.
     * If not of the specified type the error continues to propagate.
     *
     * Works for all errors of type Error and derivations of Error
     * on non-proxied promises.  For proxied promises it will only
     * work on errors of types deriving from MsPortalFx.Errors.Error.
     *
     * .catchError(MsPortalFx.Errors.CanceledError, (error) => {
     *     // error is a CanceledError of somthing deriving from it
     * })
     *
     * @param errorType The type of errors to catch.
     * @param onError The error handler.
     * @returns Promise that is resolved or rejected according to the error handler.
     */
    catchError<U, E extends MsPortalFx.Errors.Error>(errorType: MsPortalFx.Errors.ErrorType<E>, onError: (error: E) => U | PromiseLike<U>): Promise<U>;
}
declare module Q {
    interface Promise<T> {
        /**
         * Catches errors that are instances of the specified error type.
         * If not of the specified type the error continues to propagate.
         *
         * Works for all errors of type Error and derivations of Error
         * on non-proxied promises.  For proxied promises it will only
         * work on errors of types deriving from MsPortalFx.Errors.Error.
         *
         * .catchError(MsPortalFx.Errors.CanceledError, (error) => {
         *     // error is a CanceledError of somthing deriving from it
         * })
         *
         * @param errorType The type of errors to catch.
         * @param onError The error handler.
         * @returns Promise that is resolved or rejected according to the error handler.
         */
        catchError<U, E extends MsPortalFx.Errors.Error>(errorType: MsPortalFx.Errors.ErrorType<E>, onError: (error: E) => U | PromiseLike<U>): Q.Promise<U>;
    }
}
declare module FxImpl.QExtensions {
}

// FILE: MsPortalFx\Base\Base.Resources.d.ts
declare module MsPortalFx {
    module Base.Resources {
        function initialize(): void;
        /**
         * Gets the image URIs from the given node using the image root.
         *
         * @param node The node which contains the node image strings.
         * @returns Copy of the node with the node image strings converted to URIs.
         */
        function getImages<T>(node: T): T;
        /**
         * Returns whether the given URI is an absolute URI.
         *
         * @param uri The URI.
         * @returns A boolean value indicating whether the URI is absolute.
         */
        const isUriAbsolute: typeof MsPortalFx.isUriAbsolute;
        /**
         * Gets the path to the named content.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @returns The uri.
         */
        function getContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Gets the path to the named script file
         *
         * @param uri The uri of the script file.
         * @returns The uri.
         */
        function getScriptUri(uri: string): string;
        /**
         * Gets the path to the application relative uri.
         *
         * @param uri The application relative uri.
         * @returns The uri.
         */
        function getAppRelativeUri(uri: string): string;
        /**
         * Gets the absolute uri from the given uri.
         *
         * @param uri The application relative uri.
         * @returns The uri.
         */
        function getAbsoluteUri(uri: string): string;
        /**
         * Gets the path to the named content with the version segment.
         *
         * @param uri The uri of the content.
         * @param coerceAbsoluteUri Forces the returned uri to be an absolute uri. The default value is true.
         * @returns The uri.
         */
        function getVersionlessContentUri(uri: string, coerceAbsoluteUri?: boolean): string;
        /**
         * Internal only. For use by Resource generation code.
         */
        function _getImageMap(fileHierarchy: Array<any>, className: string): StringMap<string>;
    }
    /**
     * Internal only. For use by Resource generation code.
     */
    const getImages: typeof Base.Resources._getImageMap;
}

// FILE: MsPortalFx\Base\Base.Rpc2.d.ts
declare module FxImpl.Rpc {
    import FxBase = MsPortalFx.Base;
    import LifetimeManager = FxBase.LifetimeManager;
    import TelemetryContextInternal = FxImpl.TelemetryContext;
    import Po = FxImpl.Po;
    export const enum Constants {
        RegistrationTimeoutInMs = 30000,
        RpcCallTimeoutInMs = 300000,
        WindowUnloadTimeoutInMs = 240000
    }
    export type MessageContext = import("FxInternal/Rpc").MessageContext;
    export type HandlerContext<TPort> = import("FxInternal/Rpc").HandlerContext<TPort>;
    export interface HandlerPortMessageData<HandlerPortMessageBody, TProxiedObject> {
        readonly body: HandlerPortMessageBody;
        readonly obj: ReadonlyArray<TProxiedObject>;
    }
    export interface HandlerPort<THandlerPortMessageBody, TInvokerPortMessageData, TProxiedObject> {
        transferObjects(body: THandlerPortMessageBody, proxiedObjects: ReadonlyArray<TProxiedObject>): void;
        releaseObject(obj: any): void;
        onMessage(handler: (body: TInvokerPortMessageData) => void): void;
    }
    export interface InvokerPort<TInvokerPortMessageData, TSandboxPortMessageBody, TProxiedObject, TValue> {
        readonly value: TValue;
        readonly isChannelEnabled: boolean;
        postMessage(message: TInvokerPortMessageData): void;
        onObject(handler: (message: HandlerPortMessageData<TSandboxPortMessageBody, TProxiedObject>) => void): void;
        dispose(): void;
        onDispose(callback: Action1<string>): void;
    }
    export type MessagePortLike<T> = import("FxInternal/Rpc").MessagePortLike<T>;
    export type FuncEndPointHandler<T, R, TConnection> = (arg: T, handlerContext: HandlerContext<TConnection>, ltm: LifetimeManager) => PromiseLike<R> | R;
    export type AllowedOrigins = string | string[];
    export type EndPointRegistrationOptions<T, R, TConnection> = import("FxInternal/Rpc").EndPointRegistrationOptions<T, R, TConnection>;
    export interface ProxiedObjectEndPointRegistrationOptions<T, R> extends EndPointRegistrationOptions<T, R, unknown> {
        /**
         * Indicates whether remote changes are allowed.
         */
        readonly allowRemoteChanges: boolean;
    }
    export type LoadChannelFunction = (windowId: string, instanceIndex: number) => RpcChannel<any>;
    type Sender<TData, TDestination> = import("FxInternal/Rpc").Sender<TData, TDestination>;
    export type LogMessage = import("FxInternal/Rpc").LogMessage;
    interface InvokerPortMessage<T> {
        readonly connectionId: number;
        readonly data: T;
    }
    const enum HandlerPortMessageFlags {
        None = 0,
        HasInitialMessagePayload = 1,
        HasChannelMessagePayload = 2,
        IsChannelEnabled = 4
    }
    interface HandlerPortMessage {
        readonly channelObjects: ReadonlyArray<Po.SerializationResult>;
        readonly connectionId: number;
        readonly flags: HandlerPortMessageFlags;
        readonly initialObject: Po.SerializationResult;
        readonly metadata: any;
    }
    class InvokerPortContext<TInvokerData, THandlerData, TProxiedObject, TValue> extends DisposableValue<TValue> implements InvokerPort<TInvokerData, THandlerData, TProxiedObject, TValue> {
        private readonly _poMgr;
        private readonly _telemetryContext;
        private readonly _sendInvokerPortMessage;
        readonly isChannelEnabled: boolean;
        private readonly _connectionId;
        private readonly _handlerBuffer;
        private _messageHandler;
        constructor(_poMgr: Po.ProxiedObjectManager, _telemetryContext: TelemetryContextInternal.State, _sendInvokerPortMessage: Sender<InvokerPortMessage<TInvokerData>, void>, message: HandlerPortMessage);
        handleMessage(message: HandlerPortMessage): any;
        postMessage(data: TInvokerData): void;
        onObject(handler: Action1<HandlerPortMessageData<THandlerData, TProxiedObject>>): void;
    }
    export interface ChangeListener {
        onRemoteChange: (observable: KnockoutReadOnlyObservableBase<any>, path: string) => void;
    }
    export type StartOptions = import("FxInternal/Rpc").StartOptions;
    export class Client extends CoreClient {
        private _poEndPoints;
        private _poClient;
        constructor(registrationTimeoutInMs: number);
        /**
         * Registers an object factory function that can be used to create objects that are to be proxied to the caller.
         */
        registerObjectFactory<T, R>(name: string, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        /**
         * Acquires a proxied object from the given destination extension.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         * @param onObjectAcquired A callback being called with the acquired object before additional messages are processed.
         */
        acquireObject<T, R, TInvokerData = void, THandlerData = void, TProxiedObject = void>(name: string, destination: string, arg: T): Promise<InvokerPortContext<TInvokerData, THandlerData, TProxiedObject, R>>;
        start(options: StartOptions): void;
        reset(): void;
    }
    /**
     * The RPC client that can used to register and invoke RPC callbacks.
     */
    export let client: Client;
    export function start(options: StartOptions): void;
    export class ActionEndPointDefinition<T> extends ActionEndPointDefinitionBase<T> {
        invoke(client: Client, destination: string, arg: T): Promise<void>;
    }
    export class FuncEndPointDefinition<T, R> extends FuncEndPointDefinitionBase<T, R> {
        invoke(client: Client, destination: string, arg: T): Promise<R>;
    }
    export class ProxiedObjectTypeDefinition<T, R> extends EndPointDefinition {
        registerObjectFactory(client: Client, options: ProxiedObjectEndPointRegistrationOptions<T, R>): void;
        acquireObject(client: Client, destination: string, arg: T): Promise<DisposableValue<R>>;
    }
    export {};
}
declare namespace FxImpl.Rpc {
    const RoutedMessageKind: typeof import("FxInternal/Rpc").RoutedMessageKind;
    type RoutedMessageKind = import("FxInternal/Rpc").RoutedMessageKind;
    const getMessageContext: typeof import("FxInternal/Rpc").getMessageContext;
    const createCallStack: typeof import("FxInternal/Rpc").createCallStack;
    const createRpcError: typeof import("FxInternal/Rpc").createRpcError;
    const getCurrentCallStack: typeof import("FxInternal/Rpc").getCurrentCallStack;
    type DisposableValue<T> = import("FxInternal/Rpc").DisposableValue<T>;
    const DisposableValue: typeof import("FxInternal/Rpc").DisposableValue;
    type DisposableValueDictionary<TKey, T extends DisposableValue<any>> = import("FxInternal/Rpc").DisposableValueDictionary<TKey, T>;
    const DisposableValueDictionary: typeof import("FxInternal/Rpc").DisposableValueDictionary;
    type RpcChannel<T> = import("FxInternal/Rpc").RpcChannel<T>;
    const RpcChannel: typeof import("FxInternal/Rpc").RpcChannel;
    type MessageDispatcher<T, TContext> = import("FxInternal/Rpc").MessageDispatcher<T, TContext>;
    const MessageDispatcher: typeof import("FxInternal/Rpc").MessageDispatcher;
    type MessageMultiplexer<TKind extends number, TContext, TDestination> = import("FxInternal/Rpc").MessageMultiplexer<TKind, TContext, TDestination>;
    const MessageMultiplexer: typeof import("FxInternal/Rpc").MessageMultiplexer;
    const RefCountKind: typeof import("FxInternal/Rpc").RefCountKind;
    type RefCountKind = import("FxInternal/Rpc").RefCountKind;
    type EndPointTable<TConnection extends MsPortalFx.Base.Disposable, TOptions extends EndPointRegistrationOptions<any, any, TConnection>> = import("FxInternal/Rpc").EndPointTable<TConnection, TOptions>;
    const EndPointTable: typeof import("FxInternal/Rpc").EndPointTable;
    type PendingObjectTable<T> = import("FxInternal/Rpc").PendingObjectTable<T>;
    const PendingObjectTable: typeof import("FxInternal/Rpc").PendingObjectTable;
    const CoreClient: typeof import("FxInternal/Rpc").Client;
    const EndPointDefinition: typeof import("FxInternal/Rpc").EndPointDefinition;
    const ActionEndPointDefinitionBase: typeof import("FxInternal/Rpc").ActionEndPointDefinitionBase;
    const FuncEndPointDefinitionBase: typeof import("FxInternal/Rpc").FuncEndPointDefinitionBase;
}

// FILE: MsPortalFx\Base\Base.Scheduler.d.ts
declare module MsPortalFx.Base {
    function setDataPerf(enable: boolean): void;
    /**
     * devMode only test helper
     */
    function setSchedulerRunTask(newRunTask: () => Promise<any>): () => Promise<any>;
    /**
     * devMode only test helper
     */
    function resetSchedulerRunTask(): void;
    interface ScheduledTask {
        /**
         * Optional if delayInMs is not specified. The absolute time the task should execute.
         */
        absoluteTime?: number;
        /**
         * Optional if absoluteTime is not specified. The delay before the task executes.
         */
        delayInMs?: number;
        /**
         * Determines if the task is asynchronous.
         */
        isAsync?: boolean;
        /**
         * Name of the task.
         */
        name?: string;
        /**
         * Optional. Not compatible with absolute time. Should not be used if task is async.
         * (instead, call scheduleTask again on completion of the async task).
         * If set to true the task will be automatically rescheduled after completion (or failure).
         */
        recurring?: boolean;
        /**
         * Function to call that executes the task.
         */
        scheduledTask: Function;
        /**
         * Arguments to pass to the scheduled task.
         */
        args?: any[];
        /**
         * Optional. If true, diagnostic output for this task will not be logged.
         */
        silent?: boolean;
    }
    class Scheduler {
        /**
         * Schedules a task
         */
        static scheduleTask(task: ScheduledTask, allowDuplicates?: boolean): void;
        /**
         * Deletes a scheduled task
         */
        static deleteTask(task: ScheduledTask): void;
    }
}

// FILE: MsPortalFx\Base\Base.Security.d.ts
declare module MsPortalFx.Base.Security {
    import InternalExtension = FxImpl.Extension;
    /**
     * Interface for options used to get authorization tokens.
     */
    interface GetAuthorizationTokenOptions {
        /**
         * Name of the authorization token to get
         */
        readonly resourceName: string;
    }
    type AuthorizationToken = import("Fx/Security").AuthorizationToken;
    interface GetAuthorizationTokenResponse {
        /**
         * The authorization token.
         */
        readonly token?: AuthorizationToken;
        /**
         * Any errors in obtaining the token.
         */
        readonly error?: string;
        /**
         * An error details if any errors in obtaining the token.
         */
        readonly errorMessage?: string;
    }
    type UserInfo = import("Fx/Security").UserInfo;
    /**
     * Interface for authentication tokens cache.
     */
    interface IAuthTokenCache {
        /**
         * Gets a security token needed to make API calls to a back end service.
         *
         * @param options Optional options containing the resource name of the extension wants access to.
         * @returns A security token for the named service or if no such token is available undefined.
         */
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): Promise<AuthorizationToken>;
        /**
         * Gets the timestamp a resources token will expire at.
         *
         * @param resourceName The resource to get token expiration for.
         * @returns The timestamp a token will expire at or if no such token is available undefined.
         */
        getTokenExpiresAt(resourceName: string): number;
    }
    /**
     * Creates an instance of the authentication token cache.
     *
     * @param getTokenFunc function that returns authentication tokens.
     * @param seedData initial seed data for the cache.
     * @returns An instance of the authentication token cache.
     */
    function createAuthTokenCache(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => Promise<MsPortalFx.Base.Security.GetAuthorizationTokenResponse>, seedData?: StringMap<AuthorizationToken>): IAuthTokenCache;
    /**
     * Gets the security token an extension uses to make calls against
     * secured back end services.
     *
     * Note:
     * Do not cache or resuse the returned token as there is no way to tell when it will expire.
     * Always calling it makes sure your extension picks up a new token when it is refreshed by the shell.
     *
     * @param options Options that control which token is obtained.
     * @returns A security token for the named service or if no such token is available undefined.
     */
    function getAuthorizationToken(options?: GetAuthorizationTokenOptions): Promise<AuthorizationToken>;
    /**
     * Gets the signed in user and directory info.
     *
     * @returns The info for the currently signed in user and directory.
     */
    function getUserInfo(): Promise<UserInfo>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an entity.
     * secured back end services.
     *
     * @param entityId The entity to check for permissions. The entity ID MUST be a resource ID, a subscription ID or a resource group ID.
     * @param actions The actions being to checked.
     * @returns A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function hasPermission(entityId: string, actions: string[]): Promise<boolean>;
    /**
     * Checks to see if the current user has permissions to perform a set of actions against an asset.
     * secured back end services.
     *
     * @param assetId The asset to check for permissions. The asset MUST have an associated resource type.
     * @param actions The actions being to checked.
     * @returns A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
     */
    function assetHasPermission(assetId: MsPortalFx.Assets.AssetTriplet, actions: string[]): Promise<boolean>;
}
declare module FxImpl.Security {
    import FxBase = MsPortalFx.Base;
    import FxSecurity = FxBase.Security;
    import InternalExtension = FxImpl.Extension;
    import FxAuthorizationToken = FxSecurity.AuthorizationToken;
    import FxGetAuthorizationTokenResponse = FxSecurity.GetAuthorizationTokenResponse;
    const tokenErrors: {
        /**
         * Unknown error
         */
        unknown: string;
        /**
         * Extension is not allowed to get tokens
         */
        accessDenied: string;
        /**
         * The session has expired, no new tokens will be issued
         */
        sessionEnded: string;
        /**
         * The active token has expired, no new tokens can be issued
         */
        credentialsExpired: string;
        /**
         * The call to get tokens returned with a network error (status code 0).
         */
        networkError: string;
        /**
         * The user is required to use MFA.
         */
        requiresMFA: string;
        /**
         * Users account is disabled.
         */
        accountDisabled: string;
        /**
         * The portal's requests are getting throttled by AAD
         */
        tooManyRequests: string;
        /**
         * The request made by the extension was invalid.
         */
        badRequest: string;
        /**
         * App not provisioned.
         */
        appNotProvisioned: string;
        /**
         * The broker reply URLs were not added to the extension's first party AAD application.
         */
        missingBrokerReplyUrl: string;
        /**
         * The token request timed out.
         */
        brokerTimeout: string;
        /**
         * The device not in compliant state.
         */
        deviceUncompliant: string;
        /**
         * The token request fails because the user is not part of the tenant.
         */
        passthroughUserError: string;
        /**
         * The error raised when an interactive sign-in is required to fulfill the missing claims.
         */
        interactionRequiredAuthError: string;
    };
    /**
     * Represents the result of obtaining all tokens for an extension.
     * Note: this must match the ExtensionTokens class defined in ExtensionTokens.cs
     */
    interface ExtensionTokens {
        /**
         * The dictionary of resources and their access tokens.
         */
        readonly resourceByTokenMap: ReadonlyStringMap<FxSecurity.AuthorizationToken>;
    }
    /**
     * Implementation for IAuthTokenCache
     */
    class AuthTokenCacheImpl implements FxSecurity.IAuthTokenCache {
        private readonly _getTokenWorker;
        private _cachedTokenMap;
        private _stalledPromise;
        constructor(getTokenFunc: (options?: InternalExtension.GetAuthorizationTokenOptionsExtended) => Promise<FxGetAuthorizationTokenResponse>, seedData?: StringMap<FxAuthorizationToken>);
        getToken(options: InternalExtension.GetAuthorizationTokenOptions): Promise<FxAuthorizationToken>;
        getTokenExpiresAt(resourceName: string): number;
        private _refreshTokenWorker;
        private _refreshTokenWorkerInternal;
    }
    const DEV: {
        getTokenRefreshBeforeExpiryTimespanInMs: () => number;
        setTokenRefreshBeforeExpiryTimespanInMs: (value: number) => void;
    };
}

// FILE: MsPortalFx\Base\Base.Themes.d.ts
declare module MsPortalFx.Base.Themes {
    const enum ThemeMode {
        Light = 0,
        Dark = 1
    }
    const enum HighContrastMode {
        Off = 0,
        Light = 1,
        Dark = 2
    }
    interface Theme {
        /**
         * Theme color code.
         */
        colorCode: string;
        /**
         * Theme sample image uri.
         */
        imageUri: string;
        /**
         * Theme sample image svg.
         */
        svg: Base.Image;
        /**
         * Theme name.
         */
        name: string;
        /**
         * Theme title.
         */
        title: string;
        /**
         * Theme mode.
         */
        mode?: ThemeMode;
    }
}

// FILE: MsPortalFx\Base\Base.UriBuilder.d.ts
declare module MsPortalFx.Base {
    /**
     * Provides basic query string manipulation functions.
     */
    class QueryStringBuilder {
        private _qs;
        private _qsMap;
        private readonly _leadingSeparator;
        /**
         * Initializes a new instance of the query string builder.
         *
         * @param qs The initial query string.
         * @param leadingSeparator The leading character of the query string. ? by default.
         */
        constructor(qs?: string, leadingSeparator?: string);
        /**
         * Removes all query string values.
         *
         * @returns The QueryStringBuilder instance.
         */
        clear(): QueryStringBuilder;
        /**
         * Sets multiple parameters in the query string. Overwrites any existing values.
         *
         * @param keys The object that represents the key value pairs.
         * @returns The QueryStringBuilder instance.
         */
        setParameters(keys: ReadonlyStringMap<any>): QueryStringBuilder;
        private _getParameterIndex;
        /**
         * Sets a parameter in the query string. Overwrites any existing values.
         *
         * @param key The key of the parameter.
         * @param value The value of the parameter.
         * @returns The QueryStringBuilder instance.
         */
        setParameter(key: string, value: any): QueryStringBuilder;
        /**
         * Gets the value of a parameter in the query string.
         *
         * @param key The key of the parameter.
         * @returns The value of the parameter. Undefined if the value doesn't exist.
         */
        getParameter(key: string): string;
        /**
         * Gets all values of the query string as a stringmap.
         *
         * @returns StringMap of all query string key/value pairs.
         */
        getParameters(): StringMap<any>;
        /**
         * Removes multiple parameters from the query string.
         *
         * @param keys The keys of the parameter.
         * @returns The QueryStringBuilder instance.
         */
        removeParameters(keys: string[]): QueryStringBuilder;
        /**
         * Removes a parameter from the query string.
         *
         * @param key The key of the parameter.
         * @returns The QueryStringBuilder instance.
         */
        removeParameter(key: string): QueryStringBuilder;
        /**
         * Returns a string representation of the URI.
         *
         * @param includeLeadingSeparator Whether to emit the leading ?. Defaults to true.
         * @returns A string representation of the URI.
         */
        toString(includeLeadingSeparator?: boolean): string;
    }
    /**
     * Provides basic URI manipulation functions.
     */
    class UriBuilder {
        private _oq;
        /**
         * Gets or sets the path part of the URI. This includes the protocol, domain, port, and virtual path.
         */
        path: string;
        /**
         * Gets or sets the query string part of the URI. This is represented as key value pairs.
         */
        query: QueryStringBuilder;
        /**
         * Gets or sets the fragment of the URI. This includes everything after the # separator in the URI.
         */
        fragment: string;
        /**
         * Initializes a new instance of the URI.
         */
        constructor(uri?: string);
        /**
         * Gets the original query string associated with the URI.
         * Avoids any data loss that might be associated with encoding/decoding of the query string.
         */
        getOriginalQuery(): string;
        /**
         * Returns a string representation of the URI.
         */
        toString(): string;
        getScheme(): string;
        /**
         * Gets the authority part of the URI (Ex: www.test.com:880).
         */
        getAuthority(): string;
        /**
         * Gets the scheme and authority part of the URI (Ex: http://www.test.com:880).
         *
         * @param normalizeScheme Specifies whether implicit scheme/protocol should be expanded to be that of the
         * current location.
         * @returns A string that covers the schema and authority of the URI.
         */
        getSchemeAndAuthority(normalizeScheme?: boolean): string;
        /**
         * Gets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath returns /test/mypath.
         */
        getRelativePath(): string;
        /**
         * Sets the relative path of the URI.
         * Ex: Given a URI http://www.test.com:880/test/mypath and a parameter otherPath.
         * It will change the URI to http://www.test.com:880/otherPath.
         */
        setRelativePath(relativePath: string): void;
    }
}

// FILE: MsPortalFx\Base\Base.Version.d.ts
declare module MsPortalFx.Base {
    /**
     * Runtime represention of a version number.
     */
    interface Version {
        /**
         *  The major component of the version number.
         */
        major: number;
        /**
         * The minor component of the version number.
         */
        minor: number;
        /**
         * The build component of the version number.
         */
        build: number;
        /**
         * The revision component of the version number.
         */
        revision: number;
        /**
         * Serializes this version number to a string represntion.
         * The build and revision components of the version are optional and are omitted from the string if
         * they are not defined.
         *
         * @returns String represention of the version number in the format major.minor[.build[.revision]].
         */
        toString(): string;
        /**
         * Compares this instance to another version.
         *
         * @param version The version which is this instance is being compared to
         * @returns 0 if both versions are the same, -1 if this instance is a smaller version, 1 if this instance is a larger version.
         */
        compareTo(version: Version): number;
    }
    /**
     * Parses a version string and returns the runtime represention of the version number.
     * Version strings are in the format "major.minor[.build[.revision]]".
     * Build and revision are optional components in the version.   major and minor are required.
     * All component values cannot be negative and must be valid integers.
     * There cannot be more than 4 components in the string.
     *
     * @param version string represention of a version.
     * @returns The runtime represention of the version number.
     * @throws Will throw a Error if the string is not a valid version string.
     */
    function getVersionFromString(version?: string): Version;
    /**
     * Tries to convert the string representation of a version number to an equivalent
     * MsPortalFx.Base.Version object, and returns a result that indicates whether the conversion
     * succeeded and the version object if it did.
     *
     * A string that contains a version number to convert.
     */
    function tryParseVersion(version: string): Version;
}

// FILE: MsPortalFx\Base\Internal\Base.Diagnostics.Net.d.ts
declare module FxImpl.NetDiagnostics {
    import FxBase = MsPortalFx.Base;
    import FxHelpers = MsPortalFx.Helpers;
    import FxDiagnostics = FxBase.Diagnostics;
    import NetAjaxSettings = FxBase.Net2.NetAjaxSettings;
    import Telemetry = FxDiagnostics.Telemetry;
    /**
     * Telemetry actions covering network-related telemetry.
     */
    const enum TelemetryActions {
        /**
         * Ajax telemetry.
         */
        Ajax = "Ajax"
    }
    /**
     * Metadata describing a Blade instance.
     */
    type BladeInstance = {
        /**
         * The Blade's telemetry context.
         */
        context: Telemetry.Context.CompositionContext;
        /**
         * A boolean indicating whether the Blade has settled (finished rendering).
         */
        settled?: boolean;
    };
    /**
     * Called when a new Blade is opening, so telemetry for subsequent ajax calls accrues to the new Blade.
     *
     * @param bladeTelemetryContext The telemetry context for the new, opening Blade.
     * @param onNextAjax A callback called on when the next ajax call is initiated.
     * @returns Callbacks to report state changes for the Blade.
     */
    function listenForBlade(bladeTelemetryContext: Telemetry.Context.CompositionContext, onNextAjax?: () => void): {
        onSettled: () => void;
        onInteractive: (time: number) => void;
        onDisposed: () => void;
    };
    /**
     * An observable count of pending ajax calls.
     */
    const pendingCallCount: KnockoutComputed<number>;
    /**
     * An array of pending ajax calls.
     */
    const pendingAjaxCalls: ReadonlyArray<PendingAjaxCall>;
    /**
     * A pending ajax call.
     */
    type PendingAjaxCall = {
        /**
         * A logical name for the call.
         */
        readonly name: string;
        /**
         * A Promise resolving when the call concludes.
         */
        readonly promise: Promise<unknown>;
    };
    /**
     * Notes a newly initiated ajax call for inclusion in 'pendingCallCount' and 'pendingAjaxCalls'.
     *
     * @param ajaxCall The ajax call.
     */
    function noteAjaxCall(ajaxCall: PendingAjaxCall): void;
    interface NetworkTelemetry {
        (jqXHR: FxHelpers.XMLHttpRequestLike, isError?: boolean): void;
    }
    function createTelemetry(settings: NetAjaxSettings<any>, suppressHighVolume?: boolean): NetworkTelemetry;
    /**
     * Options passed to 'traceReactViewAjax'.
     */
    type TraceReactViewAjaxOptions = {
        /**
         * Information about the ajax request.
         */
        readonly request: Pick<NetAjaxSettings<any>, "skipTelemetry" | "headers" | "type" | "uri" | "data"> & {
            /**
             * Size of the request.
             */
            readonly dataSentBytes: number;
        };
        /**
         * Information about the ajax response.
         */
        readonly response: Partial<Pick<FxHelpers.XMLHttpRequestLike, "status">> & {
            /**
             * Size of the response in bytes.
             */
            readonly dataReceivedBytes?: number;
            /**
             * Indicates whether the network request failed (threw an exception).
             */
            readonly isError?: boolean;
            /**
             * An identifier returned from the service that identifies the call made from the Portal client.
             */
            readonly responseCorrelationId?: string;
            /**
             * The response text.  Only req'd when the network request is to ARM/MsGraph batch.
             */
            readonly responseText?: string;
        };
        /**
         * The ajax call start time.
         */
        readonly startTime: number;
        /**
         * The ajax call end time.
         */
        readonly endTime: number;
        /**
         * Context for the Blade that issued the ajax call (if any).
         */
        readonly bladeContext: Telemetry.Context.CompositionContext;
    };
    /**
     * Issues telemetry for an ajax call. Intended for ajax calls originating from ReactViews IFrames.
     *
     * @param options Information about the ajax call.
     */
    function traceReactViewAjax(options: TraceReactViewAjaxOptions): void;
    function registerTelemetrySubmissionHandler(): void;
    function getPerformanceTelemetry(): PerformanceTelemetry;
    function getBootstrapTelemetry(): BootstrapTelemetry;
    /**
     * Returns the current Blade instance.
     *
     * @returns The current Blade instance.
     */
    function getCurrentBladeInstance(): BladeInstance;
}

// FILE: MsPortalFx\Base\Internal\Base.Intl.d.ts
declare module MsPortalFx.Intl {
    interface NumberFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The formatting style to use. Possible values are "decimal" for plain number formatting, "currency" for currency formatting, and "percent" for percent formatting; the default is "decimal".
         */
        style?: string;
        /**
         * The currency to use in currency formatting. Possible values are the ISO 4217 currency codes, such as "USD" for the US dollar, "EUR" for the euro, or "CNY" for the Chinese RMB. There is no default value; if the style is "currency", the currency property must be provided.
         */
        currency?: string;
        /**
         * How to display the currency in currency formatting. Possible values are "symbol" to use a localized currency symbol such as €, "code" to use the ISO currency code, "name" to use a localized currency name such as "dollar"; the default is "symbol".
         */
        currencyDisplay?: string;
        /**
         * Whether to use grouping separators, such as thousands separators or thousand/lakh/crore separators. Possible values are true and false; the default is true.
         */
        useGrouping?: boolean;
        /**
         * The minimum number of integer digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumIntegerDigits?: number;
        /**
         * The minimum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number and percent formatting is 0; the default for currency formatting is the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information).
         */
        minimumFractionDigits?: number;
        /**
         * The maximum number of fraction digits to use. Possible values are from 0 to 20; the default for plain number formatting is the larger of minimumFractionDigits and 3; the default for currency formatting is the larger of minimumFractionDigits and the number of minor unit digits provided by the ISO 4217 currency code list (2 if the list doesn't provide that information); the default for percent formatting is the larger of minimumFractionDigits and 0.
         */
        maximumFractionDigits?: number;
        /**
         * The minimum number of significant digits to use. Possible values are from 1 to 21; the default is 1.
         */
        minimumSignificantDigits?: number;
        /**
         * The maximum number of significant digits to use. Possible values are from 1 to 21; the default is minimumSignificantDigits.
         */
        maximumSignificantDigits?: number;
    }
    interface DateTimeFormatOptions {
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        localeMatcher?: string;
        /**
         * The representation of the weekday. Possible values are "narrow", "short", "long".
         */
        weekday?: string;
        /**
         * The representation of the era. Possible values are "narrow", "short", "long".
         */
        era?: string;
        /**
         * The representation of the year. Possible values are "numeric", "2-digit".
         */
        year?: string;
        /**
         * The representation of the month. Possible values are "numeric", "2-digit", "narrow", "short", "long".
         */
        month?: string;
        /**
         * The representation of the day. Possible values are "numeric", "2-digit".
         */
        day?: string;
        /**
         * The representation of the hour. Possible values are "numeric", "2-digit".
         */
        hour?: string;
        /**
         * The representation of the minute. Possible values are "numeric", "2-digit".
         */
        minute?: string;
        /**
         * The representation of the second. Possible values are "numeric", "2-digit".
         */
        second?: string;
        /**
         * The representation of the time zone name. Possible values are "short", "long".
         */
        timeZoneName?: string;
        /**
         * The locale matching algorithm to use. Possible values are "lookup" and "best fit"; the default is "best fit".
         */
        formatMatcher?: string;
        /**
         * Whether to use 12-hour time (as opposed to 24-hour time). Possible values are true and false; the default is locale dependent.
         */
        hour12?: boolean;
        /**
         * The hour cycle to use. Possible values are "h11", "h12", "h23", "h24". The hour12 option takes precedence in case both options have been specified.
         */
        hourCycle?: string;
        /**
         * The time zone to use. The only value implementations must recognize is "UTC"; the default is the runtime's default time zone. Implementations may also recognize the time zone names of the IANA time zone database, such as "Asia/Shanghai", "Asia/Kolkata", "America/New_York".
         */
        timeZone?: string;
    }
}

// FILE: MsPortalFx\Base\Internal\Internal.Base.Diagnostics.Telemetry.Context.d.ts
declare module FxImpl.TelemetryContext {
    import TelemetryContext = MsPortalFx.Base.Diagnostics.Telemetry.Context;
    import ContextValue = TelemetryContext.ContextValue;
    enum ContextType {
        Part = 0,
        Blade = 1,
        CompositionItem = 2
    }
    /**
     * The current values for all provided context types.
     */
    interface ContextValues extends StringMap<ContextValue> {
    }
    /**
     * Allows saving and restoring all context state when logical operations begin and end.
     */
    interface State {
    }
    /**
     * Contributes data of the specified type to the current context.
     *
     * @param contextType The type of context.
     * @param value Value of the context.
     */
    function setContextValue(contextType: ContextType, value: ContextValue): void;
    /**
     * Removes the most recent value for this context type.
     *
     * @param name The type of context.
     */
    function resetContextValue(contextType: ContextType): void;
    /**
     * Provide a context value during an operation.
     *
     * @param action The operation to execute.
     * @param contextType The type of context.
     * @param value Value of the context.
     * @returns The return value of the operation.
     */
    const provideContext: <T>(action: () => T, contextType: ContextType, value: ContextValue) => T;
    /**
     * Gets the most recent value for this context type.
     *
     * @param contextType The type of context.
     * @returns The value if one.
     */
    function getCurrentValue<T extends ContextValue>(contextType: ContextType): T;
    /**
     * Gets all of the most recent values for all context types.
     *
     * @returns The values.
     */
    function getCurrentValues(): ContextValues;
    /**
     * Returns the current state that can be restored later.
     *
     * @returns The state.
     */
    function getState(): State;
    /**
     * Provide a state during an operation.
     *
     * @param action The operation to execute.
     * @param state The state.
     * @returns The return value of the operation.
     */
    const usingState: <T>(action: () => T, state: State) => T;
}

// FILE: MsPortalFx\Base\Internal\ObservableMap.d.ts
declare module MsPortalFx.Base.Internal {
    /**
     * An observable map. This interface is immutable.
     * All method except latch SHOULD prefix with "_" such that PO should not expose the other side of iFrame.  None should use any of these methods across iframe.
     */
    interface IObservableMap<T> {
        /**
         * Equivalent to doing () on an observable. Triggers updates in computeds, etc.
         * This is intentional to expose latch as KnockoutObservable such that the other IFrame can get access to the data as a method call.
         *
         * @returns The underlying map.
         */
        latch: KnockoutReadOnlyObservableBase<StringMap<T>>;
        /**
         * Returns the item associated with key in the map.
         *
         * @param key The key to look up.
         * @returns The item associated with the key value pair.
         */
        lookup(key: string): T;
        /**
         * Iterates through each object in the observable map.
         *
         * @param callback The function that gets called on each item in the map.
         */
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        /**
         * Determines whether all the members of an array satisfy the specified test.
         *
         * @param callbackfn A function that accepts up to two arguments. The every method calls the callbackfn function for each element in the map until the callbackfn returns false, or until the end of the map.
         * @returns True if the callback function returns true for all map elements, false otherwise.
         */
        every(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Determines whether the specified callback function returns true for any element of a map.
         *
         * @param callbackfn A function that accepts up to two arguments. The some method calls the callbackfn function for each element in the map until the callbackfn returns true, or until the end of the map.
         * @returns True if the callback function returns true for at least one map element, false otherwise.
         */
        some(callbackfn: (value: T, key: string) => boolean, thisArg?: any): boolean;
        /**
         * Creates an Array<T> from the elements of the map.
         *
         * @returns The instance of the array with flattened map elements.
         */
        toArray(): Array<T>;
        /**
         * Creates a projection of the observable map.
         *
         * @param transform A function that transforms object in this map into objects in the projection.
         * @param transform A function that transforms object in this map into objects in the projection, optionally using the old generated value.
         * @returns The projected map.
         */
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Gets the number of items in the observable map.
         */
        count: number;
        /**
         * Disposes of the map. Don't call this. Any maps that need cleaning up will require a lifetime manager.
         */
        dispose(): void;
        /**
         * Subscribes to an observable map.
         *
         * @param lifetimeManager The manager responsible for disposing of the subscription.
         * @param callback Called when the map changes.
         * @param target See observable subscribe function.
         * @param topic See observable subscribe function.
         * @returns The subscription to the map.
         */
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
    }
    /**
     * An observable map. This interface is mutable.
     * All method SHOULD prefix with "_" none of the object method expected to be executed in the other iFrame.
     */
    interface IMutableObservableMap<T> extends IObservableMap<T> {
        /**
         * Associates the passed key with the passed value.
         *
         * @param the key of the key/value pair.
         * @param the value of the key/value pair.
         */
        put(key: string, value: T): void;
        /**
         * Prevents any knockout notifications until the passed callback executes.
         * Anytime you need to push lots of key value pairs, you should do it in the passed callback.
         * This function also locks any dependant maps (projections or unions) so they too only fire one
         * update.
         *
         * @param callback the function to call before notifying subsribers.
         */
        modify(callback: () => void): void;
        /**
         * Removes all items from the observable map.
         */
        clear(): void;
        /**
         * Removes the key/value pair from the map. Throws if the key is not present in the map.
         *
         * @param key The key (and its corresponding value) to remove from the map.
         */
        remove(key: string): void;
    }
    /**
     * An observable map/dictionary. When you add or remove key value pairs, it notifies subscribers.
     * Can be used in computeds and like any other observable except that you use .latch() to read the map
     * and put, remove, and clear to mutate the map.
     */
    class ObservableMap<T> implements IMutableObservableMap<T> {
        /**
         * Actual string map that stores the values.
         */
        _modifyMap: StringMap<T>;
        /**
         * Maps, dependent on this one.
         */
        _dependantMaps: ObservableMap<any>[];
        /**
         * The internal workings of observable map. For access the readonly observable, please use latch()
         */
        private _observable;
        private _isInModifyBlock;
        put(key: string, value: T): void;
        lookup(key: string): T;
        modify(callback: () => void): void;
        latch: KnockoutObservable<StringMap<T>>;
        clear(): void;
        get count(): number;
        remove(key: string): void;
        forEach(callback: (value: T, key: string) => void, thisArg?: any): void;
        some<ThisArg>(callback: (this: ThisArg, value: T, key: string) => boolean, thisArg?: ThisArg): boolean;
        every(callback: (value: T, key: string) => boolean, thisArg?: any): boolean;
        toArray(): Array<T>;
        dispose(): void;
        subscribe(lifetimeManager: Base.LifetimeManager, callback: (newValue: StringMap<T>) => void, target?: any, topic?: string): KnockoutSubscription<StringMap<T>>;
        map<U>(lifetimeManager: MsPortalFx.Base.LifetimeManager, transform: (value: T, oldValue?: U) => U): IObservableMap<U>;
        /**
         * Adds a map as a dependant. Whenever the user adds or removes a key, this change gets reflected
         * in all dependant maps.
         *
         * @param map The map that depends on us. Generic parameter is any instead of T because projections are generally a different type.
         */
        _addDependantMap(map: ObservableMap<any>): void;
        /**
         * Removes a dependant observable map. The map will no longer receive updates from this map.
         *
         * @param map The map to remove as a dependancy. Generic parameter is any instead of T because projections are generally a different type.
         */
        _removeDependantMap(map: ObservableMap<any>): void;
        /**
         * Called when an an upstream map adds a key value pair.
         *
         * @param key The added key.
         * @param value The added value. Type is any because projections may have a different type than the parent map.
         */
        _putNotification(key: string, value: any): void;
        /**
         * Called when an upstream map removes a key.
         *
         * @param key The key removed.
         */
        _removeNotification(key: string): void;
        /**
         * Called when an upstream map removes all keys
         *
         * @param map The map being cleared.
         */
        _clearNotification(map: IObservableMap<any>): void;
        private _validateKey;
    }
    /**
     * A projection of an observable map. Whenever a key/value pair gets added to the base map,
     * a transformed object with the same key gets added to the projection. Removing from or clearing
     * the base map reflects in the projection as well.
     * Map.project is an easier was to create these.
     */
    class ObservableMapProjection<T, U> extends ObservableMap<U> {
        private _transform;
        private _map;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, map: ObservableMap<T>, transform: (value: T) => U);
        dispose(): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        put(key: string, value: U): void;
        /**
         * Projections are immutable. Throws an exception.
         */
        remove(key: string): void;
        /**
         * Projections are immutable. Throws an exceptions.
         */
        clear(): void;
        _putNotification(key: string, value: T): void;
        _removeNotification(key: string): void;
        _clearNotification(map: IObservableMap<any>): void;
    }
    /**
     * Contains the union of key/value pairs on any number of other maps.
     */
    class ObservableMapUnion<T> extends ObservableMap<T> {
        private _maps;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, ...maps: IObservableMap<T>[]);
        dispose(): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        put(key: string, value: T): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        remove(key: string): void;
        /**
         * Unions are immutable. Throws an exceptions.
         */
        clear(): void;
        _putNotification(key: string, value: T): void;
        _removeNotification(key: string): void;
        _clearNotification(map: IObservableMap<any>): void;
    }
}

// FILE: MsPortalFx\Blades.d.ts
declare module MsPortalFx.Blades {
    /**
     * Represents the different display states of the blade.
     */
    const enum DisplayState {
        /**
         * The blade is minimized.
         */
        Minimized = 0,
        /**
         * The blade is displayed in its regular format.
         */
        Normal = 1,
        /**
         * The blade is maximized.
         */
        Maximized = 2
    }
    module Internal {
        enum DisplayState {
            Minimized = 0,
            Normal = 1,
            Maximized = 2
        }
        enum BladeWidth {
            Small = 0,
            Medium = 1,
            Large = 2,
            XLarge = 3,
            Menu = 51
        }
        enum BladeStyle {
            Action = 1,
            Info = 2,
            Create = 3,
            Context = 4,
            Help = 5,
            Basic = 6,
            ContextAction = 7,
            BasicWithCommands = 8,
            Hub = 9,
            HubSubMenu = 10,
            ResourceSetting = 11,
            App = 12
        }
    }
}

// FILE: MsPortalFx\Blades\BladeStyle.d.ts
declare module MsPortalFx.Blades {
    const enum BladeStyle {
        /**
         * The action blade, the one that has commands. This is also the default blade.
         */
        Action = 1,
        /**
         * The information blade.
         */
        Info = 2,
        /**
         * The blade style for the create scenario, which contains an action bar.
         */
        Create = 3,
        /**
         * The blade style for the filter scenario.
         */
        Context = 4,
        /**
         * The blade style for help content.
         */
        Help = 5,
        /**
         * The blade that displays basic information and has no padding around its content.
         */
        Basic = 6,
        /**
         * The context blade style with commands.
         */
        ContextAction = 7,
        /**
         * The blade that displays basic information and has no padding around its content. Allows for commands.
         */
        BasicWithCommands = 8,
        /**
         * The blade style for hub.
         */
        Hub = 9,
        /**
         * The blade style for hub submenu.
         */
        HubSubMenu = 10,
        /**
         * The blade style for settings blade.
         */
        ResourceSetting = 11,
        /**
         * The app blade.
         */
        App = 12
    }
}

// FILE: MsPortalFx\Blades\BladeWidth.d.ts
declare module MsPortalFx.Blades {
    const enum BladeWidth {
        /**
         * A small blade width, using 3 azure grid columns.
         */
        Small = 0,
        /**
         * A medium blade width, using 6 azure grid columns. This is the default width when unspecified.
         */
        Medium = 1,
        /**
         * A large blade width, using 9 azure grid columns.
         */
        Large = 2,
        /**
         * An extra large blade width, using 12 azure grid columns.
         */
        XLarge = 3,
        /**
         * A blade width used for rendering a blade with a menu.
         */
        Menu = 51
    }
}

// FILE: MsPortalFx\Composition\Composition.Configuration.d.ts
declare module MsPortalFx.Composition.Configuration {
    namespace Part {
        /**
         * This is the Part Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Part such that:
         * - 'onInvoke'/'onInputsSet' is passed both:
         *   - parameters (passable from caller, bindable to values at the Dashboard level) and
         *   - settings (internal, persisted state that is never passed from caller or acquired from the Dashbaord).
         * - Parameter values can be overridden by the user (via configuration in the Context Pane).  When overridden, values passed by the
         * caller or acquired from the Dashboard via binding are ignored.
         */
        interface Contract<TParameters, TSettings> {
            /**
             * A means of extracting all current parameter/settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @returns Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TParameters, TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Part Configuration.
             * @returns A Promise reflecting the saving of the parameters/settings changes.
             */
            updateValues(newValues: ValuesWithMetadata<TParameters, TSettings>): Promise<any>;
        }
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TParameters, TSettings> {
            "--noUnusedLocals"?: TParameters | TSettings | any;
            [others: string]: any;
        }
        /**
         * A representation of the current values in a Part's Configuration, along with metadata for each value.
         * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
         * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Part.
         */
        interface ValuesWithMetadata<TParameters, TSettings> {
            /**
             * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
             * includes metadata describing each parameter value.
             */
            parameters: ParameterValuesWithMetadata<TParameters>;
            /**
             * TSettings typed Part settings that will be supplied to this Part's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
        /**
         * TParameters-typed values that will be supplied to this Part's 'onInvoke'/'onInputsSet'.  In addition to TParameters, this
         * includes metadata describing each parameter value.
         */
        interface ParameterValuesWithMetadata<TParameters> {
            /**
             * The parameter values.
             */
            values: TParameters;
            /**
             * Currently relevant for Parts only (and not for Blades).
             * Metadata covering each of the parameter values.
             */
            metadata: StringMap<ParameterMetadata>;
        }
    }
    namespace Blade {
        /**
         * Options passed to 'container.activateConfiguration()'.
         */
        interface Options<TSettings> {
            "--noUnusedLocals"?: TSettings | any;
            [others: string]: any;
        }
        /**
         * This is the Blade Configuration API which is available as 'container.activateConfiguration()'.
         *
         * This Configuration is an opt-in means of expanding upon the Blade such that:
         * - 'onInvoke'/'onInputsSet' is passed:
         *   - settings (internal, persisted state).
         */
        interface Contract<TSettings> {
            /**
             * A means of extracting all current settings values along with their metadata.
             * Typically, this is called in a 'supplyInitialData' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @returns Current Configuration values along with value metadata.
             */
            getValues(): ValuesWithMetadata<TSettings>;
            /**
             * A means of atomically committing Configuration changes, typically from a ParameterProvider Blade.
             * Typically, this is called from a 'receiveResult' callback for a BladeReference/ParameterCollector to a "Configure..."
             * ParameterProvider Blade.
             *
             * @param newValues New Configuration values and value metadata reflecting the new state of the Blade Configuration.
             * @returns A Promise reflecting the saving of the parameters/settings changes.
             */
            updateValues(newValues: ValuesWithMetadata<TSettings>): Promise<any>;
        }
        /**
         * A representation of the current values in a Blade's Configuration, along with metadata for each value.
         * Useful for passing to a "Configure..." ParameterProvider Blade for user-editing of Configuration values.
         * Also useful for returning from this same "Configure..." ParameterProvider Blade to the calling Blade.
         */
        interface ValuesWithMetadata<TSettings> {
            /**
             * TSettings typed Blade settings that will be supplied to this Blade's 'onInvoke'/'onInputsSet'.
             */
            settings: TSettings;
        }
    }
    /**
     * Per-parameter metadata returned from 'config.getValues()' or supplied by the extension when calling 'config.updateValues()'.
     */
    interface ParameterMetadata {
        /**
         * Reflects whether the corresponding Part is currently situated on a Dashboard and, if so, whether this parameter value can
         * be bound to values at the Dashboard-level.  For the extension, a non-empty array here should determine whether -- in the
         * "Configure..." Context Pane -- the user should be presented with UI to choose whether to bind to a Dashboard-level value.
         */
        bindingSources: ParameterBindingSource[];
        /**
         * Used only if the 'bindingSources' array above is non-empty.
         * Re: 'config.getValues()', indicates whether this pContractarameter value is currently bound to a value from the containing Dashboard.
         * Re: 'config.updateValues()', determines whether this parameter value should be bound to a value from the containing Dashboard.
         * If 'activeBindingSourceName' is not supplied, then any user-specified value for this parameter will be used to override
         * the value that would otherwise be acquired via binding from the containing Dashboard.
         */
        activeBindingSourceName: string;
        /**
         * Re: 'config.updateValues()', determines whether this updated parameter value should be applied to the containing dashboard.
         * This value is used only if the 'bindingSources' array is non-empty and 'activeBindingSourceName' names a binding source from
         * 'bindingSources'.
         */
        applyUpdatedValueToActiveBindingSource?: boolean;
    }
    /**
     * A description of a Dashboard-level property to which a parameter can be bound.
     */
    interface ParameterBindingSource {
        /**
         * The runtime name of the property at the Dashboard level.
         */
        name: string;
        /**
         * Indicates whether this Dashboard-level property accepts value updates (see
         * 'ParameterMetadata.applyUpdatedValueToActiveBindingSource').
         */
        acceptsValueUpdates: boolean;
    }
    /**
     * Part/Blade parameter and settings values.
     */
    interface Values<TParameters, TSettings> {
        /**
         * Parameter values.
         */
        parameters: TParameters;
        /**
         * Settings values.
         */
        settings: TSettings;
    }
    /**
     * Represents either an absolute or relative time range.
     */
    interface TimeRange {
        /**
         * An absolute time range.
         */
        absolute?: {
            /**
             * The start of the time range.
             */
            from: Date;
            /**
             * The end of the time range.
             */
            to: Date;
        };
        /**
         * A relative time range.
         */
        relative?: {
            /**
             * The duration for the relative time range.
             */
            duration: number;
            /**
             * The time unit for the duration of the relative time range.
             */
            timeUnit: TimeUnit;
        };
    }
    /**
     * Values represent units of time.  Used in TimeRange.
     */
    const enum TimeUnit {
        Minute = 0,
        Hour = 1,
        Day = 2,
        Week = 3,
        Month = 4,
        Year = 5
    }
    /**
     * A parameter value type that a Part can acquired from its Dashboard via binding.
     */
    type ValueType = string;
    /**
     * A value type that for TimeRange.
     */
    const TimeRangeValueType = "MsPortalFx.Composition.Configuration.ValueTypes.TimeRange";
}
declare module FxImpl.Composition {
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    /**
     * The signature for a callback that informs the Part/Blade that its Configuration has changed value in some way.
     */
    type ConfigurationChangedHandler = (values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>, callOnUpdateWithChanges: boolean) => Promise<any>;
    /**
     * See the MsPortalFx.Composition.Configuration.Contract for details.
     */
    class Configuration<TParameters extends StringMap<any>, TSettings extends StringMap<any>> implements FxCompositionConfiguration.Part.Contract<TParameters, TSettings>, FxCompositionConfiguration.Blade.Contract<TSettings> {
        private _persistedValues;
        private _configChangedHandler;
        /**
         * Constructs a Configuration object.
         *
         * @param options Options that determine the behavior of the Configuration object.
         * @param configChangedHandler A callback that notifies when the Part/Blade's Configuration has changed in some way.
         */
        constructor(options: FxCompositionConfiguration.Part.Options<TParameters, TSettings>, configChangedHandler: ConfigurationChangedHandler);
        /**
         * This will be called by the FX/Shell once the Part has been bound into its containing dashboard/Blade.
         *
         * @param values Parameter and settings values including metadata describing whether parameters are bound/bindable
         * to the containing dashboard or Blade.
         */
        setValues(values: FxCompositionConfiguration.Part.ValuesWithMetadata<any, any>): void;
        getValues(): FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>;
        updateValues(newValues: FxCompositionConfiguration.Part.ValuesWithMetadata<TParameters, TSettings>, callOnUpdateWithChanges?: boolean): Promise<any>;
    }
}

// FILE: MsPortalFx\Composition\Composition.PartReference.d.ts
declare module MsPortalFx.Composition {
    interface PartReferenceOptions {
        /**
         * The name of the extension that owns the part.
         */
        extensionName?: string;
        /**
         * The initial size of the part.
         */
        initialSize?: MsPortalFx.Parts.PartSize;
        /**
         * If initialSize is Custom, this specifies the number of grid rows to cover.
         */
        initialHeight?: number;
        /**
         * If initialSize is Custom, this specifies the number of grid columns to cover.
         */
        initialWidth?: number;
    }
    /**
     * Identifies the part that is referenced
     */
    class PartReference<TParameters> {
        /**
         * The name of the part.
         */
        partName: string;
        /**
         * Parameters that are passed to the target part
         */
        parameters: TParameters;
        /**
         * Options to create the target part
         */
        options: PartReferenceOptions;
        /**
         * PartReference constructor
         *
         * @param partName partName of the referenced part
         * @param parameters parameters that are passed to the target part
         * @param options options that are used to create the target part
         */
        constructor(partName: string, parameters: TParameters, options?: PartReferenceOptions);
    }
    /**
     * Identifies the part that is referenced
     */
    class ResourcePartReference {
        /**
         * The id of the resource to pin.
         */
        resourceId: string;
    }
}

// FILE: MsPortalFx\Composition\Composition.Selectable2.d.ts
declare module FxImpl {
    /**
     * Method for accessing the interface which is used as a channel of communication between
     * the shell and the public facing SDK Apis that extension use.
     *
     * @param viewModel framework view model that the shell interface is attached to. This view model is the public facing API.
     * @param initialValue if not null, the shell interface is initialized with the provided object.
     * @returns The internal communication interface.
     */
    function shellInterface<T>(viewModel: any, initialValue?: T): T;
    module CompositionCore {
        /**
         * Supplies the reason a Blade was closed, for instance, to the opening BladeReference's 'onClosed' callback.
         */
        const enum BladeClosedReason {
            /**
             * The blade was closed in reaction to some user navigation.
             */
            UserNavigation = 1,
            /**
             * The child blade closed itself programmatically.
             */
            ChildClosedSelf = 2
        }
        /**
         * The function typing for 'onClosed' callbacks for Blades.
         */
        type BladeClosedHandler = (reason: BladeClosedReason) => void;
        /**
         * The function typing for 'onClosed' callbacks for Blades, returning data from the Blade to the callback.
         */
        type BladeClosedWithDataHandler<TData> = (reason: BladeClosedReason, data: TData) => void;
        /**
         * A view model that represents a click target that opens a link.
         */
        class ClickableLink {
            /**
             * The URI that will be opened.
             */
            uri: KnockoutObservable<string>;
            /**
             * The link target. Target is _blank if unspecified.
             */
            target: KnockoutObservable<string>;
            /**
             * Window features for the new window.
             * See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features
             */
            windowFeatures?: KnockoutObservable<string>;
            /**
             * Callback triggered after the link is opened.
             *
             * @param keypress Indicates if the link is opened by keypress.
             */
            onLinkOpened: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
            /**
             * Construct an instance of the view model.
             *
             * @param uri The URI that will be opened.
             * @param target The link target.
             * @param windowFeatures Window features for the new window.
             * @param onLinkOpened Callback triggered after the link is opened.
             * @param telemetryName partner provided Telemetry identifier.
             */
            constructor(uri: string | KnockoutObservable<string>, target?: string | KnockoutObservable<string>, windowFeatures?: string | KnockoutObservable<string>, onLinkOpened?: (keypress: boolean) => void, telemetryName?: string);
        }
        /**
         * Options supplied when adding an operation to a Blade or Part.
         */
        interface OperationOptions {
            /**
             * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
             */
            blockUi: boolean;
            /**
             * The type of blocking shield that will appear if UI is blocked.
             */
            shieldType?: ShieldType;
        }
        /**
         * The type of shield to show when there is one or more operations in progress.
         */
        export import ShieldType = MsPortalFx.ViewModels.ShieldType;
        /**
         * A list of in-progress operations for the Blade or Part.  These control the Blade or Part loading indicator.
         */
        interface OperationList {
            /**
             * Adds an operation to the list.
             *
             * @param promise A promise representing the operation to be added.
             * @param options Additional options describing how the operation should be visualized.
             */
            add(promise: Promise<any>, options?: OperationOptions): void;
            /**
             * Removes an operation from the list.
             *
             * @param promise The promise matching the operation to remove.
             */
            remove(promise: Promise<any>): void;
            /**
             * Updates the options associated with an operation list entry.
             *
             * @param promise The promise matching the operation to update.
             * @param options New options for the operation.
             */
            update(promise: Promise<any>, options: OperationOptions): void;
            /**
             * Describes the options associated with an operation list entry.
             *
             * @param promise The promise matching the operation to update.
             * @returns Options associated with the operations.
             */
            getOptionsForOperation(promise: Promise<any>): OperationOptions;
        }
        /**
         * A description of a Blade that should be opened when a target is clicked.
         * BladeLink is preferred to other callback-style APIs that use "container.openBlade(...)",
         * since BladeLink works with the browser's "open in new tab/window" and "copy link" support.
         */
        type BladeReference = Composition.Selectable.BladeReference<any>;
        /**
         * Options supplied when constructing a blade link capable of opening in a new tab too.
         */
        interface BladeLink {
            /**
             * Blade reference of blade to be opened.
             */
            readonly bladeReference: BladeReference | KnockoutObservableBase<BladeReference>;
            /**
             * The callback triggered after the link is opened via left-click or 'Enter' key. This is not called when opened in a new tab/window.
             *
             * @param keypress Indicates if the link is opened by keypress.
             */
            readonly onLinkOpened?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
        }
        /**
         * Options supplied when constructing a resource blade link capable of opening in a new tab too.
         */
        interface ResourceLink {
            /**
             * Resource id.
             */
            readonly resourceId: string | KnockoutObservableBase<string>;
            /**
             * The callback triggered after the link is opened via left-click or 'Enter' key. This is not called when opened in a new tab/window.
             *
             * @param keypress Indicates if the link is opened by keypress.
             */
            readonly onLinkOpened?: (keypress: boolean) => void;
            /**
             * Telemetry identifier.
             */
            readonly telemetryName?: string;
        }
    }
    module Composition.Selectable {
        /**
         * Identifies the target blade that is to be opened
         */
        class BladeReference<TParameters> {
            private _msPortalFxCallbacks;
            /**
             * BladeReference constructor
             *
             * @param parameters parameters that are passed to the target blade
             */
            constructor(parameters: TParameters, callbacks?: any);
            /**
             * Parameters that are passed to the target blade
             */
            parameters: TParameters;
            /**
             * Create a copy of this blade reference with new parameters
             *
             * @param parameters new set of parameters to pass to the child blade
             */
            clone(parameters: TParameters): BladeReference<TParameters>;
        }
        /**
         * Callbacks for PDL generated blades
         */
        interface PdlBladeCallbacks<TOutputs> {
            /**
             * This method is invoked when outputs are returned from a child blade
             */
            onOutputsChanged: (outputs: TOutputs) => void;
        }
        /**
         * Properties which describe the blade that is too be opened
         */
        interface PdlBladeMetadata {
            /**
             * List of outputs to receive from the child blade
             */
            outputParameters?: string[];
            /**
             * If true this blade is opened as a context blade
             */
            isContextBlade?: boolean;
            /**
             * if the blade will be opened in the context pane, true open as context, false open as detail blade
             */
            persistentContextPane?: boolean;
        }
        /**
         * Options for configuring the PdlBladeReference class
         */
        interface PdlBladeReferenceOptions<TParameters, TOutputs> {
            /**
             * Parameters to pass to the child blade
             */
            parameters?: TParameters;
            /**
             * Callbacks to invoke
             */
            callbacks?: PdlBladeCallbacks<TOutputs>;
            /**
             * Optional callback that is invoked when the blade is closed.
             */
            onClosed?: CompositionCore.BladeClosedWithDataHandler<any>;
        }
        /**
         * Base class for PDL generated blade references.
         * Extension authors should not be directly creating this class
         */
        class PdlBladeReference<TParameters, TOutputs> extends BladeReference<TParameters> {
            /**
             * Name of the blade
             */
            bladeName: string;
            /**
             * Name of the extension which this contains the blade
             */
            extensionName: string;
            /**
             * Options for this blade reference
             */
            options: PdlBladeReferenceOptions<TParameters, TOutputs>;
            /**
             * Descriptor contains blade attributes
             */
            metadata: PdlBladeMetadata;
            constructor(bladeName: string, extensionName?: string, options?: PdlBladeReferenceOptions<TParameters, TOutputs>, metadata?: PdlBladeMetadata);
        }
        /**
         * Base class for generated provisioning blade references.
         * Extension authors should not be directly creating instances of this class
         */
        class ProvisioningBladeReference<TParameters, TResults> extends PdlBladeReference<TParameters, TResults> {
            constructor(bladeName: string, extensionName?: string, createLauncherOptions?: string | Common.Marketplace.MarketplaceOptions, options?: PdlBladeReferenceOptions<TParameters, TResults>, metadata?: PdlBladeMetadata);
        }
        interface MenuBladeReferenceOptions<TParameters> extends PdlBladeReferenceOptions<TParameters, void> {
            contentBladeReference?: BladeReference<unknown>;
        }
        class MenuBladeReference<TParameters> extends PdlBladeReference<TParameters, void> {
            menuId?: string;
            contentBladeReference: BladeReference<unknown>;
            constructor(bladeName: string, menuId?: string, extensionName?: string, options?: MenuBladeReferenceOptions<TParameters>, metadata?: PdlBladeMetadata);
        }
        interface ParameterProviderOptions<TParameters, TResult, TConfig> extends PdlBladeReferenceOptions<TParameters, void> {
            /**
             * A callback that supplies initial data for the parameter provider
             * in the child blade each time it opens.
             *
             * Note that the object received by the parameter provider will be a
             * deep clone of the value you give, rather than the original instance,
             * because it is passed (and sometimes stored) in a serialized form.
             *
             * @returns Initial data for the child blade.
             */
            supplyInitialData?(): TResult;
            /**
             * A callback that supplies additional configuration options for the
             * provider each time it opens. You can use this to pass non-editable
             * data, for example configuring how a form will be displayed.
             *
             * @returns Arbitrary configuration options for the child blade.
             */
            supplyProviderConfig?(): TConfig;
            /**
             * A callback to be invoked when the child blade supplies a result
             * and closes.
             *
             * @param result The result given by the child blade.
             * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
             */
            receiveResult?(result: TResult): void;
            /**
             * Provides an easy way to integrate a parameter collector with an EditScope.
             *
             * The collector will supply initial data to the provider from this edit scope
             * property, and will automatically insert the provider's output into this edit
             * scope property. The net result is that your parameter collector will act as
             * an editor for the specified edit scope property.
             *
             * If you specify this option, do not also specify either supplyInitialData or
             * receiveResult.
             */
            editScopeAccessor?: MsPortalFx.ViewModels.Forms.EditScopeAccessors<TResult>;
        }
        class ParameterProviderBladeReference<TParameters, TResult, TConfig> extends PdlBladeReference<TParameters, void> {
            constructor(bladeName: string, extensionName: string, options: ParameterProviderOptions<TParameters, TResult, TConfig>, metadata?: PdlBladeMetadata);
        }
        /**
         * Base class for selectable objects
         */
        abstract class SelectableBase<TBladeReference extends BladeReference<any>> {
        }
        /**
         * Configuration to pass to the selectable constructor
         */
        interface Selectable2Options<TBladeReference> {
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * in response to a user-invoked navigation.
             *
             * @returns A blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReference?: () => TBladeReference;
            /**
             * This callback is invoked by the portal when a new blade is to be opened
             * asynchronously in response to a user-invoked navigation.
             *
             * @returns A promise that returns a blade reference that describes the blade to open.  This value cannot be null or undefined.
             */
            supplyBladeReferenceAsync?: () => Promise<TBladeReference>;
        }
        /**
         * Selectable class that is used to open blades in response to user clicks
         */
        class Selectable2<TBladeReference extends BladeReference<any>> extends SelectableBase<TBladeReference> {
            constructor(options: Selectable2Options<TBladeReference>);
        }
        /**
         * View models which are selectable implement this interface
         */
        interface SelectableViewModel {
            configureSelectable<TBladeReference extends BladeReference<any>>(options: Selectable2Options<BladeReference<any>>): Selectable2<TBladeReference>;
        }
        /**
         * Click handler
         */
        type OnClickHandler = (evt: MsPortalFx.ViewModels.FxMouseEvent) => void;
        /**
         * List click handler
         */
        type OnListClickHandler<T> = (selectedItem: T) => void;
    }
    const BladeReference: typeof Composition.Selectable.BladeReference;
    type SelectableViewModel = Composition.Selectable.SelectableViewModel;
    const enum SelectableFlags {
        None = 0,
        IsSelectable = 1,
        ActivateAsync = 2
    }
    const enum BladeReferenceSource {
        None = 0,
        Fetch = 1,
        OpenBlade = 3,
        PendingRequest = 4
    }
    /**
     * Represents the tuple of config and initial state that is sent to
     * a provider blade.
     */
    interface InitialProviderBladeConfig<TResult, TConfig> {
        initialState: TResult;
        config: TConfig;
    }
    const enum ShellInterfaceType {
        /**
         * The interface type used to facility communication
         * between Fx.Composition.Selectable2 (extension selectable 2 API) and Base.Selectable2 (shell)
         *
         * 0x5332 is the ascii codes for 'S2';
         */
        Selectable2 = 21298,
        /**
         * The interface used for consumption by a internal shell collector instance
         */
        ParameterProviderBladeReference = 20560,
        /**
         * The interface used for consumption by a internal shell marketplace instance
         *
         * 0x4D50 is the ascii codes for 'MP';
         */
        ProvisioningBladeReference = 19792
    }
    /**
     * This is the interface through which the shell interacts with
     * the ParameterProviderBladeReference instance
     */
    interface ParameterProviderShellContract<TResult, TConfig> {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * This member is used to pin the initial config that is passed to the blade.
         * This is to ensure the config PO proxy is not prematurely garbage collected
         */
        bladeConfig: KnockoutObservable<InitialProviderBladeConfig<TResult, TConfig>>;
        /**
         * This method is invoked by the shell to get the initial config before opening the new blade on question.
         */
        getBladeConfig(selectedItem?: any): InitialProviderBladeConfig<TResult, TConfig>;
        /**
         * This method is invoked by the shell when a result is returned from the provider blade
         */
        receiveResult(result: TResult): void;
    }
    /**
     * This is the interface through which the shell interacts with
     * the ProvisioningBladeReference instance
     */
    interface MarketplaceShellContract {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         *
         */
        marketplaceOptions: Common.Marketplace.MarketplaceOptions;
    }
    const enum OpenBladeRequestFlags {
        /**
         * Default flags
         */
        Default = 0,
        /**
         * Open the blade in a context pane
         */
        OpenInContextPane = 1,
        /**
         * Open the blade as a sub-journey
         */
        OpenAsSubJourney = 2,
        /**
         * Open the blade in place
         */
        OpenInPlace = 4,
        /**
         * Start a new journey closing all blades that are currently open
         */
        OpenAsNewJourney = 8,
        /**
         * The entity opening the blade is hosted in a context pane
         */
        OpeningFromContextPane = 16,
        /**
         * Open the blade in the help pane.
         */
        OpenInHelpPane = 32,
        /**
         * Close the help pane if it is already opened
         */
        CloseHelpPane = 64,
        /**
         * Minimize the help pane if it is already opened (mutually exclusive with CloseHelpPane)
         */
        MinimizeHelpPane = 128,
        /**
         * The blade that is being opened can be minimized.  This currently only exists in support of a help pane feature.
         */
        CanMinimize = 256,
        /**
         * The opened blade is a sidebar.
         */
        OpenInSideBar = 512,
        /**
         * The opened blade is in docked pane.
         */
        OpenInDockedContextPane = 1024
    }
    /**
     * Used to indicate where a Blade was opened by.
     */
    const enum BladeOpenedBy {
        /**
         * The default when no value is supplied.
         */
        Unknown = 0,
        /**
         * Blade opened by sidebar.
         */
        SideBar = 1,
        /**
         * Blade opened by home.
         */
        Home = 2,
        /**
         * Blade opened by global search bar.
         */
        GlobalSearch = 3,
        /**
         * Blade opened by deeplink.
         */
        DeepLink = 4,
        /**
         * Blade opened by all services.
         */
        AllServices = 5,
        /**
         * Blade opened by notification.
         */
        Notification = 6,
        /**
         * Blade opened by the Avatar Menu.
         */
        AvatarMenu = 7,
        /**
         * Blade opened by KeyBoardShortcut shortcut.
         */
        KeyBoardShortcut = 8,
        /**
         * Blade opened by Feedback Pane.
         */
        FeedbackPane = 9,
        /**
         * Blade opened by Top Bar.
         */
        TopBar = 10,
        /**
         * Blade opened by Debug Pane.
         */
        DebugPane = 11
    }
    interface OpenBladeRequest {
        /**
         * The reason the request is being issued to the blade opener
         */
        reason: BladeReferenceSource;
        /**
         * Blade reference
         */
        bladeReference: Composition.Selectable.BladeReference<unknown>;
        /**
         * tracking id for this request
         *   Used for -
         *     Notification of open blade completion
         *     Lifetime management of callbacks (same blade reference/callback used to open same blade more than one time)
         *     Diagnostics/debugging
         */
        operationId: any;
        /**
         * various open blade flags
         */
        flags: OpenBladeRequestFlags;
        /**
         * Optional metadata attached to the open blade request by the control
         */
        controlMetadata?: any;
        /**
         * for selectable set, the selected item associated with the request
         */
        selectedItem?: any;
        /**
         * for async operations this is the initial width to use for the loading blade
         */
        initialWidth?: MsPortalFx.Blades.BladeWidth;
        /**
         * Optional name used in telemetry to identify which control is opening the blade
         */
        telemetryName?: string;
        /**
         * The time when the request was intiatiated.
         * This is for the purpose of measuring the total from click it took for a blade to load.
         */
        timestamp: number;
        /**
         * The context to determine where the OpenBladeRequest was opened by.
         */
        context?: {
            /**
             * This number represent one of the possible options available to represent the context that the blade was opened by.
             */
            openedBy?: BladeOpenedBy;
        };
    }
    interface OpenBladeResult {
        operationId: any;
        success: boolean;
    }
    type RequestOpenBlade = (selectable2: Composition.Selectable.Selectable2<any>, request: OpenBladeRequest) => Promise<OpenBladeResult>;
    /**
     * This is the channel through which the selectable communicates with the shell.
     *
     * Not the word interface maybe confusing here.   This is not a reference to the TypeScript type.
     */
    interface SelectableShellInterface {
        /**
         * interface type
         */
        type: ShellInterfaceType;
        /**
         * flags indicate capabilities
         */
        flags: SelectableFlags;
        /**
         * this method is invoked when shell requires a open blade request to open a new blade
         * A open blade request contains the blade reference + additional metadata
         */
        fetchRequest: (operationId: any) => OpenBladeRequest | Promise<OpenBladeRequest>;
        /**
         * This is to ensure the current blade reference that was passed to supplyBladeReference is not garbage collected
         * Parameter Provider blade references contain callbacks which can be invoked later after the supplyBladeReference
         * call has completed.  The typing is not imporant here.. only just need to ensure the object is kept alive.
         */
        currentBladeReference: KnockoutObservable<unknown>;
    }
    /**
     * This interface is the internal contract between the shell ahd the selectable view model.
     * A selectable view model is a dual honed object that supports both the legacy selectable and the new selectable.
     * This type exists for backward compat reasons.  New features probably don't need to implement this.
     *
     * This is internal implementation detail and not intended to be accessed directly by extensions.
     */
    interface SelectableViewModelContract {
        _msPortalFxIsSelectableViewModel: boolean;
        _msPortalFxSelectable: MsPortalFx.ViewModels.Selectable<any>;
        _msPortalFxSelectable2: Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    }
    /**
     * Initializes a view model which contains a selectable.
     * Also provides a generic implementation of SelectableViewModel interface as well via a mixin.
     *
     * @param viewModel A view model that is hosting a selectable.
     * @param selectable Legacy support for selectable v1
     */
    function initializeSelectableViewModel(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Assigns a legacy selectable to a selectable view model.  To be during view model construction.
     *
     * @param viewModel the selectable view model that supports both selectable and selectable 2
     * @param selectable The legacy selectable instance
     */
    function assignSelectable(viewModel: SelectableViewModel, selectable: MsPortalFx.ViewModels.Selectable<any>): void;
    /**
     * Tries to get the internal selectable view model interface for a selectable view model.
     *
     * @param viewModel The view mode for which we want to get the internal interface.
     * @returns null if the view model is not a selectable view model
     */
    function tryGetSelectableViewModelContract(viewModel: SelectableViewModel): SelectableViewModelContract;
    /**
     * Returns true if the view model is a selectable view model.
     */
    function isSelectableViewModel(viewModel: any, requireSelectable2?: boolean): viewModel is SelectableViewModelContract;
    /**
     * Returns true if view model is a selectable 2 instance
     */
    function isSelectable2(viewModel: any): viewModel is Composition.Selectable.Selectable2<Composition.Selectable.BladeReference<any>>;
    /**
     * Helper method used by the shell to invoke a callback on a blade reference
     */
    function invokeCallback<TBladeReference extends Composition.Selectable.BladeReference<any>>(bladeReference: TBladeReference, name: string, parameters: any[]): void;
}
declare module "Fx/Composition/Selectable" {
    import Impl = FxImpl.Composition.Selectable;
    export = Impl;
}

// FILE: MsPortalFx\Data\Data.AtomizationOptions.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies atomization context options.
     * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
     */
    interface AtomizationOptions {
        /**
         * Supplies the atomization context id used for cached DataSets.
         * If 'null' or 'undefined' is supplied, a default atomization context will be used.
         * Otherwise, 'atomizationContextId' identifies the atomization context to be used.
         */
        atomizationContextId?: string;
    }
}

// FILE: MsPortalFx\Data\Data.DataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A base interface for QueryCache and EntityCache.
     */
    interface DataCache<TData, TParams> {
        "--noUnusedLocals"?: TData | TParams | any;
        [others: string]: any;
    }
}

// FILE: MsPortalFx\Data\Data.DataCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for a DataCacheLoader.
     */
    interface DataCacheLoaderConfig<TEntity, TParams> {
        "--noUnusedLocals"?: TEntity | any;
        /**
         * Provides a URI from which data should be retrieved. The URI is a function
         * of the supplied parameters.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         *
         * @param params Parameters describing the data to be retrieved. For EntityCaches, this will be the entity ID. For QueryCaches, it will be query parameters.
         * @returns The URI from which data should be retrieved.
         */
        sourceUri?(params: TParams): string;
        /**
         * If true, requests issued by this DataCache will include the user's authorization header.
         *
         * This cannot be used in conjunction with supplyData, because in that case, you are taking manual control over the
         * requests that are issued.
         */
        setAuthorizationHeader?: boolean;
        /**
         * If specified, overrides how query params are mapped to cache entries.
         *
         * If you specify this, ensure that any two logically different parameter objects map to different
         * strings, and that any two logically equivalent parameter objects map to the same string.
         *
         * If not specified here, and not overridden in a custom DataCacheLoader, the default behavior
         * is to regard cache entries as equivalent if and only if they map to the same URI, not differentiating
         * by HTTP method or any other HTTP headers.
         */
        serializeParams?(params: TParams): string;
        /**
         * Specifies the HTTP method that should be used when retrieving data from
         * the configured 'sourceUri'. The default data cache loader uses 'GET' if no
         * 'httpMethod' is configured.
         *
         * Note that you can only specify an 'httpMethod' if you have specified a 'sourceUri',
         * in other words, if you are not supplying a custom loader object.
         */
        httpMethod?: string;
        /**
         * Optional. If provided, the default data loader will use any registered
         * metadata for the entity type to share entity instances across caches.
         */
        entityTypeName?: string;
        /**
         * If true, causes the loader to poll the server for updates. Defaults to false, meaning that the
         * data will only be fetched when first requested or explicitly refreshed.
         */
        poll?: boolean;
        /**
         * Specifies the interval, in milliseconds, between polls. If not set, the recommended default polling interval will be used.
         * This option only takes effect if polling is enabled. The minimum allowed value is 10000.
         */
        pollInterval?: number;
        /**
         * By default, each time the loader polls the server, it updates the local dataset to match the record order
         * in the server's response. Setting this flag to true means that the loader should skip that behavior and
         * instead preserve the client's existing record order when polling.
         */
        pollPreservesClientOrdering?: boolean;
        /**
         * If specified, the DataCache loader should call this to obtain raw JSON data to be merged into the cache.
         * A typical implementation simply performs an ajax request. Usually, the parameters (httpMethod, uri, etc.)
         * are determined by the corresponding options on your DataCacheConfig, but if you implement a custom DataCache
         * loader, then it's possible to vary these programmatically.
         *
         * @param httpMethod The HTTP method to be used.
         * @param uri The URI from which data should be fetched.
         * @param headers Any HTTP headers that should be sent with the request.
         * @param data Any data to be sent in the body of the request.
         * @param params The parameters describing the cache entry for which data is being fetched.
         * @param entryLifetime A lifetime manager object representing the duration that the entry remains in the cache.
         * @returns A promise representing the completion of the request. The promise's result value should be a JavaScript object or array representing the response.
         */
        supplyData?(httpMethod: string, uri: string, headers: StringMap<any>, data: any, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): Promise<any>;
        /**
         * If specified, the DataCache loader will call this each time any data is fetched. This callback
         * should translate the response object into a data array, and optionally, navigation metadata.
         *
         * @param responseData The response object to be processed.
         * @returns A DataCacheProcessedResponse representing the data, and optionally navigation metadata.
         */
        processServerResponse?(responseData: any): DataCacheProcessedResponse;
        /**
         * If supplied, as objects sharing the same entity ID are added to the cache, only a single object instance will be used for a given entity ID.
         */
        atomizationOptions?: AtomizationOptions;
    }
    /**
     * Supplies configuration options for a DataCache (an EntityCache or QueryCache).
     */
    interface DataCacheConfig<TEntity, TParams> extends DataCacheLoaderConfig<TEntity, TParams> {
        /**
         * An object that can supply data for a DataCache.
         *
         * Note that 'sourceUri' and 'loader' are mutually exclusive. One of these
         * must be specified, but not both.
         */
        loader?: DataCacheLoader<TEntity, TParams>;
        /**
         * @deprecated DataCacheConfig.evictionDelay - Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         *
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
        /**
         * For debugging/diagnostic purposes, this is the name of the DataCache included in any error logging done for this DataCache.
         */
        cacheName?: string;
    }
    /**
     * Represents data that may be merged into a cache.
     */
    interface DataCacheProcessedResponse {
        /**
         * The item object, or items array, that should be merged into the cache.
         */
        data: any;
        /**
         * Optional navigation metadata corresponding to the cache entry. This supports
         * navigation in standard controls, such as paging in grids.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
    }
    /**
     * Options for configuring a DataView.
     */
    interface DataViewConfig<TEntity, TParams> extends FxImpl.Data.ObjectViewConfig<TEntity, TParams> {
    }
}

// FILE: MsPortalFx\Data\Data.DataCacheLoader.d.ts
declare module MsPortalFx.Data {
    /**
     * A promise that completes with a DataSet instance, and also knows ahead of time what the DataSet instance's
     * name will be.
     */
    interface DataSetPromise extends Promise<Data.DataSet> {
        dataSetName: string;
    }
    /**
     * An object that can supply data for a DataCache.
     */
    class DataCacheLoader<TEntity, TParams> {
        protected _dataType: string;
        private _uriForParams;
        private _httpMethod;
        private _polls;
        private _pollInterval;
        protected _atomizationOptions: AtomizationOptions;
        private _serializeParams;
        private _supplyData;
        private _processServerResponse;
        private _preservesClientOrder;
        private _setAuthHeader;
        /**
         * Constructs an instance of DataCacheLoader<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Returns a boolean reflecting whether this DataCacheLoader will do background polling refresh
         * of its cached data.
         */
        _doesPoll(): boolean;
        /**
         * Provides an arbitrary string representation of the specified query parameters. Any two
         * logically different parameter objects must map to different strings. Any two logically
         * equivalent parameter objects must map to the same string.
         *
         * @param params The query parameters to be serialized.
         * @returns A string representation of the parameters.
         */
        serializeParams(params: TParams): string;
        /**
         * Begins loading a DataSet corresponding to the specified query parameters. The resulting
         * DataSet must have the specified name.
         *
         * Subclasses of DataCacheLoader may override this method to customise the loader options
         * that get passed on to the loadDataSet method.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param params Parameters representing the data to be loaded.
         * @param entryLifetime Lifetime object of the cache entry being created.
         * @returns A DataSetPromise instance.
         */
        loadDataSetForParams(dataSetName: string, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSetPromise;
        /**
         * Begins loading a DataSet corresponding to the specified loader options. The resulting
         * DataSet must have the specified name.
         *
         * @param dataSetName A name for the resulting DataSet.
         * @param dataSetLoaderOptions Options describing the URI, HTTP headers, etc., to be used in the request.
         * @returns A DataSetPromise instance.
         */
        loadDataSet(dataSetName: string, dataSetLoaderOptions: DataSetLoaderOptions): DataSetPromise;
        /**
         * Begins a new request that will cause the specified DataSet to have its data observably refreshed.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         * @returns A promise that completes when the refresh has completed.
         */
        refreshDataSet(dataSetPromise: DataSetPromise): Promise<FetchData>;
        /**
         * Notifies the loader that the specified DataSet is no longer in use. Any polling for the DataSet
         * will be stopped, and it may be released from memory.
         *
         * @param dataSetPromise A DataSetPromise that, when completed, refers to the DataSet to be disposed.
         */
        disposeDataSet(dataSetPromise: DataSetPromise): void;
        /**
         * Obtains the named data set, if it is already loaded and populated.
         *
         * @param dataSetName The name of the DataSet.
         * @returns The DataSet instance if it is already loaded, otherwise null.
         */
        getLoadedDataSet(dataSetName: string): MsPortalFx.Data.DataSet;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         *
         * @param dataSetName The name of the data set.
         * @returns True if a request is in flight; false otherwise.
         */
        isLoadingDataSet(dataSetName: string): boolean;
        protected _getDataSetLoaderOptions(dataSetName: string, params: TParams, entryLifetime: MsPortalFx.Base.LifetimeManager): DataSetLoaderOptions;
    }
    class DataCacheLoader2<TEntity, TParams> extends DataCacheLoader<TEntity, TParams> {
        /**
         * Constructs an instance of DataCacheLoader2<TEntity, TParams>.
         *
         * @param config Configuration options specifying how the data should be loaded.
         */
        constructor(config: DataCacheLoaderConfig<TEntity, TParams>);
        /**
         * Creates a DataSet in the underlying loader, populating the DataSet with some initial data.
         *
         * @param dataSetName The name of the DataSet.
         * @param params Parameters representing the data to be loaded.
         * @param data Initial data for the DataSet.
         * @param entryLifetime Lifetime object of the cache entry being created.
         * @returns The DataSet in the underlying loader
         */
        establishDataSet(dataSetName: string, params: TParams, data: any, entryLifetime: MsPortalFx.Base.LifetimeManager): Data.DataSet;
    }
}

// FILE: MsPortalFx\Data\Data.DataProvider.d.ts
declare module MsPortalFx.Data.DataProvider {
    /**
     * The contract of DataProvider.
     */
    interface DataProvider {
        /**
         * processResult function is an option for Data.Loader.
         */
        processResult?: ProcessResultFunction;
        /**
         * shapeQuery function.
         */
        shapeQuery?: ShapeQueryFunction;
    }
}

// FILE: MsPortalFx\Data\Data.DataProvider.DataContractJsonSerializer.d.ts
declare module MsPortalFx.Data.DataProvider {
    let DataContractJsonSerializer: DataProvider;
}

// FILE: MsPortalFx\Data\Data.DataProvider.OData.d.ts
declare module MsPortalFx.Data.DataProvider {
    interface ODataQuery {
        /**
         * String result should be filtered with.
         */
        $filter?: string;
        /**
         * Name of property by which result should be ordered.
         */
        $orderby?: string;
        /**
         * Number of entries that should be skipped.
         */
        $skip?: number;
        /**
         * Cap number of result entries.
         */
        $top?: number;
        /**
         * Should include result entries count.
         */
        $inlinecount?: string;
    }
    let OData: DataProvider;
}

// FILE: MsPortalFx\Data\Data.DataSet.d.ts
declare module MsPortalFx.Data {
    import DataSetMergeOptions = MsPortalFx.Data.DataSetMergeOptions;
    /**
     * DataSet is a simple data abstraction exposing managed values through single property.
     */
    class DataSet {
        private _type;
        private _data;
        private _navigationMetadata;
        private _partialErrors;
        private _lifetime;
        _atomizationContext: FxImpl.Data.AtomizationContext;
        /**
         * Creates a data set.
         *
         * @param type The type of the data to be cached in the data set.
         * @param lifetime Data set lifetime object.
         * @param atomizationOptions Atomization options, if not provided, data set will not be atomized.
         */
        constructor(type?: string, lifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: MsPortalFx.Data.AtomizationOptions);
        /**
         * The data cached in this data set.
         */
        get data(): any;
        /**
         * Lifetime manager of this data set. Only atomized data sets have lifetime managers.
         */
        get lifetime(): MsPortalFx.Base.LifetimeManager;
        /**
         * Type of data cached in this data set.
         */
        get type(): string;
        /**
         * Navigation metadata, if available, for this data set.
         */
        get navigationMetadata(): KnockoutObservable<DataNavigationMetadata>;
        /**
         * Error information associated with this data set.
         */
        get partialErrors(): KnockoutObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * Locks a data item such that the item cannot be updated or deleted during merge. This is done to guard
         * against fetched server data overwriting client-side-only creates and updates.
         *
         * @param item The data item to be locked.
         * @param editKind The kind of client-side edit that preceded this lock.
         */
        static lockItem(item: any, editKind: EditKind): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @returns A boolean indicating whether the data has unmerged client changes.
         */
        static hasUnmergedClientChanges(data: any): boolean;
        /**
         * Unlocks a data item so that the item can be updated or deleted during merge. This is done once a client-side
         * create/update has been acknowledged by the server.
         *
         * @param item The data item to be unlocked.
         * @param rememberLockUntilMerged Indicates that the lock is to be remembered as an indicator of an item that
         * is not synchronized with respect to its server-side counterpart.  See 'hasUnmergedClientChanges'.  Defaults
         * to 'true' if not supplied.
         */
        static unlockItem(item: any, rememberLockUntilMerged: boolean): void;
        /**
         * Determines if a data item is locked.
         *
         * @param item The data item.
         * @returns A boolean value indicating whether the data item is locked.
         */
        static isLockedItem(item: any): boolean;
        /**
         * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id properties will be determined.
         * @returns An array of property names or null.
         */
        static getIdPropertyNames(dataSetOrArray: any): string[];
        /**
         * Gets the name of that data item property that uniquely identifies a data item among its peers in a cached array.
         *
         * @param dataSetOrArray The data set or array cached within a data set for which the id property will be determined.
         * @returns A property name or null.
         */
        static getIdPropertyName(dataSetOrArray: any): string;
        /**
         * Merges new data onto a discrete array/object contained in the data set.
         * This method should not be used with DataSets that are enabled for data atomization.
         * For scenarios using data atomization, use the "merge" instance method on DataSet.
         *
         * @param source The new data to be merged onto cached data.
         * @param target The cached data onto which the new data will be merged.
         * @param mergeOptions An optional object describing merge options.
         */
        static mergeWithoutAtomization(source: any, target: any, mergeOptions?: DataSetMergeOptions): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Adds an item in an observable manner to an array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param sourceArray Objects to be inserted into array. These objects will be cloned and appropriately decorated before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param lock Indicates whether the item should be locked. Defaults to true.
         * @param targetArray Target array in DataSet.
         */
        addItems(index: number, sourceArray: any[], mergeOptions?: DataSetMergeOptions, lock?: boolean, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: KnockoutObservableArray<any>): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param index Index in array, where source objects will be inserted into array.
         * @param howMany How many elements should be removed from the array.
         * @param type Target's type. If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param targetArray Target array in DataSet.
         */
        removeItems(index: number, howMany?: number, type?: string, targetArray?: any[]): void;
        /**
         * Removes an item in an observable manner from a data set or array within a data set.
         *
         * @param item Item to be removed from within target array.
         * @param type Type of the item.
         * @param targetArray Target array from which item will be removed. If not provided, operation will be performed on data set root.
         */
        removeItem(item: any, type?: string, targetArray?: any): void;
        /**
         * Sets property of a target with a given value.
         *
         * @param propertyName Name of a property on target object in DataSet.
         * @param source Value object, which target[propertyName] will be set to.
         * This object will be cloned and associated with enity type metadata before being added to target.
         * @param mergeOptions Merge options.
         * If a data set is atomized and targetArray is provided, 'type' option has to provided to perform atomization properly.
         * @param target Target object in DataSet.
         */
        setProperty(propertyName: string, source: any, mergeOptions?: DataSetMergeOptions, target?: any): void;
        /**
         * Merges new data into the data set.
         *
         * @param source The new data to be merged into this data set.
         * @param mergeOptions An optional object describing merge options.
         */
        merge(source: any, mergeOptions?: DataSetMergeOptions): void;
        /**
         * Indicates whether any items within the data set have been recently unlocked and not yet subsequently merged
         * from server data.
         *
         * @param data The data to be examined for unmerged client changes.  If null or not supplied, all data cached
         * in the data set will be considered.
         * @returns A boolean indicating whether the data has unmerged client changes.
         */
        hasUnmergedClientChanges(): boolean;
    }
}

// FILE: MsPortalFx\Data\Data.DataSetMergeOptions.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes possible MsPortalFx.Data.DataSet merge options.
     */
    interface DataSetMergeOptions {
        /**
         * When merging an array, indicates that the ordering of the new array should be preserved.
         */
        preserveNewItemsOrdering?: boolean;
        /**
         * Indicates that items are not to be removed from arrays during this merge.
         */
        preventItemRemoval?: boolean;
        /**
         * The time at which the fetch for the new data was initiated. New data will only be merged into the cache
         * if it was sourced after its cached counterpart was unlocked.
         */
        fetchStart?: number;
        /**
         * A name used to tag diagnostic output from this merge.
         */
        dataSetName?: string;
        /**
         * The type of the data being merged (if not supplied during construction).
         */
        type?: string;
    }
}

// FILE: MsPortalFx\Data\Data.EditScope.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplied at construction time, reflects the kind of EditScope instance that will be created.
     */
    enum EditScopeKind {
        /**
         * A copy of the input data becomes 'editScope.root', the editable data to which UI is bound.
         */
        Copy = 0,
        /**
         * The input data itself becomes 'editScope.root', the editable data to which UI is bound.
         */
        InPlace = 1
    }
    /**
     * Reflects the edit state of an item.
     */
    enum EditState {
        /**
         * The item has not been edited since it was loaded from the server.
         */
        None = 0,
        /**
         * The item is one that was created in memory but not yet created on the server.
         */
        Created = 1,
        /**
         * The item is one that is marked for deletion but not yet deleted on the server.
         */
        Deleted = 2,
        /**
         * The item is one whose property values have been updated in memory but not yet saved to the server.
         */
        Updated = 3
    }
    /**
     * Editable copy of input data, which can then be utilized in editable, revertable view models.
     */
    interface EditScope<TData> extends MsPortalFx.Base.Disposable {
        /**
         * The editable, revertable copy of the input data.
         */
        root: TData;
        /**
         * Is 'true' if the EditScope contains edited entities (entities in 'Updated', 'Deleted' or 'Created' states).
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently refreshing (its 'refresh' method has been called and the
         * corresponding operation is in progress).
         */
        refreshing: KnockoutObservableBase<boolean>;
        /**
         * Is 'true' if the EditScope is currently saving its changes (its 'saveChanges' method has been called and the
         * corresponding operation is in progress).
         */
        saving: KnockoutObservableBase<boolean>;
        /**
         * Marks an entity in the EditScope as being deleted, putting the entity in the 'Deleted' state.
         *
         * @param entity The entity.
         */
        markForDelete(entity: Object): void;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @returns The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: TEntity[]): TEntity;
        /**
         * Creates a new empty entity that can be added to the given array of entities when the edits are saved.
         *
         * @param entityArray The entity array to which the new, empty entity will be added.
         * @returns The empty entity that has not yet been added to the given array of entities.
         */
        create<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): TEntity;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: TEntity[]): void;
        /**
         * Adds a created entity to the given array of entities when the edits are saved.
         * The entity is added in the array of created entities retrieved using 'getCreated'.  The entity will
         * be in the 'Created' state.
         *
         * @param entity The entity to be added to the array of created entitites.
         * @param entityArray The entity array to which the new, empty entity will be added.
         */
        addCreated<TEntity>(entity: TEntity, entityArray: KnockoutObservableBase<TEntity[]>): void;
        /**
         * Reverts any creates, updates, deletes applied to this entity, return it to the 'None' edit state.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         *
         * @param entity The entity being reverted.
         */
        revert(entity: Object): void;
        /**
         * Reverts any creates, updates, deletes applied to the EditScope.
         * Created entities are removed from their 'getCreated' entities array.  Updated entities are restored
         * to their original values.  Deleted entities are no longer marked for delete.
         */
        revertAll(): void;
        /**
         * Gets an observable EditState value, reflecting the create/update/delete state of the supplied entity.
         *
         * @param entity The entity being reverted.
         * @returns The observable EditState value.
         */
        getEditState(entity: Object): KnockoutObservableBase<EditState>;
        /**
         * Gets the original data for a given editable entity or editable array of entities.
         *
         * @param entityOrEntityArray The editable entity or array of entities.
         * @returns The data reflecting the original state of the editable data.
         */
        getOriginal(entityOrEntityArray: any): any;
        /**
         * Gets an array of created entities that will be created in the entity array when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @returns The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: TEntity[]): KnockoutObservableArray<TEntity>;
        /**
         * Gets an array of created entities that will be created in the entityArray when the EditScope edits are saved.
         *
         * @param entityArray The entity array to which entities have been added via 'create'.
         * @returns The array of entities in the 'Created' state.
         */
        getCreated<TEntity>(entityArray: KnockoutObservableBase<TEntity[]>): KnockoutObservableArray<TEntity>;
        /**
         * This method is available only on EditScopes created via EditScopeKind.CopyInputDataToMakeEditableData.
         *
         * Updates the EditScope so that 'editScope.root' (the editable data) reflects the current values in the
         * original data.
         *
         * This method should be used:
         * - To load original data asynchronously after the EditScope has been created and bound into view models.
         * - To incrementally load more or different original data into the EditScope ("show more" or "sort" in a grid).
         */
        mergeFromOriginal(): void;
        /**
         * Applies updates to EditScope data in such a way that updates are not confused with user-enacted edits and,
         * thus, do not dirty the EditScope.
         *
         * When this method completes, editable and original entities will both reflect their refreshed state.
         * User-enacted property-level updates will be over-written by newly loaded values.
         */
        refresh(): Promise<any>;
        /**
         * Initiates an async save operation to commit EditScope edits to a server.  Requires that the corresponding
         * EditScopeCache has been configured with a 'saveEditScopeChanges' callback.
         *
         * When the operation completes, the EditScope will be back in a non-dirty state, reflecting the now-saved
         * data.
         */
        saveChanges(): Promise<any>;
        /**
         * Resets the value of an EditScope observable, in a manner where the reset is not confused as a user-authored
         * edit.
         */
        resetValue<TValue>(accessor: EditScopeAccessors<TValue>, newValue: EditScope.ResetValue<TValue>): void;
        /**
         * For a given entity array, returns an array representation that includes the user's edits.  Here:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with user-edited property values and;
         * - 'Deleted' entities are excluded.
         * Additionally, this method returns discrete arrays of 'Created', 'Updated' and 'Deleted' entities (to save
         * explicit calls to 'editScope.getCreated()' and filtering based on 'editScope.getEditState()').
         */
        getEntityArrayWithEdits<TEntity>(entityArray: TEntity[] | KnockoutObservableBase<TEntity[]>): EntityArrayWithEdits<TEntity>;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: TItem[]): void;
        /**
         * Applies any differences between 'sourceArray' and 'targetArray' as user edits to the supplied EditScope
         * 'targetArray'.
         *
         * If 'targetArray' is an EditScope entity array (that is, an array described by type metadata that includes
         * '{ entityType: true }'), then differences are applied as follows:
         * - 'Created' entities: Any entities that are exclusive to 'sourceArray' (that is, not in 'targetArray') will be
         * represented as 'Created' entities (see 'editScope.addCreated()' and 'editScope.getCreated()').
         * - 'Updated' entities: For entities common to 'sourceArray' and 'targetArray', updated property values in the
         * entity from 'sourceArray' will be applied to the corresponding entity in 'targetArray'.
         * - 'Deleted' entities: Any entities missing from 'sourceArray' (that is, are in 'targetArray' only) will be
         * represented in 'targetArray' as 'Deleted' entities.
         *
         * If 'targetArray' is an EditScope array that is not entity-typed (not described by type metadata at all or
         * described by type metadata that doesn't include '{ entityType: true }'), then the items in 'targetArray' will
         * be replaced entirely by those in 'sourceArray'.  In this case, 'sourceArray' and 'targetArray' are treated
         * like single values.
         *
         * It is recommended that 'targetArray' be modeled as an entity array, as then, user edits can be persisted in
         * a small, space-efficient format.  In contrast, any user edit to a non-entity typed array requires that the
         * persisted edit include the entire array contents (which can be large).
         */
        applyArrayAsEdits<TItem>(sourceArray: TItem[], targetArray: KnockoutObservableBase<TItem[]>): void;
    }
    /**
     * A snapshot representation of an user-edited entity array, where the representation includes 'Created' entities
     * but doesn't include 'Deleted' entities.  This representation is suitable for returning from a ParameterProvider
     * Blade back to a corresponding ParameterCollector, where the array can be applied to the ParameterCollector's
     * EditScope using 'editScope.applyArrayAsedits()'.
     */
    interface EntityArrayWithEdits<TEntity> {
        /**
         * An array representation of an entity array where:
         * - 'Created' entities are appended and;
         * - 'Updated' entities are represented with edited property values and;
         * - 'Deleted' entities are not represented at all (are excluded).
         */
        arrayWithEdits: TEntity[];
        /**
         * 'Created' entities in the containing entity array.  These could otherwise be accessed using
         * 'editScope.getCreated()'.
         */
        createdEntities: TEntity[];
        /**
         * 'Updated' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Updated' state.
         */
        updatedEntities: TEntity[];
        /**
         * 'Deleted' entities in the containing entity array.  These could otherwise be determined using
         * 'editScope.getEditState()' and filtering entities that are in the 'Deleted' state.
         */
        deletedEntities: TEntity[];
    }
    /**
     * A description of an entity edited in the EditScope.  An array of these is supplied as part of an EditScope
     * 'saveChanges' operation.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    interface EditScopeEdit {
        /**
         * Reflects the kind of edit for this entity (create, update or delete).
         */
        editState: EditState;
        /**
         * The type name of the edited entity.
         */
        entityTypeName: string;
        /**
         * The edited entity.
         */
        entity: any;
    }
    /**
     * Different actions to be taken -- after an EditScope 'saveChanges' operation completes successfully --
     * to reflect the user's now-saved edits in the EditScope.  See EditScopeCacheOptions.saveEditScopeChanges.
     */
    enum AcceptEditScopeChangesAction {
        /**
         * When this action is returned, the user's client-side edits are accepted as the new EditScope values once
         * the 'saveChanges' operations completes successfully.  It assumed that these client-side edits reflect the state
         * saved to the server.
         */
        AcceptClientChanges = 0,
        /**
         * When this action is returned, the user's client-side edits accumulated in the EditScope are
         * discarded/reverted once the 'saveChanges' operation completes successfully.  This is useful for scenarios
         * where a user completes a form and clicks 'add' to add an item to a collection, then the form clears
         * to allow for the addition of successive items.
         */
        DiscardClientChanges = 1,
        /**
         * When this action is returned, the EditScope will be implicitly refreshed once the 'saveChanges' operation completes
         * successfully.  The user's client-side edits will be discarded in favor of those newly saved values returned
         * from the server during the 'refresh' operation.
         */
        RefreshFromServerImplicitly = 2,
        /**
         * When this action is returned, it is assumed that the 'dataToUpdate' parameter to the 'saveEditScopeChanges'
         * callback was updated from the server data by the callback.  In this case, it is assumed that this update
         * reflects both the user's edits and any server-generated values related to the save.  The user's client-side
         * edits will be discarded in favor of those values returned from the server.
         */
        ServerChangesAppliedManually = 3,
        /**
         * When this action is returned, it is expected that the 'dataToMerge' property is additionally supplied and
         * that it contains the newly saved server data.  In this case, it is assumed that 'dataToMerge' reflects both
         * the user's edits and any server-generated values related to the save.  The user's client-side edits will be
         * discarded in favor of those values returned from the server.
         */
        ServerDataReturned = 4
    }
    /**
     * The promise returned from 'saveEditScopeChanges' on 'EditScopeCache' can resolve with an object of this type.
     * This object describes how/whether user edits are to be accepted as the new, post-'saveChanges' values in the
     * EditScope.
     */
    interface AcceptEditScopeChangesOptions<TData> {
        /**
         * A description of what to do with user edits when the EditScope 'saveChanges' operation concludes.
         */
        action: AcceptEditScopeChangesAction;
        /**
         * When 'action' is 'AcceptEditScopeChangesAction.ServerDataReturned', this is the server data that is be
         * accepted as the new EditScope data.  It is assumed that this data reflects both the user's saved edits
         * as well as any server-generated values related to the save.  The user's client-side edits will be discarded
         * in favor of the values in 'dataToMerge'.
         */
        dataToMerge?: TData;
    }
    /**
     * Represents a pair of functions that can be evaluated to acquire corresponding 'original' and 'editable'
     * observables from an EditScope.
     */
    interface EditScopeAccessors<TValue> {
        /**
         * A function that will return an observable containing the original value for the field.
         */
        getOriginalObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
        /**
         * A function that will return an observable containing the editable value for the field.
         */
        getEditableObservable: (lifetime: MsPortalFx.Base.LifetimeManager) => KnockoutObservableBase<TValue>;
    }
}
declare module MsPortalFx.Data.EditScope {
    /**
     * See EditScope's 'resetValue' method.  This represents the values with which to reset a pair of corresponding
     * 'original' and 'editable' EditScope observables.
     */
    interface ResetValue<TValue> {
        /**
         * The new value for the EditScope observable that is being reset with EditScope's 'resetValue'
         * method.  This becomes the value of both the 'editable' and 'original' versions of the data.
         */
        newInputValue: TValue;
        /**
         * Optional.  This should be a different value than 'newInputValue'.  This value will be applied to the
         * 'editable' version data, putting the enclosing entity into an 'Updated' state (since the 'original'
         * and 'editable' values will be different).
         */
        newEditableValue?: TValue;
    }
}
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import EditState = MsPortalFx.Data.EditState;
    import MergeVisitorOptions = FxImpl.Data.MergeVisitorOptions;
    import AcceptEditScopeChangesOptions = MsPortalFx.Data.AcceptEditScopeChangesOptions;
    import EditScopeKind = MsPortalFx.Data.EditScopeKind;
    /**
     * The flag specifying that some edits can be non-persistent. This applies, for example, to passwords.
     * We consider removing non-persistent objects but decided to keep code supporting it for a while and use this flag for it.
     * The flag should be used for tests only to keep the code for a while.
     * Do not use the flag in PROD code.
     * TODO: Should be removed later with RDTask 4285673:[IaaSV2] Get rid of non-persistent properties at all
     *       (also _shouldPersistObjectPropertyEdits, _removeNonPersistedPropertySentinels, and dependent code)
     */
    let allowNonPersistentEdits: boolean;
    /**
     * Serializable edits collected by an EditScope.
     */
    interface EditScopeEdits {
        /**
         * A version number for the serialization format used to serialize the edits.
         */
        version?: number;
        /**
         * The serializable edits.
         */
        edits: EditScopeEdit[];
    }
    /**
     * A single, serializable edit collected by an EditScope.
     */
    interface EditScopeEdit {
        /**
         * Reflects whether this edit is a create, update or delete.
         */
        state: EditState;
        /**
         * A reference to the entity to which the edit pertains.
         * For 'Updated' and 'Deleted', this is the entity being updated or deleted.
         * For 'Created', this is the entity that nests an entity-typed array into which nested entities are being
         * created.
         */
        entityReference: EntityReference;
        /**
         * For creates in entity array, this is the dot-delimited path into the entity object used to locate
         * the nested array.
         */
        entityPath?: string;
        /**
         * For creates in entity array, these are serialized representations of the created entities.
         */
        createdEntities?: string[];
        /**
         * For entity updates, this is a serialized representation of the entity updates.
         */
        entityUpdates?: string;
    }
    /**
     * A serializable reference to an entity.  Used to create a serializable description of an entity edit.
     */
    interface EntityReference {
        /**
         * The type of the entity.
         */
        type: string;
        /**
         * The id of the entity.
         */
        id: string;
    }
    /**
     * Internal EditScope interface with which we serialize/deserialize EditScope edits.
     */
    interface EditScope<TData> extends MsPortalFx.Data.EditScope<TData> {
        /**
         * Gets edits in an EditScope in a serializable form.
         *
         * @returns The serializable edits.
         */
        getEdits(): EditScopeEdits;
        /**
         * An observable that signals when 'getEdits()' have changed (and should be saved to user settings).
         *
         * @returns The observable whose value changes when 'getEdits()' have changed.
         */
        editsChanged: KnockoutObservableBase<void>;
        /**
         * Applies edits to an EditScope.
         *
         * @param edits The deserialized edits.
         * @returns A boolean indicating whether the edits could be applied.  Returns 'false' if the underlying original
         * data has changed in such a way that the edits couldn't be applied.
         */
        applyEdits(edits: EditScopeEdits): boolean;
        /**
         * A boolean reflecting whether the EditScope has been disposed.
         */
        isDisposed: boolean;
    }
    /**
     * Options supplied when instantiating an EditScope.
     */
    interface EditScopeOptions<TData> {
        /**
         * Reflects the kind of EditScope instance that will be created via Internal.Data.EditScope.createEditScope().
         * If not supplied, the default value is EditScopeKind.Copy.
         */
        kind?: EditScopeKind;
        /**
         * Optional name of a type describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeName?: string;
        /**
         * Optional type metadata describing the data.  If neither 'typeName' nor 'typeMetadata' is supplied, it is
         * assumed that the data being edited consists of a single entity (with no provision for nesting entities).
         */
        typeMetadata?: Metadata.Metadata;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         */
        refresh?: (dataToUpdate: TData) => Promise<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called.  Once the edits
         * have been saved to the server, the callback can choose to update the EditScope data with saved server data
         * (although this is an uncommon scenario).  To do so, it should resolve its promise with options describing
         * how to merge the saved server data.
         */
        save?: (editScope: MsPortalFx.Data.EditScope<TData>, edits: MsPortalFx.Data.EditScopeEdit[], dataToUpdate: TData) => Promise<AcceptEditScopeChangesOptions<TData>>;
    }
    /**
     * An interface from which Form's EditScopeAccessors will inherit.  Used to identify those EditScopeAccessors
     * that always return observables contained in the EditScope, making these EditScopeAccessors usable by
     * EditScope's 'resetValue' method.
     */
    interface InternalEditScopeAccessors {
        /**
         * Identifies EditScopeAccessors that are usable by the EditScope.resetValue() method.
         */
        returnsObservablesFromEditScope: boolean;
    }
    /**
     * Constructs an EditScope instance.
     *
     * @param data Model data from which an editable copy will be created.
     * @param options Optional options with which the EditScope will be created.
     * @returns The created EditScope instance.
     */
    function createEditScope<TData>(lifetimeManager: MsPortalFx.Base.LifetimeManager, data: TData, options?: EditScopeOptions<TData>): EditScope<TData>;
    function logEditsToConsole(edits: EditScopeEdits): void;
    let nonPersistedPropertySentinel: string;
    /**
     * Options supplied when constructing a ApplyEntityArrayAsEditsVisitor.
     */
    interface ApplyEntityArrayAsEditsVisitorOptions<TEntity> extends MergeVisitorOptions {
        /**
         * Delegates to the caller the responsibility of treating the add of an entity to an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleAdd: (entityToAdd: TEntity) => void;
        /**
         * Delegates to the caller the responsibility of treating the delete of an entity from an entity array
         * in the course of applying edits from the source entity array to the target entity array.
         */
        handleDelete: (entityToDelete: TEntity) => void;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A ref-counted cache of EditScopes.
     */
    interface EditScopeCache<TData, TParams> extends MsPortalFx.Base.Disposable {
        /**
         * Creates an EditScopeView that is used by a view model to fetch EditScope instances.
         *
         * @param lifespan Reflects the lifetime of the caller.  This is used to determine when cached EditScopes are no
         * longer referenced.
         * @returns An EditScopeView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeView<TData, TParams>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         * @returns A promise that resolves when callback has been called on all editScopes.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeCache.Create.d.ts
declare module MsPortalFx.Data.EditScopeCache {
    /**
     * Creates a new instance of EditScopeCache for specified options.
     */
    function createNew<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
    /**
     * @deprecated EditScopeCache.create is deprecated.
     * Creates a new instance of EditScopeCache for specified options.
     */
    function create<T, TId>(options: MsPortalFx.Data.EditScopeCacheOptions<T, TId>): MsPortalFx.Data.EditScopeCache<T, TId>;
}

// FILE: MsPortalFx\Data\Data.EditScopeCacheOptions.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    /**
     * Options supplied to EditScopeCache.createNew.
     */
    interface EditScopeCacheOptions<TData, TParams> {
        /**
         * Determines the kind of EditScope that will be created.  Defaults to
         * EditScopeKind.CopyInputDataToMakeEditableData.
         */
        kind?: EditScopeKind;
        /**
         * Type metadata name. Only necessary for EditScopes that contain more than simply a root-level entity
         * (rather, that contain nested entities).
         */
        entityTypeName?: string;
        /**
         * Generates a string that will be used as the cache key for a cached EditScope.  This function should return a
         * unique string for every distinct 'params' in use.
         *
         * @param params Parameters identifying the EditScope data.
         * @returns A string represention of the parameters.
         */
        serializeParams?: (params: TParams) => string;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this data cache (a QueryCache or EntityCache) is used to retrieve data that will be used as the original
         * data for the new EditScope.
         */
        dataCache?: EditScopeInputDataCache<TData, TParams>;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForNewData)
         * this function returns an instance of type TData that will be used as the original data for the new EditScope.
         * If this function is not supplied, then Metadata.create(entityTypeName) will be used to create an object
         * (and not an array) of type TData.
         *
         * @returns Data to be used as the original data for the new EditScope. This can be an object, an array or an
         * observable array of the type described by 'entityTypeName'.
         */
        supplyNewData?: () => TData;
        /**
         * When creating an EditScope<TData> for the cache (in response to a call to EditScopeView.fetchForExistingData)
         * this function retrieves existing data identified by 'params'. This data will be used as the original
         * data for the EditScope.
         * In most cases, it is simpler to supply the 'dataCache' option to retrieve existing data, since
         * QueryCache/EntityCache instances can be simply configured to load server data.
         *
         * @param params Parameters used to retrieve data.
         * @param lifetime An object that issues a notification when the cache entry is evicted. Use this to clean up
         * any resources held by the cache entry.
         * @returns A promise resolved with the data.
         */
        supplyExistingData?: (params: TParams, lifetime: MsPortalFx.Base.LifetimeManager) => Promise<TData>;
        /**
         * Optional callback that will be called when the EditScope 'refresh' method is called.  With the callback,
         * the EditScope data can be updated directly via 'dataToUpdate' or the callback can resolve its returned
         * promise with the data for EditScope to merge.
         *
         * @param params Parameters identifying the EditScope.
         * @param lifetime An object that issues a notification when the refresh is completed.  Typical use it to use
         * 'lifetime' to acquire an EntityView or QueryView with which to refresh EditScope input data.
         * @param dataToUpdate The data which the callback can manually update to reflect server changes.
         * @returns A promise reflecting when new server data has been loaded.  If the promise is resolved with new
         * data, the new data will be merged into the EditScope.  Otherwise, it will be assumed that 'dataToUpdate'
         * was updated manually to reflect the latest state of the data on the server.
         */
        refreshEditScope?: (params: TParams, lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => Promise<TData>;
        /**
         * Optional callback that will be called when the EditScope 'saveChanges' method is called, delegating to the
         * extension to save EditScope edits to their server.
         *
         * @param params Parameters identifying the EditScope.
         * @param editScope The EditScope whose changes are being saved.
         * @param edits A description of the edits accumulated by the EditScope.
         * @param lifetime This should be used in the uncommon case where the extension chooses to -- once the server
         * has accepted the changes -- refresh the EditScope data from the server via a second HTTP call.  Typically,
         * 'lifetime' would be used to acquire an EntityView or QueryView with which to refresh EditScope data once the
         * HTTP call to save has completed.
         * @param dataToUpdate This should be used in the uncommon case where the extension chooses to -- once the server has
         * accepted the changes -- refresh the EditScope data (either based on the HTTP response from the save operation
         * or via a second HTTP call).  Importantly, this covers the case of server-generated values related to the save
         * operation.  'dataToUpdate' is the data which the callback can manually update to reflect the new server data.
         * @returns A promise reflecting when the EditScope changes have been saved to the server (and, optionally, the
         * callback has obtained the newly saved data from the server).  The promise can be resolved with a
         * object describing how/whether to reflect the user's now-saved edits as the new values in the EditScope.
         * If the promise is resolved with no value, the user's client-side edits will be accepted and the EditScope
         * will simply be marked as not dirty.
         */
        saveEditScopeChanges?: (params: TParams, editScope: EditScope<TData>, edits: EditScopeEdit[], lifetime: FxBase.LifetimeManager, dataToUpdate: TData) => Promise<AcceptEditScopeChangesOptions<TData>>;
        /**
         * An optional callback triggered when the EditScope is created and added to the cache.
         *
         * @param lifetime An object that issues a notification when the cached entry is evicted/disposed. Use this to
         * clean up any resources that share the same lifetime as the cached EditScope.
         */
        onEditScopeCreated?: (lifetime?: FxBase.LifetimeManager, editScope?: EditScope<TData>) => any;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeInputDataCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of query results for a specific type of data and query parameters, suitable for use as input
     * data to an EditScopeCache.
     */
    interface EditScopeInputDataCache<TData, TParams> {
        /**
         * A boolean reflecting whether this DataCache is one that polls for server changes. Not proxyable
         */
        _doesPoll(): boolean;
        /**
         * Creates a DataView that provides a convenient way to retrieve data from the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new DataView. A
         * typical example is a PartContainer instance - supplying one means that the DataView's entries may be released
         * when the corresponding Part is removed from the UI.
         * @returns A DataView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager): EditScopeInputDataView<TData, TParams>;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeInputDataView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entry from an underlying EditScopeInputDataCache. The 'data' property represents the
     * value(s) returned from the most recently issued (and completed) 'fetch' or 'refresh' call.
     */
    interface EditScopeInputDataView<TData, TParams> {
        /**
         * Sets the DataView's current query parameters, changing what data it exposes.  The data will be fetched from
         * the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete.  This is so you do not need manual code to stop superseded
         * promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched.  If you supply null/undefined, then the
         * preceding query will be superseded, but no new query will be begun - the DataView will therefore become
         * empty.
         * @returns A promise that completes when the load has completed.
         */
        fetch(params: TParams): Promise<any>;
        /**
         * Instructs the underlying data cache to re-fetch and update whatever data is currently being exposed by this
         * instance.
         *
         * If a request is currently in progress, this does not trigger a further request.  So, it is safe to invoke
         * 'refresh' immediately after a 'fetch' if you want to be sure to fetch fresh data and not accept existing
         * cached data.
         *
         * @returns A promise that completes when the refresh is done.  Or, if a request was already in progress, a
         * promise that completes when the existing request completes.
         */
        refresh(): Promise<any>;
        /**
         * The data loaded for this view.
         *
         * @returns The loaded data of type TData (or null/undefined if the data has not been loaded).
         */
        data: TData;
    }
}

// FILE: MsPortalFx\Data\Data.EditScopeView.d.ts
declare module MsPortalFx.Data {
    interface EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        editScope: KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): Promise<any>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): Promise<any>;
    }
    /**
     * Options for configuring an EditScopeView.
     */
    interface EditScopeViewConfig<TData, TParams> extends FxImpl.Data.ObjectViewConfig<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> {
    }
    /**
     * An EditScopeView is a view used to supply EditScopes to a view model. The view's observable 'editScope' changes
     * value to reflect asynchronous calls to 'fetchForNewData' and 'fetchForExistingData'.
     */
    class EditScopeView<TData, TParams> extends FxImpl.Data.ObjectView<EditScope<TData>, FxImpl.Data.EditScopeKey<TParams>> implements EditScopeViewContract<TData, TParams> {
        /**
         * An observable containing an EditScope instance reflecting the last successful call to 'fetchForNewData' or
         * 'fetchForExistingData'.
         */
        get editScope(): KnockoutObservable<EditScope<TData>>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId'. This view's observable 'editScope'
         * property will be set with the fetched EditScope.
         */
        fetchForNewData(editScopeId: string): Promise<any>;
        /**
         * Asynchronously fetches an EditScope based on the supplied 'editScopeId' and 'query'. This view's observable
         * 'editScope' property will be set with the fetched EditScope.
         */
        fetchForExistingData(editScopeId: string, params?: TParams): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Data.EntityCache.d.ts
declare module MsPortalFx.Data {
    /**
     * A cache of entities of a specific type.
     */
    class EntityCache<TEntity, TId> extends FxImpl.Data.DataCache<TEntity, TId> implements EditScopeInputDataCache<TEntity, TId>, DataCache<TEntity, TId> {
        private _findCachedEntity;
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: EntityCacheConfig<TEntity, TId>);
        /**
         * Constructs an instance of EntityCache<TEntity, TId>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: DataCacheConfig<TEntity, TId>);
        /**
         * Creates an EntityView that provides a convenient way to retrieve entities from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EntityView. A typical example is a
         * PartContainer instance - supplying one means that the EntityView's entries may be released when the corresponding Part is
         * removed from the UI.
         * @param config Additional options for configuring the EntityView.
         * @returns An EntityView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>): EntityView<TEntity, TId>;
        protected _tryFindDataInRelatedCache(id: TId, entryLifetime: MsPortalFx.Base.LifetimeManager): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: MsPortalFx\Data\Data.EntityCacheConfig.d.ts
declare module MsPortalFx.Data {
    /**
     * Supplies configuration options for an EntityCache.
     */
    interface EntityCacheConfig<TEntity, TId> extends DataCacheConfig<TEntity, TId> {
        /**
         * A description of how to locate an entity already loaded into a related DataCache.
         * This is a performance optimization that allows calls to 'entityView.fetch()' to quickly return
         * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
         * resources.
         */
        findCachedEntity?: FindCachedEntityInQueryCacheOptions<TEntity, TId> | FindCachedEntityInDataCacheOptions<TEntity, TId, any, any>;
    }
    /**
     * A description of how to locate an entity already loaded into a related QueryCache<TEntity>.
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * resources.
     */
    interface FindCachedEntityInQueryCacheOptions<TEntity, TId> {
        /**
         * A QueryCache caching arrays of entities of the same 'TEntity' type.
         */
        queryCache: QueryCache<TEntity, any>;
        /**
         * A function that determines whether a given entity matches an id.
         *
         * @param entity The entity.
         * @param id The ID to compare against this entity's ID.
         * @returns True if the entity's ID matched 'id'.
         */
        entityMatchesId(entity: TEntity, id: TId): boolean;
    }
    /**
     * A description of how to locate an entity already loaded into a related DataCache (a QueryCache or EntityCache).
     * This is a performance optimization that allows a call to 'entityView.fetch()' to quickly return
     * already-loaded data.  This optimization is important in many master/detail scenarios like browsing
     * ARM resources.
     */
    interface FindCachedEntityInDataCacheOptions<TEntity, TId, TData, TParams> {
        /**
         * A DataCache caching entities of the same 'TEntity' type, nested in some array or as an object property value.
         */
        dataCache: DataCache<TData, TParams>;
        /**
         * A function used to find -- within a cache entry -- the entity matching a given 'id'.
         *
         * @param cacheEntryParams The parameters which serve as the key of the cache entry.
         * @param cacheEntryData The data of the cache entry.
         * @param id The ID of the entity to find.
         * @returns The entity within the cache entry or 'null' if the entity is not found in this cache entry.
         */
        findMatchingEntityInCacheEntry(cacheEntryParams: TParams, cacheEntryData: TData, id: TId): TEntity;
    }
}

// FILE: MsPortalFx\Data\Data.EntityView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of a single entity from an underlying EntityCache. The
     * 'item' observable property remains constant but its contents change whenever
     * you request a different entity ID or when that entity's data is updated.
     */
    class EntityView<TEntity, TId> extends FxImpl.Data.DataView<TEntity, TId> implements EditScopeInputDataView<TEntity, TId> {
        private _item;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create an EntityCache and then use its 'createView' method to obtain an EntityView.
         *
         * @param dataSource Internal. Extensions should not use this EntityView constructor directly.
         * @param lifetime Internal. Extensions should not use this EntityView constructor directly.
         * @param config Internal. Extensions should not use this EntityView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TId>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TId>);
        /**
         * An observable property whose value is the current entity retrieved from the underlying cache.
         * The value is 'null' until the first entity is retrieved.
         *
         * Use the EntityView's 'fetch' method to specify an entity ID that, when loaded, will give the data for this property.
         *
         * Use the EntityView's 'refresh' method to cause this property's data to be updated via a new server request.
         */
        get item(): KnockoutObservable<TEntity>;
        get data(): TEntity;
    }
}

// FILE: MsPortalFx\Data\Data.ErrorNotificationTarget.d.ts
declare module MsPortalFx.Data {
    /**
     * Represents an object that receives notifications about errors encountered in the data layer.
     */
    interface ErrorNotificationTarget extends MsPortalFx.Base.LifetimeManager {
        /**
         * Issues a notification that a 'not found' error was encountered in the data layer.
         *
         * @param message Optional error message to be used in place of the default.
         */
        notFound?(message?: string): void;
    }
}

// FILE: MsPortalFx\Data\Data.Loader.d.ts
declare module MsPortalFx.Data {
    import FxBase = MsPortalFx.Base;
    import FxBaseNet = FxBase.Net2;
    function setCustomMinimumPoolInterval(poolInterval: number): void;
    function resetCustomMinimumPoolInterval(): void;
    /**
     * Specifies the rate at which the data loader should poll the server for updates.
     */
    enum PollFrequency {
        /**
         * The data loader will not poll for updates.
         */
        Never = 1,
        /**
         * The data loader will poll at the recommended rate.
         */
        Normal = 2
    }
    /**
     * FetchData is the interface for return of name: datasetName, value as DataSet
     */
    interface FetchData extends NameValue<string, DataSet> {
    }
    /**
     * Fetch parameters for fetch start callback.
     */
    interface FetchStartParameters {
        /**
         * The name of the data set
         */
        dataSetName: string;
        /**
         * The fetch promise.
         */
        promise: Promise<FetchData>;
        /**
         * A flag to distinguish Shell.Data.Loader.getData from polling refresh.
         */
        isClientInitiated: boolean;
    }
    /**
     * Fetch parameters for fetchData function of a Loader.
     */
    interface FetchParameters {
        /**
         * Additional data for a performed fetch.
         */
        data: any;
        /**
         * Additional headers for a performed fetch.
         */
        headers: any;
    }
    /**
     * Loader specific options.
     */
    interface LoaderOptions {
        /**
         * Computes HTTP parameters in preparation for a fetch of server data.
         */
        getFetchParameters?: (dataSetName: string, lastFetchState: any, fetchingSameData: boolean) => FetchParameters;
        /**
         * Function that performs actual data retrieval from a data source.
         */
        fetchData?: (dataSetName: string, uri: string, ajaxData: any, ajaxHeaders: any) => Promise<any>;
        /**
         * List of functions processing fetch results of a loader.
         */
        processResult?: Array<ProcessResultFunction>;
    }
    /**
     * Options that control how a DataSet is loaded.
     */
    interface DataSetLoaderOptions {
        /**
         * The URI from which data will be fetched for this data set.
         */
        uri: string;
        /**
         * An optional HTTP method to be used when making requests for this data set.
         */
        httpMethod?: string;
        /**
         * An optional, object-typed value that is passed as the 'data' option to the ajax call.
         */
        ajaxData?: any;
        /**
         * An optional, object-typed value that is passed as the 'headers' option to the ajax call.
         */
        ajaxHeaders?: any;
        /**
         * An optional boolean with a default value of false. If true, will always initiate a fetch from the server, even when this call returns cached data.
         */
        forceCacheRefresh?: boolean;
        /**
         * Adds a fetchStart event handler to the resulting data set, called whenever a fetch from the server is initiated for this data set.  A promise for the fetch is supplied to the handler.
         */
        fetchStartListener?: MsPortalFx.Base.Callbacks<FetchStartParameters>;
        /**
         * The frequency at which the loader should poll the server for updates.
         */
        pollFrequency?: PollFrequency;
        /**
         * Should preserve new items ordering during merge operations on data set.
         */
        preserveNewItemsOrdering?: boolean;
        /**
         * Loader specific options.
         */
        loaderOptions?: LoaderOptions;
        /**
         * An optional type string used to retrieve metadata for use during merging of fetched data.
         */
        type?: string;
        atomizationOptions?: AtomizationOptions;
        /**
         * Lifetime referrer of a data set for use in atomization garbage collection mechanism.
         */
        dataSetLifetime?: MsPortalFx.Base.LifetimeManager;
        /**
         * A name for the resulting DataSet.
         */
        dataSetName?: string;
        /**
         * Determines whether to automatically obtain and append an authorization header.
         * If undefined, the authorization header is appendended automatically for all relative URIs,
         * but skipped for absolute URIs.
         *
         * Set to true to append the default authorization header.
         * Set to { resourceName: 'audienceName'} to append an authorization token targeted at a specific audience.
         */
        setAuthorizationHeader?: boolean | FxBaseNet.AuthorizationOptions;
    }
    /**
     * Polling intervals definitions.
     */
    interface PollingIntervals {
        [interval: string]: number;
        /**
         * Fast polling interval.
         */
        fastPollingInterval?: number;
        /**
         * Normal polling interval.
         */
        pollingInterval?: number;
        /**
         * Slow polling interval.
         */
        slowPollingInterval?: number;
    }
    class Loader {
        static _internal: {
            setDefaultPollingIntervals: (intervals: any) => void;
        };
        /**
         * Fetches data from the cache or server. This is an asynchronous function.
         * Shell.Data.Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: jQueryDeferred, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName The name of the data set being retrieved.
         * If not supplied, the data set name will be inferred the URI supplied as options.uri.
         * @param options An options object.
         * @returns A promise reflecting the success or failure of this asynchronous call.
         * The promise is resolved with parameters:
         *   * dataSetName: The name of the data set.
         *   * dataSet: The data set containing the data retrieved.
         * The promise is rejected with parameters:
         *   * dataSetName: The name of the data set.
         *   * jqXHR: The jQuery XmlHttpRequest object used for the server fetch.
         *   * textStatus: A string describing the error type.
         *   * errorThrown: Any error thrown in JavaScript in the course of processing the server fetch.
         */
        static getData(options: DataSetLoaderOptions): Promise<FetchData>;
        static getData(dataSetName: string, options: DataSetLoaderOptions): Promise<FetchData>;
        /**
         * Refreshes data in the data set, using the URI, data and headers supplied in the most recent
         * call to Shell.Data.Loader.getData.
         *
         * @param dataSetName Data set name.
         * @returns A promise reflecting the success or failure of the server fetch.
         */
        static forceRefresh(dataSetName: string): Promise<FetchData>;
        /**
         * Retrieves a data set from a local, in-memory cache. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: Promise<any>, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param create Create a new data set (with no initial value/data) if one is not present in the cache. Defaults to 'false'.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @returns The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, create?: boolean, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Retrieves a data set from a local, in-memory cache. The data set will be created if it doesn't already exist. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: Promise<any>, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param dataSetType Type of the data set.
         * @param initialData Initial data merged into data set.
         * @param dataSetLifetime Data set lifetime manager.
         * @param atomizationOptions Data set atomization options.
         * @returns The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet(dataSetName: string, dataSetType?: string, initialData?: any, dataSetLifetime?: MsPortalFx.Base.LifetimeManager, atomizationOptions?: AtomizationOptions): DataSet;
        /**
         * Retrieves a data set from a local, in-memory cache. The data set will be created if it doesn't already exist. This is a synchronous function.
         * Loader issues the following jQuery events on data sets it manages:
         *   * fetchStart: Triggered when a server fetch is initiated to populate or refresh data in a data set.
         *        Arguments supplied as (dataSetName: string, promise: Promise<any>, isClientInitiated: boolean).
         *   * mergeComplete: Triggered when the result of a server fetch is merged into a data set.
         *
         * @param dataSetName Data set name.
         * @param create Create a new data set (with no initial value/data) if one is not present in the cache. Defaults to 'false'.
         * @param initialData Initial data merged into data set.
         * @param options Options used to create the DataSet, if necessary.
         * @returns The data set named by 'dataSetName' or null if the data set has not yet been created or loaded.
         */
        static getDataSet2(dataSetName: string, create: boolean, options: DataSetLoaderOptions, initialData: any): any;
        /**
         * Determines whether or not the specified data set is awaiting a response to an already-issued request.
         *
         * @param dataSetName The name of the data set.
         * @returns True if a request is in flight; false otherwise.
         */
        static hasRequestInFlight(dataSetName: string): boolean;
        /**
         * Disposes and clears the data set from that set managed by Shell.Data.Loader.
         *
         * @param dataSetName Data set name.
         */
        static disposeDataSet(dataSetName: string): void;
        /**
         * Enables or disables data refresh at the 'fast' refresh interval, often reflecting that the
         * data set is currently being viewed.
         *
         * @param dataSetName Data set name.
         * @param fast If true, the 'fast' refresh interval is selected for this data set.
         */
        static setFastPolling(dataSetName: string, fast: boolean): void;
        /**
         * Pauses data refresh by increasing a reference count
         */
        static pausePolling(): void;
        /**
         * Resumes data refresh by decreasing a reference count.
         */
        static resumePolling(): void;
        /**
         * Supplies a set of default loader options that will be used when loading data sets.
         *
         * @param loaderOptions The default loader options.
         */
        static setDefaultLoaderOptions(loaderOptions: LoaderOptions): void;
        /**
         * Helper to get current MinimumPoolingInterval (used in Data.DataCacheLoder.ts)
         */
        static getMinPollingInterval: () => number;
        /**
         * Supplies a set of polling intervals used to control the rate at which a data set is implicitly
         * refreshed from the server.
         *
         * @param dataSetName Data set name.
         * @param pollingIntervals An object with optional 'fastPollingInterval', 'pollingInterval' and
         * 'slowPollingInterval' properties, all Number-typed and in milliseconds.
         */
        static setPollingIntervals(pollingIntervals: PollingIntervals): void;
        static setPollingIntervals(dataSetName: string, pollingIntervals: PollingIntervals): void;
        /**
         * Reset the polling intervals to default setting that can void the effect by setPollingIntervals
         */
        static resetPollingIntervals(dataSetName?: string): void;
    }
    module Loader.Internal {
        function disposeAllCachedDataSetsForTests(): void;
    }
}

// FILE: MsPortalFx\Data\Data.LockState.d.ts
declare module MsPortalFx.Data {
    /**
     * An enumeration type representing the kinds of client-side edits to which MsPortalFx.Data.DataSet.lockItem
     * applies.
     */
    enum EditKind {
        /**
         * "Add" type of edit.
         */
        Add = 0,
        /**
         * "Update" type of edit.
         */
        Update = 1
    }
    /**
     * Defines client-side lock state of an element stored in MsPortalFx.Data.DataSet.
     */
    interface LockState {
        /**
         * Lock type of edit.
         */
        editKind?: MsPortalFx.Data.EditKind;
        /**
         * Date when unlocked.
         */
        unlockedAt?: number;
    }
}

// FILE: MsPortalFx\Data\Data.Metadata.d.ts
declare module MsPortalFx.Data.Metadata {
    /**
     * Interface describing on of possible type representations of elements stored in MsPortalFx.Data.DataSet.
     */
    interface MetadataProperty {
        /**
         * Type of the property.
         */
        itemType?: string;
        /**
         * Indicates whether property is an array.  Default is 'false'.
         */
        isArray?: boolean;
        /**
         * Indicates whether property is a date.
         */
        isDate?: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits?: boolean;
        /**
         * Determines if edits are persisted to User Settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits?: boolean;
    }
    /**
     * Interface describing metadata of elements stored in MsPortalFx.Data.DataSet.
     * This interface corresponds with 'TypeMetadata' C# type.
     */
    interface Metadata {
        /**
         * Name of the type.
         */
        name?: string;
        /**
         * List of id properties of a type.
         */
        idProperties?: string[];
        /**
         * List of properties in type.
         */
        properties?: {
            [property: string]: MetadataProperty;
        };
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether instances of this type each of a globally unique id.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeName' C# type.
     */
    interface CompressedTypeName {
        /**
         * Index of a part in namespace array.
         */
        namespaceIndex: number;
        /**
         * Type name.
         */
        name: string;
    }
    /**
     * Contract for compressed type property metadata with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeProperty' C# type.
     */
    interface CompressedTypeProperty {
        /**
         * Index of a type in namespace array.
         */
        typeIndex: number;
        /**
         * Value indicating whether property is enumerable or not.
         */
        isArray: boolean;
        /**
         * Value indicating whether property is a date.
         */
        isDate: boolean;
        /**
         * Determines if edits are tracked by EditScope.  Default is 'true'.  If 'false', property value cannot be used with form fields.
         */
        trackEdits: boolean;
        /**
         * Determines if edits are persisted to user settings.  Set to 'false' for properties like passwords.  Default is 'true'.
         */
        persistEdits: boolean;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypeMetadata' C# type.
     */
    interface CompressedTypeMetadata {
        /**
         * Type name.
         */
        name: CompressedTypeName;
        /**
         * List of properties in type.
         */
        properties: {
            [property: string]: CompressedTypeProperty;
        };
        /**
         * List of id properties of a type.
         */
        idProperties: string[];
        /**
         * Reflects whether this type is an entity type.  An entity type is one that can be edited and reverted
         * independently from any nesting or nested model data.
         */
        entityType?: boolean;
        /**
         * Indicates whether the entity has a globally unique ids.
         */
        hasGloballyUniqueId?: boolean;
    }
    /**
     * Data visitation callbacks.
     */
    interface TypedDataVisitorCallbacks {
        /**
         * Callback triggered whenever an array is found on travelsal path.
         */
        visitArray: (data: any, type: string) => void;
    }
    /**
     * Contract for compressed metadata created with TypeMetadataGenerator.GenerateTypeMetadata.
     * Corresponds with 'Microsoft.Portal.TypeMetadata.TypesMetadata' C# type.
     */
    interface CompressedTypesMetadata {
        /**
         * Namespaces array.
         */
        namespaces: string[];
        /**
         * List of metadata.
         */
        metadata: CompressedTypeMetadata[];
        /**
         * Index of root type in types array.
         */
        rootTypeIndex: number;
    }
    /**
     * Gets metadata corresponding to a given type name.
     *
     * @param type The name of the type.
     * @returns Metadata for the type.
     */
    function getTypeMetadata(type: string): Metadata;
    /**
     * Gets the type of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @returns The type name of the property.
     */
    function getPropertyType(type: string, propertyName: string): string;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @returns The type name of the property.
     */
    function getPropertyType(typeMetadata: Metadata, propertyName: string): string;
    /**
     * Gets type metadata of a property from a given metadata object.
     *
     * @param typeMetadata Metadata object.
     * @param property Property of which metadata is to be found.
     * @returns Metadata of a given property.
     */
    function getPropertyTypeMetadata(typeMetadata: Metadata, property: string): Metadata;
    /**
     * Gets the property metadata.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @returns The property metadata.
     */
    function getPropertyMetadata(type: string, propertyName: string): MetadataProperty;
    /**
     * Gets the cardinality of a property.
     *
     * @param type The name of the type containing the property.
     * @param propertyName The property name.
     * @returns Value of the property.isArray value.
     */
    function getPropertyCardinality(type: string, propertyName: string): boolean;
    /**
     * Gets the type of a property.
     *
     * @param typeMetadata Metadata for the type containing the property.
     * @param propertyName The property name.
     * @returns Value of the property.isArray value.
     */
    function getPropertyCardinality(typeMetadata: Metadata, propertyName: string): boolean;
    /**
     * Gets the property names for a given type.
     *
     * @param typeMetadata Metadata for the type.
     * @returns An array of property names.
     */
    function getProperties(typeMetadata: Metadata): string[];
    /**
     * Gets a boolean reflecting whether the type has at least one id property.
     *
     * @param typeMetadata Metadata describing the type of the item.
     * @returns Whether the Metadata has an id.
     */
    function typeHasId(typeOrTypeMetadata: Metadata.Metadata | string): boolean;
    /**
     * Gets a string reflecting the identity of a supplied item.
     *
     * @param item The data item.
     * @param type The type name.
     * @returns A string representation of the identity of the item.
     */
    function getItemId(item: Object, typeOrMetadata: Metadata | string): string;
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param metadata Type metadata.
     * @returns An array of property names or null.
     */
    function getIdPropertyNames(metadata: Metadata.Metadata): string[];
    /**
     * Gets the names of those data item properties that uniquely identify a data item among its peers in a cached array.
     *
     * @param typeName Type name.
     * @returns An array of property names or null.
     */
    function getIdPropertyNames(typeName: string): string[];
    /**
     * An utility function that decorates an array or object with typing.
     *
     * @param data The array or object.
     * @param type The type name.
     */
    function decorateWithType(data: any, type: string): void;
    /**
     * Typed data visitation.
     *
     * @param data Data to be visited.
     * @param type Type of visited data.
     * @param callbacks Callbacks to be triggered while traversing.
     */
    function visitTypedData(data: any, type: string, callbacks: TypedDataVisitorCallbacks): void;
    /**
     * Determines the item type of an array.
     *
     * @param array The array (observable or native).
     * @returns The item type name.
     */
    function getArrayItemType(array: any): string;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @returns The object with undefined-valued property values.
     */
    function createEmptyObject(type: string): any;
    /**
     * Creates an object of a specified type.
     *
     * @param typeOrMetadata Type of the object to be created.
     * @returns The object with undefined-valued property values.
     */
    function createEmptyObject(metadata: Metadata): any;
    /**
     * Returns a boolean reflecting whether this type is an entity type.
     *
     * @param typeOrMetadata Type to be created.
     * @returns A boolean reflecting whether this type is an entity type.
     */
    function typeIsEntityType(typeMetadata: Metadata.Metadata): boolean;
    /**
     * Sets type information for a supplied type name.
     * Note that there is no provision to unset type metadata, as the assumption is that each extension will have
     * a small, static number of model types.
     *
     * @param type The type name.
     * @param metadata The type information.
     */
    function setTypeMetadata(type: string, metadata: Metadata): void;
    /**
     * Sets type information for a collection of types.
     * Use Microsoft.Portal.Framework.ExtensionData.TypeMetadataGenerator to produce the compressed 'typesMetadata'
     * consumed by this function.
     *
     * @param typesMetadata Compressed type information for a collection of types.
     * @returns Type information for the first type name, which by convention is the root type of the collection of types.
     */
    function setTypesMetadata(typesMetadata: CompressedTypesMetadata): Metadata;
    module Internal {
        /**
         * Clears type metadata for all types.
         */
        function clearAllTypesMetadata(): void;
    }
}

// FILE: MsPortalFx\Data\Data.ObjectCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides configuration for an ObjectCache object.
     */
    interface ObjectCacheConfig<TKey, TValue> {
        /**
         * Provides a string representation of the specified cache key. Every distinct cache
         * key must have a distinct string representation.
         *
         * @param key The cache key to serialize.
         * @returns A string represention of the cache key.
         */
        serializeKey(key: TKey): string;
        /**
         * Given a key, this function supplies a value for a newly created cache entry. This function will be invoked
         * only when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @returns The cache value.
         */
        supplyValue(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * A variation of 'supplyValue'.  This function should only return a non-null value if that value is already
         * cached on the client (in some underlying or related cache).  When a cache entry is created using this
         * function, for telemetry purposes, this will be considered a cache hit.  This function will be invoked only
         * when creating new cache entries.
         *
         * @param key The cache key.
         * @param entryLifetime An object that issues a notification when the cache entry is evicted. Use this to clean up any resources held by the cache entry.
         * @returns The cache value.
         */
        tryFindValueInRelatedCache?(key: TKey, entryLifetime: MsPortalFx.Base.LifetimeManager): {
            value: TValue;
        };
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The cache key for the entry being ejected.
         */
        onEntryDisposed?(entry: TValue, key: TKey): void;
        /**
         * @deprecated ObjectCacheConfig.evictionDelay - Please do not use this option. It is deprecated and will be removed. Instead, set
         * the 'extendEntryLifetimes' option to 'true'.
         *
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         */
        evictionDelay?: number;
        /**
         * If true, cache entries will be retained in memory for a framework-controlled period even when
         * no other objects are referring to them. This makes the cache perform better: future 'fetch'
         * operations are more likely to be satisfied without needing to wait for HTTP requests.
         *
         * We recommend that you always enable this option. Please ensure that none of your other code
         * relies on cache entries being evicted synchronously.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A reference-counted cache of objects of a specific type.
     */
    class ObjectCache<TKey, TValue> {
        private _referrerPropertyName;
        private _referrerUniqueId;
        private _supplyValue;
        private _tryFindValueInRelatedCache;
        private _serializeKey;
        private _entries;
        /**
         * Constructs an instance of ObjectCache.
         *
         * @param config Configuration for the instance.
         */
        constructor(config: ObjectCacheConfig<TKey, TValue>);
        /**
         * Retrieves a value from the cache. If the value was not already cached, it will be created,
         * added to the cache, and then returned.
         *
         * @param key Cache key for the item to retrieve.
         * @param referrer Associates the cache entry with this referrer, so it will remain cached at least until this object notifies that it was disposed.
         * Pass null to avoid participating in the refcounting.
         * @returns The cached value.
         */
        getValue(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): TValue;
        /**
         * Ensures that the cache contains an entry for the specified key. If the cache already contains an entry for the specified
         * key, nothing will happen (the entry will not be overwritten).
         *
         * @param key Cache key for the item.
         * @param value The value to be inserted if there was no existing entry.
         * @param referrer Associates the cache entry with this referrer, whether or not it already exists in the cache.
         */
        insertValueIfNotPresent(key: TKey, value: TValue, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Determines whether or not the cache contains an entry for the specified key.
         *
         * @param key Cache key for the item.
         * @returns True if the entry is present; false otherwise.
         */
        hasEntry(key: TKey): boolean;
        /**
         * Removes any association between the specified key and referrer, or does nothing if there was no such association.
         * Once a cache entry has no remaining referrers, it will be removed from the cache.
         *
         * @param key Cache key for the item.
         * @param referrer The referrer to be dissociated from the cache entry.
         */
        dissociateEntry(key: TKey, referrer: MsPortalFx.Base.LifetimeManager): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: TKey): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: TKey, value: TValue) => void): void;
        /**
         * Disposes the cache, so that it releases references to all entries. Once this is done,
         * that cache can no longer store new entries.
         */
        dispose(): void;
        private _getOrCreateReferrerId;
    }
}

// FILE: MsPortalFx\Data\Data.PartialError.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes a partial error returned while attempting to fetch data.
     */
    interface PartialError {
    }
}

// FILE: MsPortalFx\Data\Data.ProcessedResult.d.ts
declare module MsPortalFx.Data {
    /**
     * The contract of data that's passed as in/out parameter for ProcessResultFunction.
     */
    interface ProcessedResult {
        /**
         * The result from the AJAX request passed in subsequent Data.Loader result processor functions.
         * This is the data that would be merged into the data set.
         */
        data?: any;
        /**
         * Describes the state of navigable data, for example specifying the
         * total number of items or the token needed to fetch further data.
         */
        navigationMetadata?: DataNavigationMetadata;
        /**
         * An optional collection of partial errors returned by the server, possibly in
         * addition to any data received successfully.
         */
        partialErrors?: MsPortalFx.Data.PartialError[];
        /**
         * Determines type of data to be merged into the data set.
         * Can alternatively be supplied as an option to MsPortalFx.Data.Loader.getData.
         */
        type?: string;
        /**
         * Clients can return select response headers and return them here.
         */
        fetchState?: any;
    }
    /**
     * The contract of Data.Loader result processing function.
     */
    interface ProcessResultFunction {
        /**
         * Function that decides whether to merge data in Data.Loader once retrieved. It also shapes the data, type
         * and fetch state before the actual merge happens.
         *
         * @param dataSetName Name of the data set for which data is being fetched.
         * @param result Object passed along the Data.Loader chain of result processors to subsequent
         *     ProcessResultFunction functions calls. Once all functions are called, this object contains the type of
         *     the data to be merged as well as state that is to be saved between this and subsequent server fetches.
         * @param lastFetchState Fetch state returned by the previous fetch for this data set.
         * @param fetchingSameData A boolean indicating that the URI/data/headers have not changed from those used for
         *     the previous fetch for this data set.
         * @param entityType Specifies the type of entities in the data set, or null if unknown.
         * @returns Return false if 'result.data' is to be discarded and subsequent result processor functions are not
         *     called. Return true to continue calling subsequent result processor functions. The last such return
         *     value determines whether the fetch result is to be merged into the data set. See ProcessResultOutput
         *     type documentation for details on how 'result' object is used later to determine further actions if
         *     ProcessResultFunction returns true.
         */
        (dataSetName: string, result: ProcessedResult, lastFetchState: any, fetchingSameData: boolean, entityType: string): boolean;
    }
}

// FILE: MsPortalFx\Data\Data.Query.d.ts
declare module MsPortalFx.Data {
    interface DataSourcePaging {
        /**
         * How many results should be skipped.
         */
        skip?: number;
        /**
         * How many results should be returned.
         */
        take?: number;
    }
    /**
     * Representation of a remote data query.
     */
    interface Query {
        /**
         * Paging options.
         */
        paging?: DataSourcePaging;
        /**
         * Direction of sorting (ascending or descending).
         */
        sort?: any;
        /**
         * Filter format: [{ property: ..., operator: ..., value: ...}, ...]
         */
        filter?: any;
        /**
         * Should query return total number of elements on endpoint side
         */
        includeTotalCount?: any;
    }
    /**
     * The contract of for shaping queries sent to extension endpoint.
     */
    interface ShapeQueryFunction {
        /**
         * Function that shapes representation of the data query to a format that can be included in an HTTP call to fetch server data.
         *
         * @param query Representation of a remote data query.
         * @returns Representation of the query used for the HTTP call for server data.
         */
        (query: Query): any;
    }
}

// FILE: MsPortalFx\Data\Data.QueryCache.d.ts
declare module MsPortalFx.Data {
    /**
     * Options to define how a navigator is created from a QueryCache.
     */
    interface CreateNavigatorOptions<TEntity, TMappedEntity> {
        /**
         * A callback that will be used to produce the 'items' collection on the
         * resulting data navigator. You can use this to project the source entities
         * into a different data format. You should use an observable mapping, for
         * example sourceItems.map(...), so that the navigator can remain up-to-date
         * as it moves through the underlying data.
         *
         * @param lifespan A lifetime object that signals when you should release any resources held by your mapping.
         * @param sourceItems The navigator's underlying items to be mapped.
         * @returns The mapped array.
         */
        createMapping?(lifespan: MsPortalFx.Base.LifetimeManager, sourceItems: KnockoutObservableArray<TEntity>): KnockoutObservableBase<TMappedEntity[]>;
    }
    /**
     * A cache of query results for a specific type of entity and query parameters.
     * Note: In the base class, this class is marked as non-serializable re: PO.
     */
    class QueryCache<TEntity, TQueryParams> extends FxImpl.Data.DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> implements EditScopeInputDataCache<KnockoutObservableBase<TEntity[]>, TQueryParams>, DataCache<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _navigationOptions;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: MsPortalFx.Data.QueryCacheConfig<TEntity, TQueryParams>);
        /**
         * Creates a QueryView that provides a convenient way to retrieve query results from
         * the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new QueryView. A typical example is a
         * PartContainer instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed
         * from the UI.
         * @param config Additional options for configuring the QueryView.
         * @returns A QueryView instance.
         */
        createView(lifespan: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>): QueryView<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @returns A RemoteDataNavigator instance.
         */
        createNavigator(lifespan: MsPortalFx.Base.LifetimeManager): RemoteDataNavigator<TEntity, TQueryParams>;
        /**
         * Creates a RemoteDataNavigator that can query and navigate through data supplied by the cache instance.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held. A typical example is a PartContainer
         * instance - supplying one means that the cache entries may be released when the corresponding Part is removed from the UI.
         * @param options Options influencing the resulting data navigator.
         * @returns A RemoteDataNavigator instance.
         */
        createNavigatorWithOptions<TMappedEntity>(lifespan: MsPortalFx.Base.LifetimeManager, options: CreateNavigatorOptions<TEntity, TMappedEntity>): RemoteDataNavigator<TMappedEntity, TQueryParams>;
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<TEntity, TQueryParams>;
        _findMatchingEntity<TId>(comparer: (entity: TEntity, id: TId) => boolean, id: TId): TEntity;
        protected _getDataFromDataSet(dataSet: DataSet): KnockoutObservableBase<TEntity[]>;
    }
    /**
     * Supplies configuration options for a QueryCache.
     */
    interface QueryCacheConfig<TEntity, TParams> extends DataCacheConfig<TEntity, TParams> {
        /**
         * Describes how any QueryViews based on this cache can navigate through the data.
         */
        navigation?: QueryCacheNavigationOptions<TEntity, TParams>;
    }
    /**
     * Describes how any QueryViews based on a QueryCache are able to navigate through the data.
     */
    interface QueryCacheNavigationOptions<TEntity, TParams> {
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param skip The number of records to skip.
         * @param take The number of records to take.
         * @param filter Any filtering value entered by the user.
         * @returns A promise representing the operation.
         */
        loadBySkipTake?(queryView: QueryView<TEntity, TParams>, query: TParams, skip: number, take: number, filter: string, sort?: SortBy[]): Promise<any>;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param queryView The QueryView instance that should be navigated.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to fetch
         * the next range of data.
         * @param filter Any filtering value entered by the user.
         * @returns A promise representing the operation.
         */
        loadByContinuationToken?(queryView: QueryView<TEntity, TParams>, query: TParams, reset: boolean, filter: string, sort?: SortBy[]): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Data.QueryView.d.ts
declare module MsPortalFx.Data {
    /**
     * Provides a view of query results from an underlying QueryCache. The
     * 'items' observable array property remains constant but its contents change
     * whenever you change query parameters, or when the results themselves change.
     */
    class QueryView<TEntity, TQueryParams> extends FxImpl.Data.DataView<TEntity, TQueryParams> implements EditScopeInputDataView<KnockoutObservableBase<TEntity[]>, TQueryParams> {
        private _items;
        private _metadata;
        /**
         * Internal constructor. Extensions should not invoke this directly. Instead,
         * create a QueryCache and then use its 'createView' method to obtain a QueryView.
         *
         * @param dataSource Internal. Extensions should not use this QueryView constructor directly.
         * @param lifetime Internal. Extensions should not use this QueryView constructor directly.
         * @param config Internal. Extensions should not use this QueryView constructor directly.
         */
        constructor(dataSource: FxImpl.Data.QueryViewSource<TEntity, TQueryParams>, lifetime: MsPortalFx.Base.LifetimeManager, config?: DataViewConfig<TEntity, TQueryParams>);
        /**
         * An observable array whose contents are the current query results retrieved from the underlying cache.
         * The array is empty until the first query results are obtained.
         *
         * Use the QueryView's 'fetch' method to specify a query that, when completed, will give the data for this array.
         *
         * Use the QueryView's 'refresh' method to cause this array's data to be updated via a new server request.
         */
        get items(): KnockoutObservableArray<TEntity>;
        get metadata(): KnockoutObservableBase<DataNavigationMetadata>;
        get data(): KnockoutObservableBase<TEntity[]>;
    }
}

// FILE: MsPortalFx\Data\Data.UriFormatter.d.ts
declare module MsPortalFx.Data {
    /**
     * Returns a URI formatting function that uses the specified format string. This can be
     * suppled as the 'sourceUri' parameter on a DataCacheConfig instance.
     *
     * If the parameter value you will later supply is a simple primitive (string or number),
     * then your format string should refer only to a single token, '{id}'.
     * Example: '/products/{id}.json'
     *
     * If the parameter value you will later supply is an object with subproperties,
     * then your format string should instead reference those subproperties by name, for example:
     * Example: '/products/{department}/{category}/all'.
     *
     * @param uriFormat A formatting string.
     * @param encodeTokens If true, tokens will be URI component encoded. If false, tokens will be inserted without encoding, so you must ensure you have already encoded the tokens appropriately.
     * @returns A URI formatting function.
     */
    function uriFormatter(uriFormat: string, encodeTokens: boolean): (params: any) => string;
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.AtomizationContext.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxLifetimeManager = FxBase.LifetimeManager;
    /**
     * Atomization serves two main goals:
     * 1) Enables several data views to be bound to one data entity, thus giving smooth, consistent
     *    experience to user, where 2 views representing the same asset are always in sync.
     * 2) Minimizes memory trace.
     */
    interface AtomizationContext {
        /**
         * Add a new entity to atomization context.
         *
         * @param type Entity type.
         * @param id Entity id.
         * @param entity Entity itself.
         * @param referrer Lifetime manager of the requesting data set.
         */
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        /**
         * Retrieves an appropriate entity from atomization context. Null if entity is not present.
         *
         * @param type Entity type.
         * @param id Entity id.
         * @param referrer Lifetime manager of the requesting data set.
         * @returns Entity itself.
         */
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        /**
         * Update references to elements removed from an array in atomization context.
         *
         * @param type Entity type.
         * @param removedItemsArray Removed items.
         * @param referrer Lifetime manager of the requesting data set.
         */
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    /**
     * Implementation of a atomization context with garbage collection.
     */
    class RefCountingAtomizationContext implements AtomizationContext {
        private _atomizationCache;
        constructor();
        getEntity(type: string, id: string, referrer: FxLifetimeManager): Object;
        addEntity(type: string, id: string, entity: Object, referrer: FxLifetimeManager): void;
        releaseEntities(type: string, removedItemsArray: any[], referrer: FxLifetimeManager): void;
    }
    module AtomizationContext {
        let atomizationContextCollection: StringMap<FxImpl.Data.AtomizationContext>;
        /**
         * Retrieves a atomization context. Creates one if hasn't been created yet, using
         */
        function get(id?: string): FxImpl.Data.AtomizationContext;
        /**
         * Retrieves information whether a given type can be atomized.
         *
         * @param type Type in question.
         * @returns Whether a given type can be atomized.
         */
        function canAtomizeType(type: string): boolean;
        /**
         * Factory of atomization contexts.
         *
         * @returns Atomization context.
         */
        function createInstance(): FxImpl.Data.AtomizationContext;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.CloneVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a CloneVisitor is to be used.
     */
    interface CloneVisitorContract {
        /**
         * Deeply clones the supplied data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         * @returns A clone of the data.
         */
        clone(data: any, typeMetadata: Metadata.Metadata): any;
    }
    /**
     * Options supplied when constructing a CloneVisitor.
     */
    interface CloneVisitorOptions extends VisitorOptions {
    }
    /**
     * This interface is used to customize a CloneVisitor by supplying mix-in style callbacks.
     */
    interface CloneVisitorCallbacks extends VisitorCallbacks<void, any> {
    }
    /**
     * A visitor that deeply clones supplied data.
     */
    class CloneVisitor extends Visitor<void, any> implements CloneVisitorContract {
        /**
         * Constructs an CloneVisitor instance.
         *
         * @param options Options used in the construction of the CloneVisitor.
         * @param callbacks Optional, mix-in style callbacks that override default CloneVisitor behavior.
         */
        constructor(options: CloneVisitorOptions, callbacks: CloneVisitorCallbacks);
        clone(data: any, typeMetadata: Metadata.Metadata): any;
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata): ArrayOrObservableArray;
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata): StringMap<any>;
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata): any;
        visitDate(date: Date): Date;
        visitScalar(value: number | string): any;
        visitFunction(fn: Function): any;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.DataCache.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    /**
     * Provides a specialised API on top of ObjectCache intended for loading DataSet
     * objects via FxData.Loader. This is not intended to be used directly - developers
     * should use one of the two subclasses, EntityCache or QueryCache, depending on whether
     * they want to retrieve single entities by ID, or multiple entities by query.
     */
    abstract class DataCache<TEntity, TParams> implements DataViewSource<TEntity, TParams> {
        private _loader;
        private _cacheByParams;
        private _cacheName;
        /**
         * Constructs an instance of DataCache<TEntity, TParams>.
         *
         * @param config Configuration for the new instance.
         */
        constructor(config: FxData.DataCacheConfig<TEntity, TParams>);
        /**
         * Retrieves a DataSetPromise from the cache. If it is not already present in the cache,
         * it will be created (e.g. via the configured loader).
         *
         * @param params Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @returns A promise that will complete with the retrieved DataSet.
         */
        fetch(params: TParams, referrer: FxBase.LifetimeManager): FxData.DataSetPromise;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * supplied parameters.
         *
         * @param params Parameters defining what data the cache entry should refresh (or load, if not already cached).
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed. If you pass 'null', then this call will not force the cache entry to stay in memory.
         * @returns A promise that will complete when the data has finished being refreshed.
         */
        refresh(params: TParams, referrer: FxBase.LifetimeManager): Promise<any>;
        /**
         * Instructs the underlying data loader to refresh data in the DataSet corresponding to the
         * specified cache entries.
         *
         * @param predicate A predicate that determines which cache entries should be refreshed. If not specified, all in-memory cache entries will be refreshed.
         */
        refreshAll(predicate?: (params: TParams) => boolean): void;
        /**
         * Immediately removes the specified cache entry, regardless of whether it has active referrers,
         * and without waiting for any eviction delay. This also stops any polling configured for this entry.
         *
         * If there was no cache entry matching the specified parameters, this method does nothing.
         *
         * @param params Parameters defining the entry to be removed.
         */
        forceRemove(params: TParams): void;
        /**
         * Passes each current cache entry to a callback, so that you may mutate it in place (for
         * example, to reflect the result of a create/update/delete operation without waiting for
         * polling to complete).
         *
         * Any in-flight poll/refresh requests for updated cache entries will be discarded and
         * restarted. This ensures the old requests don't overwrite your changes with stale data.
         *
         * @param callback A callback invoked for each cache entry.
         * @param predicate An optional predicate that determines which cache entries are to be updated. If not specified, all cache entries are to be updated.
         */
        applyChanges(callback: (params: TParams, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        /**
         * Disposes the DataCache, which in turn disposes all DataSets it was holding.
         */
        dispose(): void;
        /**
         * See FxData.DataCache interface.
         */
        _doesPoll(): boolean;
        _findEntity<TEntity, TId, TData>(findCallback: (cacheEntryParams: TParams, cacheEntryData: TData, id: TId) => TEntity, id: TId): TEntity;
        /**
         * Dumps the data currently in the data cache
         *
         * @param dumpAsObjects If not set this function will print all the data in the cache to the console and return nothing. If set to true the function will return the objects in the cache.
         * @returns If dumpAsObjects is not set there is no return value. If it is set the data in the cache will be returned.
         */
        dump(dumpAsObjects?: boolean): any;
        protected _tryFindDataInRelatedCache(params: TParams, entryLifetime: FxBase.LifetimeManager): any;
        protected _forEachEntry(callback: (params: TParams, dataSetPromise: FxData.DataSetPromise, dataSet: FxData.DataSet) => void, predicate?: (params: TParams) => boolean): void;
        protected abstract _getDataFromDataSet(dataSet: FxData.DataSet): any;
        private _supplyValue;
        private _establishDataSet;
        private _createUniqueDataSetName;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeCache.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    import Rpc = FxImpl.Rpc;
    import FxImplData = FxImpl.Data;
    let saveSerializedEditScopeEndPoint: Rpc.ActionEndPointDefinition<FxImplData.SaveSerializedEditScopeParameters>;
    let loadSerializedEditScopeEndPoint: Rpc.FuncEndPointDefinition<string, FxImplData.EditScopeEdits>;
    let onEditScopeDiscardedEndPoint: Rpc.ActionEndPointDefinition<string>;
    let updateEditScopeIsSavingStateEndPoint: Rpc.ActionEndPointDefinition<FxImplData.UpdateEditScopeIsSavingStateParameters>;
    interface SaveSerializedEditScopeParameters {
        editScopeId: string;
        edits: EditScopeEdits;
    }
    interface UpdateEditScopeIsSavingStateParameters {
        editScopeId: string;
        isSaving: boolean;
    }
    enum FetchEditScopeError {
        /**
         * The ajax call to loading original data failed.
         */
        LoadOriginalDataFailed = 0,
        /**
         * The ajax call to load serialized, previously authored edits failed.
         */
        LoadEditsFailed = 1,
        /**
         * Deserialized, previously authored edits are no longer consistent with the current server data.
         */
        ApplyEditsFailed = 2
    }
    /**
     * Load and save EditScope edits callback interface.
     */
    interface EditScopeCacheEditsCallbacks {
        /**
         * Function called to load EditScope edits.
         */
        loadEdits?: (editScopeId: string) => Promise<FxImplData.EditScopeEdits>;
        /**
         * Function called to save EditScope edits.
         */
        saveEdits?: (editScopeId: string, editScope: FxImplData.EditScope<any>) => void;
        /**
         * Function called to bracket an async EditScope 'save' operation.
         */
        updateEditScopeIsSavingState?: (editScopeId: string, isSaving: boolean) => void;
    }
    /**
     * Receives editScopeDiscarded events for dirty editScopes from Shell and routes them to the EditScopeCaches.
     */
    class EditScopeDiscardedReceiver {
        private _caches;
        constructor(rpcClient?: Rpc.Client);
        register(editScopeCache: EditScopeCacheBase): void;
        deregister(editScopeCache: EditScopeCacheBase): void;
    }
    let editScopeDiscardedReceiver: FxImplData.EditScopeDiscardedReceiver;
    interface EditScopeCacheBase {
        onEditScopeDiscarded(editScopeId: string): Promise<any>;
    }
    /**
     * A cache of EditScopes.
     */
    class EditScopeCache<TData, TParams> implements FxData.EditScopeCache<TData, TParams>, EditScopeCacheBase, FxImplData.ViewSource<EditScopeKey<TParams>> {
        static allLifetimes: FxImpl.TriggerableLifetimeManager;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private _updateEditScopeIsSavingState;
        private readonly _ltm;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: FxData.EditScopeCacheOptions<TData, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @returns An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: FxData.EditScopeViewConfig<TData, TParams>): FxData.EditScopeView<TData, TParams>;
        /**
         * Retrieves a Promise<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @returns A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): Promise<EditScope<TData>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<TData>) => void): Promise<any>;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: FxData.EditScopeView<TData, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): Promise<any>;
        private static _remoteSaveEditScope;
        private static _remoteSaveEdits;
        private static _remoteLoadEdits;
        private static _remoteUpdateEditScopeIsSavingState;
        private get _isDisposed();
        private _serializeKey;
        private _getEditScopeForKey;
        private _acquireEditScope;
        private _loadAndApplyEdits;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeCacheOld.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    /**
     * A cache of key results for a specific type of EditScope and key parameters.
     */
    class EditScopeCacheOld<T, TParams> implements FxData.EditScopeCache<T, TParams>, FxImpl.Data.EditScopeCacheBase, FxImpl.Data.ViewSource<EditScopeKey<TParams>> {
        private static _rpcClient;
        private _options;
        private _cacheByParams;
        private _loadEdits;
        private _saveEdits;
        private readonly _ltm;
        private _editScopeEditsChangedSubs;
        /**
         * Initializes a new instance of EditScopeCache.
         */
        constructor(options: FxData.EditScopeCacheOptions<T, TParams>, callbacks?: EditScopeCacheEditsCallbacks);
        /**
         * Creates a EditScopeView that provides a convenient way to retrieve an EditScope from the cache.
         *
         * @param lifespan An object that defines the minimum lifespan of cache entries held for the new EditScopeView. A typical example is a PartContainer
         * instance - supplying one means that the QueryView's entries may be released when the corresponding Part is removed from the UI.
         * @param config Additional options for configuring the EditScopeView.
         * @returns An EditScopeView instance.
         */
        createView(lifespan: FxBase.LifetimeManager, config?: FxData.EditScopeViewConfig<T, TParams>): FxData.EditScopeView<T, TParams>;
        /**
         * Retrieves a Promise<Data.EditScope> from the cache. If it is not already present in the cache,
         * it will be created (either via a configured supplyExistingData, or supplyNewData).
         *
         * @param key Parameters defining what data the cache entry should load.
         * @param referrer The cache entry will remain in memory until the referrer signals that it is disposed.
         * @returns A promise that will complete with the retrieved EditScope.
         */
        fetch(key: EditScopeKey<TParams>, referrer: FxBase.LifetimeManager): Promise<EditScope<any>>;
        /**
         * Invokes a callback for each entry currently in the EditScopeCache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEditScope(callback: (editScopeId: string, editScope: EditScope<any>) => void): Promise<any>;
        /**
         * Disposes the EditScopeCache, which in turn disposes all EditScopes it was holding.
         */
        dispose(): void;
        disposeAndDiscardEdits(editScopeId: string, editScopeView: FxData.EditScopeView<T, TParams>): void;
        onEditScopeDiscarded(editScopeId: string): Promise<any>;
        private static _remoteSaveEditScope;
        private static _remoteSaveEdits;
        private static _remoteLoadEdits;
        private get _isDisposed();
        private _revertEditScope;
        private _serializeKey;
        private _getEditScopeForKey;
        private _acquireEditScope;
        private _loadAndApplyEdits;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.EditScopeKey.d.ts
declare module FxImpl.Data {
    /**
     * Internal EditScope key value for specific T type held in cache.
     */
    interface EditScopeKey<TParams> {
        /**
         * EditScope id.
         */
        editScopeId: string;
        /**
         * Value identifying the data loaded into the EditScope held in the cache.
         * If the data is object-typed, this value is an id identifying that entity.
         * If the data is array-typed, this value is the query processed to return the array items.
         *
         * There are two sentinel values:
         * undefined - implies, that EditScopeView.fetchForNewData was called.
         * null - implies, that EditScopeView.fetchForExistingData was called and no 'params' was passed.
         *        This happens e.g. in scenario, when there's only one array on the server, that user
         *        wants to retrieve.
         */
        params: TParams;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.MergeVisitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An interface through which a MergeVisitor is to be used.
     */
    interface MergeVisitorContract<TData> {
        /**
         * Merges supplied source data onto a supplied target.
         *
         * @param source The source data (from which values will be copied).
         * @param target The target (onto which source values will be applied).
         * @param typeMetadata Type metadata covering the source/target data.
         */
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
    }
    /**
     * Options supplied when constructing a MergeVisitor.
     */
    interface MergeVisitorOptions extends VisitorOptions {
        /**
         * A callback called when data is detached from the target data.
         *
         * @param data The data.
         * @param typeMetadata Type metadata covering the data.
         */
        onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * A callback called to clone supplied source data, in the event that the data is new to the target data.
         *
         * @param data The data to be cloned.
         * @param typeMetadata Type metadata covering the data.
         * @returns A clone of the data.
         */
        clone: (data: any, typeMetadata: Metadata.Metadata) => any;
    }
    /**
     * This interface is used to customize a MergeVisitor by supplying mix-in style callbacks.
     */
    interface MergeVisitorCallbacks extends VisitorCallbacks<any, boolean> {
    }
    /**
     * A Visitor that observably merges source data onto target data.
     */
    class MergeVisitor<TData> extends Visitor<any, boolean> implements MergeVisitorContract<TData> {
        _clone: (data: any, typeMetadata: Metadata.Metadata) => any;
        _onDetach: (data: any, typeMetadata: Metadata.Metadata) => void;
        /**
         * Constructs an MergeEntityOnlyVisitor instance.
         *
         * @param options Options used in the construction of the MergeEntityOnlyVisitor.
         */
        constructor(options: MergeVisitorOptions, callbacks: MergeVisitorCallbacks);
        merge(source: TData, target: TData, typeMetadata: Metadata.Metadata): void;
        visitObject(sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        /**
         * See base class.
         */
        visitObjectPropertyValueDispatch(property: string, sourceObject: StringMap<any>, typeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitNonEntityTypedObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitObjectPropertyValue(property: string, sourceObject: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, targetObject: StringMap<any>): boolean;
        visitArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray): boolean;
        _mergeArray(sourceArray: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, targetArray: ArrayOrObservableArray, workerFunctions?: {
            getEdits?: (unwrappedSourceArray: any[], unwrappedTargetArray: any[]) => KnockoutArrayEdit<any>[];
            getSourceItem?: (targetItem: any, unwrappedSourceArray: any[]) => any;
            handleAdd?: (itemToAdd: any, index: number) => void;
            handleDelete?: (itemToDelete: any, index: number) => void;
        }): boolean;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.RefCountCache.d.ts
declare module FxImpl.Data {
    /**
     * For testing only. This API does not exist in production code.
     */
    function internalSetDefaultEvictionDelay(newValue: number): number;
    /**
     * Configures a RefCountCache instance.
     */
    interface RefCountCacheConfig<T> {
        /**
         * Optional. Invoked to notify that the given entry is being ejected from the cache.
         *
         * @param entry The entry being ejected.
         * @param key The entry key.
         */
        onEntryDisposed?(entry: T, key: string): void;
        /**
         * Causes cache entries to remain in memory for a specified period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'extendEntryLifetimes' setting.
         */
        evictionDelay?: number;
        /**
         * Causes cache entries to remain in memory for a framework-controlled period after
         * their last referrer is removed.
         *
         * Do not use this in conjunction with the 'evictionDelay' setting.
         */
        extendEntryLifetimes?: boolean;
    }
    /**
     * A cache of objects of type T, uniquely identifiable via string keys, in which all
     * accesses to the cache are tracked by referrerId (another string key). The cache tracks
     * which referrers have references to which entries, and automatically ejects cache entries
     * when no referrers have references to them.
     */
    class RefCountCache<T> {
        private _onDisposeEntryCallback;
        private _isDisposed;
        private _evictionDelayMilliseconds;
        private _evictionTimeoutHandlesByKey;
        private _entriesByKey;
        private _entriesByReferrerThenKey;
        /**
         * Constructs an instance of RefCountCache.
         *
         * @param config Configuration for the RefCountCache instance.
         */
        constructor(config?: RefCountCacheConfig<T>);
        /**
         * Gets or creates a cache entry for the given key.
         *
         * @param key The entry key.
         * @param referrerId An arbitrary unique string. The entry will be held in memory until this referrerId disposes its reference. If you pass
         * null/undefined, no referrer will be associated with the entry.
         * @param createCallback A function that supplies a value for the entry. This is called only when creating new entries.
         * @returns A new or existing cache entry.
         */
        getEntry(key: string, referrerId: string, createCallback: () => T): T;
        /**
         * Reveals whether or not the RefCountCache currently holds an entry for the given key.
         *
         * @param key The entry key.
         * @returns True if the entry exists; false otherwise.
         */
        hasEntry(key: string): boolean;
        /**
         * Disassociates the given entry from the given referrer. If the entry is no longer
         * associated with any referrers, it will be ejected from the cache.
         *
         * @param key The entry key.
         * @param referrerId The ID of the referrer.
         */
        dissociateEntry(key: string, referrerId: string): void;
        /**
         * Dissociates all referrers from the entry and evicts the entry from the cache. Does not wait
         * for any eviction delay.
         *
         * @param key The entry to be evicted.
         */
        immediatelyEvictEntry(key: string): void;
        /**
         * Removes all associations with the given referrer. Any entries that no longer
         * have associations will be ejected from the cache.
         *
         * @param referrerId The ID of the referrer.
         */
        disposeReferrer(referrerId: string): void;
        /**
         * Invokes a callback for each entry currently in the cache.
         *
         * @param callback The callback to be invoked.
         */
        forEachEntry(callback: (key: string, value: T) => void): void;
        /**
         * Disposes the RefCountCache so that onDisposeEntryCallback runs for every entry.
         * Once disposed, the RefCountCache may no longer be used to retrieve entries.
         */
        dispose(): void;
        private _ensureReferenceExists;
        private _cancelAnyDelayedEviction;
        private _delayedEvictEntryIfNoReferences;
        private _immediateEvictEntryIfNoReferences;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Shared.d.ts
declare module FxImpl.Data.Shared {
    /**
     * A JavaScript array instance wrapped in an observable wrapper.  Only in some cases will this be a
     * KnockoutObservableArray.
     */
    type ObservableArray = KnockoutObservableBase<any[]>;
    /**
     * A JavaScript array which may or may not be wrapped in an observable wrapper.
     */
    type ArrayOrObservableArray = any[] | ObservableArray;
    /**
     * Unwraps a property value on a given object.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @returns The unwrapped object property value.
     */
    function unwrapObjectPropertyValue(obj: StringMap<any>, property: string): any;
    /**
     * Returns a boolean reflecting whether a property on a supplied object is observable.
     * Here, we follow a conventional usage of Knockout observables where observability is considered to be an aspect of
     * the (object,key)-pair.  The 'property value' here is the result of unwrapping.
     * The exception here are observable arrays, which are treated themselves as self-standing containers and, hence,
     * not unwrapped by this function.
     *
     * @param obj An object.
     * @param property A property name.
     * @returns A boolean reflecting whether the object property value is observable.
     */
    function isObservableObjectPropertyValue(obj: StringMap<any>, property: string): boolean;
    /**
     * Unwraps a value that is assumed/asserted to be of type T[] or of type KnockoutObservableBase<T[]> and its
     * subclasses.
     *
     * @param data The array or observable-wrapped array.
     * @returns A JavaScript array.
     */
    function unwrapArrayOrObservableArray(data: ArrayOrObservableArray): any[];
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.ViewSource.d.ts
declare module FxImpl.Data {
    interface QueryViewSource<T, TParams> extends DataViewSource<T, TParams> {
        /**
         * Any navigation options configured for this QueryCache.
         */
        navigationOptions: MsPortalFx.Data.QueryCacheNavigationOptions<T, TParams>;
    }
    interface DataViewSource<T, TParams> extends RefreshableViewSource<T, TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @returns A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): MsPortalFx.Data.DataSetPromise;
    }
    interface RefreshableViewSource<T, TParams> extends ViewSource<TParams> {
        "--noUnusedLocals"?: T | any;
        /**
         * Instructs the data source to update the contents of whatever T corresponds to the
         * specified parameters.
         *
         * @param params Parameters describing the data to be updated.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @returns A promise that completes when the refresh has completed.
         */
        refresh(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): Promise<any>;
    }
    interface ViewSource<TParams> {
        /**
         * Retrieves data matching the specified parameters.
         *
         * @param params Parameters describing the data to be fetched.
         * @param referrer A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @returns A promise that completes with the requested data.
         */
        fetch(params: TParams, referrer: MsPortalFx.Base.LifetimeManager): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Views.d.ts
declare module FxImpl.Data {
    import FxBase = MsPortalFx.Base;
    import FxData = MsPortalFx.Data;
    import ErrorNotificationTarget = FxData.ErrorNotificationTarget;
    interface CancelableRequestInfo<T extends Promise<any>> {
        cancelationToken: FxBase.Promises.CancelationToken;
        cancelablePromise: T;
        externalPromise: Promise<any>;
    }
    /**
     * Represents a callback that will be invoked when an a fetch operation
     * reports a 'not found' error.
     */
    interface InterceptNotFoundCallback<TParams> {
        (params: TParams): void;
    }
    /**
     * Options for configuring an ObjectView.
     */
    interface ObjectViewConfig<TObject, TParams> {
        "--noUnusedLocals"?: TObject | any;
        /**
         * Indicates whether the ObjectView should intercept any 'not found' (404) errors, and if so,
         * how they should be handled. Defaults to 'true'.
         *
         *  - 'false' means that the ObjectView will not intercept 'not found' errors, which means that
         *    such errors will cause parts/blades to go into generic failure states
         *  - 'true' means that the ObjectView will intercept 'not found' errors, and handle them by
         *    displaying a generic 'not found' message
         *  - callback functions mean that custom 'not found' handling applies, so 404s will trigger
         *    your callback. This is useful for displaying custom 'not found' messages.
         *
         * Regardless of this option, all onInputsSet promise rejections other than 'not found' (404) will
         * continue to trigger generic part/blade failures.
         */
        interceptNotFound?: boolean | InterceptNotFoundCallback<TParams>;
    }
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * This class should not be instantiated directly.  Rather, acquire an instance of a subclass by
     * calling 'createView' on a Cache instance.
     */
    class ObjectView<TObject, TParams> {
        _loadedCacheEntry: KnockoutObservable<TObject>;
        _interceptNotFound: boolean | InterceptNotFoundCallback<TParams>;
        _isDisposed: boolean;
        _dataSource: ViewSource<TParams>;
        _errorNotificationTarget: ErrorNotificationTarget;
        _currentParams: TParams;
        _currentCacheEntryDisposer: FxBase.DisposableLifetimeManager;
        _requestInProgress: KnockoutObservable<CancelableRequestInfo<Promise<TObject>>>;
        _isLoading: KnockoutComputed<boolean>;
        _lifetime: FxBase.LifetimeManager;
        /**
         * Constructs an instance of ObjectView<TEntity, TParams>.
         *
         * @param dataSource A provider of data for the ObjectView, for example a DataCache instance.
         * @param lifetime The current cache entry referenced by this ObjectView will remain in memory at least until this object notifies that it is disposed.
         * @param errorNotificationTarget An object that represents the minimum lifetime of the current cache entry, and can optionally receive notifications about any errors encountered.
         * @param config Options for configuring the instance.
         */
        constructor(dataSource: ViewSource<TParams>, errorNotificationTarget: ErrorNotificationTarget, config: ObjectViewConfig<TObject, TParams>);
        /**
         * An observable value that indicates whether this ObjectView currently refers to a request that has not yet completed.
         */
        get loading(): KnockoutComputed<boolean>;
        /**
         * Sets the ObjectView's current query parameters, changing what data it exposes.
         * The data will be fetched from the underlying cache, which may or may not already have it in memory.
         *
         * If you call 'fetch' while an earlier load is still in progress, the older load will be superseded,
         * meaning that its promise will never complete. This is so you do not need manual code to stop
         * superseded promise handlers from performing actions that are now irrelevant.
         *
         * @param params Query parameters describing the data to be fetched. If you supply null/undefined, then the preceding query will be superseded,
         * but no new query will be begun - the ObjectView will therefore become empty.
         * @returns A promise that completes when the load has completed.
         */
        fetch(params: TParams): Promise<any>;
        private _cancelInProgressRequest;
        private _releaseCurrentContents;
        private _handleFetchRejections;
    }
    /**
     * Provides a convenient way to access results from an underlying ViewSource. Whenever you modify
     * the query parameters associated with the ObjectView, it will fetch a corresponding TObject from
     * the underlying ViewSource.
     *
     * Extension developers are not intended to use this directly, and should instead use one of the
     * specialized subclasses, e.g. EntityView, QueryView, that can be obtained by calling
     * .createView() on an EntityCache or QueryCache instance.
     */
    class DataView<TEntity, TParams> extends ObjectView<FxData.DataSet, TParams> {
        private _partialErrors;
        private get _refreshableDataSource();
        /**
         * Internal constructor. Extension developers are not intended to use this directly, and should
         * instead use one of the specialized subclasses, e.g. EntityView, QueryView, that can be obtained
         * by calling .createView() on an EntityCache or QueryCache instance.
         */
        constructor(dataSource: FxImpl.Data.DataViewSource<TEntity, TParams>, lifetime: FxBase.LifetimeManager, config: ObjectViewConfig<TEntity, TParams>);
        get partialErrors(): KnockoutReadOnlyObservableArray<FxData.PartialError>;
        /**
         * Instructs the underlying data loader to re-fetch and update whatever data is
         * currently being exposed by this instance.
         *
         * If a request is currently in progress, this does not trigger a further request.
         * So, it is safe to invoke 'refresh' immediately after a 'fetch' if you want to
         * be sure to fetch fresh data and not accept existing cached data.
         *
         * @returns A promise that completes when the refresh is done. Or, if a request was already in progress, a promise that completes when the existing request completes.
         */
        refresh(): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Internal\Internal.Data.Visitor.d.ts
declare module FxImpl.Data {
    import Metadata = MsPortalFx.Data.Metadata;
    import ArrayOrObservableArray = Shared.ArrayOrObservableArray;
    /**
     * An entity is an object whose associated type metadata describes an entity type (with a primary key /
     * unique id).
     */
    type Entity = StringMap<any>;
    /**
     * An array of entity objects.  An entity is an object whose associated type metadata describes an entity type (with
     * a primary key / unique id).
     */
    type EntityArray = ArrayOrObservableArray;
    /**
     * This interface is used to customize a Visitor by supplying mix-in style callbacks.
     */
    interface VisitorCallbacks<TArgs, TResult> {
        /**
         * Visits an entity-typed array (observable or native).
         *
         * @param array An entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityArray?: (array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed array (observable or native).
         *
         * @param array An non-entity-typed array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array (observable or native).
         *
         * @param array An array (observable or native).
         * @param typeMetadata Type metadata covering the array and its contained items.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArray?: (array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an array item.
         *
         * @param item An item contained in an array.
         * @param index The index for the item in the containing array.
         * @param typeMetadata Type metadata covering item.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitArrayItem?: (item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits an entity-typed object.
         *
         * @param entity An entity-typed object.
         * @param typeMetadata Type metadata covering the entity.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntity?: (entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed object.
         *
         * @param obj A non-entity-typed object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a object.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObject?: (obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Determines whether a given object property should be visited.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata for the object.
         * @returns A boolean reflecting whether the property should be visited.
         */
        shouldVisitObjectProperty?: (property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata) => boolean;
        /**
         * Visits an entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a non-entity-typed property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitNonEntityTypedObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a property on an object.
         *
         * @param property The property name.
         * @param obj The object.
         * @param propertyTypeMetadata Type metadata covering the property on the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValue?: (property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs) => TResult;
        /**
         * Visits a date value.
         *
         * @param date The date value.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitDate?: (data: Date, args?: TArgs) => TResult;
        /**
         * Visits a scalar (non-Date) value.
         *
         * @param value The scalar value.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitScalar?: (value: number | string, args?: TArgs) => TResult;
        /**
         * Visits a function.
         *
         * @param fn The function.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitFunction?: (fn: Function, args?: TArgs) => TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorContract<TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata): TResult;
    }
    /**
     * An interface through which a Visitor is to be used.
     */
    interface VisitorWithArgsContract<TArgs, TResult> {
        /**
         * Performs the visitation.
         *
         * @param data The data to be visited.
         * @param typeMetadata Type metadata covering the data.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visit(data: any, typeMetadata: Metadata.Metadata, args: TArgs): TResult;
    }
    /**
     * Options supplied when constructing a Visitor.
     */
    interface VisitorOptions {
    }
    /**
     * A Visitor that can be extended/specialized via inheritance and via mix-in style callbacks.
     */
    class Visitor<TArgs, TResult> implements VisitorWithArgsContract<TArgs, TResult>, VisitorContract<TResult>, VisitorCallbacks<TArgs, TResult> {
        _callbacks: VisitorCallbacks<TArgs, TResult>;
        /**
         * Constructs a Visitor instance.
         *
         * @param options Options used in the construction of the Visitor.
         * @param callbacks Optional, mix-in style callbacks that override default Visitor behavior.
         */
        constructor(options: VisitorOptions, callbacks: VisitorCallbacks<TArgs, TResult>);
        visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitEntityArray(array: EntityArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitArray(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitArrayItem(item: any, index: number, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitEntity(entity: Entity, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitObject(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        shouldVisitObjectProperty(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata): boolean;
        visitEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitNonEntityTypedObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitObjectPropertyValue(property: string, obj: StringMap<any>, propertyTypeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        visitDate(date: Date, args?: TArgs): TResult;
        visitScalar(value: number | string, args?: TArgs): TResult;
        visitFunction(fn: Function, args?: TArgs): TResult;
        /**
         * Returns the object properties that should be visited.
         *
         * @param obj An object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns An array of string that are the names of the properties that should be visited.
         */
        getObjectPropertiesToVisit(obj: StringMap<any>, typeMetadata: Metadata.Metadata): string[];
        /**
         * Visits a property on an object, delegating to 'visitEntityTypedObjectPropertyValue' or
         * 'visitNonEntityTypedObjectPropertyValue' based on type metadata.
         *
         * @param property The property name.
         * @param obj The object.
         * @param typeMetadata Type metadata covering the object.
         * @param args Arguments threaded down through the recursive visitation.
         * @returns A value determined by the extender of this Visitor.  Defaults to undefined.
         */
        visitObjectPropertyValueDispatch(property: string, obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visit(data: any, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitArrayDispatch(array: ArrayOrObservableArray, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
        _visitObjectDispatch(obj: StringMap<any>, typeMetadata: Metadata.Metadata, args?: TArgs): TResult;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigationMetadata.d.ts
declare module MsPortalFx.Data {
    /**
     * Describes the state of navigable data, for example specifying the
     * total number of items or the token needed to fetch further data.
     *
     * This information is typically extracted from a server response.
     */
    interface DataNavigationMetadata {
        /**
         * If available, provides the total number of items that may be navigated through.
         * Not all data sources make this information available, so this property may be null/undefined.
         */
        totalItemCount?: number;
        /**
         * If applicable, specifies the server-generated continuation token value that may
         * be used to fetch the next range of items. This value may be in any format - for
         * example, it may be an entire URI.
         */
        continuationToken?: string;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigator.d.ts
declare module MsPortalFx.Data {
    enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    /**
     * Represents a source of data that supports one or more standard navigation mechanisms,
     * such as skip/take or continuation tokens.
     */
    interface DataNavigator<T> {
        /**
         * The current range of items.
         */
        items: KnockoutObservableBase<T[]>;
        /**
         * Provides metadata about navigation state, such as current page index
         * or the total number of items.
         */
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        /**
         * Describes errors associated with the current items in the data navigator.
         */
        partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>;
        /**
         * If this data navigator supports loading via skip/take, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadBySkipTake?(skip: number, take: number, filter: string, sort?: SortBy[]): Promise<any>;
        /**
         * If the data navigator supports loading via continuation tokens, resets its state so that
         * the next load will fetch the first page of data.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        resetLoadByContinuationToken?(filter: string, sort?: SortBy[]): void;
        /**
         * If the data navigator supports loading via continuation tokens, loads data by that method.
         * This property will be null/undefined if this data navigator does not support skip/take.
         */
        loadByContinuationToken?(): Promise<any>;
        /**
         * Instructs all consumers of this navigator to reset their navigation state
         * and begin at the first page.
         *
         * @returns A promise that completes when all consumers of the navigator have finished resetting their navigation state.
         */
        resetNavigation(): Promise<any>;
        /**
         * Used by controls that are consuming the navigator to receive notification
         * when the navigation state should be reset. Not intended for use from
         * portal extension code.
         *
         * @param callback Callback to invoke when navigation state should be reset.
         */
        addResetNavigationListener(callback: () => Promise<any>): void;
        /**
         * Removes a callback previously registered using addResetListener. Not intended
         * for use from portal extension code.
         *
         * @param callback Callback to be removed. Must be the same function instance that was previously registered.
         */
        removeResetNavigationListener(callback: () => Promise<any>): void;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.DataNavigatorBase.d.ts
declare module MsPortalFx.Data {
    /**
     * An abstract base class for data navigators.
     */
    class DataNavigatorBase<TEntity> implements DataNavigator<TEntity> {
        items: KnockoutObservableBase<TEntity[]>;
        metadata: KnockoutObservableBase<DataNavigationMetadata>;
        private _resetListeners;
        private _partialErrors;
        constructor(partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        get partialErrors(): KnockoutReadOnlyObservableArray<PartialError>;
        resetNavigation(): Promise<any>;
        addResetNavigationListener(callback: () => Promise<any>): void;
        removeResetNavigationListener(callback: () => Promise<any>): void;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.LocalDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * A DataNavigator that supports skip/take over in-memory data.
     */
    class LocalDataNavigator<T> extends DataNavigatorBase<T> {
        private _allItems;
        private _currentSkipTakeParams;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, allItems: KnockoutObservableBase<T[]>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        loadBySkipTake(skip: number, take: number, filter: string): Promise<any>;
    }
}

// FILE: MsPortalFx\Data\Navigation\Data.RemoteDataNavigator.d.ts
declare module MsPortalFx.Data {
    /**
     * Options that describe how a RemoteDataNavigator should perform navigation.
     */
    interface RemoteDataNavigatorOptions<TEntity, TQueryParams> {
        "--noUnusedLocals"?: TEntity | any;
        /**
         * If the data source supports skip/take, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         */
        loadBySkipTake?(metadata: DataNavigationMetadata, query: TQueryParams, skip: number, take: number, filter: string, sort?: SortBy[]): Promise<any>;
        /**
         * If the data source supports continuation tokens, fetches data by that method.
         * This property should be null/undefined if the data source does not support it.
         *
         * @param metadata The most recent metadata, if any, fetched previously by this data source.
         * @param query Query parameters to be used.
         * @param reset If true, indicates that the first page of data should be loaded. Otherwise, the continuation token in metadata should be used to
         * fetch the next range of data.
         * @param filter Specifies any filtering value entered by the user.
         * @param sort An array of objects to sort by.
         * @returns A promise representing the operation.
         */
        loadByContinuationToken?(metadata: DataNavigationMetadata, query: TQueryParams, reset: boolean, filter: string, sort?: SortBy[]): Promise<any>;
    }
    /**
     * A DataNavigator that uses callbacks to read arbitrary external
     * data, such as data loaded on demand from a remote server.
     */
    class RemoteDataNavigator<TEntity, TQueryParams> extends DataNavigatorBase<TEntity> {
        private _options;
        private _continuationTokenFilter;
        private _continuationTokenSort;
        private _continuationTokenResetRequested;
        private _queryParams;
        constructor(lifetime: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableBase<TEntity[]>, metadata: KnockoutObservableBase<DataNavigationMetadata>, options: RemoteDataNavigatorOptions<TEntity, TQueryParams>, partialErrors?: KnockoutReadOnlyObservableArray<MsPortalFx.Data.PartialError>);
        loadBySkipTake(skip: number, take: number, filter: string, sort?: SortBy[]): Promise<any>;
        loadByContinuationToken(): Promise<any>;
        resetLoadByContinuationToken(filter: string, sort?: SortBy[]): void;
        /**
         * Sets query parameters on the navigator, and resets navigation state so that
         * consumers will load the first page of results for the new query. Typically,
         * parts should call this from their onInputsSet methods.
         *
         * Controls that use navigators will not request any data until the first time
         * that navigation state is reset, so you must call this from onInputsSet even
         * if your navigator has no particular query (in this case, just pass 'null' to
         * signal that you are ready for the control to load data).
         *
         * @param query The new query parameters that will be passed to your loadBy... callbacks.
         * @returns A promise that completes when all consumers of the navigator have finished resetting their navigation state. Typically, you should return
         * this from your onInputsSet method.
         */
        setQuery(query: TQueryParams): Promise<any>;
        private _getClonedQuery;
    }
}

// FILE: MsPortalFx\Decorators.d.ts
declare module MsPortalFx.Composition {
    import FxBase = MsPortalFx.Base;
    /**
     * This decorator should only apply to properties.
     *
     * It marks the property ignored by Po. Properties that are marked NotProxied are excluded from
     * observable / view model proxying.  Marking properties with this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    function NotProxied(target: any, key: string, descriptor: PropertyDescriptor): void;
    /**
     * This decorator should only apply to class which contains properties.
     *
     * It makes all properties in this class ignored by Po. All properties in this class are excluded from
     * observable / view model proxying. Marking this decorator enables a significant performance
     * optimization for observable / view model proxying.
     *
     * @param target The target object
     * @param key The property key
     * @param descriptor The property descriptor
     */
    let ProxyCompatibilityMode: Action1<any>;
    let exportForDevMode: {
        log: FxBase.Diagnostics.Log;
    };
}

// FILE: MsPortalFx\Environment.d.ts
declare module FxImpl {
    let features: Features;
}

// FILE: MsPortalFx\EnvironmentInit.d.ts
declare module FxImpl {
    const origin: string;
    const protocol: string;
    const href: string;
    function onEnvironmentSet(callback: Action1<typeof MsPortalFx.getEnvironmentValue>): void;
    function throwBeforeEnvironment(): void;
    function setEnvironment(): void;
    /**
     * Returns uri that includes the scheme. Assumes that uris that do not begin with a scheme or a slash are in
     * application relative form.
     *
     * @param uri A uri.
     * @returns The absolute uri.
     */
    function ensureAbsoluteUri(uri: string): string;
}
declare module MsPortalFx {
    const isIFrame: boolean;
    /**
     * Gets the value of the specified feature.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns The value of the feature.
     */
    function getFeatureValue(feature: string): string;
    /**
     * Gets a value indicating whether or not the specified feature is enabled.
     * NOTE: The feature must be specified without the <Extension>_ prefix.
     *
     * @param feature The name of the feature.
     * @returns True if the feature is enabled; else false.
     */
    function isFeatureEnabled(feature: string): boolean;
    /**
     * Gets the value of an environment variable, preserving the typing.
     *
     * @param key The name of the value to get
     * @param defaultValue The value to return if the value is not there
     * @returns The value from the enviroment or the defaultValue
     */
    function getEnvironmentValue<T extends keyof FxEnvironment>(key: T, defaultValue?: FxEnvironment[T]): FxEnvironment[T];
    const isDevelopmentMode: boolean;
    const isTestMode: boolean;
    const isInWebWorker: boolean;
    const sessionId: string;
    const trace: DeepReadonly<TraceConfig>;
    const portalUri: string;
    /**
     * The original Object.defineProperty() method. This method defines a new property directly on an object, or modifies an existing property on an object, and returns the object.
     * NOTE: 1. The Object.defineProperty() might be overridden to only defines non enumeration property. So, the MsPortalFx.defineProperty is the recommended way to define enumeration property.
     *       2. Set "MsPortalFx.defineProperty" to "MsPortalFx.defineProperty || Object.defineProperty" to avoid potential recursive loop.
     *
     * @param obj The object on which to define the property.
     * @param property name The property name.
     * @param descriptor The descriptor for the property.
     */
    let defineProperty: typeof Object.defineProperty;
}

// FILE: MsPortalFx\Errors\Errors.d.ts
declare module MsPortalFx.Errors {
    type ErrorContract = import("Fx/Errors").ErrorContract;
    type ErrorType<E extends Error> = import("Fx/Errors").ErrorType<E>;
    type ErrorOptions = import("Fx/Errors").ErrorOptions;
    /**
     * Defines the contract of an error related to Data within the Framework.
     */
    interface DataErrorContract extends ErrorContract {
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Information associated with the error.
         */
        errorData: any;
    }
    /**
     * Defines the options of a data error.
     */
    interface DataErrorOptions extends ErrorOptions {
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Information associated with the error.
         */
        errorData?: any;
    }
    /**
     * Represents a generic data error.
     */
    class DataError extends Error implements DataErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the data set that was the source of the error.
         */
        dataSetName: string;
        /**
         * Constructs a DataError.
         *
         * @param dataSetName The name of the data set.
         * @param errorData Error related data.
         */
        constructor(dataSetName: string, errorData?: any);
        /**
         * Constructs a DataError.
         *
         * @param options The data error options.
         */
        constructor(options: DataErrorOptions);
    }
    /**
     * Represents a fetch data error.
     */
    class FetchDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a FetchDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
        /**
         * Constructs a FetchDataError.
         *
         * @param options The fetch data error options.
         */
        constructor(options: DataErrorOptions);
    }
    /**
     * Represents an unauthorized data error.
     */
    class UnauthorizedDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a UnauthorizedDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
        /**
         * Constructs an UnauthorizedDataError.
         *
         * @param options The unauthorized data error options.
         */
        constructor(options: DataErrorOptions);
    }
    /**
     * Represents a "not found" data error.
     */
    class NotFoundDataError extends DataError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a NotFoundDataError.
         *
         * @param dataSetName The data set name for the error source.
         * @param errorData Error specific data.
         */
        constructor(dataSetName: string, errorData?: any);
        /**
         * Constructs an NotFoundDataError.
         *
         * @param options The not found data error options.
         */
        constructor(options: DataErrorOptions);
    }
    /**
     * DisposedError properties.
     */
    interface DisposedErrorContract extends ErrorContract {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    /**
     * DisposedError options.
     */
    interface DisposedErrorOptions extends ErrorOptions {
        /**
         * The name of the object being disposed.
         */
        source?: string;
    }
    /**
     * Represents a disposed error.
     */
    class DisposedError extends Error implements DisposedErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The name of the object being disposed.
         */
        source: string;
        /**
         * Construct a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a DisposedError.
         * Thrown when a instance is accessed after being disposed.
         *
         * @param options The error options.
         */
        constructor(options?: DisposedErrorOptions);
    }
    /**
     * AjaxError properties.
     */
    interface AjaxErrorContract extends ErrorContract {
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
    }
    /**
     * AjaxError options.
     */
    interface AjaxErrorOptions extends ErrorOptions {
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
    }
    /**
     * Represents a Ajax error.
     */
    class AjaxError extends Error implements AjaxErrorContract {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * The XHR of the response.
         */
        jqXHR: JQueryXHR<any>;
        /**
         * The text status.
         */
        textStatus: string;
        /**
         * The XHR Error string
         */
        errorThrown: string;
        /**
         * Construct a AjaxError.
         * Thrown when a instance is accessed after being Ajax.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a AjaxError.
         * Thrown when a instance is accessed after being Ajax.
         *
         * @param options The error options.
         */
        constructor(options?: AjaxErrorOptions);
    }
}
declare namespace MsPortalFx.Errors {
    type ErrorLevel = import("Fx/Errors").ErrorLevel;
    const ErrorLevel: typeof import("Fx/Errors").ErrorLevel;
    const isInstanceOfErrorType: typeof import("Fx/Errors").isInstanceOfErrorType;
    const getErrorOptions: typeof import("Fx/Errors").getErrorOptions;
    type Error = import("Fx/Errors").FxError;
    const Error: typeof import("Fx/Errors").FxError;
    type CanceledError = import("FxInternal/Errors").FxCanceledError;
    const CanceledError: typeof import("FxInternal/Errors").FxCanceledError;
    type DisposedCanceledError = import("FxInternal/Errors").FxDisposedCanceledError;
    const DisposedCanceledError: typeof import("FxInternal/Errors").FxDisposedCanceledError;
}

// FILE: MsPortalFx\Extension\ActionBarKind.d.ts
declare module MsPortalFx.Extension {
    const enum ActionBarKind {
        /**
         * Indicates that no action bar is to be used.
         */
        None = 0,
        /**
         * The type of action bar to use in a form blade.
         */
        Create = 1,
        /**
         * The type of action bar to use in a picker blade.
         */
        Picker = 2,
        /**
         * The type of action bar to use in a form blade.
         */
        Form = 3,
        /**
         * The type of action bar to use in a filter blade.
         */
        Filter = 4,
        /**
         * The type of action bar to use in a delete confirmation blade.
         */
        Delete = 5,
        /**
         * The type of action bar to use in a generic blade.
         */
        Generic = 6
    }
}

// FILE: MsPortalFx\Extension\AssetIdSourceType.d.ts
declare module MsPortalFx.Extension {
    const enum AssetIdSourceType {
        /**
         * Asset ID from a property on the inputs.
         */
        FromInput = 0,
        /**
         * Asset ID from a property on the property provider service on the scope asset type.
         */
        FromProvider = 1,
        /**
         * Asset ID from a property on the property provider service on the permission asset type.
         */
        FromSourceProvider = 2
    }
}

// FILE: MsPortalFx\Extension\CommandKind.d.ts
declare module MsPortalFx.Extension {
    const enum CommandKind {
        /**
         * A standard command invokes execute on the command view model
         */
        Standard = 0,
        /**
         * A Url command opens a new Url in new browser session
         */
        Url = 1,
        /**
         * A blade command kind opens a blade
         */
        Blade = 2,
        /**
         * A FileDownload command kind to download file content.
         */
        FileDownload = 3,
        /**
         * A ListCommand opens a list of items
         */
        List = 4,
        /**
         * A Dynamic command initializes and executes another command.
         */
        Dynamic = 5
    }
}

// FILE: MsPortalFx\Extension\Extension.d.ts
declare module FxImpl.Extension {
    import Rpc = FxImpl.Rpc;
    const extensionStatusEndPoint: Rpc.ActionEndPointDefinition<ExtensionStatus>;
    const getCurrentlDeepLinkEndpoint: Rpc.FuncEndPointDefinition<void, string>;
    interface ReactBootPayload {
        readonly requireConfig: any;
        readonly extensionEnvironment: any;
        readonly features: StringMap<string>;
    }
    const postBootEndPoint: Rpc.ActionEndPointDefinition<ReactBootPayload>;
    /**
     * Result returned from 'waitForExtensionIdleEndPoint'.
     */
    interface WaitForExtensionIdleResult {
        /**
         * Pending async operations count when 'waitForExtensionIdleEndPoint' is called.
         */
        readonly pendingOperationsCount: number;
        /**
         * The time in milliseconds spent waiting.
         */
        readonly waitDuration: number;
        /**
         * A flag indicating if loading of this Blade was interrupted by a new Blade being opened.
         */
        readonly interruptedByChild: boolean;
    }
    /**
     * An endpoint used by Shell to determine when all pending async calls (RPC and ajax) have resolved in
     * the extension, to determine when Blade-rendering is fully complete.
     */
    const waitForExtensionIdleEndPoint: Rpc.FuncEndPointDefinition<{
        bladeName: string;
        bladeInstanceId: string;
    }, WaitForExtensionIdleResult>;
    /**
     * Arguments passed to report ReactView lifecycle changes to the extension worker.
     */
    type ReactViewLifetimeArgs = {
        /**
         * The ReactView name.
         */
        readonly viewName: string;
        /**
         * The Blade sequence number.
         */
        readonly sequenceNumber: number;
    };
    /**
     * An endpoint called by Shell to inform the extension that a new ReactView is being rendered.
     */
    const onNewReactViewEndPoint: Rpc.ActionEndPointDefinition<ReactViewLifetimeArgs>;
    /**
     * An endpoint called by Shell to inform the extension when a ReactView becomes interactive.
     */
    const onReactViewInteractiveEndPoint: Rpc.ActionEndPointDefinition<{
        bladeInstanceId: string;
        time: number;
    }>;
    /**
     * An endpoint called by Shell to inform the extension that a ReactView has been disposed.
     */
    const onReactViewDisposed: Rpc.ActionEndPointDefinition<ReactViewLifetimeArgs>;
    /**
     * An endpoint called by Shell to send a telemetry event to the extension's telemetry table.
     */
    const traceToExtensionEndPoint: Rpc.ActionEndPointDefinition<[MsPortalFx.Base.Diagnostics.Telemetry.TelemetryEvent, TelemetryContext.State]>;
    /**
     * An endpoint called by Shell to send a telemetry event to the extension's telemetry table.
     */
    const endTraceToExtensionEndPoint: Rpc.FuncEndPointDefinition<[MsPortalFx.Base.Diagnostics.Telemetry.TelemetryEvent, number, string | boolean, any, TelemetryContext.State], number>;
    /**
     * The descriptor for an extension window.
     */
    interface ExtensionDescriptor {
        /**
         * The name of the extension.
         */
        name: string;
    }
    /**
     * Types of events an extension can notify the shell about.
     */
    const enum ExtensionStatusCode {
        /**
         * The extension is operating normally.
         */
        Normal = 0,
        /**
         * The extension has detected that it's server version has changed.
         */
        VersionChanged = 1,
        /**
         * The extension has detected that it is no longer authorized for its server.
         */
        AuthorizationExpired = 2,
        /**
         * When ajax calls return a status code 0,
         * Usually happens when unable to connect to the network, firewall issues or browser extensions.
         */
        UnknownNetworkError = 4,
        /**
         * Disconnected from Relex.
         */
        RelexDisconnected = 5,
        /**
         * Too many requests. User has exceeded the rate limit.
         */
        TooManyRequests = 6,
        /**
         * Session expired
         */
        SessionExpired = 7,
        /**
         * MFA error
         */
        MfaError = 8,
        /**
         * Claims error
         */
        ClaimsError = 9
    }
    interface ExtensionStatus {
        code: ExtensionStatusCode;
        message?: string;
        data?: {
            clientRequestId?: string;
            correlationId?: string;
            missingClaims?: string;
            resourceName?: string;
            retryAfter?: string;
            type?: string;
            uri?: string;
            version?: string;
        };
    }
    const enum LocatorType {
        /**
         * Locator for an extension definition.
         */
        Extension = 0,
        /**
         * Locator for a blade definition.
         */
        Blade = 1,
        /**
         * Locator for a lens definition.
         */
        Lens = 2,
        /**
         * Locator for an asset type definition.
         */
        AssetType = 3,
        /**
         * Locator for a command group.
         */
        CommandGroup = 4,
        /**
         * Locator for a part instance definition.
         */
        PartInstance = 5,
        /**
         * Locator for a part type definition.
         */
        PartType = 6,
        /**
         * Locator for a startboard part instance definition.
         */
        StartboardPartInstance = 7,
        /**
         * Locator for an action bar definition.
         */
        BladeActionBar = 8,
        /**
         * Locator for a command.
         */
        Command = 9,
        /**
         * Removed type
         */
        UnusedPlaceholder = 10,
        /**
         * Locator for a hub instance manifest.
         */
        Hub = 11,
        /**
         * Locator for a custom lens.
         */
        CustomLens = 12,
        /**
         * Locator for a command type defined in the commands catalog.
         */
        CommandType = 13,
        /**
         * Locator for a blade redirect.
         */
        BladeRedirect = 14,
        /**
         * Locator for a part instance redirect.
         */
        PartInstanceRedirect = 15,
        /**
         * Locator for a part type redirect.
         */
        PartTypeRedirect = 16,
        /**
         * Browse configuration for a asset type
         */
        AssetTypeForBrowse = 17,
        /**
         * Html template for parts and blades
         */
        HtmlTemplate = 18
    }
}

// FILE: MsPortalFx\Extension\Extension.Definition.d.ts
declare module MsPortalFx.Extension {
    /**
     * Definition for an extension.
     */
    interface Definition {
        /**
         * Name of the extension.
         */
        name: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Definition schema version.
         */
        schemaVersion?: string;
        /**
         * For diagnostics only.
         * This property is to assistant in identfying which build of the extension this is
         * i.e. debug vs retail
         */
        buildDescription?: string;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * Parts to show on startboard on startup.
         */
        startBoardParts?: PartInstanceDefinition[];
        /**
         * List of templates defined by the template
         */
        htmlTemplates?: StringMap<HtmlTemplateDefinition>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: string[];
    }
    interface CommandsDefinition {
        /**
         * Reusable command types defined within this extension.
         */
        commandsCatalog?: CommandDefinition[];
        /**
         * A list of groups of commands.
         */
        commandGroups?: CommandGroupDefinition[];
    }
    /**
     * Definition for an item that can host commands.
     */
    interface CommandContainerDefinition {
        /**
         * Command group associated with this blade.
         */
        commandGroup?: string;
        /**
         * Reference to command group that is associated with this blade.
         * Also included binding overrides for command view model inputs.
         */
        commandGroupReference?: CommandGroupReference;
    }
    const enum BladeAttributes {
        /**
         * Blade has no attributes and will take all defaults
         */
        None = 0,
        /**
         * The blade explicitly does not support rebind
         */
        SuppressRebind = 1,
        /**
         * The blade explicitly supports provisioning
         * It accepts as an optional input "_provisioningContext"
         */
        DoesProvisioning = 2,
        /**
         * The blade represents a dx view.
         */
        DxBlade = 4,
        /**
         * The blade is a ReactView.
         */
        ReactView = 16
    }
    type ViewModelLocator = import("Fx/Extension").ViewModelLocator;
    /**
     * Definition for a blade.
     */
    interface BladeDefinition extends AssetInstanceDefinition, CommandContainerDefinition {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Lenses contained on the blade.
         */
        lenses: LensDefinition[];
        /**
         * The view model factory of the blade.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * Action bar contained on the blade.
         */
        actionBar?: ActionBarDefinition;
        /**
         * Names of inputs that will be supplied by master parts when this blade is invoked.
         */
        inputs?: string[];
        /**
         * Names of  optional inputs that will be supplied by master parts when this blade is invoked.
         */
        optionalInputs?: string[];
        /**
         * Name of inputs that will be used to identify the template of this blade.
         */
        templateKeyInputs?: string[];
        /**
         * Names of outputs that the blade can supply to the master part that invoked it.
         */
        outputs?: string[];
        /**
         * View Model providing a display Title & Icon URI.
         */
        viewModelName?: string;
        /**
         * Internal. Not for use by extensions.
         */
        _internal_viewModelExtensionName?: string;
        /**
         *  Inputs from blade to above View Model providing a display Title & Icon URI.
         */
        viewModelInputs?: InputBinding[];
        /**
         * Bindings between the inner parts and the blade.
         */
        bindings?: InputBinding[];
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * Width of this blade when used as contextPane.
         */
        contextPaneWidth?: MsPortalFx.Blades.BladeWidth;
        /**
         * Flag to indicate if this blade should be rendered in a fully responsive container.
         */
        reflowReady?: boolean;
        /**
         * Initial display state of this blade on first composition.
         * DisplayState.Minimized is ignored.
         */
        initialDisplayState?: MsPortalFx.Blades.DisplayState;
        /**
         * A value indicating whether or not the blade is locked.
         */
        locked?: boolean;
        /**
         * A value indicating whether or not the blade can be pinned to the startboard.
         */
        pinnable?: boolean;
        /**
         * The name of the part defined to represent the pinned blade.
         */
        pinnedPart?: string;
        /**
         * The extension of the part defined to represent the pinned blade.
         */
        pinnedPartExtension?: string;
        /**
         * A value indicating where the declarative view source file is located.
         */
        dxSourcePath?: string;
        /**
         * The type of edit scope to created for the when the blade is opened. The id of the created
         * edit scope will be passed to the blade as an input parameter named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * The style of the blade.
         */
        style?: Blades.BladeStyle;
        /**
         * If true, disposes the edit scope when blade would be implicitly closed by shell due to a selection change; else prompts for confirmation.
         */
        discardEditsOnSelectionChange?: boolean;
        /**
         * The permissions for the blade.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The toolbar for the blade.
         */
        toolbar?: ToolbarDefinition;
        /**
         * If this is a menu blade, describes its configuration options. If this is not a menu blade, this property is not set.
         */
        menuBlade?: MenuBladeConfig;
        /**
         * If this is a tab menu blade, describes its configuration options. If this is not a tab menu blade, this property is not set.
         */
        tabMenuBlade?: TabMenuBladeConfig;
        /**
         * If this is a template blade, describes its configuration options. If this is not a template blade, this property is not set.
         */
        templateBlade?: TemplateBladeConfig;
        /**
         * If this is a frame blade, describes its configuration options. If this is not a frame blade, this property is not set.
         */
        frameBlade?: FrameBladeConfig;
        /**
         * Delays composing blade content till inputs are set.
         */
        waitForInputsSet?: boolean;
        /**
         * Gets or sets the activation style.
         */
        activationStyle?: ActivationStyle;
        /**
         * blade attributes, a collection of bitwise flags
         * Eventually the other boolean properties should be migrated to this member
         */
        attributes?: BladeAttributes | number;
        /**
         * Indicates whether this Blade has an 'onPin' method.
         */
        hasOnPinMethod?: boolean;
        /**
         * List of external domains that are allowlisted for usage in links without redirecting to a confirmation page.
         */
        trustedLinkedDomains?: string[];
        /**
         * Blade view model bundle loading measurements.
         */
        viewModelBundleLoading?: {
            /**
             * The time at which bundle-loading completes.
             */
            end: number;
            /**
             * The time spent on bundle-loading.
             */
            duration: number;
        };
        /**
         * A value that indicates whether this blade uses Weave rendering.
         */
        isWeave?: boolean;
        /**
         * Configuration options for a ReactView.
         */
        reactView?: ReactViewConfig;
        /**
         * Configuration options for a DxView.
         */
        dxView?: DxViewConfig;
    }
    /**
     * Describes configuration options for a menu blade.
     */
    interface MenuBladeConfig {
        /**
         * Indicates whether this is a no-PDL MenuBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a tab menu blade.
     */
    interface TabMenuBladeConfig {
        /**
         * Indicates whether this is a no-PDL MenuBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a template blade.
     */
    interface TemplateBladeConfig extends ItemWithTemplate {
        /**
         * Specifies whether the blade is a parameter provider.
         */
        parameterProvider?: boolean;
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * The size of the part.  Only FullWidthFitHeight and FitToContainer are valid.
         */
        partSize?: MsPortalFx.Parts.PartSize;
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
        /**
         * Indicates whether this is a no-PDL TemplateBlade.
         */
        isV2?: boolean;
    }
    /**
     * Describes configuration options for a frame blade.
     */
    interface FrameBladeConfig {
        /**
         * Part settings to be applied to the virtual part
         */
        partState?: PartStateDefinition;
    }
    /**
     * Configuration options for a ReactView.
     */
    interface ReactViewConfig {
    }
    /**
     * Configuration options for a DxView.
     */
    interface DxViewConfig {
        /**
         * The dx view runtime extension.
         */
        runtimeExtension: string;
    }
    /**
     * Defines the attributes for a toolbar.
     */
    interface ToolbarDefinition {
        /**
         * The source for the toolbar view model.
         */
        source: InputBinding;
    }
    /**
     * Definition of a action bar instance.
     */
    interface ActionBarDefinition {
        /**
         * Name of this action bar instance.
         */
        name?: string;
        /**
         * The view model locator of the action bar instance.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The kind of action bar.
         */
        actionBarKind?: MsPortalFx.Extension.ActionBarKind;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a property on some other view model.
         */
        source?: InputBinding;
        /**
         * If given, specifies the view model associated with the action bar.
         * This is used when referencing the view model as a standalone item (not a property on some other view model).
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the action bar.
         */
        bindings?: InputBinding[];
    }
    /**
     * Definition for a lens.
     */
    interface LensDefinition {
        /**
         * Name of the lens.
         */
        name?: string;
        /**
         * Optional title to be displayed in the lens.
         */
        title?: string;
        /**
         * Part instances contained on the lens.
         */
        partInstances?: PartInstanceDefinition[];
        /**
         * Checks if it is a summary lens.
         */
        isSummary?: boolean;
    }
    /**
     * The mode of the redirect part.
     */
    const enum RedirectMode {
        /**
         * It is not a redirect part.
         */
        None = 0,
        /**
         * The redirect part preserves the pinning.
         */
        Preserve = 1,
        /**
         * The part is completed deprecated.
         */
        Deprecate = 2
    }
    /**
     * Definition of a part instance.
     */
    interface PartInstanceDefinition {
        /**
         * Name of this part instance.
         */
        name?: string;
        /**
         * Reference to part type to instantiate. Either reference or inline must be declared.
         */
        reference?: PartReferenceDefinition;
        /**
         * Part definition to instantiate. Either reference or inline must be declared.
         */
        inline?: PartDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider. This information is provided here
         * so that we know whether references to external parts are parameter providers.
         */
        parameterProvider?: boolean;
        /**
         * Indicates if the part is retired.
         */
        redirectMode?: RedirectMode;
        /**
         * Some configuration options that are part type sepecific
         * This is for parts which have better perf when they can be initialized early.
         */
        options?: StringMap<any>;
    }
    /**
     * Definition of a part reference instance.
     */
    interface PartReferenceDefinition {
        /**
         * Name of the part type.
         */
        partTypeName: string;
        /**
         * Extension where part type is defined. Defaults to same extension where reference is used.
         */
        extension?: string;
        /**
         * Version of the extension.
         */
        version?: string;
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Initial size of this part newly instantiated. Defaults to 'defaultInitialSize' defined on part type.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Type of asset that this instance is bound to.
         * This is used as an override for the assetType that is used in the referenced part type.
         * The assetPropertyId cannot be overridden because that is a part implementation
         * detail.
         */
        assetType?: string;
        /**
         * The view model locator to inject as a property of the referenced part view model in order to extend it.
         */
        extenderViewModelLocator?: MsPortalFx.Extension.ViewModelLocator;
        /**
         * Name of view model to inject as a property of the referenced part view model in order to extend it.
         */
        extenderViewModel?: string;
    }
    /**
     * The definition of the part gallery info
     */
    interface PartGalleryInfoDefinition {
        /**
         * The text of the part on the part gallery.
         */
        title: string;
        /**
         * The category that the part belongs to.
         */
        category?: string;
        /**
         * Part description
         */
        description?: string;
        /**
         * The thumbnail for the part on the part gallery.
         */
        thumbnail?: Base.Image;
        /**
         * Gets the selectable path to trigger auto configuration.
         */
        autoConfigSelectablePath?: string;
        /**
         * The feature values used to conditionally show the part in the gallery.
         */
        feature?: string;
    }
    /**
     * The definition of the part input.
     */
    interface InputDefinition {
        /**
         * The name of the input.
         */
        name: string;
        /**
         * The type of the input.
         */
        type?: string;
        /**
         * Indicates if the input is optional.
         */
        optional?: boolean;
        /**
         * Indicates if the input is the asset id.
         */
        isAssetId?: boolean;
    }
    /**
     * Definition of a part type.
     */
    interface PartTypeDefinition extends PartDefinition {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * The view model locator of the Part.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
        /**
         * Reference to part type to instantiate.
         */
        reference?: PartReferenceDefinition;
        /**
         * Specifies whether or not the part acts as a parameter provider.
         */
        parameterProvider?: boolean;
        /**
         * If the Part uses the @Filterable decorator, these are the filters supported statically by the Part.
         */
        filters?: DashboardFilter[];
        /**
         * Indicates whether this Part supports filtering.
         */
        supportsFiltering?: boolean;
        /**
         * Informs the shell to always invoke onClick and ignore the associated deepLink
         * for parts pinned to a dashboard
         */
        ignorePinnedDeepLink?: boolean;
    }
    /**
     * If a Part uses the @Filterable decorator, this is a representation of a filter supported statically by the Part.
     */
    interface DashboardFilter {
        /**
         * The kind of the filter.
         */
        filterKind: MsPortalFx.Extension.FilterKind;
        /**
         * If the filter is extension-defined, this is an id that identifies the filter.
         */
        filterId?: string;
    }
    interface ItemWithTemplate {
        /**
         * Key to the HTML template used by the item.
         */
        htmlTemplate?: string;
        /**
         * The HTML template used by the item. This is preferred. If not specified,
         * the htmlTemplate key is used to get it from the global list of templates.
         */
        htmlTemplateInline?: HtmlTemplateDefinition;
    }
    /**
     * Definition for a part.
     */
    interface PartDefinition extends AssetInstanceDefinition, CommandContainerDefinition, ItemWithTemplate {
        /**
         * Name of the viewmodel to use.
         */
        viewModel?: string;
        /**
         * The view model locator of the view model.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * Default template for this part.
         */
        partKind?: Parts.PartKind | number;
        /**
         * View model properties that part can declare input bindings for.
         */
        inputs?: string[];
        /**
         * Input bindings for the view model of the part.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade(s) that will be created based on this part.
         */
        details?: DetailsDefinition[];
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
        /**
         * The part initial width in grid steps if the initialSize is PartSize.Custom.
         */
        initialWidth?: number;
        /**
         * The part initial height in grid steps if the initialSize is PartSize.Custom.
         */
        initialHeight?: number;
        /**
         * Optional. Initial size of this part when rendered in a larger context.
         * This size is applied when the larger context is first rendered. If no large size is provided, then conserve the initial size.
         */
        largeInitialSize?: Parts.PartSize;
        /**
         * Sizes supported by a custom part.  Ignored for parts that are not PartKind.Custom.
         */
        supportedSizes?: Parts.PartSize[];
        /**
         * The resize mode for this this part. Ignored for parts that are not PartKind.Custom.
         */
        resizeMode?: Parts.ResizeMode;
        /**
         * Properties in viewmodel to save in viewstate.
         */
        viewStateProperties?: string[];
        /**
         * The type of edit scope to created for the when the tile is put on the start board. The id of the created
         * edit scope will be passed to the part as a property named 'editScopeId'.
         */
        editScopeType?: string;
        /**
         * Strategies to save view model properties in user settings.
         */
        partState?: PartStateDefinition;
        /**
         * Optional. Whether the part can use old versions of inputs. Default is false.
         *
         * Old versions of inputs might be present if the part was pinned/cloned and the input properties changed in PDL.
         */
        canUseOldInputVersions?: boolean;
        /**
         * The permissions for the part.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * Specifies whether this part and its parent blade share the same view model.
         */
        shareVmWithParentBlade?: boolean;
        /**
         * Optional part options.
         */
        options?: StringMap<any>;
        /**
         * List of style sheet contents defined by the extension.
         */
        styleSheets?: StyleSheetDefinition[];
        /**
         * Indicates whether the FX is to apply default padding to the content area of the Part.
         */
        noFxContentPadding?: boolean;
        /**
         * List of external domains that are allowlisted for usage in links without redirecting to a confirmation page.
         */
        trustedLinkedDomains?: string[];
    }
    /**
     * Definition for strategies to save view model properties in user settings.
     */
    interface PartStateDefinition {
        /**
         * Property names whose values are saved for each inputs identity.
         */
        inputIdentityProperties?: string[];
        /**
         * Properties whose values are saved to a user defined key.
         */
        sharedProperties?: PartSharedStateDefinition[];
    }
    /**
     * Definition for part properties that get saved to settings with a user defined key.
     */
    interface PartSharedStateDefinition {
        /**
         * Property name to save.
         */
        property: string;
        /**
         * User setting key to use when saving value.
         */
        key: string;
    }
    /**
     * The definition of the default blade action.
     */
    interface DefaultBladeAction {
        /**
         * The name of the part that owns default blade action.
         */
        partName: string;
        /**
         * The name of the default action
         */
        actionName: string;
    }
    /**
     * Definition for how detail blades should be open.
     */
    interface DetailsDefinition {
        /**
         * The name of the details definition.
         */
        name?: string;
        /**
         * Name of details blade to open. Undefined if selection implements DynamicSelection.
         */
        blade?: string;
        /**
         * Name of extension of the details blade to open. Undefined if selection implements DynamicSelection.
         */
        bladeExtension?: string;
        /**
         * Whether multiple blades should be open.
         */
        isMultiple?: boolean;
        /**
         * Input bindings that trigger the opening of detail blade.
         */
        invocationInputArguments?: InputBinding[];
        /**
         * location of selectable or selectable set in the view model that will trigger
         * opening the blade.   If this is omitted then container.selectable is used.
         */
        selectablePath?: string;
        /**
         * Bindings to populate the selection value that is passed to the blade.
         * This is only applicable to the invocationInputArguments generated by the shell.
         * This feature is used when explicit invocation input arguments are not provided.
         */
        selectableBindings?: InputBinding[];
        /**
         * Additional input bindings for the view model of the details blade.
         */
        additionalInputArguments?: InputBinding[];
        /**
         * Output bindings between the detail blade and the part's view model.
         */
        outputArguments?: InputBinding[];
        /**
         * The parameter collector model associated with the blade action, if any.
         */
        parameterCollector?: string;
        /**
         * Flag indicating if this blade action starts a sub journey.
         */
        asSubJourney?: boolean;
        /**
         * Gets or sets if the blade will be opened in the context pane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    interface ActivationStyle {
        /**
         * The width of the curent blade when it activates a detail blade.
         */
        width?: MsPortalFx.Blades.BladeWidth;
    }
    /**
     * Definition for an input of a part/blade/command.
     */
    interface InputBinding {
        /**
         * Name of part's view model property.
         */
        property?: string;
        /**
         * Specifies from where to acquire individual values for the array-typed input property on the part's view
         * model.
         */
        valuesFrom: Reference[];
        /**
         * In binding scenarios that distinguish between required and optional parameters,
         * such as part binding, indicates whether this binding parameter is optional. In
         * other scenarios it should not be true.
         */
        optional?: boolean;
        /**
         * Whether this input is part of a set that uniquely identifies the values.
         */
        isIdentityInput?: boolean;
    }
    /**
     * Describes a reference to property on a part or a blade's model.
     */
    interface Reference {
        /**
         * Specifies the type of the reference.
         */
        referenceType: ReferenceType;
        /**
         * Refers to the property on the source's model.
         */
        property: string;
        /**
         * When "referenceType" is "Part", names the part that is being referenced.  If not supplied, the part is
         * determined implicitly from part context in which the reference is used.
         */
        part?: string;
        /**
         * When "referenceType" is "Command", names the blade command that is being referenced.
         */
        bladeCommand?: string;
        /**
         * When "referenceType" is "Command", names the part command that is being referenced.
         */
        partCommand?: string;
        /**
         * When "referenceType" is "Constant", the value to use as the source value of binding.
         */
        constantValue?: any;
    }
    interface CommandExternalReference {
        /**
         * Command type defined in the commands catalog.
         */
        commandType: string;
        /**
         * Name of the extension that defines the commands catalog.
         *   Undefined to assume the same extension.
         */
        extension?: string;
    }
    interface CommandDefinition extends AssetInstanceDefinition {
        /**
         * Identifier for the command.
         */
        name?: string;
        /**
         * The view model locator of the blade.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The command text.
         */
        text?: string;
        /**
         * View model for the command.
         */
        viewModel?: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
        /**
         * Defines the detail blade that can be opened by this command
         */
        details?: DetailsDefinition;
        /**
         * The permissions for the command.
         */
        permissions?: Array<Permission | PermissionSet>;
        /**
         * The kind of the command.
         */
        commandKind?: CommandKind;
        /**
         * Reference to a command defined in the commands catalog of an extension.
         */
        reference?: CommandExternalReference;
    }
    /**
     * The server event that maps to this notification.
     */
    interface ServerEvent {
        /**
         * The event source.
         */
        source: string;
        /**
         * The event operation.
         */
        operation: string;
    }
    /**
     * The notification message.
     */
    interface NotificationMessage {
        /**
         * The message type.
         */
        type: NotificationMessageType;
        /**
         * The notification status.
         */
        status: string;
        /**
         * The notification substatus.
         */
        subStatus?: string;
        /**
         * The title to show for the notification.
         */
        title: string;
        /**
         * The descriptive message to show for the notification.
         */
        message: string;
        /**
         * The optional asset type associated with the notification message.
         */
        assetType?: string;
    }
    /**
     * Definition for the instance of an asset.
     */
    interface AssetInstanceDefinition {
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * Name of the input property that maps to the identifier of this asset.
         * Required if 'assetType' is defined.
         */
        assetIdInputProperty?: string;
    }
    interface CommandGroupDefinition {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         */
        commands: CommandDefinition[];
    }
    interface CommandReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Input bindings for the view model of the command.
         */
        bindings?: InputBinding[];
    }
    interface CommandGroupReference {
        /**
         * Name for the command group.
         */
        name: string;
        /**
         * Commands in the command group.
         * These references exist to override command bindings.
         */
        commands: CommandReference[];
    }
    /**
     * Definition of a gallery service.
     */
    interface MarketplaceDefinition {
        /**
         * Service view model factory.
         */
        serviceViewModelLocator: ViewModelLocator;
        /**
         * Service view model name.
         */
        serviceViewModel: string;
    }
    /**
     * The permission base for the permission and permission set classes.
     */
    interface PermissionBase {
        /**
         * The type of the permission.
         */
        permissionType: PermissionType;
    }
    /**
     * Defines the permission type used by the permission base to describe the type of permission.
     */
    const enum PermissionType {
        /**
         * The permission is a permission object.
         */
        Permission = 0,
        /**
         * The permission is a permission set (collection of permissions).
         */
        PermissionSet = 1
    }
    /**
     * Permission used on part, command and blade.
     */
    interface Permission extends PermissionBase {
        /**
         * The optional extension name for the asset type for the action.
         */
        extensionName?: string;
        /**
         * The the asset type for the action.
         */
        assetType: string;
        /**
         * The reference for the asset id for the action.
         */
        assetId: AssetIdSource;
        /**
         * The action required for the permission.
         */
        action: string;
    }
    /**
     * Permission set used on part, command and blade.
     */
    interface PermissionSet extends PermissionBase {
        /**
         * The set requirement for the set.
         */
        requirement: SetRequirement;
        /**
         * The permissions for the set.
         */
        permissions: Array<Permission | PermissionSet>;
    }
    /**
     * Describes a asset ID source reference for a permission.
     */
    interface AssetIdSource {
        /**
         * Specifies the type of the reference.
         */
        sourceType: AssetIdSourceType;
        /**
         * The name of the property for the asset ID.
         */
        property: string;
        /**
         * When the source type is "FromProvider" or "FromSourceProvider", this is the key to pass to the property
         * provider along with the inputs.
         */
        providerKey?: string;
    }
    /**
     * Points to a knockout HTML fragment which functions as a extension html template.
     */
    interface HtmlTemplateDefinition {
        /**
         * The file path/name which this template was defined in
         */
        file: string;
        /**
         * The template content
         */
        content: string;
    }
    /**
     * Points to a set of CSS styles.
     */
    interface StyleSheetDefinition {
        /**
         * The file path/name which this style sheet was defined in.
         */
        file: string;
        /**
         * The style sheet content.
         */
        content: string;
    }
}

// FILE: MsPortalFx\Extension\Extension.Manifest.d.ts
declare module FxImpl {
    /**
     * The environment information for an asset type or kind (base).
     */
    interface ConfigAssetTypeOrKindOverride {
        /**
         * The options for the asset type of kind (overrides PDL options).
         */
        readonly options?: string | number;
        /**
         * The flag to hide (or show) the browse info box (overrides PDL BrowseInfoBox).
         */
        readonly hidebrowseinfobox?: boolean;
    }
    /**
     * The environment information for an asset type.
     */
    interface ConfigAssetTypeOverride extends ConfigAssetTypeOrKindOverride {
        /**
         * The environment information for any kinds attached to the asset type.
         */
        readonly kinds?: ReadonlyStringMap<ConfigAssetTypeOrKindOverride>;
        /**
         * This environment information for feature card options attached to the asset type.
         */
        readonly featureCardOptions?: ReadonlyArray<ConfigAssetTypeFeatureCardOptions>;
    }
    /**
     * The environment information for an asset type's feature card options.
     */
    interface ConfigAssetTypeFeatureCardOptions {
        /**
         * The ID of the feature card option.
         */
        readonly id: string;
        /**
         * The extension that owns the feature card for the option.
         */
        readonly extension: string;
        /**
         * The enabled value (boolean or experiment name) for the feature card option.
         */
        readonly enabled: boolean | string;
    }
    /**
     * The environment information for browse command bar layout.
     */
    interface ConfigAssetTypeBrowseCommandLayout {
        /**
         * The layout for non selection commands.
         */
        commands: ReadonlyArray<string>;
        /**
         * The layout for selection commands.
         */
        selectionCommands: ReadonlyArray<string>;
    }
    /**
     * The environment information for browse command bar layout experiments.
     */
    interface ConfigAssetTypeCommandsExperimentation {
        /**
         * The experiments for command bar layout for a given asset type.
         */
        experiments: ReadonlyStringMap<ReadonlyStringMap<ConfigAssetTypeBrowseCommandLayout>>;
    }
    /**
     * The environment configuration for an asset manifest.
     */
    interface EnvironmentConfigurationForAssetManifest {
        /**
         * The list of asset types that are to be hidden for the environment.
         *
         * @deprecated EnvironmentConfigurationForAssetManifest.hideAssetTypes - This has been superseded by the assetTypeOptions but we need to handle older builds of extension config.
         */
        hideAssetTypes?: ReadonlyArray<string>;
        /**
         * The list of asset types where instances are to be hidden for the environment.
         */
        assetTypeOptions?: ReadonlyStringMap<ConfigAssetTypeOverride>;
        /**
         * The map of the api versions to use for the resource types for the environment.
         */
        resourceTypeApiVersions?: ReadonlyStringMap<string>;
        /**
         * The map of asset type to ARG browse options for the environment.
         */
        argBrowseOptions?: ReadonlyStringMap<string>;
        /**
         * The map of asset type to ARG column visibility for the environment.
         * This is used to show/hide columns per environment.
         */
        showArgColumns?: ReadonlyStringMap<ReadonlyStringMap<boolean>>;
        /**
         * The map of the asset type to the list of commands to hide.
         */
        hideAssetTypeCommands?: ReadonlyStringMap<ReadonlyArray<string>>;
        /**
         * The map of the asset type to the browse command bar layout experiments.
         */
        assetTypeBrowseCommandsExperiments?: ReadonlyStringMap<ReadonlyStringMap<ConfigAssetTypeBrowseCommandLayout>>;
        /**
         * The map of the asset type to the api-versions of extensible command operations.
         */
        assetTypeExtensibleCommandsApiVersions?: ReadonlyStringMap<ReadonlyStringMap<ReadonlyStringMap<string>>>;
    }
    /**
     * The environment configuration for a feature card manifest.
     */
    interface EnvironmentConfigurationForFeatureCardManifest {
        /**
         * The list of asset types where instances are to be hidden for the environment.
         */
        featureCardOptions?: ReadonlyStringMap<{
            resourceType: string;
            enabled: (boolean | string);
        }[]>;
    }
    const enum ExtensionManifestFlags {
        /**
         * Whether the extension supports FastExtensionLoad
         */
        FastExtensionLoad = 1,
        /**
         *  Whether the extension supports Prewarming
         */
        Prewarming = 2,
        /**
         *  Whether the extension supports TestPrewarming
         */
        TestPrewarming = 4,
        /**
         *  Whether the extension uses no-code blade definition types
         */
        BladeDefinitionCodelessGen = 8,
        /**
         *  Whether the extension uses no-code part definition types
         */
        PartDefinitionCodelessGen = 16,
        /**
         *   Whether the extension uses view definition for the asset
         */
        UiDefExtension = 32
    }
    /**
     * Defines the manifests providing asset types.
     */
    interface ManifestForAssetTypes {
        /**
         * List of asset types supported by this extension.
         */
        assetTypes?: MsPortalFx.Extension.AssetTypeManifest[];
        /**
         * Determines that this extension opted into Experimentation using the ExP platform
         */
        enableExperimentation?: boolean;
        /**
         * The environment configuration for the manifest.
         */
        environmentConfiguration?: StringMap<EnvironmentConfigurationForAssetManifest>;
        /**
         * Feedback email address
         */
        feedbackEmail?: string;
        /**
         * List of flags associated with an extension
         */
        flags?: ExtensionManifestFlags;
        /**
         * If this flag is true visual artifacts are displayed in the assets, parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * List of notifications supported by this extension
         */
        notifications?: MsPortalFx.Extension.NotificationDefinition[];
        /**
         * List of notifications in the new schema supported by this extension
         */
        notifications2?: MsPortalFx.Extension.Notification[];
        /**
         * Page version of the extension.
         */
        pageVersion?: string;
        /**
         * The hash of the prewarmer script.
         */
        prewarmerScript?: [string, string];
        /**
         * The list of redirects.
         */
        redirects?: MsPortalFx.Extension.RedirectDefinition[];
        /**
         * The map of weave blades.
         */
        weaveBladesMap?: ReadonlyStringMap<FxImpl.WeaveBladeFlags>;
    }
    /**
     * Defines the manifests providing asset type browse definitions.
     */
    interface ManifestForAssetTypesBrowse {
        assetTypesBrowse?: MsPortalFx.Extension.AssetTypeBrowseManifest[];
    }
    /**
     * Defines the manifests providing asset type browse definitions.
     */
    interface ManifestForFeatureCard {
        /**
         * List of feature card manifests.
         */
        featureCards?: MsPortalFx.Extension.FeatureCardManifest[];
        /**
         * The environment configuration for the manifest.
         */
        featureCardEnvironmentConfiguration?: StringMap<EnvironmentConfigurationForFeatureCardManifest>;
    }
    /**
     * Defines the manifests providing asset type menu definitions.
     */
    interface ManifestForAssetTypesMenu {
        assetTypesMenu?: MsPortalFx.Extension.AssetTypeMenuManifest[];
    }
    /**
     * Defines the manifests providing gallery parts.
     */
    interface ManifestForGalleryParts {
        /**
         * The list of gallery parts.
         */
        galleryParts?: MsPortalFx.Extension.GalleryPartManifest[];
    }
    interface ManifestForCreateUiDefinition {
        /**
         * The map of assets to create ui definition uris.
         */
        createUiDefinition?: ReadonlyStringMap<string>;
    }
    /**
     * Defines the manifests providing survey definitions.
     */
    interface ManifestForSurvey {
        surveys?: ReadonlyArray<MsPortalFx.Extension.SurveyManifest>;
    }
    interface ManifestForViewDefinition {
        /**
         * The map of assets to view definition uris.
         */
        viewDefinition?: ReadonlyStringMap<string>;
    }
    /**
     * Defines the manifest for an extension's per-environment configuration.
     */
    interface ManifestForExtensionConfiguration {
        /**
         * The map of configurations.
         */
        extensionConfiguration?: ReadonlyStringMap<any>;
    }
    /**
     * Defines the manifest for an extensions declarative file definitions.
     */
    interface ManifestForDeclarativeDefinitions {
        /**
         * The map of assets to declarative file definitions.
         */
        declarativeDefinitions?: ReadonlyStringMap<ManifestForDeclarativeDefinition>;
    }
    /**
     * Defines the manifest for a declarative file definition.
     */
    interface ManifestForDeclarativeDefinition {
        /**
         * The kind of dx view.
         */
        kind: string;
        /**
         * The file path to the configuration of the dx view.
         */
        path: string;
        /**
         * Is dx view pinnable.
         */
        pinnable?: boolean;
    }
    /**
     * Defines the manifest for source file mappings.
     */
    interface ManifestForSourceMappings {
        /**
         * The map of type to instance to source files.
         */
        sourceMappings?: ManifestForSourceMappingType;
    }
    /**
     * Defines the manifest for source file mapping types.
     */
    interface ManifestForSourceMappingType {
        /**
         * The map of asset types to source files.
         */
        assetTypes?: ManifestForSourceMappingDefinition[];
        /**
         * The map of declarative definitions to source files.
         */
        declarativeDefinitions?: ManifestForSourceMappingDefinition[];
    }
    /**
     * Defines the manifest for the source file mapping definition.
     */
    interface ManifestForSourceMappingDefinition {
        /**
         * The name of the item.
         */
        name: string;
        /**
         * The source path of the item.
         */
        sourcePath?: string;
    }
}
declare module MsPortalFx.Extension {
    /**
     * String map that maps the value specified in the feature flag to the enum.
     */
    const ArgBrowseFeatureValueToEnumMap: StringMap<ArgBrowseOptions>;
    /**
     * String map that maps the value specified in the feature flag to the enum.
     */
    const RemappedArgBrowseFeatureValueToEnumMap: StringMap<{
        mappedOption: ArgBrowseOptions;
        mappedOptionString: string;
    }>;
    /**
     * String map that maps the value specified in the feature flag to the enum for ARM fallback.
     */
    const ArgBrowseFeatureValueToFallbackEnumMap: StringMap<ArmBrowseOptions>;
    const enum NotificationMessageType {
        /**
         * Indicates an error message.
         */
        Error = 0,
        /**
         * Indicates a warning message.
         */
        Warning = 1,
        /**
         * Indicates a success message.
         */
        Success = 2,
        /**
         * Indicates a progress message.
         */
        Progress = 3,
        /**
         * Indicates an info message.
         */
        Info = 4
    }
    /**
     * Manifest for an extension.
     */
    interface Manifest extends FxImpl.ManifestForAssetTypes, FxImpl.ManifestForAssetTypesBrowse, FxImpl.ManifestForAssetTypesMenu, FxImpl.ManifestForFeatureCard, FxImpl.ManifestForCreateUiDefinition, FxImpl.ManifestForGalleryParts, FxImpl.ManifestForSurvey, FxImpl.ManifestForViewDefinition, FxImpl.ManifestForDeclarativeDefinitions, FxImpl.ManifestForExtensionConfiguration, FxImpl.ManifestForSourceMappings {
    }
    interface RedirectDefinition {
        /**
         * The type of redirect.
         */
        type: RedirectType;
        /**
         * The extension of the blade/part to redirect to.
         */
        toExtension?: string;
        /**
         * The extension of the blade/part to redirect from.
         */
        fromExtension?: string;
        /**
         * Specifies that an ExP feature gate of the form "RedirectBlade-{sourceExtensionName}-{sourceBladeName}" is to be used to control whether this redirect is honored for a customer session.
         * {@link https://aka.ms/IbizaExperimentation Ibiza Experimentation }
         */
        useFlighting?: boolean;
    }
    interface BladeRedirectDefinition extends RedirectDefinition {
        /**
         * Can can only be MenuBlade or ResourceMenuBlade for blade redirects
         */
        type: RedirectType.ResourceMenuBlade | RedirectType.Blade;
        /**
         * The name of the blade to redirect.
         */
        fromBlade: string;
        /**
         * The name of the blade to redirect to.
         */
        toBlade?: string;
        /**
         * Specifies that an ExP feature gate of the form "RedirectBlade-{sourceExtensionName}-{sourceBladeName}" is to be used to control whether this redirect is honored for a customer session.
         * {@link https://aka.ms/IbizaExperimentation Ibiza Experimentation }
         */
        useFlighting?: boolean;
    }
    interface PartRedirectDefinition extends RedirectDefinition {
        /**
         * Can can only be PartType or PartInstance for part redirects
         */
        type: RedirectType.PartType | RedirectType.PartInstance;
        /**
         * The part name which is being redirected from
         */
        fromPart: string;
        /**
         * Blade name if the part is a instance in a blade
         */
        fromBlade?: string;
        /**
         * Lens name if the part is a instance in a blade
         */
        fromLens?: string;
        /**
         * The part name which is being redirected to
         */
        toPart: string;
        /**
         * Optional bindings used to replace the previous part bindings
         */
        bindings?: MsPortalFx.Extension.InputBinding[];
    }
    interface AssetRedirectDefinition extends RedirectDefinition {
        /**
         * Redirect type can only be Asset
         */
        type: RedirectType.Asset;
        /**
         * Name of the asset we are redirecting from
         */
        fromAsset: string;
        /**
         * Optional, the name of the kind we are redirecting from
         */
        fromKind?: string;
        /**
         * Name of the asset we are redirecting to
         */
        toAsset: string;
        /**
         * Optional, the name of the we are redirecting too
         */
        toKind?: string;
    }
    /**
     * Asset type manifest for an extension.
     */
    interface AssetTypeManifest {
        /**
         * The name of the asset type.
         */
        name?: string;
        /**
         * The entry point of the view model.
         */
        viewModelLocator?: ViewModelLocator;
        /**
         * The name of the extension that contains the view model.
         */
        viewModelExtensionName?: string;
        /**
         * The singular display name of the asset type.
         */
        singularDisplayName?: string;
        /**
         * The plural display name of the asset type.
         */
        pluralDisplayName?: string;
        /**
         * The lowercase singular display name of the asset type.
         */
        lowerSingularDisplayName?: string;
        /**
         * The lowercase plural display name of the asset type.
         */
        lowerPluralDisplayName?: string;
        /**
         * The service display name of the asset type.
         */
        serviceDisplayName?: string;
        /**
         * The contracts flag for which contracts the asset view model supports.
         */
        contracts?: MsPortalFx.Assets.AssetContracts;
        /**
         * The name of the asset type view model associated with this asset type.
         */
        viewModel?: string;
        /**
         * The icon of the asset type.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The part associated with this asset.
         */
        partName?: string;
        /**
         * The extension where the external part is located
         */
        partExtensionName?: string;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the functionality is preview
         */
        isPreview?: boolean;
        /**
         * If this flag is true visual artifacts are displayed in the asset's parts and blades to indicate the asset type is disabled by policy
         */
        isDisabled?: boolean;
        /**
         * The blade associated with the asset.
         */
        bladeName?: string;
        /**
         * The blade extension associated with the asset.
         */
        bladeExtensionName?: string;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        options?: MsPortalFx.Extension.AssetTypeOptions;
        /**
         * Optional browse type which indicates the type of browse for the asset type.
         */
        browseType?: BrowseType;
        /**
         * Optional 'private' browse flag which indicates to exclude this asset from the browse UX.
         *
         * @deprecated AssetTypeManifest.privateBrowse 04/30/2020 - This has been superseded by options. Please use the 'options' property and the
         * AssetTypeOptions flags.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        privateBrowse?: boolean;
        /**
         * Optional link URI for browse associated with the asset using a link to an external source.
         */
        browseLinkUri?: string;
        /**
         * Optional browse flag which indicates that if RDFE access is not available to not show this asset from the browse UX.
         */
        browseRequiresRdfe?: boolean;
        /**
         * Optional browse flag which are the browse requirements.
         */
        browseRequirements?: MsPortalFx.Assets.BrowseRequirements;
        /**
         * Optional resource type definition associated with the asset.
         */
        resourceType?: ResourceTypeDefinition;
        /**
         * The service name for the property provider service associated with the asset.
         */
        propertyProviderServiceViewModelLocator?: MsPortalFx.Extension.ViewModelLocator;
        /**
         * The service name for the property provider service associated with the asset.
         */
        propertyProviderServiceViewModel?: string;
        /**
         * The type of the asset id.
         */
        assetIdType?: string;
        /**
         * The create blade name.
         */
        noPdlCreateBlade?: string;
        /**
         * The name of the extension with the create blade.
         */
        noPdlCreateExtension?: string;
        /**
         * The parameters to open the create blade.
         */
        noPdlCreateParameters?: any;
        /**
         * The blade to launch after initiating creation of an instance of the asset.
         */
        postCreateBlade?: Common.Assets.PostCreateBladeReference;
        /**
         * The market place item.
         */
        marketplaceItemId?: string;
        /**
         * The market place category.
         */
        marketplaceMenuItemId?: string;
        /**
         * The static overview menu item for the asset type.
         */
        staticOverview?: StaticOverviewDefinition;
        /**
         * The list of keywords.
         * NOTE: comma separated list.
         */
        keywords?: string;
        /**
         * The service menu blade reference.
         */
        serviceMenuBlade?: string;
        /**
         * The service menu blade reference extension.
         */
        serviceMenuBladeExtension?: string;
        /**
         * The service menu ID.
         */
        serviceMenuItemId?: string;
        /**
         * A brief description of the asset type. Max length is 350 characters.
         */
        description?: string;
        /**
         * A link which points to learn more content of the asset type.
         */
        links?: LinkDefinition[];
        /**
         * Optional ARG browse option on which experience should be shown for the asset type.
         */
        armBrowseOption?: ArmBrowseOptions;
        /**
         * Optional ARM browse option on which experience should be shown for the asset type.
         */
        argBrowseOption?: ArgBrowseOptions;
        /**
         * Optional ARG column options to turn on / off columns per environment.
         */
        showArgColumns?: ReadonlyStringMap<boolean>;
        /**
         * Optional list of commands to be hidden for the asset type.
         */
        hiddenCommands?: ReadonlyArray<string>;
        /**
         * This is an internal-only flag to pass config information to the browse query manifest to override this flag.
         */
        hideBrowseInfoBox?: boolean;
        /**
         * Optional browse deep link used for browse to replace the standard browse blade launched from all services.
         */
        browseDeepLink?: string;
        /**
         * Optional map of browse commandbar layout experiments.
         */
        browseCommandExperiments?: ReadonlyStringMap<FxImpl.ConfigAssetTypeBrowseCommandLayout>;
        /**
         * The optional map of command ids to api-versions per resource type for a given asset type.
         * This is used to override default api-versions in extensible ARM bulk command definitions.
         */
        extensibleCommandsApiVersions?: ReadonlyStringMap<ReadonlyStringMap<string>>;
        /**
         * Optional array for feature card options for the asset type.
         */
        featureCardOptions?: ReadonlyArray<{
            readonly id: string;
            readonly extension: string;
            readonly enabled: boolean | string;
        }>;
    }
    /**
     * The resource type definition defines the resource type information for an asset type.
     */
    interface ResourceTypeDefinition {
        /**
         * The name of the resource type.
         */
        resourceTypeName: string;
        /**
         * The top level tenant alias used to communicate to ARM.  This is valid only for tenant-routing resources.
         *
         * The resource type name is the "full" resource type.  This is the full hierarchical type that is returned in
         * the ResourceType property of the results and provides a match between a resource type (and resource ID) to
         * the asset type. For a nested resource this would be:
         *      {resourceProviderNamespace}/{parentType}/{nestedType}/.../{nestedType}.
         * E.g. Microsoft.Type/Parent/Child
         *
         * The top level tenant alias is the "flat" resource type.  This is a non-hierarchical type used to enumerate
         * instances using ARM's Providers API. Your RP manifest must enable nested resources to be enumerated at the
         * top level for it to be used with the Portal FX Browse support. For more info contact your ARM partner.
         *
         * For root resource types, this would be the same as the resource type name.  For nested resource types, this
         * would be:
         *      {resourceProviderNamespace}/{nestedType}.
         * E.g. Microsoft.Type/Child
         */
        topLevelTenantAlias?: string;
        /**
         * The top level resource type alias used to communicate to ARM.  This is valid only for end-point-routing
         * resources.  See the notes for the topLevelTenantAlias for more information (same value).
         */
        topLevelResourceTypeAlias?: string;
        /**
         * The ARM API version to use for this resource type.
         * If this is not specified, the latest API version will be used from the ARM manifest file.
         */
        apiVersion?: string;
        /**
         * The routing type for the resource type.
         * If this is not specified, the 'Default' routing type will be used.
         */
        routingType?: ResourceRoutingType;
        /**
         * The optional array of kinds for this resource type.
         */
        kinds?: ResourceKindDefinition[];
        /**
         * The optional array of proxy routing filters for this resource type.
         */
        proxyRoutingFilters?: ProxyRoutingFilter[];
    }
    type ResourceKindDefinition = import("Fx/Assets").ResourceKindDefinition;
    /**
     * The Link definition defines title and url for the asset type documentation.
     */
    interface LinkDefinition {
        /**
         * The title for link.
         */
        title: string;
        /**
         * The uri for the link.
         */
        uri: string;
    }
    type StaticOverviewDefinition = import("Fx/Assets").StaticOverviewDefinition;
    interface AssetTypeMenuManifest {
        /**
         * Name of the asset type of the menu definition.
         */
        name: string;
        /**
         * The overview menu item.
         */
        overview: AssetMenuItem;
        /**
         * The menu groups.
         */
        groups: Array<AssetMenuGroup>;
        /**
         * The menu options.
         */
        options: AssetMenuOptions | AssetResourceMenuOptions;
    }
    interface MenuItemBase {
        /**
         * The id of the item.
         */
        id: string;
        /**
         * Localized display name of the item.
         */
        displayName: string;
        /**
         * Localized keywords for the item.
         */
        keywords?: string;
    }
    interface AssetMenuItem extends MenuItem, FeatureItem<AssetMenuItem> {
        /**
         * The tab items in the menu item.
         */
        readonly tabItems?: ReadonlyArray<AssetTabMenuItem>;
        /**
         * The browse resource type for the item.
         */
        readonly browseResourceType?: string;
    }
    interface AssetTabMenuItem extends TabMenuItem, FeatureItem<AssetTabMenuItem> {
    }
    /**
     * The Feature conditions used to manipulate objects with feature flags.
     */
    const enum FeatureWhen {
        /**
         * The condition is when the feature is enabled.
         */
        Enabled = "Enabled",
        /**
         * The condition is when the feature is disabled.
         */
        Disabled = "Disabled",
        /**
         * The condition is when the feature value is equal to the given value.
         */
        ValueEquals = "ValueEquals",
        /**
         * The condition is when the feature value is not equal to the given value.
         */
        ValueNotEquals = "ValueNotEquals"
    }
    /**
     * Manifest declaration for including an object based on a feature flag.
     */
    interface Feature<T> {
        /**
         * The name of the feature.
         */
        readonly name: string;
        /**
         * The condition to include the parent object.
         */
        readonly includeWhen?: FeatureWhen;
        /**
         * The value of the feature required to include the parent object.
         */
        readonly value?: string;
    }
    /**
     * Manifest declaration for replacing an object based on a feature flag.
     */
    interface FeatureReplacement<T> {
        /**
         * The name of the feature.
         */
        readonly name: string;
        /**
         * The condition to replace the parent object.
         */
        readonly replaceWhen?: FeatureWhen;
        /**
         * The value of the feature required to replace the parent object.
         */
        readonly value?: string;
        /**
         * The replacement object used to replace the parent.
         */
        readonly replacement?: T;
    }
    /**
     * Manifest declaration for applying a feature flag to an object.
     * Note: The type declaration should include 'extends T' but this isn't supported in TS
     */
    interface FeatureItem<T> {
        /**
         * The feature declaration for the item.
         */
        readonly "fx.feature"?: Feature<T> | FeatureReplacement<T>;
    }
    interface TabMenuItem extends MenuItemBase {
        /**
         * Blade name for the item.
         */
        readonly bladeName: string;
        /**
         * Optional blade extension name for the item.
         */
        readonly bladeExtensionName?: string;
        /**
         * Optional blade parameters for the item.
         */
        readonly bladeParameters?: StringMap<any>;
        /**
         * The browse resource type for the item.
         */
        readonly browseResourceType?: string;
    }
    interface MenuItem extends MenuItemBase {
        /**
         * The icon of the menu item.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * Localized tooltip for the item.
         */
        tooltip?: string;
        /**
         * Blade name for the item.
         */
        bladeName: string;
        /**
         * Optional blade extension name for the item.
         */
        bladeExtensionName?: string;
        /**
         * Optional blade parameters for the item.
         */
        bladeParameters?: StringMap<any>;
        /**
         * The tab items in the menu item.
         */
        readonly tabItems?: ReadonlyArray<TabMenuItem>;
    }
    interface AssetMenuGroup extends MenuGroup, FeatureItem<AssetMenuGroup> {
        /**
         * The items in the menu group.
         */
        readonly items: Array<AssetMenuItem>;
    }
    interface MenuGroup extends MenuItemBase {
        /**
         * The items in the menu group.
         */
        items: Array<MenuItem>;
        /**
         *  The ID for the built-in group.
         */
        referenceId?: string;
        /**
         * The elevated state of the menu group.
         */
        elevated?: boolean;
    }
    interface AssetMenuOptions extends FeatureItem<AssetMenuOptions> {
        /**
         * Enable search for the menu.
         */
        showSearch?: boolean;
    }
    interface AssetResourceMenuOptions extends MsPortalFx.Assets.ResourceMenuOptions, FeatureItem<AssetResourceMenuOptions> {
    }
    /**
     * Manifest for a notification that will be used to format notifications.
     */
    interface NotificationDefinition {
        /**
         * The notification event source for this notification.
         */
        eventSource: string;
        /**
         * The notification event type of this notification.
         */
        eventType: string;
        /**
         * The notification label for this notification.
         */
        label: string;
        /**
         * The notification message for this notification.
         * Note that this message can support format items. The notification arguments received by the server will be plugged into these items
         * Example: This is a {0} message written by {1}.
         */
        message: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
    }
    /**
     * Manifest for a notification in the new schema.
     */
    interface Notification {
        /**
         * The notification name.
         */
        name: string;
        /**
         * The notification asset type of this notification.
         */
        assetType?: string;
        /**
         * The server event that this notification maps to.
         */
        serverEvent?: ServerEvent;
        /**
         * The messages for this notification.
         */
        messages: NotificationMessage[];
    }
    /**
     * Manifest for a part instance.
     */
    interface PartInstanceManifest {
        /**
         * The name of the part instance.
         */
        name: string;
        /**
         * Default initial size of this part when instantiated. Defaults to PartSize.Normal.
         */
        initialSize?: Parts.PartSize;
    }
    /**
     * Manifest for a blade.
     */
    interface BladeManifest {
        /**
         * Name of the blade.
         */
        name: string;
        /**
         * Width of this blade when displayed.
         */
        width?: MsPortalFx.Blades.BladeWidth;
        /**
         * A list of extension name hints that are likely to be required by the blade.
         */
        extensionHints?: string[];
    }
    interface GalleryPartManifest {
        /**
         * Name of the part type.
         */
        name?: string;
        /**
         * Initial size for the part.
         */
        initialSize?: Parts.PartSize;
        /**
         * Initial width for the custom size part.
         */
        initialWidth?: number;
        /**
         * Initial height for the custom size part.
         */
        initialHeight?: number;
        /**
         * The info of the part shown in the part gallery.
         */
        partGalleryInfo?: PartGalleryInfoDefinition;
        /**
         * Type of asset that this instance is bound to.
         */
        assetType?: string;
        /**
         * The definitions of the inputs to the part.
         */
        inputDefinitions?: InputDefinition[];
    }
    type BrowseResourceSelection = import("Fx/Assets").BrowseResourceSelection;
    type ArmCommandOptionsManifest = import("Fx/Assets").ArmCommandOptionsManifest;
    type ArmCommandDefinition = import("Fx/Assets").ArmCommandDefinition;
    type AsyncOperationOptions = import("Fx/Assets").AsyncOperationOptions;
    type ConfirmationOptionsManifest = import("Fx/Assets").ConfirmationOptionsManifest;
    export import ArmStaticCommand = Common.Assets.ArmStaticCommand;
    type BladeReferenceOptions = import("Fx/Assets").BladeReferenceOptions;
    type AssetTypeCommandManifest = import("Fx/Assets").CommandManifest;
    type AssetTypeCommandSet = import("Fx/Assets").CommandSet;
    type AssetTypeBrowseManifest = import("Fx/Assets").BrowseManifest;
    type AssetTypeBrowseInfoBoxManifest = import("Fx/Assets").BrowseInfoBoxManifest;
    type AssetTypeBrowseColumnManifest = import("Fx/Assets").BrowseColumnManifest;
    type AssetTypeMergedResourceTypeManifest = import("Fx/Assets").MergedResourceTypeManifest;
    type FeatureCardManifest = import("Fx/Assets").FeatureCardManifest;
    /**
     * Contains list of tasks aka questions about tasks the extension would like to ask user in HaTs survey.
     */
    interface SurveyManifest {
        /**
         * List of tasks aka questions about tasks the extension would like to ask user in HaTs survey.
         */
        readonly tasks: ReadonlyArray<SurveyTask>;
    }
    /**
     * What each task aka question should contain about tasks the extension would like to ask user in HaTs survey.
     */
    interface SurveyTask {
        /**
         * The localized task/question the extension wants to ask user in HaTs survey.
         */
        readonly displayName: string;
        /**
         * The priority task/question the extension wants to ask user in HaTs survey.
         */
        readonly priority: number;
        /**
         * The loggable id for the localized task/question the extension wants to ask user in HaTs survey.
         */
        readonly taskKey: string;
    }
}
declare namespace MsPortalFx.Extension {
    const ArmBrowseOptions: typeof import("Fx/Assets").ArmBrowseOptions;
    type ArmBrowseOptions = import("Fx/Assets").ArmBrowseOptions;
    const ArgBrowseOptions: typeof import("Fx/Assets").ArgBrowseOptions;
    type ArgBrowseOptions = import("Fx/Assets").ArgBrowseOptions;
    const AssetTypeOptions: typeof import("Fx/Assets").AssetTypeOptions;
    type AssetTypeOptions = import("Fx/Assets").AssetTypeOptions;
    const BrowseType: typeof import("Fx/Assets").BrowseType;
    type BrowseType = import("Fx/Assets").BrowseType;
    const ResourceRoutingType: typeof Common.AssetTypes.ResourceRoutingType;
    type ResourceRoutingType = import("Fx/Assets").ResourceRoutingType;
    const ProxyRoutingFilter: typeof import("Fx/Assets").ProxyRoutingFilter;
    type ProxyRoutingFilter = import("Fx/Assets").ProxyRoutingFilter;
    const ColumnFormat: typeof import("Fx/Assets").ColumnFormat;
    type ColumnFormat = import("Fx/Assets").ColumnFormat;
    const SummaryVisualizations: typeof import("Fx/Assets").SummaryVisualizations;
    type SummaryVisualizations = import("Fx/Assets").SummaryVisualizations;
}

// FILE: MsPortalFx\Extension\FilterKind.d.ts
declare module MsPortalFx.Extension {
    const enum FilterKind {
        /**
         * The TimeRange filter.
         */
        TimeRange = 0,
        /**
         * The Equality filter.
         */
        Equality = 1,
        /**
         * The Subscription filter.
         */
        Subscription = 2,
        /**
         * The Location filter.
         */
        Location = 3,
        /**
         * The ResourceType filter.
         */
        ResourceType = 4,
        /**
         * The ResourceGroup filter.
         */
        ResourceGroup = 5
    }
}

// FILE: MsPortalFx\Extension\KindVisibility.d.ts
declare module MsPortalFx.Extension {
    const enum KindVisibility {
        /**
         * Normal visibility.
         */
        Normal = 0,
        /**
         * Hidden visibility.
         */
        Hidden = 1
    }
}

// FILE: MsPortalFx\Extension\RedirectType.d.ts
declare module MsPortalFx.Extension {
    const enum RedirectType {
        /**
         * No redirect.
         */
        None = 0,
        /**
         * Defines a redirect to a blade.
         */
        Blade = 2,
        /**
         * Defines a redirect to the resource menu blade.
         */
        ResourceMenuBlade = 3,
        /**
         * Defines a redirect from a part type to another part type
         */
        PartType = 4,
        /**
         * Defines a redirect from a part instance on a blade to a part type
         */
        PartInstance = 5,
        /**
         * Defines a redirect to a asset
         */
        Asset = 6
    }
}

// FILE: MsPortalFx\Extension\ReferenceType.d.ts
declare module MsPortalFx.Extension {
    const enum ReferenceType {
        /**
         * The reference is to a view model property on a part.
         */
        Part = 0,
        /**
         * The reference is to an input belonging to the enclosing blade.
         */
        BladeInput = 1,
        /**
         * The reference is to a view model property on a blade's action bar.
         */
        BladeActionBar = 2,
        /**
         * The reference is to a property on a blade's extension view model.
         */
        BladeProperty = 3,
        /**
         * The reference is to a view model property on a command.
         */
        Command = 4,
        /**
         * The reference is a constant value.
         */
        Constant = 5,
        /**
         * The reference is to a property on a a item that is currently selected
         */
        SelectedItem = 6,
        /**
         * The reference is to a view model property on the part adapter.
         */
        Adapter = 7,
        /**
         * The reference is to a property on the containing Dashboard.
         */
        Dashboard = 8,
        /**
         * The reference is to an input of the part adapter.
         */
        AdapterInput = 9,
        /**
         * The reference is to the parameters passed to an AzBlade, made available to the AzBlade's virtual Part.
         */
        _Internal_AzBladeParameters = 999
    }
}

// FILE: MsPortalFx\Extension\Runtime.d.ts
declare module FxImpl {
    function toAbsoluteUrisRequire(requireConfig: RequireConfig): void;
    module Extension {
        import FxBase = MsPortalFx.Base;
        import Rpc = FxImpl.Rpc;
        import FxAssets = MsPortalFx.Assets;
        import FxExtension = MsPortalFx.Extension;
        import FuncEndPointDefinition = Rpc.FuncEndPointDefinition;
        import Security = FxBase.Security;
        import Settings = MsPortalFx.Settings;
        /**
         * The delete/put resource input for the ame confirmation dialog.
         */
        interface DeletePutResource {
            /**
             * The resource id.
             */
            readonly resourceId: string;
            /**
             * The http method operation.
             */
            readonly httpMethod: string;
        }
        const invokeAmeConfirmationDialogEndPoint: Rpc.FuncEndPointDefinition<DeletePutResource[], boolean>;
        const getExtensionGalleryService: Rpc.ProxiedObjectTypeDefinition<void, any>;
        const getBladeDefinitionEndPoint: Rpc.FuncEndPointDefinition<string, FxExtension.BladeDefinition>;
        const getPartDefinitionEndPoint: Rpc.FuncEndPointDefinition<string, FxExtension.PartTypeDefinition>;
        const downloadBladeBundlesEndPoint: Rpc.ActionEndPointDefinition<string>;
        /**
         * Parameters needed to load a ReactView's model
         */
        interface ReactModelParams {
            /**
             * ReactView's model name
             */
            modelName: string;
            /**
             * Id of the port used to communicate with ReactView iframe
             */
            portId: number;
            /**
             * Parameters for the ReactView.  Used to initialize the model early.
             */
            parameters: ReadonlyStringMap<unknown>;
        }
        /**
         * Parameters needed to dispose a ReactView's model
         */
        interface DisposeReactModelParams {
            /**
             * ReactView's model name
             */
            modelName: string;
            /**
             * Id of the port used to communicate with ReactView iframe
             */
            portId: number;
            /**
             * If model's module should be unloaded
             */
            unrequire: boolean;
        }
        interface GetManifestParams {
            extensionName: ExtensionNames;
            propertyName: keyof MsPortalFx.Extension.Manifest;
        }
        /**
         * Module used by CreateUiDef extension.
         */
        module CreateUiDef {
            /**
             * Parameters needed to read extension's per-environment configurations.
             */
            interface GetExtensionConfigParams {
                /**
                 * Name of the extension for which the configurations are to be read.
                 */
                readonly extensionName: string;
            }
            /**
             * Invoked from CreateUiDef Extension to read partner extension's per-environment configurations.
             */
            const getExtensionConfigurationEndPoint: Rpc.FuncEndPointDefinition<GetExtensionConfigParams, any>;
            /**
             * Invoked from CreateUiDef Extension to register sideloaded test extensions.
             */
            const registerTestExtensionsEndPoint: Rpc.FuncEndPointDefinition<TestExtensionMetadata[], void>;
            /**
             * Invoked from CreateUiDef Extension to unregister sideloaded test extensions.
             */
            const unregisterTestExtensionsEndPoint: Rpc.FuncEndPointDefinition<TestExtensionMetadata[], void>;
            /**
             * Invoked from CreateUiDef Extension to read sideloaded test extensions.
             */
            const listTestExtensionsEndPoint: Rpc.FuncEndPointDefinition<void, TestExtensionMetadata[]>;
        }
        interface ExtensionRegistration {
            baseUri: string;
            resourceId?: string;
        }
        interface CatalogApiCacheContent {
            createMenu: string;
            portal: ReadonlyStringMap<string>;
            curationData: string;
        }
        interface TestExtensionMetadata {
            readonly name: string;
            readonly uri: string;
            readonly armResourceId?: string;
        }
        const getReactModelEndPoint: Rpc.ActionEndPointDefinition<ReactModelParams>;
        const disposeReactModelEndPoint: Rpc.ActionEndPointDefinition<DisposeReactModelParams>;
        const getCommandsDefinitionEndPoint: Rpc.FuncEndPointDefinition<void, FxExtension.CommandsDefinition>;
        const pingEndPoint: Rpc.FuncEndPointDefinition<void, void>;
        const getLastResourceIdInJourneyEndPoint: Rpc.FuncEndPointDefinition<void, string>;
        /**
         * The dynamic dx blade reference options for the getDynamicDxBladeReference API.
         */
        interface DynamicDxBladeReferenceOptions {
            /**
             * The blade name suffix for the view.
             */
            bladeNameSuffix: string;
        }
        /**
         * The dynamic dx blade reference for getDynamicDxBladeReference() API.
         */
        interface DynamicDxBladeReference {
            /**
             * The blade name.
             */
            readonly bladeName: string;
            /**
             * The extension name for the blade
             */
            readonly extensionName: string;
        }
        interface GetAuthorizationTokenOptions {
            /**
             * The resource name.
             */
            readonly resourceName?: string;
            /**
             * The content of the WWW-Authenticate header returned on unauthorized responses due to continuous access evaluation policy revocations.
             * Includes the base64-encoded, serialized set of claims needed in the resulting token.
             */
            readonly wwwAuthHeader?: string;
            /**
             * The name of the stamp from which to load the extension's authorization configuration.
             */
            readonly authConfigStamp?: string;
            /**
             * The AAD resource URL or GUID.
             */
            readonly audience?: string;
            /**
             * Indicates if the extension is a third party extension.
             */
            readonly isThirdPartyExtension?: boolean;
            /**
             * The tenant ID to use when requesting a token. If not specified, the tenant ID of the tenant the user is currently signed into is used by default.
             */
            readonly tenantId?: string;
        }
        interface GetAuthorizationTokenOptionsExtended extends GetAuthorizationTokenOptions {
            readonly isBackground: boolean;
            readonly skipCache?: boolean;
        }
        /**
         * The parameters required to make a PoP token request.
         */
        interface PopTokenData {
            /**
             * The scopes required on the PoP token.
             */
            readonly scopes: string[];
            /**
             * The all-caps name of the HTTP method of the request that will use the signed token (GET, POST, PUT, etc.)
             */
            readonly resourceRequestMethod: string;
            /**
             * The URL of the protected resource for which the access token is being issued
             */
            readonly resourceRequestUri: string;
            /**
             * A stringified JSON object containing custom client claims to be added to the PoP token.
             */
            readonly shrClaims?: string;
            /**
             * A server-generated, signed timestamp that is Base64URL encoded as a string. This nonce is used to
             * mitigate clock-skew and time-travel attacks meant to enable PoP token pre-generation.
             */
            readonly shrNonce?: string;
        }
        let getCatalogApiCacheContentEndPoint: Rpc.FuncEndPointDefinition<void, CatalogApiCacheContent>;
        let getExtensionRegistrationEndPoint: Rpc.FuncEndPointDefinition<ExtensionNames, ExtensionRegistration>;
        let getManifestEndPoint: Rpc.FuncEndPointDefinition<GetManifestParams, any>;
        let getAuthorizationTokenEndPoint: Rpc.FuncEndPointDefinition<GetAuthorizationTokenOptionsExtended, Security.GetAuthorizationTokenResponse>;
        let getPopTokenEndPoint: Rpc.FuncEndPointDefinition<PopTokenData, Security.GetAuthorizationTokenResponse>;
        let getUserInfoEndPoint: typeof import("FxInternal/RpcEndPointsCore").getUserInfoEndPoint;
        let getSharedSettingsEndPoint: Rpc.FuncEndPointDefinition<any, Settings.SharedSettings>;
        let getLocalGalleryPackagesEndpointsDefinition: Rpc.FuncEndPointDefinition<void, string[]>;
        let getLocalGalleryPackagesEndpointDefinition: Rpc.FuncEndPointDefinition<void, string>;
        interface HasPermissionsToShellArgs {
            entityId: string;
            requestedActions: string[];
        }
        let hasPermissionsToShell: Rpc.FuncEndPointDefinition<HasPermissionsToShellArgs, string | boolean>;
        /**
         * @deprecated MsPortalFx.Extension.Runtime.FxImpl.Extension.mapAssetIdToResourceIdEndPoint 2020/04/30 - All asset ID's should be resource ID's and this should no longer be used.
         * This was exposed by the mapAssetIdToResourceId in Assets.ts which is also deprecated. Since all
         * asset ID's are now resource ID's, just use the resource ID directly.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        let mapAssetIdToResourceIdEndPoint: Rpc.FuncEndPointDefinition<FxAssets.AssetTriplet, string>;
        let mapResourceIdToAssetIdEndPoint: Rpc.FuncEndPointDefinition<string, FxAssets.AssetTriplet>;
        interface MapAssetIdToDynamicSelectionArgs {
            assetId: FxAssets.AssetTriplet;
            forceBladeSelection: boolean;
        }
        let mapAssetIdToDynamicSelectionAndIconEndPoint: Rpc.FuncEndPointDefinition<MapAssetIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
        interface MapResourceIdToDynamicSelectionArgs {
            resourceId: string;
            forceBladeSelection: boolean;
        }
        let mapResourceIdToDynamicSelectionAndIconEndPoint: Rpc.FuncEndPointDefinition<MapResourceIdToDynamicSelectionArgs, FxAssets.DynamicSelectionAndIcon>;
        interface GetAssetTypeInformationEndPointArgs {
            extensionName: string;
            assetType: string;
        }
        let getAssetTypeInformationEndPoint: FuncEndPointDefinition<GetAssetTypeInformationEndPointArgs, FxAssets.AssetTypeInformation>;
        let getResourceTypeAssetTypeInformationEndPoint: FuncEndPointDefinition<string[], FxAssets.ResourceTypeAssetTypeInformation[]>;
        let getResourceAssetInformationEndPoint: Rpc.FuncEndPointDefinition<string[], FxAssets.ResourceAssetInformation[]>;
        interface GetResourceEndPointArgs {
            resourceId: string;
            skipCache: boolean;
            invoker: string;
        }
        /**
         * @deprecated MsPortalFx.Extension.Runtime.FxImpl.Extension.getResourceEndPoint 2020/04/30 - This should no longer be used, it is no longer supported.  Use batch() call to ARM endpoint
         * directly to retrieve a resource.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        let getResourceEndPoint: Rpc.FuncEndPointDefinition<GetResourceEndPointArgs, HubsExtension.AzureContracts.ResourceWithStrings>;
        interface Definition extends FxExtension.Definition {
            requireConfig?: RequireConfig;
        }
        /**
         * Metadata describing how inputs can be bound to properties on the Part's container (its enclosing Dashboard and, later, enclosing
         * Blade).
         */
        type InputsMetadata = StringMap<InputMetadata>;
        /**
         * Metadata describing how an input can be bound to a property from its container (its enclosing Dashboard and, later, enclosing Blade).
         */
        interface InputMetadata {
            /**
             * Those sources available at the container level.  The user will select 0 or 1 of these via configuration UI.
             */
            bindingSources: InputBindingSource[];
            /**
             * The currently selected source or null/undefined if the user has elected to override this input with an explicitly specified
             * value.
             */
            activeBindingSourceName: string;
        }
        /**
         * Metadata describing a container property to which a Part input can be bound.  For a given Part input, the user will select 0 or 1
         * of these via configuration UI.
         */
        interface InputBindingSource {
            /**
             * The runtime-level name of the property at the container level (the Dashboard or, later, the enclosing Blade).
             */
            name: string;
            /**
             * Indicates whether this Dashboard-level property accepts value updates.
             */
            acceptsValueUpdates: boolean;
        }
        function getRuntime(): {
            getLocalGalleryPackagesEndpoints: () => Promise<string[]>;
        };
        module IrisNotifications {
            import IrisNotificationsCommon = Common.Notifications.IrisNotifications;
            const getIrisContentEndPoint: Rpc.FuncEndPointDefinition<IrisNotificationsCommon.GetIrisContentOptions, IrisNotificationsCommon.IrisContent>;
            const sendIrisSignalEndPoint: Rpc.FuncEndPointDefinition<IrisNotificationsCommon.SignalOptions, void>;
        }
    }
}

// FILE: MsPortalFx\Extension\SetRequirement.d.ts
declare module MsPortalFx.Extension {
    enum SetRequirement {
        /**
         * All items in the set must be satisfied (operator AND).
         */
        All = 0,
        /**
         * Any items in the set must be satisfied (operator OR).
         */
        Any = 1
    }
}

// FILE: MsPortalFx\Globalization.d.ts
declare module FxImpl {
    const knownCulturesMap: StringMap<Language>;
    interface Format<T> {
        format(value: T): string;
    }
    interface FormatCache<TOptions, TValue> {
        getValue(options?: TOptions): Format<TValue>;
    }
    class IntlContext {
        displayLanguage: string;
        formatCulture: string;
        numbers: FormatCache<MsPortalFx.Intl.NumberFormatOptions, number>;
        dateTimes: FormatCache<MsPortalFx.Intl.DateTimeFormatOptions, Date>;
        supported: (locales: string[]) => string[];
        constructor(displayLanguage: string, formatCulture: string, intl?: any);
    }
    function createWithBrowserIntl(displayLanguage: string, formatCulture: string): IntlContext;
    module Intl {
        const displayLanguage: string;
        const formatCulture: string;
        const effectiveLocale: string;
        interface NumberFormat {
            /**
             * Returns the format of the number according to the formatting options of this NumberFormat object.
             */
            format(value: number): string;
        }
        /**
         * An object that can provide language sensitive number formatting.
         */
        module NumberFormat {
            /**
             * Creates a new instance of an object that can provide language sensitive number formatting.
             */
            function create(options?: MsPortalFx.Intl.NumberFormatOptions): NumberFormat;
            /**
             * Returns the format of the number default formatting options for the current locale.
             */
            function format(value: number): string;
        }
        interface DateTimeFormat {
            /**
             * Returns the format of the number according to the formatting options of this DateTimeObject object.
             */
            format(value: Date): string;
        }
        /**
         * An object that can provide language sensitive date and time formatting.
         */
        module DateTimeFormat {
            /**
             * The format options that returns strings similar to 11/30/2011.
             */
            const shortDatePattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011.
             */
            const longDatePattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to Wednesday, November 30, 2011, 5:25:30 AM.
             */
            const fullDateTimePattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 30.
             */
            const monthDayPattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25 AM.
             */
            const shortTimePattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to 5:25:30 AM.
             */
            const longTimePattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * The format options that returns strings similar to November 2011.
             */
            const yearMonthPattern: MsPortalFx.Intl.DateTimeFormatOptions;
            const weekDayPattern: MsPortalFx.Intl.DateTimeFormatOptions;
            /**
             * Creates a new instance of an object that can provide language sensitive date and time formatting.
             */
            function create(options?: MsPortalFx.Intl.DateTimeFormatOptions): DateTimeFormat;
        }
        module Internal {
            function supportedLocalesOf(locales: string[]): string[];
        }
    }
    function sanitizeFormatCulture(format: string, language: string): string;
    /**
     * Language object which has a corresponding culture information of locale, name, and localized name.
     */
    interface Language {
        /**
         * Language locale identifier.
         */
        locale: string;
        /**
         * Language English name.
         */
        name: string;
        /**
         * Language localized name.
         */
        localizedName: string;
        /**
         * Language neutral culture status.
         */
        neutralCulture: boolean;
        /**
         * Default specific culture.
         */
        specificCulture?: string;
    }
}
declare module "MsPortalFx/Globalization" {
    let Intl: typeof FxImpl.Intl;
    export = Intl;
}

// FILE: MsPortalFx\Hubs\InternalCommands.d.ts
declare module FxImpl {
    /**
     * Interface is in Framework but implementation is in Framework.Client under Internal/ListCommand.
     * Declaring the interface here allows the shell to avoid referencing the Framework.Client module.
     * This is a internal command type that exists only for hubs.
     */
    interface ListCommand2Contract extends MsPortalFx.ViewModels.ListCommandContract {
        /**
         * Shell tests for the existance of this property.
         * Name is short intentionally to keep the size small.
         */
        lc2: boolean;
    }
}

// FILE: MsPortalFx\Hubs\Notifications.d.ts
declare module MsPortalFx.Hubs.Notifications {
    import FxAssets = MsPortalFx.Assets;
    import FxViewModels = MsPortalFx.ViewModels;
    /**
     * The notification status.
     */
    enum NotificationStatus {
        /**
         * An Information notification
         */
        Information = 0,
        /**
         * A Warning notification
         */
        Warning = 1,
        /**
         * An Error notification
         */
        Error = 2,
        /**
         * An InProgress notification
         */
        InProgress = 3,
        /**
         * A Success notification
         */
        Success = 4
    }
    /**
     * Interface that represents data required to create a client notification.
     */
    interface ClientNotificationParameters {
        /**
         * The notification status - Information, Warning, Error, InProgress, Success.
         */
        status: NotificationStatus;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Optionally, render the notification description as HTML.
         */
        descriptionAsHtml?: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds?: string[];
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentComplete?: number;
        /**
         * The asset associated with the notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        asset?: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri?: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade?: FxViewModels.DynamicBladeSelection;
        /**
         * The notification id.
         */
        notificationId?: string;
        /**
         * Any additional properties associated with the notification.
         */
        additionalProperties?: any;
    }
    /**
     * Interface that represents data representing a client notification.
     * This interface cannot be used to create a new notification.
     */
    interface ClientNotificationData extends ClientNotificationParameters {
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * Boolean indicating if this is a recommendation notification.
         */
        isRecommendation?: boolean;
    }
    /**
     * Client notification class
     */
    class ClientNotification implements ClientNotificationParameters {
        /**
         * The notification status - Information, Warning, Error, InProgress, Success.
         */
        status: NotificationStatus;
        /**
         * The notification id.
         */
        notificationId: string;
        /**
         * The notification title.
         */
        title: string;
        /**
         * The notification description.
         */
        description: string;
        /**
         * Render the notification description as HTML.
         */
        descriptionAsHtml: boolean;
        /**
         * The event correlation ids associated with the notification.
         */
        correlationIds: string[];
        /**
         * The percentage of operation completed. Used only when notification status is InProgress.
         * If a value is specified, a deterministic progress bar is shown. If not, a non-deterministic progress bar is shown.
         */
        percentComplete: number;
        /**
         * The asset associated with the notification.
         */
        asset: FxAssets.AssetTriplet;
        /**
         * A URI that the notification links to.
         */
        uri: string;
        /**
         * The blade linked to this notification.
         * Either the asset or the linked blade can be specified but not both.
         */
        linkedBlade: FxViewModels.DynamicBladeSelection;
        /**
         * Additional properties on the notification.
         */
        additionalProperties: any;
        /**
         * Constructs a notification object that can be published.
         *
         * @param params The client notification data.
         */
        constructor(params: ClientNotificationParameters);
        validate(): boolean;
        package(): FxImpl.Hubs.Notifications.InternalClientNotificationData;
        /**
         * Generates a randomly unique id to be used for notificationId, correlationId, and others where needed.
         *
         * @returns string id that always starts with clientNotification and ends with a globally unique identifier.
         */
        static generateClientNotificationId(): string;
        /**
         * Publishes this notification to the portal using the properties specified.
         */
        publish(): void;
        /**
         * Publishes a one time notification.
         *
         * @param params The client notification data.
         * @returns the client notification created from the passed in params.
         */
        static publish(params: ClientNotificationParameters): ClientNotification;
    }
}
declare module FxImpl.Hubs.Notifications {
    import Rpc = FxImpl.Rpc;
    import Notifications = MsPortalFx.Hubs.Notifications;
    let addClientNotificationDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData, void>;
    let addClientNotificationsDefinition: Rpc.FuncEndPointDefinition<InternalClientNotificationData[], void>;
    /**
     * The action performed when the modal notification buttons are clicked.
     */
    const enum ModalNotificationClickAction {
        /**
         * Execute a click on the notification
         */
        NotificationClick = 1,
        /**
         * Refresh the portal
         */
        RefreshPortal = 2
    }
    /**
     * Action to take for the client notification URI.
     */
    enum ClientNotificationUriAction {
        /**
         * Navigates within the portal (ex: route to deep link).
         */
        NavigatePortal = 0,
        /**
         * Opens the URI in a new browser tab.
         */
        OpenInNewTab = 1,
        /**
         * Opens the URI in the current browser tab (replacing the portal).
         */
        OpenInCurrentTab = 2
    }
    /**
     * Notification field type (for inline forms).
     */
    const enum NotificationFieldType {
        /**
         * TextBox control.
         */
        TextBox = 0,
        /**
         * TextArea control (multiline textbox).
         */
        TextArea = 1,
        /**
         * Email control (textbox with email validation).
         */
        Email = 2,
        /**
         * CheckBox control.
         */
        CheckBox = 3
    }
    /**
     * The parameters for the modal dialog.
     */
    interface ModalNotificationParams {
        /**
         * The notification that is shown in the menu and in the dialog.
         * The asset specified in the notification will be launched on the primary click.
         */
        notification: InternalClientNotificationData;
        /**
         * The primary button text. Optional, if not specified will default to OK.
         */
        primaryButtonText?: string;
        /**
         * The secondary button text. Optional, if not specified will default to Cancel.
         */
        secondaryButtonText?: string;
        /**
         * The action performed when the primary button is clicked. Defaults to no action.
         */
        primaryButtonClickAction?: ModalNotificationClickAction;
        /**
         * The action performed when the secondary button is clicked. Defaults to no action.
         */
        secondaryButtonClickAction?: ModalNotificationClickAction;
    }
    /**
     * Metadata defining a notification form field.
     */
    interface NotificationField {
        /**
         * Field name.
         */
        name: string;
        /**
         * Field label (should be localized).
         */
        label: string;
        /**
         * Field type (defines the generated control).
         */
        fieldType: NotificationFieldType;
        /**
         * Default value for the field. Default is empty.
         */
        defaultValue?: string;
        /**
         * Defines whether the field is optional. Default is required.
         */
        optional?: boolean;
    }
    /**
     * Defines the arguments for making an AJAX call to a specified endpoint from an actionable
     * notification.
     */
    interface EndpointArgs {
        /**
         * The endpoint URI. This can be formatted with the field values using the field names. This
         * format ${fieldName} will be replaced with the field value.
         */
        uri: string;
        /**
         * The AJAX call method/type (http verb).
         */
        method: string;
        /**
         * The body (data). This can be formatted with the field values using the field names. This
         * format ${fieldName} will be replaced with the field value.
         */
        body: string;
        /**
         * Message to replace the notification content if the AJAX call succeeds.
         */
        successMessage: string;
        /**
         * Message to replace the notification content if the AJAX call fails.
         */
        failureMessage: string;
        /**
         * Defines whether we shuold supply the ARM tokens in the authentication header or not.
         */
        useArmToken?: boolean;
    }
    /**
     * Defines the arguments for launching an external link from an actionable notification.
     */
    interface ExternalLinkArgs {
        /**
         * The URI to launch.
         */
        uri: string;
    }
    /**
     * Defines the arguments for launching a deep link from an actionable notification.
     */
    interface DeepLinkArgs extends ExternalLinkArgs {
    }
    /**
     * Defines the arguments for pinning a dashboard part from an actionable notification.
     */
    interface PinToDashboardArgs {
        /**
         * The name of the pinned part.
         */
        name: string;
        /**
         * The name of the extension for the pinned part.
         */
        extension: string;
        /**
         * The parameters for the pinned part.
         */
        parameters: Record<string, any>;
    }
    /**
     * Defines an actionable notification action. If more than one action is defined, the first in
     * the following order will be executed and the rest will be ignored: openBlade, deepLink,
     * externalLink.
     */
    interface NotificationAction {
        /**
         * Arguments for an "openBlade" action (opens a portal blade).
         *
         * @example
         *  {
         *      blade: 'MyBladeName',
         *      extension: 'MyExtensionName',
         *      parameters: { ...MyBladeParameters },
         *      openContextPane: true|false
         *  }
         *
         * This will open MyBladeName within the current Portal browser tab, passing 'parameters' to that blade.
         * If openContextPane is set (true) then it will open as a context pane, maintaining current user journey. Not set (false) and it will
         * open as a blade, starting a new user journey and closing all blades that are currently open.
         */
        openBlade?: OpenBladeArgs;
        /**
         * Arguments for an "externalLink" action (launches an external link in new tab).
         *
         * @example
         *  {
         *      uri: 'https://www.bing.com/'
         *  }
         *
         * This will open a new browser tab with the provided uri as its destination.
         */
        externalLink?: ExternalLinkArgs;
        /**
         * Arguments for a "deepLink" action (launches a deep link). Reroutes the portal to the specific deeplink location.
         *
         * @example
         *  {
         *      uri: '#/blade/myextensionname/mybladename'
         *  }
         *
         * This will reroute current Portal browser tab to the 'mybladename' blade, or other deeplink experience (ie. #asset/, #create/, etc.).
         */
        deepLink?: DeepLinkArgs;
    }
    /**
     * Defines an actionable notification button action. If more than one action is defined, the first in
     * the following order will be executed and the rest will be ignored: openBlade, deepLink,
     * externalLink, pinToDashboard, endpoint.
     */
    interface NotificationButton extends NotificationAction {
        /**
         * Button label (should be localized).
         */
        label: string;
        /**
         * Optional button id  which will be logged in telemetry (non localized string).
         */
        id?: string;
        /**
         * Arguments for an "endpoint" action (making an AJAX call to a specified endpoint).
         */
        endpoint?: EndpointArgs;
        /**
         * Arguments for an "pinToDashboard" action.
         */
        pinToDashboard?: PinToDashboardArgs;
        /**
         * Styles the button as a secondary button. Also secondary buttons do not trigger form
         * validation. Defaults to false.
         */
        secondary?: boolean;
    }
    /**
     * Defines an inline form for actionable notifications.
     */
    interface NotificationInlineForm extends NotificationAction {
        /**
         * List of notification form fields.
         * Remains connected temporarily to avoid compile time breaks, but fields are not used (haven't been for a long while).
         */
        fields?: NotificationField[];
        /**
         * List of notification action buttons.
         */
        buttons?: NotificationButton[];
    }
    /**
     * The RPC method that hubs calls to add a modal notification.
     */
    let showModalNotification: Rpc.FuncEndPointDefinition<ModalNotificationParams, MsPortalFx.ViewModels.Dialogs.DialogResult>;
    /**
     * Interface that represents additional data about Iris notifications.
     */
    interface IrisNotificationDetails {
        /**
         * The telemetry callback URI to declare any action (must replace {ACTION} with portion with reported action).
         */
        readonly actionBeaconUri?: string;
        /**
         * The telemetry callback URI to declare official receipt of message (ie. NotificationShown).
         */
        readonly impressionsUri?: string;
        /**
         * The notification id. This will be logged as a notification identifier for different types of notifications.
         */
        readonly notificationId?: string;
    }
    /**
     * Interface that represents data of an image related to a modal notification. The image will only be displayed when the notification toastDuration is Modal.
     */
    interface ModalImage {
        /**
         * The source url of the image.
         */
        readonly imageUrl: string;
        /**
         * Whether the image will persist on a small screen or zoom in. The default value is false.
         */
        readonly showOnZoom?: boolean | string;
        /**
         * For accessibility. The alternative text when the image fails to load. The default value is "".
         */
        readonly alternativeText?: string;
        /**
         * The width of the image. Default is "100%".
         */
        readonly imageWidth?: string;
        /**
         * The height of the image. Default is "auto".
         */
        readonly imageHeight?: string;
    }
    /**
     * Interface that represents data related to a modal.
     */
    interface ModalNotificationData {
        /**
         * Data of an image related to a modal notification. The image will only be displayed when the notification toastDuration is Modal.
         */
        image?: ModalImage;
        /**
         * Width of the modal notification. Applicable only when the notification toastDuration is Modal. Default is "400px".
         */
        width?: string;
    }
    /**
     * Interface that represents data representing a client notification.
     */
    interface InternalClientNotificationData extends Notifications.ClientNotificationData {
        /**
         * Data related to a modal.
         */
        modalNotificationData?: ModalNotificationData;
        /**
         * Flag indicating if this is a server event.
         */
        isServerEvent?: boolean;
        /**
         * Action to take for the notification URI.
         */
        uriAction?: ClientNotificationUriAction;
        /**
         * Toast duration for the notification.
         */
        toastDuration?: ToastDuration;
        /**
         * Inline form metadata for actionable notifications.
         */
        inlineForm?: NotificationInlineForm;
        /**
         * Details about the Iris notification.
         */
        irisNotificationDetails?: IrisNotificationDetails;
        /**
         * The email id of the user.
         */
        caller?: string;
    }
    /**
     * Client notification class
     */
    class InternalClientNotification extends Notifications.ClientNotification {
        /**
         * Toast duration for the notification.
         */
        toastDuration?: ToastDuration;
        /**
         * Inline form metadata for actionable notifications.
         */
        inlineForm?: NotificationInlineForm;
        /**
         * Iris notification details.
         */
        irisNotificationDetails?: IrisNotificationDetails;
        /**
         * Action to take for the notification URI.
         */
        uriAction?: ClientNotificationUriAction;
        /**
         * Data related to a modal.
         */
        modalNotificationData?: ModalNotificationData;
        /**
         * The email id of user.
         */
        caller: string;
        /**
         * Constructs a notification object that can be published.
         *
         * @param params client notification data.
         */
        constructor(params: InternalClientNotificationData);
        /**
         * Publishes this notification to the portal using the properties specified.
         *
         * @returns The timestamp at which the notification was published.
         */
        publish(): Date;
        /**
         * Publishes a one time notification.
         *
         * @param params The client notification data.
         * @returns internal client notification not meant for partner use.
         */
        static internalPublish(params: InternalClientNotificationData): InternalClientNotification;
    }
}
declare namespace FxImpl.Hubs.Notifications {
    /**
     * Defines the arguments for opening a blade from an actionable notification.
     */
    type OpenBladeArgs = import("Fx/Notifications").OpenBladeArgs;
    /**
     * Notification toast duration.
     */
    type ToastDuration = import("Fx/Notifications").ToastDuration;
    const ToastDuration: typeof import("Fx/Notifications").ToastDuration;
}

// FILE: MsPortalFx\Internal\Internal.Constants.d.ts
declare module FxImpl.Constants {
    module RpcMethods {
        const addClientNotification: string;
        const addClientNotifications: string;
        const addFxClientNotifications: string;
        const brokerExtensionService: string;
        const canShowNps: string;
        const deletePutConfirmation: string;
        const entryPointGetBladeDefinition: string;
        const entryPointGetReactModel: string;
        const entryPointDisposeReactModel: string;
        const entryPointGetCommandsDefinition: string;
        const entryPointGetControlDefinition: string;
        const entryPointGetPartDefinition: string;
        const forwardEvent: string;
        const getArmEndpoint: string;
        const getAllAssetTypes: string;
        const getAssetTypeInformation: string;
        const setAllTokensForExtension: string;
        const getCatalogApiCacheContent: string;
        const getDeepLinkUri: string;
        const getExtensionRegistration: string;
        const getIrisContent: string;
        const getLastResourceIdInJourney: string;
        const getLocationDisplayNames: string;
        const getManifest: string;
        const getManifestEnvironment: string;
        const getRegisteredResourceProviderInfo: string;
        const getResource: string;
        const getResourceAssetInformation: string;
        const getResourceGroup: string;
        const getResourceTypeAssetTypeInformation: string;
        const getSelectedSubscriptions: string;
        const getSettings: string;
        const getSharedSettings: string;
        const getUserInfo: string;
        const hasPermission: string;
        const listTestExtensions: string;
        const logFeatureAdoptionTelemetry: string;
        const mapAssetIdToDynamicSelectionAndIcon: string;
        const mapAssetIdToResourceId: string;
        const mapResourceIdToAssetId: string;
        const mapResourceIdToDynamicSelectionAndIcon: string;
        const navigateToDashboard: string;
        const networkTelemetry: string;
        const notifyDeployment: string;
        const openDockedContextPane: string;
        const pollDeployment: string;
        const internalDeploymentHelper: string;
        const experimentationHelper: string;
        const experimentationValuesHelper: string;
        const notifyExtensionStatus: string;
        const ping: string;
        const pinParts: string;
        const postBoot: string;
        const registration: string;
        const registerTestExtensions: string;
        const sendIrisSignal: string;
        const setExtensionFlights: string;
        const shellReadUserSettings: string;
        const shellWriteLastUsedUserSettings: string;
        const shellWriteUserSettings: string;
        const showNps: string;
        const unregisterTestExtensions: string;
        const updateSubscriptionInfo: string;
        const updateTenantInfo: string;
        const viewModels: string;
        const tryEarlyGetViewModel: string;
        const hubsGetResourceGroupsFromSubscription: string;
        const getLockValidation: string;
        const getSasUriForQueue: string;
        const getClientIp: string;
        const getHmacSha256: string;
        const getExtensionGalleryServiceViewModel: string;
        const getLocalGalleryPackagesEndpoints: string;
        const getLocationsForCreate: string;
        const getLocations: string;
        const getProvisioningOperation: string;
        const getProvisioningRequest: string;
        const initiateProvisioningRequest: string;
        const registerLocalGalleryPackagesEndpoint: string;
        const submitProvisionerTelemetry: string;
    }
}

// FILE: MsPortalFx\Knockout\knockout.d.ts
/*!
 * Knockout JavaScript library v3.4.1
 * (c) The Knockout.js team - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
interface KnockoutDisposable {
    dispose(): void;
}
interface KnockoutSubscription<T> extends KnockoutDisposable {
    _target: KnockoutObservableBase<T>;
    callback(value: T): void;
    disposeCallback(this: KnockoutSubscription<T>): void;
    isDisposed?: boolean;
}
interface KnockoutReadOnlyObservableBase<T> extends KnockoutSubscribable<T> {
    peek(): T;
}
interface KnockoutObservableBase<T> extends KnockoutReadOnlyObservableBase<T> {
    (value: T): void;
}
interface KnockoutComputedOptions<T> {
    read?: () => T;
    write?: (value: T) => void;
    owner?: any;
    disposeWhen?(): boolean;
    deferEvaluation?: boolean;
}
interface KnockoutComputed<T> extends KnockoutObservableBase<T>, KnockoutDisposable {
    getDependenciesCount(): number;
    hasWriteFunction(): boolean;
    isActive(): boolean;
}
interface KnockoutComputedStatic {
    fn: KnockoutComputed<any>;
}
interface KnockoutPureComputedStatic {
    fn: KnockoutComputed<any>;
    <T>(func: () => T, context?: any): KnockoutComputed<T>;
    <T>(options?: KnockoutComputedOptions<T>): KnockoutComputed<T>;
}
interface KnockoutReadOnlyObservable<T> extends KnockoutReadOnlyObservableBase<T> {
    equalityComparer(a: T, b: T): boolean;
    valueHasMutated(): void;
    valueWillMutate(): void;
}
interface KnockoutObservable<T> extends KnockoutReadOnlyObservable<T>, KnockoutObservableBase<T> {
}
interface KnockoutReadOnlyObservableArray<T> extends KnockoutReadOnlyObservable<T[]> {
    indexOf(searchElement: T, fromIndex?: number): number;
    slice(start: number, end?: number): T[];
}
interface KnockoutObservableArray<T> extends KnockoutReadOnlyObservableArray<T>, KnockoutObservable<T[]> {
    splice(start: number, deleteCount?: number, ...items: T[]): T[];
    pop(): T;
    push(...items: T[]): number;
    shift(): T;
    unshift(...items: T[]): number;
    reverse(): T[];
    sort(compareFunction?: (a: T, b: T) => number): void;
    replace(oldItem: T, newItem: T): void;
    remove(item: T): T[];
    remove(predicate: (item: T) => boolean): T[];
    removeAll(items?: T[]): T[];
    destroy(item: T): void;
    destroyAll(items?: T[]): void;
}
interface KnockoutObservableArrayStatic {
    fn: KnockoutObservableArray<any>;
    <T>(value?: T[]): KnockoutObservableArray<T>;
}
interface KnockoutSubscribable<T> {
    (): T;
    extend(source: any): KnockoutObservableBase<T>;
    getSubscriptionsCount(): number;
    notifySubscribers(this: this, valueToWrite: T, topic?: string): void;
}
interface KnockoutObservableStatic {
    fn: KnockoutObservable<any>;
    <T>(value?: T): KnockoutObservable<T>;
}
interface KnockoutArrayEdit<T> {
    status: string;
    index?: number;
    moved?: number;
    value: T;
}
interface KnockoutCompareArrayOptions {
    sparse?: boolean;
    dontLimitMoves?: boolean;
}
interface KnockoutSubscribableStatic {
    fn: KnockoutSubscribable<any>;
    <T>(): KnockoutSubscribable<T>;
}
declare namespace ko {
    let observable: KnockoutObservableStatic;
    let computed: KnockoutComputedStatic;
    let pureComputed: KnockoutPureComputedStatic;
    let observableArray: KnockoutObservableArrayStatic;
    let subscribable: KnockoutSubscribableStatic;
    function isComputed<TV, TO extends KnockoutComputed<TV> = KnockoutComputed<TV>>(instance: TV | TO): instance is TO;
    function isPureComputed<TV, TO extends KnockoutReadOnlyObservableBase<TV> = KnockoutReadOnlyObservableBase<TV>>(instance: TV | TO): instance is TO;
    function isWritableObservable<TV, TO extends KnockoutObservable<TV> = KnockoutObservable<TV>>(instance: TV | TO): instance is TO;
}
declare namespace ko {
    function isObservable<TV, TO extends KnockoutObservableBase<TV> = KnockoutObservableBase<TV>>(instance: TV | TO): instance is TO;
    function isSubscribable<TV, TO extends KnockoutSubscribable<TV> = KnockoutSubscribable<TV>>(instance: TV | TO): instance is TO;
    namespace utils {
        function extend(target: any, source: any): any;
        function arrayForEach<T>(array: ArrayLike<T>, action: Action2<T, number>): void;
        function arrayIndexOf<T>(array: ArrayLike<T>, item: T): number;
        function arrayFirst<T, TOwner = void>(array: ArrayLike<T>, predicate: (this: TOwner, item: T, index: number) => boolean, predicateOwner?: TOwner): T;
        function arrayRemoveItem<T>(array: T[], itemToRemove: T): void;
        function arrayGetDistinctValues<T>(array: ArrayLike<T>): T[];
        function arrayMap<T, U>(array: ArrayLike<T>, mapping: Func2<T, number, U>): U[];
        function arrayFilter<T>(array: ArrayLike<T>, predicate: Func2<T, number, boolean>): T[];
        function arrayPushAll<T>(array: T[] | KnockoutObservableArray<T>, valuesToPush: ArrayLike<T>): KnockoutObservableArray<T> | T[];
        function unwrapObservable<T>(value: T | KnockoutObservableBase<T>): T;
        function peekObservable<T>(value: T | KnockoutObservableBase<T>): T;
    }
    namespace utils {
        function compareArrays<T>(oldArray: T[], newArray: T[], options?: boolean | KnockoutCompareArrayOptions): KnockoutArrayEdit<T>[];
    }
    export import unwrap = ko.utils.unwrapObservable;
    function toJS(rootObject: any): any;
    function toJSON(rootObject: any, replacer?: (this: any, key: string, value: any) => any, space?: string | number): string;
    const ignoreDependencies: <T>(callback: () => T, callbackTarget?: any, callbackArgs?: any[]) => T;
}

// FILE: MsPortalFx\MsPortalFxBegin.d.ts
declare module FxImpl {
}
declare module MsPortalFx.Base {
    type Disposable = import("Fx/Lifetime").Disposable;
    type ActionOrDisposable = import("Fx/Lifetime").ActionOrDisposable;
    type LifetimeManagerBase = import("Fx/Lifetime").LifetimeManagerBase;
    type LifetimeManager = import("Fx/Lifetime").LifetimeManager;
    type DisposableLifetimeManager = import("Fx/Lifetime").DisposableLifetimeManager;
}

// FILE: MsPortalFx\MsPortalFxEnd.d.ts
declare module FxImpl {
    /**
     * Promise resolved when require config has been called and init scripts have been injected
     */
    const requireReady: Promise<void>;
    function injectShellScripts(requireConfig: RequireConfig, shellRequireConfig: RequireConfig): void;
    function requireExtension(): Promise<void>;
}

// FILE: AzureDataContracts.d.ts
declare module HubsExtension.AzureContracts {
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBase {
        /**
         * The extended location (Edge zone) of the resource entity
         */
        readonly extendedLocation?: ExtendedLocation;
        /**
         * The resource entity id of the resource entity.
         */
        readonly id: string;
        /**
         * The name of the resource entity.
         */
        readonly name: string;
        /**
         * The location of the resource entity.
         */
        readonly location: string;
        /**
         * The tags of the resource entity.
         */
        readonly tags: ReadonlyStringMap<string>;
        /**
         * The properties of the resource entity.
         */
        readonly properties: ReadonlyStringMap<any>;
        /**
         * Is this resource group managed by another resource.
         */
        readonly managedBy?: string;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseWithStrings extends ResourceBase {
        /**
         * The location string for the resource group's location.
         */
        readonly locationString: string;
    }
    /**
     * The locked states enumeration provides named constants for the resource group.
         * DEPRECRATED 11/14/2018
     */
    type ResourceLockState = Obsolete;
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroup extends ResourceBase {
        /**
         * The lock state of the resource group.
         * DEPRECRATED 11/14/2018
         */
        readonly lockState?: Obsolete;
        /**
         * The provisioning state of the resource group.
         */
        readonly provisioningState: string;
    }
    /**
     * Type of extended location.
     */
    enum ExtendedLocationType {
        /**
         * The type is EdgeZone for Edge zone locations.
         */
        EdgeZone = "EdgeZone",
        /**
         * The type is Region for main locations.
         */
        Region = "Region",
    }

    /**
     * Data model for a extendedLocation.
     */
    interface ExtendedLocation {
        /**
         * Type of extendedLocation
         */
        type: ExtendedLocationType;
        /**
         * Name of extendedLocation
         */
        name: string;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupWithStrings extends ResourceGroup, ResourceBaseWithStrings {
    }
    /**
     * Data model for a single resource.
     */
    interface Resource extends ResourceBase {
        /**
         * The resource group ID of the resource.
         */
        readonly resourceGroup: string;
        /**
         * The type of the resource.
         */
        readonly type: string;
        /**
         * The resource type kind of the resource.
         */
        readonly kind?: string;
        /**
         * The self link URI of the resource.
         * DEPRECRATED 11/14/2018
         */
        readonly selfLinkUri?: Obsolete;
        /**
         * The zones of the resource entity.
         */
        readonly zones?: ReadonlyArray<string>;
        /**
         * The plan of the resource entity.
         */
        readonly plan?: ReadonlyStringMap<any>;
        /**
         * The sku of the resource entity.
         */
        readonly sku?: ReadonlyStringMap<any>;
        /**
         * The identity of the resource entity.
         */
        readonly identity?: ReadonlyStringMap<any>;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceWithStrings extends Resource, ResourceBaseWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        readonly trimmedName: string;
    }
}

// FILE: MsPortalFx\Observables\AzureObservables.d.ts
declare module HubsExtension.Internal.Azure {
    import ActionEndPointDefinition = FxImpl.Rpc.ActionEndPointDefinition;
    /**
     * Endpoint for the hubs extension to communicate subscription changes to the shell.
     */
    let updateSubscriptionInfoEndPoint: ActionEndPointDefinition<ReadonlyArray<MsPortalFx.Azure.Subscription>>;
    /**
     * Endpoint for the hubs extension to send resource provider information to the shell.
     */
    let getRegisteredResourceProviderInfoEndPoint: ActionEndPointDefinition<string[]>;
}
declare module HubsExtension.Azure {
    import FxBase = MsPortalFx.Base;
    import FxImage = FxBase.Image;
    /**
     * Data model for a single resource entity.
     */
    export import ResourceBase = HubsExtension.AzureContracts.ResourceBase;
    /**
     * Data model for a single resource entity.
     */
    export import ResourceBaseWithStrings = HubsExtension.AzureContracts.ResourceBaseWithStrings;
    /**
     * Data model for a single resource group.
     */
    export import ResourceGroup = HubsExtension.AzureContracts.ResourceGroup;
    /**
     * Data model for a single resource group with the display strings.
     */
    export import ResourceGroupWithStrings = HubsExtension.AzureContracts.ResourceGroupWithStrings;
    /**
     * Data model for a single resource.
     */
    export import Resource = HubsExtension.AzureContracts.Resource;
    /**
     * Data model for a single resource with the display strings.
     */
    export import ResourceWithStrings = HubsExtension.AzureContracts.ResourceWithStrings;
    /**
     * Data contract for a list of Azure values.
     */
    interface CollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
    }
    /**
     * Data contract for a list of Azure values with a continuation token.
     */
    interface ContinuationCollectionResponse<T> {
        /**
         * The list of objects of type T.
         */
        value: T[];
        /**
         * The optional continuation token.
         */
        token?: string;
    }
    /**
     * Data contract for Azure subscription policies.
     */
    class SubscriptionPolicies {
        /**
         * The subscription location placement id.
         */
        locationPlacementId: string;
        /**
         * The subscription quota id.
         */
        quotaId: string;
    }
    /**
     * Data model for tenant info.
     */
    class TenantInfo {
        /**
         * List of all tenants for the user.
         */
        tenants: Tenant[];
        /**
         * Whether the call to get tenants for the user failed.
         */
        failure: boolean;
    }
    /**
     * Data model for a tenant.
     */
    class Tenant {
        /**
         * Tenant id.
         */
        id: string;
        /**
         * The tenant domain name.
         */
        domainName: string;
        /**
         * The tenant display name.
         */
        displayName: string;
        /**
         * The tenant category.
         */
        tenantCategory: string;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservable {
        /**
         * The resource entity id of the resource entity.
         */
        readonly id: KnockoutObservableBase<string>;
        /**
         * The name of the resource entity.
         */
        readonly name: KnockoutObservableBase<string>;
        /**
         * The location of the resource entity.
         */
        readonly location: KnockoutObservableBase<string>;
        /**
         * The tags of the resource entity.
         */
        readonly tags: KnockoutObservableBase<ReadonlyStringMap<string>>;
        /**
         * The properties of the resource entity.
         */
        readonly properties: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * Is this resource group managed by another resource.
         */
        readonly managedBy?: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource entity.
     */
    interface ResourceBaseObservableWithStrings extends ResourceBaseObservable {
        /**
         * The location string for the resource group's location.
         */
        readonly locationString: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource group.
     */
    interface ResourceGroupObservable extends ResourceBaseObservable {
        /**
         * The provisioning state of the resource group.
         */
        readonly provisioningState: KnockoutObservableBase<string>;
    }
    /**
     * Data model for a single resource group with the display strings.
     */
    interface ResourceGroupObservableWithStrings extends ResourceGroupObservable, ResourceBaseObservableWithStrings {
    }
    /**
     * Data contract for a list of Azure resource groups.
     */
    interface ResourceGroupList {
        /**
         * The list of resource groups.
         */
        readonly resourceGroups: ReadonlyArray<ResourceGroup>;
    }
    /**
     * Data model for a single resource.
     */
    interface ResourceObservable extends ResourceBaseObservable {
        /**
         * The resource group ID of the resource.
         */
        readonly resourceGroup: KnockoutObservableBase<string>;
        /**
         * The type of the resource.
         */
        readonly type: KnockoutObservableBase<string>;
        /**
         * The resource type kind of the resource.
         */
        readonly kind?: KnockoutObservableBase<string>;
        /**
         * The zones of the resource entity.
         */
        readonly zones?: KnockoutObservableBase<ReadonlyArray<string>>;
        /**
         * The plan of the resource entity.
         */
        readonly plan?: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * The plan of the resource entity.
         */
        readonly sku?: KnockoutObservableBase<ReadonlyStringMap<any>>;
        /**
         * The identity of the resource entity.
         */
        readonly identity?: KnockoutObservableBase<ReadonlyStringMap<any>>;
    }
    /**
     * Data model for a single resource with the display strings.
     */
    interface ResourceObservableWithStrings extends ResourceObservable, ResourceBaseObservableWithStrings {
        /**
         * The resource name without the parent resource if it's a nested resource.
         */
        readonly trimmedName: KnockoutObservableBase<string>;
    }
    /**
     * Data contract for a list of Azure resources.
     */
    interface ResourceList {
        /**
         * The list of resources.
         */
        readonly resources: ReadonlyArray<Resource>;
    }
    /**
     * The data model used by the region picker.
     */
    class RegionPickerDataModel {
        /**
         * The default parameter set.
         */
        regionPicker: {
            /**
             * The region id.
             */
            regionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the subscription picker.
     */
    class SubscriptionPickerDataModel {
        /**
         * The default parameter set.
         */
        subscriptionPicker: {
            /**
             * The subscription id.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * The subscription name.
             */
            subscriptionName: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the create new resource group.
     */
    class ResourceGroupDataModel {
        /**
         * The default parameter set.
         */
        resourceGroup: {
            /**
             * The new resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The subscription Id for the new resource group.
             */
            subscriptionId: KnockoutObservable<string>;
        };
    }
    /**
     * The data model used by the resource group picker.
     */
    class ResourceGroupPickerDataModel {
        /**
         * The default parameter set.
         */
        resourceGroupPicker: {
            /**
             * The resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The resource group location.
             */
            resourceGroupLocation: KnockoutObservable<string>;
            /**
             * The subscription Id for the resource group.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * Flag to indicate new resource group or existing one.
             */
            isNewResourceGroup: KnockoutObservable<string>;
        };
    }
    module SpecPicker {
        import SpecPicker = HubsExtension.Azure.SpecPicker;
        const enum OriginControl {
            Unknown = 0,
            DropDown = 1,
            Selector = 2,
            InfoBox = 3
        }
        /**
         * Spec picker selection modes.
         */
        const enum SelectionMode {
            /**
             * Single selection.
             */
            Single = 0,
            /**
             * Multiple selection.
             */
            Multiple = 1
        }
        type ColorScheme = "" | "mediumBlue" | "darkOrchid" | "yellowGreen" | "orange";
        /**
         * Data contract for a spec.
         */
        interface Spec extends FxImpl.Composition.Selectable.Selectable2Options<FxImpl.Composition.Selectable.BladeReference<any>> {
            /**
             * The id.
             */
            id: string;
            /**
             * The spec code.
             */
            specCode: string;
            /**
             * The color scheme.
             */
            colorScheme: ColorScheme;
            /**
             * The title.
             */
            title: string;
            /**
             * The sub title.
             * This value will be displayed if there is not enough space for title in some container. e.g spec title in recommendation blade
             */
            shortTitle?: string;
            /**
             * The features.
             */
            features: Array<SpecPicker.Feature>;
            /**
             * The promoted features.
             */
            promotedFeatures: Array<SpecPicker.PromotedFeature>;
            /**
             * The spec cost.
             */
            cost: SpecPicker.SpecCost;
        }
        /**
         * Data contract for a Feature.
         */
        interface Feature {
            /**
             * The id.
             */
            id: string;
            /**
             * The display name.
             */
            displayName?: string;
            /**
             * The display value.
             */
            displayValue?: string | number;
            /**
             * The icon name.
             */
            iconName?: string;
            /**
             * The icon Svg Data.
             */
            iconSvgData?: string;
            /**
             * The icon image.
             */
            iconImage?: FxImage;
        }
        /**
         * Data contract for a Promoted Feature.
         */
        interface PromotedFeature {
            /**
             * The id.
             *
             * It can be set to lookup the promoted feature in partner extensions.
             * This id is optional. Since it isn't required by spec picker control.
             */
            id?: string;
            /**
             * The value.
             */
            value: string;
            /**
             * The unit description.
             */
            unitDescription: string;
        }
        /**
         * Data contract for a spec data.
         */
        interface SpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The specs.
             */
            specs: Array<SpecPicker.Spec>;
            /**
             * The resource map used for spec cost computation.
             * It's a mapping from regionId to array of resource quota set.
             */
            resourceMap?: StringMap<Pricing.SpecResourceSet[]>;
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             * this value will be log to telemetry log
             */
            specType: string;
            /**
             * The common properties of reservation, should only be used by reservations.
             */
            reservationProperties?: Pricing.ReservationPropertiesDefinition;
            /**
             * The message will be displayed on the top of specPickerPart.
             */
            message?: string;
            /**
             * The message will be displayed on top of specPickerPart for Direct EA user.
             * If this message is not set, the default message is "Prices presented below are estimated retail prices and do not reflect applicable discounts
             * for your subscription. If you have purchased Azure services through a reseller, contact your reseller for applicable pricing."
             */
            messageForEA?: string;
            /**
             * The message will be displayed on top of specPickerPart for Indirect EA user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForIndirectEA?: string;
            /**
             * The message will be displayed on the top of specPickerPart for Reseller user.
             * If this message is not set, no message will be shown by default on top of specPickerPart.
             */
            messageForReseller?: string;
        }
        /**
         * Data contract for spec picker blade parameter.
         * This contract defined all required properties to open spec picker blade.
         */
        interface SpecPickerBladeParameter {
            /**
             * The blade to open.
             */
            detailBlade: string;
            /**
             * The extension to open.
             */
            extension: string;
            /**
             * The selected spec id.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecId?: string;
            /**
             * The selected specs ids.
             * This parameter will be set to ProviderInputs.inputParameters.
             */
            selectedSpecIds?: string[];
            /**
             * If this property is set to true, it will show the recommended view by default.
             * If don't set this property, the default view is "View All spec"
             */
            selectRecommendedView?: boolean;
            /**
             * The subscription id.
             * This parameter will be set to ProviderInputs.options.
             */
            subscriptionId: string;
            /**
             * The region id.
             * This parameter will be set to ProviderInputs.options.
             */
            regionId: string;
            /**
             * The disabled specs. Will be used by spec picker part.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from extender view model.
             * If you don't provide a value and there is no "disabledSpecs" in extender view model, spec picker won't show disabled spec.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recommendedSpecIds" from extender view model.
             * If you don't provide a value and there is no "recommendedSpecIds" in extender view model, spec picker won't show recommended specs.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids. (future api)
             * This parameter will be set to ProviderInputs.options.
             * If you don't provide a value, spec picker will try to get "recentSpecIds" from extender view model.
             * If you don't provide a value and there is no "recentSpecIds" in extender view model, spec picker won't show recent specs.
             * Currently not used for the spec picker, but used for the dropdown
             */
            recentSpecIds?: string[];
            /**
             * The options.
             * This parameter will be merge to ProviderInputs.options and this value will be passed to extender.
             */
            options?: any;
            /**
             * Whether to hide the cost or not.
             */
            hideCost?: boolean;
        }
        /**
         * Data contract for disabled spec.
         */
        interface DisabledSpec {
            /**
             * The disabled spec id.
             */
            specId: string;
            /**
             * The disabled message.
             * If you don't provide a value, the default message is "Not available".
             */
            message?: string;
            /**
             * The blade reference for disabled specs
             */
            supplyBladeReferenceAsync?: Func<Promise<FxImpl.Composition.Selectable.BladeReference<any>>>;
            /**
             * The help balloon message.
             * If you don't provide a value, the help balloon won't display.
             */
            helpBalloonMessage?: string;
            /**
             * The help balloon link text.
             */
            helpBalloonLinkText?: string;
            /**
             * The help balloon link URI.
             */
            helpBalloonLinkUri?: string;
        }
        /**
         * Data contract for pricing tier display.
         */
        interface PricingTierDisplay extends PricingTierSpecDisplay {
            /**
             * The asset name.
             */
            assetName: string;
            /**
             * The part title.
             * If you don't provide a value, the default value is "Pricing tier".
             */
            partTitle?: string;
            /**
             * The feature icons.
             */
            featureIcons?: KnockoutObservableBase<any[]>;
            /**
             * The multi specs display object
             */
            specs?: KnockoutObservableBase<PricingTierSpecsDisplay[]>;
        }
        interface PricingTierSpecDisplay {
            /**
             * The spec code.
             * If you don't provide a value, the default value will get from spec card.
             */
            specCode?: string;
            /**
             * The first number.
             */
            firstNumber?: KnockoutObservableBase<any>;
            /**
             * The first text.
             */
            firstText?: KnockoutObservableBase<string>;
            /**
             * The second number.
             */
            secondNumber?: KnockoutObservableBase<any>;
            /**
             * The second text.
             */
            secondText?: KnockoutObservableBase<string>;
        }
        interface PricingTierSpecsDisplay extends PricingTierSpecDisplay {
            /**
             * The corresponding spec id
             * Must be provided to correlate spec display info
             */
            specId: string;
        }
        /**
         * Data contract for pricing tier launcher extender input.
         */
        interface PricingTierLauncherExtenderInput {
            /**
             * The entity id.
             */
            entityId?: any;
        }
        /**
         * Data contract for pricing tier launcher spec data.
         */
        interface PricingTierLauncherSpecData {
            /**
             * The features.
             */
            features: SpecPicker.Feature[];
            /**
             * The spec.
             */
            spec?: SpecPicker.Spec;
            /**
             * The specs.
             */
            specs?: SpecPicker.Spec[];
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface PricingTierLauncherExtenderOutput {
            /**
             * The pricing tier display data
             */
            pricingTierDisplay: PricingTierDisplay;
            /**
             * The spec picker blade parameter.
             */
            specPickerBladeParameter: SpecPickerBladeParameter;
            /**
             * The spec data.
             */
            specData: SpecPicker.PricingTierLauncherSpecData;
            /**
             * The error message displayed by the Part when it has failed.
             */
            failureMessage?: string;
        }
        /**
         * Data contract or a pricing tier launcher extender.
         */
        interface PricingTierLauncherExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<PricingTierLauncherExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<PricingTierLauncherExtenderOutput>;
            /**
             * Save selected spec async.
             *
             * @param selected spec id.
             * @returns A promise representing the completion of the operation.
             */
            saveSelectedSpecAsync?(selectedSpecId: string): Promise<any>;
            /**
             * Save selected specs async.
             *
             * @param selected specs ids.
             * @returns A promise representing the completion of the operation.
             */
            saveSelectedSpecsAsync?(selectedSpecsIds: string[]): Promise<any>;
            /**
             * Checks to see if the current user has read permission to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @returns A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasReadPermision?(entityId: any): Promise<boolean>;
        }
        /**
         * Data contract for spec picker extender input.
         */
        interface SpecPickerExtenderInput {
            /**
             * The selected spec id.
             */
            selectedSpecId?: string;
            /**
             * The selected spec id.
             */
            selectedSpecIds?: string[];
            /**
             * Whether to hide the cost column or not
             */
            hideCost?: boolean;
            /**
             * The options.
             * This value will be passed from collector to provider part. And passed from provider part to extender.
             */
            options: any;
            /**
             * The specs made available to the spec picker extender
             */
            availableSpecData: KnockoutObservableBase<Spec[]>;
        }
        /**
         * Data contract for pricing tier launcher extender output.
         */
        interface SpecPickerExtenderOutput {
            /**
             * The spec data.
             */
            specData?: SpecPicker.SpecData;
            /**
             * The disabled specs.
             * If you don't provide a value, spec picker will try to get "disabledSpecs" from provider parameter.
             */
            disabledSpecs?: DisabledSpec[];
            /**
             * The recommended spec ids.
             */
            recommendedSpecIds?: string[];
            /**
             * The recent spec ids.
             */
            recentSpecIds?: string[];
            /**
             * The error message displayed by the Part when it has failed.
             */
            failureMessage?: string;
            /**
             * The specs passed through a filter
             */
            filteredSpecIds?: KnockoutComputed<string[]>;
        }
        /**
         * Data contract for spec picker extender.
         */
        interface SpecPickerExtender {
            /**
             * The input from part view model to extender.
             */
            input: KnockoutObservableBase<SpecPickerExtenderInput>;
            /**
             * The output from extender to part view model.
             */
            output: KnockoutObservableBase<SpecPickerExtenderOutput>;
            /**
             * Checks to see if the current user has permissions to access pricing tier launcher part.
             *
             * @param entityId The entity to check for permissions. It will be null during creation.
             * @param options The options from provider.
             * @returns A promise that resolves to true if the current user can perform all the provided actions against the provided entity.
             */
            hasEditPermision?(entityId: any, options: any): Promise<boolean>;
            /**
             * The controls to be placed on the filter form
             */
            filterControls?: KnockoutObservableArray<FilterControl>;
            /**
             * The selection mode for the specPicker
             */
            selectionMode?: SelectionMode;
            /**
             * The message shown when there are no specs.
             */
            noSpecsMsg?: KnockoutObservableBase<string>;
        }
        /**
         * Controls allowed in the spec picker filter section
         */
        type FilterControl = MsPortalFx.Control;
        /**
         * Data contract for spec picker launcher part view model.
         */
        interface SpecPickerLauncherPartViewModel {
            /**
             * Get provider input.
             *
             * @param providerId The provider id.
             * @returns A spec picker blade parameter.
             */
            getProviderInput(providerId: string): SpecPickerBladeParameter;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecId The selected spec id.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @returns A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecAsync?(selectedSpecId: string, selectedRecommendedView?: boolean): Promise<any>;
            /**
             * Update selected spec async.
             *
             * @param selectedSpecIds The selected specs ids.
             * @param selectedRecommendedView Shows if the recommended view was selected or not.
             * @returns A promise representing the update selected spec request which will complete asynchronously.
             */
            updateSelectedSpecsAsync?(selectedSpecIds: string[], selectedRecommendedView?: boolean): Promise<any>;
        }
        /**
         * Data contract for a spec cost.
         * This cost is hard coded in spec data. Doesn't return from Billing API
         */
        interface SpecCost {
            /**
             * The amount.
             */
            amount?: number;
            /**
             * The currency code.
             */
            currencyCode?: string;
            /**
             * The caption.
             */
            caption: string;
            /**
             * The decimal precision of the price. Defaults to 2.
             */
            decimalPrecision?: number;
        }
        /**
         * Spec picker V3 data used in ParameterCollection flow
         */
        module ParameterCollectionV3 {
            /**
             * Spec picker V3 data sent from Collector to Provider and back from Provider to Collector.
             */
            interface SpecPickerProviderCollectorParameter {
                fromProviderToCollector: SpecPickerProviderCollectorParameterFromProvider;
                fromCollectorToProvider: SpecPickerProviderCollectorParameterFromCollector;
            }
            interface SpecPickerProviderCollectorParameterFromProvider {
                /**
                 * The selected spec id.
                 */
                selectedSpecId?: string;
                /**
                 * The selected specs ids.
                 */
                selectedSpecIds?: string[];
                /**
                 * Check if the recommended view should be shown by default.
                 */
                selectedRecommendedView: boolean;
            }
            interface SpecPickerProviderCollectorParameterFromCollector {
                /**
                 * The entity id.
                 */
                entityId: any;
                /**
                 * The selected spec id.
                 */
                selectedSpecId?: string;
                /**
                 * The selected specs ids.
                 */
                selectedSpecIds?: string[];
                /**
                 * The subscription id.
                 */
                subscriptionId: string;
                /**
                 * The region id.
                 */
                regionId: string;
                disabledSpecs: SpecPicker.DisabledSpec[];
                recommendedSpecIds: string[];
                recentSpecIds?: string[];
                /**
                 * Whether to hide the cost or not
                 */
                hideCost?: boolean;
                selectRecommendedView: boolean;
                options: StringMapPrimitive;
                /**
                 * A telemetry flag to determine which control or part was responsible for launching the spec picker.
                 */
                originControl?: SpecPicker.OriginControl;
            }
        }
    }
    module Lock {
        /**
         * The data contract for all information needed to check a lock on a resource
         */
        interface LockCheck {
            /**
             * The resource id to check
             */
            resourceId: string;
            /**
             * The level of the lock
             */
            lockLevel: LockType;
        }
        type LockType = "ReadOnly" | "CanNotDelete" | "";
    }
    module Pricing {
        import ResourceManager = MsPortalFx.Azure.ResourceManager;
        /**
         * Data contract for spec cost query input.
         */
        interface SpecCostQueryInput {
            /**
             * The subscription Id.
             */
            subscriptionId: string;
            /**
             * The list of spec resource sets.
             */
            specResourceSets: SpecResourceSet[];
            /**
             * The list spec ids to allow zero cost.
             * This is a pre-defined list of specs that are allowed zero cost, to avoid displaying misleading billing information in UI. Make it required is to
             * enforce awareness of this parameter.
             *
             * 1) Sometimes a zero cost is computed by the billing backend for various reasons, either legitimate or not, for any spec card.
             * 2) There is a very strong design requirement that the spec picker should never show a zero unexpected.
             */
            specsToAllowZeroCost: string[];
            /**
             * The spec type. e.g. "Website", "VirtualMachine"
             */
            specType?: string;
            /**
             * The common properties of reservation, should only be used by reservations.
             */
            reservationProperties?: ReservationPropertiesDefinition;
        }
        /**
         * Data contract for reservation properties
         */
        interface ReservationPropertiesDefinition {
            /**
             * The version of reservation. e.g. "1.0".
             */
            version: string;
        }
        /**
         * Data contract for a first party resource quota.
         */
        interface FirstPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The MINT Resource Id (referred to as Resource GUID in some documentation).
             */
            resourceId: string;
            /**
             * The quantity of the resource.
             */
            quantity: number;
        }
        /**
         * Data contract for a resource quota set.
         */
        interface SpecResourceSet {
            /**
             * The spec id.
             */
            id: string;
            /**
             * This property is obsolete. Please use firstParty.
             */
            quotas?: FirstPartyResource[];
            /**
             * The first party quotas.
             */
            firstParty?: FirstPartyResource[];
            /**
             * The third party quotas.
             */
            thirdParty?: ThirdPartyResource[];
            /**
             * The reservation spec properties.
             */
            reservationSpecProperties?: ReservationSpecPropertiesDefinition;
        }
        /**
         * Data contract for reservation spec properties.
         */
        interface ReservationSpecPropertiesDefinition {
            /**
             * The reservation term.
             */
            term: string;
        }
        /**
         * Data contract for a third party resource.
         */
        interface ThirdPartyResource {
            /**
             * The round-tripped Id.
             */
            id?: string;
            /**
             * The resource publisher Id.
             */
            publisherId: string;
            /**
             * The resource offer Id.
             */
            offerId: string;
            /**
             * The resource plan Id.
             */
            planId: string;
            /**
             * The promotion code.
             */
            promotionCode: string;
            /**
             * The third party meters.
             */
            meters: ThirdPartyMeter[];
        }
        /**
         * Data contract for a third party meter.
         */
        interface ThirdPartyMeter {
            /**
             * The meter ID
             */
            meterId: string;
            /**
             * The meter quantity
             */
            quantity: number;
        }
        /**
         * Data contract for a third party resource and the quantity of that resource
         */
        interface CostEstimate {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The total monetary amount for this estimate
             * FirstParty + ThirdParty, but single currency
             */
            amount: number;
            /**
             * The billing currency code (e.g. USD)
             */
            currencyCode: string;
            /**
             * The status code for the individual spec cost
             */
            statusCode: SpecCostQueryResultSpecStatusCode;
            /**
             * The cost the first party resources
             */
            firstParty: CostEstimateResource[];
            /**
             * The cost the third party resources
             */
            thirdParty: CostEstimateResource[];
            /**
             * The availability id
             */
            availabilityId?: string;
        }
        /**
         * Data contract for a cost estimate resource.
         */
        interface CostEstimateResource {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The line level cost breakdown for the resource.
             */
            meters: CostEstimateMeter[];
            /**
             * Additional info about the third party plan / SKU. Null for 1st party resources and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            features?: ProductFeatures;
            /**
             * The per-term cost of purchasing this resource. Null for 1st party resources, and comes from the Ratings API
             * for 3rd party resources. Marked optional to avoid breaking older unit tests.
             */
            costPerTerm?: number;
            /**
             * A string indicating the length of the subscription period for this 3rd party resource.
             * An empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * This value is not localized (it is set from a list of constant values hard coded in the data-market feed).
             * Marked optional to avoid breaking older unit tests.
             */
            term?: string;
        }
        /**
         * Describes whether the third party product has a free trial or is a bring-your-own-license offer.
         */
        interface ProductFeatures {
            /**
             * Indicates whether a 3rd party plan/SKU includes a free trial period.
             */
            hasFreeTrial: boolean;
            /**
             * Indicates whether a third party plan / SKU requires the user to buy a license externally.
             */
            bringYourOwnLicense: boolean;
        }
        /**
         * Data contract for a cost estimate meter.
         */
        interface CostEstimateMeter {
            /**
             * The round-tripped Id
             */
            id: string;
            /**
             * The monetary amount for this estimate
             * This is in the billing currency code, which is specified in the parent object.
             */
            amount: number;
            /**
             * The monetary amount per unit
             * This value is prorated for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitAmount: number;
            /**
             * The Per Unit currency code (e.g. USD)
             * This is the same as the billing currency code for 1st party resources, and comes from the Ratings API for 3rd party resources
             */
            perUnitCurrencyCode: string;
            /**
             * The localized unit. It's empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             */
            unit: string;
            /**
             * The name of the meter. Empty string for 1st party resources, and comes from the Ratings API for 3rd party resources.
             * Marked optional to avoid breaking older unit tests.
             */
            name?: string;
            /**
             * Price rules describing the progressive pricing scheme for this meter. Meters which have one flat rate will have a single rule
             * with no upper/lower bound. Marked optional to avoid breaking older unit tests.
             */
            priceRules?: PriceRule[];
        }
        /**
         * An interval in a progressing pricing scheme.
         */
        interface PriceRule {
            /**
             * The lower bound for this interval. If this value is null, then there is no lower bound.
             */
            from: number;
            /**
             * The upper bound for this interval. If this value is null, then there is no upper bound.
             */
            to: number;
            /**
             * The cost for each unit of usage between from and to.
             * This is expressed in the PerUnitCurrencyCode currency code given by the parent CostEstimateMeter.
             */
            amount: number;
        }
        /**
         * Data contract for the spec cost query result.
         */
        interface SpecCostQueryResult {
            /**
             * Gets or sets a flag that indicates whether the costs were successfully returned.
             * Otherwise, a failure statusCode is returned.
             */
            isSuccess: boolean;
            /**
             * @deprecated SpecCostQueryResult.isEASubscription - Please use "channel" property instead of this. For backwards compatibility,
             * this will be set to true for channel === DirectEA and false for all other channels.
             *
             * Gets or sets a flag that indicates whether the cost is of enterprise agreement type.
             */
            isEASubscription: boolean;
            /**
             * Gets or sets the channel.
             */
            channel: string;
            /**
             * Gets or sets the list of the list of cost estimates.
             */
            costs: CostEstimate[];
            /**
             * Gets or sets the status code.
             */
            statusCode: Pricing.SpecCostQueryResultStatusCode;
            /**
             * Gets or sets the SpecCostQueryResult version.
             */
            version: string;
        }
        /**
         * Constants for gallery pricing.
         */
        module Constants {
            /**
             * Constants for the gallery pricing summary blade.
             */
            let PricingSummaryBlade: {
                displayText: string;
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the gallery legal terms blade.
             */
            let LegalTermsBlade: {
                bladeName: string;
                bladeExtension: string;
            };
            /**
             * Constants for the channel type.
             */
            let ChannelType: {
                directEA: string;
                indirectEA: string;
                unknownEA: string;
                direct: string;
                csp: string;
            };
        }
        /**
         * Gallery create pricing information model.
         */
        interface PricingInfo {
            /**
             * The subscription id.
             */
            subscriptionId: string;
            /**
             * The pricing tier selections made by the user.
             */
            pricingTierSelections: PricingTierSelection[];
            /**
             * The usage-based resources selected by the user.
             */
            usageBasedResources: UsageBasedResource[];
            /**
             * Gallery item products with pricing information.
             */
            products?: ResourceManager.GalleryItemProduct[];
            /**
             * Gallery item products with no pricing information.
             */
            productsWithNoPricing?: ResourceManager.GalleryItemProduct[];
            /**
             * Optional. Shows the "Pin to Startboard" checkbox on the legal terms blade.
             */
            showPinToStartboardCheckbox?: boolean;
        }
        /**
         * Pricing tier selection model.
         */
        interface PricingTierSelection {
            /**
             * The pricing tier id.
             */
            pricingTierId: string;
            /**
             * The pricing tier display name.
             */
            pricingTierDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
            /**
             * The calculated unit display name.
             */
            unitDisplayName: string;
            /**
             * The spec resource set.
             */
            specResourceSet: SpecResourceSet;
            /**
             * The specs allowed to have zero as a possible cost amount.
             */
            specsToAllowZeroCost: string[];
        }
        /**
         * Usage-based resource model.
         */
        interface UsageBasedResource {
            /**
             * The resource display name.
             */
            resourceDisplayName: string;
            /**
             * The resource type display name.
             */
            resourceTypeDisplayName: string;
            /**
             * The number of instances.
             */
            instanceCount: number;
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Costing data is not available.
             */
            CostDataNotAvailable = 1,
            /**
             * Batch mode request error-ed for some items.
             */
            Partial = 2,
            /**
             * Batch mode request error-ed for all items.
             */
            BatchFailed = 3,
            /**
             * Auth failure.
             */
            AuthFailure = 4,
            /**
             * An unexpected exception was thrown by the subscription provider component. Check logs for details.
             */
            SubscriptionException = 5,
            /**
             * User&apos; subscription was not found.
             */
            SubscriptionNotFound = 6,
            /**
             * User&apos; subscription is not active.
             */
            SubscriptionNotActive = 7,
            /**
             * Subscription data is invalid.
             */
            SubscriptionIsInvalid = 8,
            /**
             * Not supported in billing region.
             */
            NotSupportedInBillingRegion = 9,
            /**
             * Pricing is not available for this subscription.
             */
            SubscriptionPricingUnavailable = 10,
            /**
             * Invalid returned from Billing API.
             */
            InvalidEnrollment = 11,
            /**
             * Pricing is available as retail when EA is requested
             */
            SuccessAsRetailForEa = 12,
            /**
             * Spec is not supported in the current environment, e.g. Mooncake
             */
            NotSupportedInCurrentEnvironment = 13,
            /**
             * Pricing is available as retail when new EA is requested
             */
            SuccessAsRetailForNewEa = 14
        }
        /**
         * Status code for the GetSpecsCosts result
         * The corresponding C# enum is CostEstimateOverallStatusCode
         */
        const enum SpecCostQueryResultSpecStatusCode {
            /**
             * Costing data was successfully returned.
             */
            Success = 0,
            /**
             * Error retrieving price
             */
            PricingException = 1,
            /**
             * Spec not supported in region
             */
            NotSupportedInBillingRegion = 2,
            /**
             * Spec not available for subscription
             */
            NotAvailableForSubscription = 3,
            /**
             * Spec returns for retail but not ea
             */
            SuccessAsRetailForEa = 4,
            /**
             * Meter doesn't exist, do not display
             */
            MeterNotFound = 5,
            /**
             * Spec returns for retail but not ea. (New ea subscription case)
             */
            SuccessAsRetailForNewEa = 6
        }
    }
    /**
     * The resource type cache type.
     */
    type ResourceTypeCache = StringMap<ResourceTypeMetadata>;
    /**
     * The resource type metadata from the server.
     */
    interface ResourceTypeMetadata {
        /**
         * The name of the resource type.
         */
        resourceType: string;
        /**
         * The list of capabilities supported by the type.
         * Note: This is a comma separated list of capabilities
         * Example: "CrossResourceGroupResourceMove, CrossSubscriptionResourceMove"
         */
        capabilities: string;
    }
}

// FILE: MsPortalFx\Parts\PartColor.d.ts
declare module MsPortalFx.Parts {
    enum PartColor {
        /**
         * The default theme color.
         */
        Theme = 0,
        /**
         * Blue.
         */
        Blue = 1,
        /**
         * Green.
         */
        Green = 2,
        /**
         * Orange.
         */
        Orange = 3,
        /**
         * Pink.
         */
        Pink = 4,
        /**
         * Purple.
         */
        Purple = 5,
        /**
         * Azure.
         */
        Azure = 6,
        /**
         * Dark.
         */
        Dark = 7,
        /**
         * Red.
         */
        Red = 8
    }
}

// FILE: MsPortalFx\Parts\PartKind.d.ts
declare module MsPortalFx.Parts {
    enum PartKind {
        /**
         * Custom part that requires a provided template
         */
        Custom = 0,
        /**
         * Part to show the summary of a collection.
         */
        CollectionSummary = 1,
        /**
         * Part used for provisioning an asset.
         */
        Provisioning = 17,
        /**
         * Part to show the summary of a collection.
         */
        Button = 20,
        /**
         * Part used to launch a quick start blade.
         */
        QuickStart = 21,
        /**
         * Part used to represent an asset.
         */
        Asset = 22,
        /**
         * Part used to show documentation or getting started information.
         */
        InfoList = 23,
        /**
         * Part used to show a list of properties.
         */
        Properties = 24,
        /**
         * Part used to display a collection of records with an optional rollup.
         */
        Collection = 25,
        /**
         * Part used to render a web page inside an iframe.
         */
        Frame = 31,
        /**
         * Part that displays an extension error.
         */
        _Internal_Error = 997,
        /**
         * Part used to render an AppBlade.
         */
        _Internal_App = 998,
        /**
         * Part that hosts a ReactView/ReactTile (a react component rendered inside a visible iframe).
         */
        _Internal_React = 1000
    }
}

// FILE: MsPortalFx\Parts\PartSize.d.ts
declare module MsPortalFx.Parts {
    const enum PartSize {
        /**
         * A tile that is 1 column x 1 row.
         */
        Mini = 0,
        /**
         * A tile that is 2 columns x 1 row.
         */
        Small = 1,
        /**
         * A tile that is 2 columns x 2 rows.
         */
        Normal = 2,
        /**
         * A tile that is 4 columns x 2 rows.
         */
        Wide = 3,
        /**
         * A tile that is 2 columns x 4 rows.
         */
        Tall = 4,
        /**
         * A tile that is 6 columns x 4 rows.
         */
        HeroWide = 5,
        /**
         * A tile that is 4 columns x 6 rows.
         */
        HeroTall = 6,
        /**
         * A tile that is 6 columns by unbounded rows that fits the content.
         */
        HeroWideFitHeight = 7,
        /**
         * A tile that expands all the available columns by unbounded rows that fits the content.
         */
        FullWidthFitHeight = 8,
        /**
         * A tile that fits all the available space of the content area it occupies.
         */
        FitToContainer = 9,
        /**
         * A tile that is 4 columns x 4 rows.
         */
        Large = 10,
        /**
         * A tile that is 6 columns x 6 rows.
         */
        Hero = 11,
        /**
         * A tile with a custom size.
         */
        Custom = 99
    }
}

// FILE: MsPortalFx\Parts\PartSizeHelper.d.ts
declare module MsPortalFx.Parts {
    enum InternalPartSize {
        Mini = 0,
        Small = 1,
        Normal = 2,
        Wide = 3,
        Tall = 4,
        HeroWide = 5,
        HeroTall = 6,
        HeroWideFitHeight = 7,
        FullWidthFitHeight = 8,
        FitToContainer = 9,
        Large = 10,
        Hero = 11,
        Custom = 99
    }
}

// FILE: MsPortalFx\Parts\PartState.d.ts
declare module MsPortalFx.Parts {
    /**
     * Reflects the overall state of a Part, which determines whether or not it can be bound and displayed on the screen.
     */
    enum PartState {
        /**
         * The Part ready to be bound and displayed.
         */
        Ready = 0,
        /**
         * The Part is in a failed state where it cannot be bound and displayed. Instead, the user will see an error.
         */
        Failed = 1
    }
}

// FILE: MsPortalFx\Parts\ResizeMode.d.ts
declare module MsPortalFx.Parts {
    const enum ResizeMode {
        /**
         * Default mode. Resizes based on an optional set of fixed sizes.
         */
        Fixed = 0,
        /**
         * Resizes programmatically based on extension requesting size change.
         */
        Programmatic = 1,
        /**
         * Resizes based on user interaction.
         */
        User = 2
    }
}

// FILE: MsPortalFx\Polyfills\array.d.ts
interface ReadOnlyArrayPolyfills<T> {
}
interface ReadonlyArray<T> extends ReadOnlyArrayPolyfills<T> {
}
interface ArrayPolyfills<T> extends ReadOnlyArrayPolyfills<T> {
}
interface Array<T> extends ArrayPolyfills<T> {
}
/**
 * Returns a negative, zero or a positive number if its first
 * parameter is smaller, equal or greater than its second parameter
 * respectively.
 */
interface Comparator<T> {
    (a: T, b: T): number;
}
declare module MsPortalFx {
}

// FILE: MsPortalFx\Polyfills\date.d.ts
interface Date {
    toString(value: MsPortalFx.Intl.DateTimeFormatOptions): string;
    /**
     * Calculates date for first day of the week for the date.
     *
     * @param firstDayOfWeek 0 - Sunday, 1 - Monday, ..., 6 - Saturday.
     * @returns date object representing the first day of the week for the date
     */
    getFirstDayOfWeek(firstDayOfWeek?: number): Date;
}
declare interface DateConstructor {
    getLocaleValues: () => any;
    setLocaleValues: (def?: any) => void;
}
declare module MsPortalFx {
    function getLocaleValues(): {
        days: string[];
        daysAbbr: string[];
        months: string[];
        monthsAbbr: string[];
        ampm: string[];
        ampmAbbr: string[];
        dateSeparator: string;
        timeSeparator: string;
        standard: {
            d: string;
            D: string;
            f: string;
            F: string;
            g: string;
            G: string;
            m: string;
            M: string;
            r: string;
            R: string;
            s: string;
            t: string;
            T: string;
            u: string;
            y: string;
            Y: string;
        };
        firstDayOfWeek: number;
    };
    function setLocaleValues(def?: any): void;
    function getDateToStringFunc(): (format?: string | MsPortalFx.Intl.DateTimeFormatOptions) => string;
    function dateParse(value: string): number;
}

// FILE: MsPortalFx\Polyfills\string.d.ts
interface StringPolyfills {
    /**
     * Formats a string based on its key value pair object.
     *
     * @param args The list of arguments format arguments. For example: "String with params {0} and {1}".format("val1", "val2");.
     * @returns Formatted string.
     */
    format(this: string, ...restArgs: any[]): string;
    /**
     * Formats a string based on its key value pair object.
     *
     * @param formatSpecifierMap An object that contains that format mappings. For example: "String with parameters {one} and {two}".format({one: "val1", two: "val2"});.
     * @param tokenEncoder If specified, this callback will be used to produce a string representation of the tokens being injected into the string.
     * @returns Formatted string.
     */
    format(this: string, formatSpecifierMap: Object, tokenFormatter?: (tokenValue: any) => string): string;
    /**
     * Replace all instances of a substring in a string, using a search string.
     *
     * @param searchValue A string to search for.
     * @param replaceValue A string containing the text to replace for every successful match of searchValue in this string.
     * @returns A string with the replacements.
     */
    replaceAll(this: string, searchValue: string, replaceValue: string): string;
}
interface String extends StringPolyfills {
}
declare module MsPortalFx {
}

// FILE: MsPortalFx\RequireMetadata.d.ts
declare module FxImpl {
    const RequireMetadata: {
        [moduleId: string]: string[];
    };
}

// FILE: Strings.d.ts
declare namespace MsPortalFx.Resources {
    const Strings: {
        readonly Azure: {
            readonly BaseResourceDropDown: {
                /**
                 * The text "Selected item doesn't exist in the list."
                 */
                readonly creatingResourcedDisabledValidationMessage: string;
                /**
                 * The text "{0} does not exist in the list."
                 */
                readonly searchingValidationMessage: string;
            };
            readonly Legal: {
                readonly LegalTermsSelector: {
                    /**
                     * The text "Legal terms accepted"
                     */
                    readonly legalTermsAcceptedMessage: string;
                    /**
                     * The text "Legal terms"
                     */
                    readonly legalTermsLabel: string;
                    /**
                     * The text "Review legal terms"
                     */
                    readonly legalTermsMessage: string;
                };
            };
            readonly Locations: {
                readonly DropDown: {
                    /**
                     * The text "Location"
                     */
                    readonly defaultLabel: string;
                    /**
                     * The text "Deploy to an edge zone"
                     */
                    readonly edgeLocationSubLabel: string;
                    /**
                     * The text "No regions are enabled for this creation. Try using a different subscription or contact support if you believe this to be an error"
                     */
                    readonly emptyMessage: string;
                    /**
                     * The text "Region {0}"
                     */
                    readonly group: string;
                    /**
                     * The text "These locations are part of the R{0} group"
                     */
                    readonly groupBubble: string;
                    /**
                     * The text "Other"
                     */
                    readonly groupOther: string;
                    /**
                     * The text "Choose these regions to reach specific geographic areas"
                     */
                    readonly groupOtherBubble: string;
                    /**
                     * The text "Recommended"
                     */
                    readonly groupRecommended: string;
                    /**
                     * The text "Choose these locations for the broadest set of Azure products and long-term capacity growth"
                     */
                    readonly groupRecommendedBubble: string;
                    /**
                     * The text "Service Provided"
                     */
                    readonly groupServiceProvided: string;
                    /**
                     * The text "These locations are made available specially for this resource by the resource provider"
                     */
                    readonly groupServiceProvidedBubble: string;
                };
            };
            readonly ManagmenetGroups: {
                readonly DropDown: {
                    /**
                     * The text "Select a management group"
                     */
                    readonly placeHolder: string;
                };
            };
            readonly ResourceGroups: {
                readonly DropDown: {
                    readonly ProvisioningStateValidation: {
                        /**
                         * The text "You cannot create resources in this resource group. {0}"
                         */
                        readonly baseMessage: string;
                        /**
                         * The text "The selected resource group has been deleted."
                         */
                        readonly deleted: string;
                        /**
                         * The text "The selected resource group is being deleted. "
                         */
                        readonly deleting: string;
                        /**
                         * The text "The selected resource group is involved in a move operation. It may be selectable again in few minutes."
                         */
                        readonly movingresources: string;
                    };
                    /**
                     * The text "Name of new {0}"
                     */
                    readonly createNewAriaLabel: string;
                    /**
                     * The text "Create new or use existing {0}"
                     */
                    readonly defaultAriaLabel: string;
                    /**
                     * The text "Resource group"
                     */
                    readonly defaultLabel: string;
                    /**
                     * The text "A resource group is a container that holds related resources for an Azure solution."
                     */
                    readonly description: string;
                    /**
                     * The text "The selected resource group is read only"
                     */
                    readonly lockedValidationMessage: string;
                    /**
                     * The text "Name"
                     */
                    readonly name: string;
                    /**
                     * The text "No resource groups exist"
                     */
                    readonly noOptions: string;
                    /**
                     * The text "You cannot create resources in this resource group without all of the following permissions ({0})"
                     */
                    readonly requiredPermissionsValidationMessage: string;
                    /**
                     * The text "Select existing {0}"
                     */
                    readonly useExistingAriaLabel: string;
                };
                readonly InfoBalloon: {
                    /**
                     * The text "Learn more here."
                     */
                    readonly linkText: string;
                    /**
                     * The text "A resource group is a collection of resources that share the same lifecycle, permissions, and policies."
                     */
                    readonly text: string;
                };
            };
            readonly ResourceManager: {
                readonly Provisioner: {
                    readonly ArmValidation: {
                        /**
                         * The text "Unable to submit request. Check network connectivity and try again."
                         */
                        readonly networkFailure: string;
                        /**
                         * The text "There were validation errors. Click here to view details."
                         */
                        readonly validationFailed: string;
                    };
                    /**
                     * The text "Show pricing summary"
                     */
                    readonly pricingSummaryLinkLabel: string;
                    /**
                     * The text "Automation options"
                     */
                    readonly seeTemplateLink: string;
                };
            };
            readonly Subscriptions: {
                readonly DropDown: {
                    /**
                     * The text "Subscription"
                     */
                    readonly defaultLabel: string;
                    /**
                     * The text "The selected subscription is disabled."
                     */
                    readonly disabledSubscriptionValidationMessage: string;
                    /**
                     * The text "global subscription filter"
                     */
                    readonly globalSubscriptionFilter: string;
                    /**
                     * The text "Only showing subscriptions selected in the {0}."
                     */
                    readonly onlyShowingSelectedSubsMessage: string;
                    /**
                     * The text "You cannot create resources in this subscription without all of the following permissions ({0})"
                     */
                    readonly requiredPermissionsValidationMessage: string;
                    /**
                     * The text "Only showing subscriptions selected in the "
                     */
                    readonly showingSelectedSubsMessagePrefix: string;
                    /**
                     * The text "."
                     */
                    readonly showingSelectedSubsMessageSuffix: string;
                    /**
                     * The text "Resource provider(s): {1} are not registered for subscription {0} and you don’t have permissions to register a resource provider for subscription {0}"
                     */
                    readonly subCantRegisterWithRP: string;
                    /**
                     * The text "The subscription {0} is not allowed to register the resource provider(s): {1}."
                     */
                    readonly subDisallowedRP: string;
                    /**
                     * The text "The selected subscription is not allowed to create this resource."
                     */
                    readonly subscriptionNotAllowedForGalleryItemValidationMessage: string;
                    /**
                     * The text "Showing {0} of {1} selected subscriptions. Search for other selected subscriptions using the search filter."
                     */
                    readonly tooManyToDisplay: string;
                    /**
                     * The text "Unknown"
                     */
                    readonly unknownTenant: string;
                };
            };
            readonly Validators: {
                readonly Policy: {
                    /**
                     * The text "Policy {0} details"
                     */
                    readonly clickDetails: string;
                    /**
                     * The text "Policy enforcement. Value does not meet requirements on resource:"
                     */
                    readonly enforcement: string;
                    /**
                     * The text "The field '{0}' is required: "
                     */
                    readonly fieldRequired: string;
                    /**
                     * The text "The field '{0}' with the value '{1}' is denied: "
                     */
                    readonly fieldValueDenied: string;
                    /**
                     * The text "The field '{0}' with the value '{1}' is required: "
                     */
                    readonly fieldValueRequired: string;
                    /**
                     * The text "Tag {0}"
                     */
                    readonly tag: string;
                    /**
                     * The text "The value '{0}' in this field was denied: "
                     */
                    readonly valueDenied: string;
                    /**
                     * The text "This field is required: "
                     */
                    readonly valueRequired: string;
                    /**
                     * The text "This value '{0}' is required in this field: "
                     */
                    readonly valueRequiredWithValue: string;
                };
                readonly RequiredPermission: {
                    /**
                     * The text "You cannot perform this action without all of the following permissions ({0})"
                     */
                    readonly message: string;
                };
                readonly ReservedResourceName: {
                    /**
                     * The text "The resource name '{0}' or a part of the name is a trademarked or reserved word."
                     */
                    readonly message: string;
                };
            };
            /**
             * The text "{0} (Code: {1})"
             */
            readonly errorMessageWithCode: string;
            /**
             * The text "{0} (Code: {1}, Target: {2})"
             */
            readonly errorMessageWithTarget: string;
            /**
             * The text "An unknown error occurred."
             */
            readonly unknownErrorOccured: string;
        };
        readonly Chart: {
            /**
             * The text "No data to display"
             */
            readonly noDataMessage: string;
        };
        readonly CoreGrid: {
            /**
             * The text "Loading..."
             */
            readonly loading: string;
            /**
             * The text "No results."
             */
            readonly noData: string;
            /**
             * The text "Sorting..."
             */
            readonly sorting: string;
        };
        readonly DatePolyfill: {
            readonly AgoStrings: {
                /**
                 * The text "a day ago"
                 */
                readonly aDay: string;
                /**
                 * The text "a minute ago"
                 */
                readonly aMinute: string;
                /**
                 * The text "a month ago"
                 */
                readonly aMonth: string;
                /**
                 * The text "a week ago"
                 */
                readonly aWeek: string;
                /**
                 * The text "a year ago"
                 */
                readonly aYear: string;
                /**
                 * The text "an hour ago"
                 */
                readonly anHour: string;
                /**
                 * The text "{0} days ago"
                 */
                readonly days: string;
                /**
                 * The text "{0} hours ago"
                 */
                readonly hours: string;
                /**
                 * The text "a few seconds ago"
                 */
                readonly lessThanAMinute: string;
                /**
                 * The text "{0} minutes ago"
                 */
                readonly minutes: string;
                /**
                 * The text "{0} months ago"
                 */
                readonly months: string;
                /**
                 * The text "{0} weeks ago"
                 */
                readonly weeks: string;
                /**
                 * The text "{0} years ago"
                 */
                readonly years: string;
            };
            readonly Days: {
                /**
                 * The text "Friday"
                 */
                readonly friday: string;
                /**
                 * The text "Monday"
                 */
                readonly monday: string;
                /**
                 * The text "Saturday"
                 */
                readonly saturday: string;
                /**
                 * The text "Sunday"
                 */
                readonly sunday: string;
                /**
                 * The text "Thursday"
                 */
                readonly thursday: string;
                /**
                 * The text "Tuesday"
                 */
                readonly tuesday: string;
                /**
                 * The text "Wednesday"
                 */
                readonly wednesday: string;
            };
            readonly DaysAbbr: {
                /**
                 * The text "Fri"
                 */
                readonly friday: string;
                /**
                 * The text "Mon"
                 */
                readonly monday: string;
                /**
                 * The text "Sat"
                 */
                readonly saturday: string;
                /**
                 * The text "Sun"
                 */
                readonly sunday: string;
                /**
                 * The text "Thu"
                 */
                readonly thursday: string;
                /**
                 * The text "Tue"
                 */
                readonly tuesday: string;
                /**
                 * The text "Wed"
                 */
                readonly wednesday: string;
            };
            readonly Months: {
                /**
                 * The text "April"
                 */
                readonly april: string;
                /**
                 * The text "August"
                 */
                readonly august: string;
                /**
                 * The text "December"
                 */
                readonly december: string;
                /**
                 * The text "February"
                 */
                readonly february: string;
                /**
                 * The text "January"
                 */
                readonly january: string;
                /**
                 * The text "July"
                 */
                readonly july: string;
                /**
                 * The text "June"
                 */
                readonly june: string;
                /**
                 * The text "March"
                 */
                readonly march: string;
                /**
                 * The text "May"
                 */
                readonly may: string;
                /**
                 * The text "November"
                 */
                readonly november: string;
                /**
                 * The text "October"
                 */
                readonly october: string;
                /**
                 * The text "September"
                 */
                readonly september: string;
            };
            readonly MonthsAbbr: {
                /**
                 * The text "Apr"
                 */
                readonly april: string;
                /**
                 * The text "Aug"
                 */
                readonly august: string;
                /**
                 * The text "Dec"
                 */
                readonly december: string;
                /**
                 * The text "Feb"
                 */
                readonly february: string;
                /**
                 * The text "Jan"
                 */
                readonly january: string;
                /**
                 * The text "Jul"
                 */
                readonly july: string;
                /**
                 * The text "Jun"
                 */
                readonly june: string;
                /**
                 * The text "Mar"
                 */
                readonly march: string;
                /**
                 * The text "May"
                 */
                readonly may: string;
                /**
                 * The text "Nov"
                 */
                readonly november: string;
                /**
                 * The text "Oct"
                 */
                readonly october: string;
                /**
                 * The text "Sep"
                 */
                readonly september: string;
            };
        };
        readonly DeleteAssetConfirmation: {
            /**
             * The text "Affected items"
             */
            readonly affectedItemsLabel: string;
            /**
             * The text "Please enter '{0}' to confirm delete."
             */
            readonly assetNameValidationFailureMessage: string;
            /**
             * The text "Are you sure you want to delete {0}?"
             */
            readonly bladeTitle: string;
            /**
             * The text "Type the {0} name"
             */
            readonly confirmationLabel: string;
            /**
             * The text "Warning! Deleting {0} is irreversible. The action you're about to take can't be undone. Going further will delete it and all the items in it permanently."
             */
            readonly warningText: string;
        };
        readonly DeleteCommand: {
            readonly Confirmation: {
                /**
                 * The text "Are you sure you want to delete it?"
                 */
                readonly message: string;
                /**
                 * The text "Delete"
                 */
                readonly title: string;
            };
            readonly Failure: {
                /**
                 * The text "The command was cancelled. Resources can be modified or deleted through Geneva Actions."
                 */
                readonly ameCancelledDescription: string;
                /**
                 * The text "There was an error deleting it."
                 */
                readonly message: string;
                /**
                 * The text "Error"
                 */
                readonly title: string;
            };
        };
        readonly EditableGrid: {
            /**
             * The text "Delete"
             */
            readonly deleteCommandText: string;
            /**
             * The text "Insert"
             */
            readonly insertCommandText: string;
            /**
             * The text "Move to bottom"
             */
            readonly moveBottomCommandText: string;
            /**
             * The text "Move down"
             */
            readonly moveDownCommandText: string;
            /**
             * The text "Move to top"
             */
            readonly moveTopCommandText: string;
            /**
             * The text "Move up"
             */
            readonly moveUpCommandText: string;
        };
        readonly FileDownload: {
            /**
             * The text "No access"
             */
            readonly unauthorizedText: string;
        };
        readonly FileDownloadCommand: {
            /**
             * The text "Default authorization token is not available"
             */
            readonly authTokenNotAvailable: string;
            /**
             * The text "error"
             */
            readonly fileDownloadErrorStatus: string;
        };
        readonly FileUpload: {
            /**
             * The text "Drag and drop the files"
             */
            readonly dragAndDropFiles: string;
            /**
             * The text "File upload manager is still initializing and it's not ready to process new file uploads."
             */
            readonly notReady: string;
            /**
             * The text "File upload operation is not supported for the current upload type or upload state."
             */
            readonly notSupported: string;
        };
        readonly HeatMap: {
            /**
             * The text "No items in heat map"
             */
            readonly noUnitsMessage: string;
        };
        readonly NumericTextBox: {
            /**
             * The text "The value must be a valid number."
             */
            readonly invalidText: string;
        };
        readonly Part: {
            readonly Chart: {
                /**
                 * The text "Edit"
                 */
                readonly editButtonText: string;
            };
            readonly PropertiesPart: {
                /**
                 * The text "change"
                 */
                readonly changeLabel: string;
                /**
                 * The text "Change resource group"
                 */
                readonly changeResourceGroupLabel: string;
                /**
                 * The text "Change subscription"
                 */
                readonly changeSubscriptionLabel: string;
            };
            readonly Provisioning: {
                /**
                 * The text "In progress..."
                 */
                readonly description: string;
            };
            readonly Quickstart: {
                /**
                 * The text "Quickstart"
                 */
                readonly title: string;
            };
            readonly ResourceSummary: {
                /**
                 * The text "Location"
                 */
                readonly locationPropertyLabel: string;
                /**
                 * The text "Not available"
                 */
                readonly notAvailable: string;
                /**
                 * The text "Resource group"
                 */
                readonly resourceGroupPropertyLabel: string;
                /**
                 * The text "Status"
                 */
                readonly statusPropertyLabel: string;
                /**
                 * The text "Subscription ID"
                 */
                readonly subscriptionIdPropertyLabel: string;
                /**
                 * The text "Subscription name"
                 */
                readonly subscriptionNamePropertyLabel: string;
            };
            readonly SettingList: {
                readonly Group: {
                    /**
                     * The text "Automation"
                     */
                    readonly automation: string;
                    /**
                     * The text "General"
                     */
                    readonly general: string;
                    /**
                     * The text "Monitoring"
                     */
                    readonly monitoring: string;
                    /**
                     * The text "Quick Access"
                     */
                    readonly quickAccess: string;
                    /**
                     * The text "Resource management"
                     */
                    readonly resourceManagement: string;
                    /**
                     * The text "Settings"
                     */
                    readonly settings: string;
                    /**
                     * The text "Support + troubleshooting"
                     */
                    readonly support: string;
                };
                readonly Keyword: {
                    /**
                     * The text "events"
                     */
                    readonly events: string;
                    /**
                     * The text "insights"
                     */
                    readonly insights: string;
                    /**
                     * The text "logs"
                     */
                    readonly logs: string;
                };
                readonly Keywords: {
                    /**
                     * The text "access, permission"
                     */
                    readonly accessControl: string;
                    /**
                     * The text "event logs, operation logs, events, support, insights, monitoring"
                     */
                    readonly eventLogs: string;
                    /**
                     * The text "capture, automate, automation, PowerShell, command line, CLI, .NET, C#, csharp"
                     */
                    readonly exportTemplate: string;
                    /**
                     * The text "troubleshooting, submit, support request, cases, tickets, incidents, help, tools, diagnostics, problems, slow, connectivity, down"
                     */
                    readonly helpRequest: string;
                    /**
                     * The text "preview, features, pre-release"
                     */
                    readonly previewFeatures: string;
                    /**
                     * The text "cloud services, CPUs, processors, cores, storage accounts"
                     */
                    readonly quotas: string;
                    /**
                     * The text "support, advisor, recommendations, recommendation, best practice"
                     */
                    readonly resourceAdvisor: string;
                    /**
                     * The text "support, help"
                     */
                    readonly resourceHealth: string;
                    /**
                     * The text "troubleshooting, submit, support requests, cases, tickets, incidents, help"
                     */
                    readonly troubleshoot: string;
                };
                /**
                 * The text "Access"
                 */
                readonly access: string;
                /**
                 * The text "Access control (IAM)"
                 */
                readonly accessControl: string;
                /**
                 * The text "My permissions"
                 */
                readonly accessDetails: string;
                /**
                 * The text "CLI / PS"
                 */
                readonly cliPs: string;
                /**
                 * The text "Activity log"
                 */
                readonly eventLogs: string;
                /**
                 * The text "Export template"
                 */
                readonly exportTemplate: string;
                /**
                 * The text "New support request"
                 */
                readonly helpRequest: string;
                /**
                 * The text "Locks"
                 */
                readonly locks: string;
                /**
                 * The text "Resource locks"
                 */
                readonly locksForSubscriptions: string;
                /**
                 * The text "Preview features"
                 */
                readonly previewFeatures: string;
                /**
                 * The text "Properties"
                 */
                readonly properties: string;
                /**
                 * The text "Usage + quotas"
                 */
                readonly quotas: string;
                /**
                 * The text "Advisor recommendations"
                 */
                readonly resourceAdvisor: string;
                /**
                 * The text "Resource groups"
                 */
                readonly resourceGroups: string;
                /**
                 * The text "Resource health"
                 */
                readonly resourceHealth: string;
                /**
                 * The text "Resource providers"
                 */
                readonly resourceProviders: string;
                /**
                 * The text "Resources"
                 */
                readonly resources: string;
                /**
                 * The text "Roles"
                 */
                readonly roles: string;
                /**
                 * The text "Filter settings"
                 */
                readonly searchBoxPlaceholder: string;
                /**
                 * The text "Management certificates"
                 */
                readonly subCerts: string;
                /**
                 * The text "Tags"
                 */
                readonly tags: string;
                /**
                 * The text "Diagnose and solve problems"
                 */
                readonly troubleshoot: string;
                /**
                 * The text "Users"
                 */
                readonly users: string;
            };
        };
        readonly Pickers: {
            readonly AccessDenied: {
                /**
                 * The text "You do not have permissions to pick this item"
                 */
                readonly reasonMessage: string;
            };
            readonly Specs: {
                readonly DropDown: {
                    /**
                     * The text "All Available Pricing"
                     */
                    readonly available: string;
                    /**
                     * The text "{0} ({1})"
                     */
                    readonly labelFormatter: string;
                    /**
                     * The text "View full pricing details"
                     */
                    readonly labelLinkText: string;
                    /**
                     * The text "Recently Used"
                     */
                    readonly recent: string;
                    /**
                     * The text "Recommended"
                     */
                    readonly recommended: string;
                    /**
                     * The text "Pricing tier"
                     */
                    readonly title: string;
                };
                /**
                 * The text "Pricing tier"
                 */
                readonly pricingTier: string;
            };
        };
        readonly ResourceGroup: {
            readonly Validation: {
                /**
                 * The text "A resource group with the same name already exists in the selected subscription {0}."
                 */
                readonly alreadyExistsMessage: string;
                /**
                 * The text "Resource group names can only include alphanumeric, underscore, parentheses, hyphen, period (except at end), and Unicode characters that match the allowed characters."
                 */
                readonly invalidMessage: string;
                /**
                 * The text "Resource group names only allow up to 90 characters."
                 */
                readonly lengthValidationMessage: string;
                /**
                 * The text "You do not have permissions to create resource groups under subscription {0}."
                 */
                readonly subscriptionHasNoPermissionsMessage: string;
            };
        };
        readonly SequentialDataGrid: {
            /**
             * The text "Load more"
             */
            readonly loadAdditionalPageText: string;
        };
        readonly Services: {
            readonly AssetHandler: {
                /**
                 * The text "Type"
                 */
                readonly assetTypeGridColumn: string;
                /**
                 * The text "Title"
                 */
                readonly titleGridColumn: string;
            };
            readonly Gallery: {
                /**
                 * The text "View pricing summary"
                 */
                readonly viewPricingSummaryLabel: string;
            };
        };
        readonly Toolbar: {
            readonly FeedbackButton: {
                /**
                 * The text "Feedback"
                 */
                readonly title: string;
            };
            readonly MoveButton: {
                /**
                 * The text "Move to another region"
                 */
                readonly region: string;
                /**
                 * The text "Moving resources to another region must be sourced from the same region"
                 */
                readonly regionDisabledMessage: string;
                /**
                 * The text "Move to another resource group"
                 */
                readonly resourcegroup: string;
                /**
                 * The text "Move to another subscription"
                 */
                readonly subscription: string;
                /**
                 * The text "Move"
                 */
                readonly title: string;
                /**
                 * The text "Moving VMs to an Availability Zone must be sourced from the same region"
                 */
                readonly zonalMoveDisabledMessage: string;
                /**
                 * The text "Move to another availibility zone(s)"
                 */
                readonly zone: string;
            };
        };
        readonly UnitConversion: {
            /**
             * The text "B"
             */
            readonly billion: string;
            /**
             * The text "B/s"
             */
            readonly billionPerSecond: string;
            /**
             * The text "B"
             */
            readonly bytes: string;
            /**
             * The text "B/day"
             */
            readonly bytesPerDay: string;
            /**
             * The text "B/hr"
             */
            readonly bytesPerHour: string;
            /**
             * The text "B/min"
             */
            readonly bytesPerMinute: string;
            /**
             * The text "B/s"
             */
            readonly bytesPerSecond: string;
            /**
             * The text "/day"
             */
            readonly countPerDay: string;
            /**
             * The text "/hr"
             */
            readonly countPerHour: string;
            /**
             * The text "/min"
             */
            readonly countPerMinute: string;
            /**
             * The text "/s"
             */
            readonly countPerSecond: string;
            /**
             * The text "days"
             */
            readonly days: string;
            /**
             * The text "GiB"
             */
            readonly gigabytes: string;
            /**
             * The text "GiB/s"
             */
            readonly gigabytesPerSecond: string;
            /**
             * The text "GB/s"
             */
            readonly gigabytesPerSecondSI: string;
            /**
             * The text "GB"
             */
            readonly gigabytesSI: string;
            /**
             * The text "hr"
             */
            readonly hours: string;
            /**
             * The text "KiB"
             */
            readonly kilobytes: string;
            /**
             * The text "KiB/s"
             */
            readonly kilobytesPerSecond: string;
            /**
             * The text "kB/s"
             */
            readonly kilobytesPerSecondSI: string;
            /**
             * The text "kB"
             */
            readonly kilobytesSI: string;
            /**
             * The text "MiB"
             */
            readonly megabytes: string;
            /**
             * The text "MiB/s"
             */
            readonly megabytesPerSecond: string;
            /**
             * The text "MB/s"
             */
            readonly megabytesPerSecondSI: string;
            /**
             * The text "MB"
             */
            readonly megabytesSI: string;
            /**
             * The text "μs"
             */
            readonly microSeconds: string;
            /**
             * The text "ms"
             */
            readonly milliSeconds: string;
            /**
             * The text "M"
             */
            readonly million: string;
            /**
             * The text "M/s"
             */
            readonly millionPerSecond: string;
            /**
             * The text "mins"
             */
            readonly minutes: string;
            /**
             * The text "%"
             */
            readonly percentage: string;
            /**
             * The text "PiB"
             */
            readonly petabytes: string;
            /**
             * The text "PiB/s"
             */
            readonly petabytesPerSecond: string;
            /**
             * The text "PB/s"
             */
            readonly petabytesPerSecondSI: string;
            /**
             * The text "PB"
             */
            readonly petabytesSI: string;
            /**
             * The text "s"
             */
            readonly seconds: string;
            /**
             * The text "TiB"
             */
            readonly terabytes: string;
            /**
             * The text "TiB/s"
             */
            readonly terabytesPerSecond: string;
            /**
             * The text "TB/s"
             */
            readonly terabytesPerSecondSI: string;
            /**
             * The text "TB"
             */
            readonly terabytesSI: string;
            /**
             * The text "K"
             */
            readonly thousand: string;
            /**
             * The text "K/s"
             */
            readonly thousandPerSecond: string;
            /**
             * The text "T"
             */
            readonly trillion: string;
            /**
             * The text "T/s"
             */
            readonly trillionPerSecond: string;
        };
        readonly ViewModels: {
            readonly Container: {
                /**
                 * The text "Network error"
                 */
                readonly networkError: string;
                /**
                 * The text "The request either timed out or your browser refused the connection. Check your network status, browser settings, browser extensions, or VPN settings for conflicts."
                 */
                readonly networkErrorDetails: string;
                /**
                 * The text "Not found"
                 */
                readonly notFound: string;
                /**
                 * The text "No access"
                 */
                readonly unauthorizedText: string;
                /**
                 * The text "The extension encountered an unexpected error and provided no additional details."
                 */
                readonly unexpectedError: string;
            };
            readonly Controls: {
                readonly CreatorAndComboBox: {
                    /**
                     * The text "Create new"
                     */
                    readonly createNew: string;
                    /**
                     * The text "(New) {0}"
                     */
                    readonly newItemText: string;
                    /**
                     * The text "Select existing..."
                     */
                    readonly selectExisting: string;
                    /**
                     * The text "Use existing"
                     */
                    readonly useExisting: string;
                };
                readonly CreatorAndSelector: {
                    /**
                     * The text "Create new"
                     */
                    readonly createNew: string;
                    /**
                     * The text "Select existing"
                     */
                    readonly selectExisting: string;
                    /**
                     * The text "Use existing"
                     */
                    readonly useExisting: string;
                };
                readonly ResourceGroups: {
                    /**
                     * The text "Create new resource group"
                     */
                    readonly createNew: string;
                    /**
                     * The text "Select existing resource group"
                     */
                    readonly selectExisting: string;
                };
                /**
                 * The text "Button"
                 */
                readonly button: string;
                /**
                 * The text "Calendar"
                 */
                readonly calendar: string;
                /**
                 * The text "File upload"
                 */
                readonly fileUpload: string;
                /**
                 * The text "No results"
                 */
                readonly noRowsMessage: string;
                /**
                 * The text "Search"
                 */
                readonly search: string;
                /**
                 * The text "Selector"
                 */
                readonly selector: string;
            };
            readonly Toolbar: {
                /**
                 * The text "No access"
                 */
                readonly noAccess: string;
            };
        };
    };
}

// FILE: MsPortalFx\Services\Services.AssetHandler.d.ts
declare module MsPortalFx.Services {
    /**
     * The asset expansion class provides several helpers for asset expanding regular value to asset values.
     *
     * @deprecated 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
     * no code in FX will use this.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    module AssetExpansion {
        /**
         * Gets the prefix of all the asset expansion properties.
         *
         * @deprecated AssetExpansion.assetDetailsPropertyPrefix 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetDetailsPropertyPrefix: Obsolete;
        /**
         * Gets the name of the asset details expanded property.
         *
         * @deprecated AssetExpansion.assetDetailsPropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetDetailsPropertyName: Obsolete;
        /**
         * Gets the name of the asset title expanded property.
         *
         * @deprecated AssetExpansion.titlePropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const titlePropertyName: Obsolete;
        /**
         * Gets the name of the asset description expanded property.
         *
         * @deprecated AssetExpansion.descriptionPropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const descriptionPropertyName: Obsolete;
        /**
         * Gets the name of the asset icon expanded property.
         *
         * @deprecated AssetExpansion.iconPropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const iconPropertyName: Obsolete;
        /**
         * Gets the name of the asset type string expanded property.
         *
         * @deprecated AssetExpansion.assetTypeStringPropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetTypeStringPropertyName: Obsolete;
        /**
         * Gets the name of the asset ID expanded property.
         *
         * @deprecated AssetExpansion.assetIdPropertyName 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is safe to remove,
         * no code in FX will use this.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        const assetIdPropertyName: Obsolete;
        /**
         * Checks if the given value has been asset expanded.
         *
         * @deprecated AssetExpansion.isAssetExpanded 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param value The value to check.
         * @returns true if the value has been asset expanded, else null.
         */
        function isAssetExpanded(value: any): Obsolete;
        /**
         * Gets the asset expansion from the given value.
         *
         * @deprecated AssetExpansion.getAssetExpansion 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param value The value to use.
         * @returns The asset expansion if the value was asset expanded, otherwise returns null.
         */
        function getAssetExpansion(value: any): Obsolete;
        /**
         * Adds an asset expansion to the given value.
         *
         * @deprecated AssetExpansion.addAssetExpansion 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param value The value to expand.
         * @param assetDetails The asset expansion.
         * @returns The value that was expanded.
         */
        function addAssetExpansion(value: any, assetDetails: AssetDetails): Obsolete;
        /**
         * Removes the asset expansion from the give value.
         *
         * @deprecated AssetExpansion.removeAssetExpansion 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param value The value to unexpand.
         */
        function removeAssetExpansion(value: any): Obsolete;
    }
    /**
     * The asset details provides information about the asset.
     *
     * @deprecated AssetDetails 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type AssetDetails = Obsolete;
    /**
     * Asset expands an item.
     *
     * @deprecated assetExpandItem 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * @param item The item to be cloned and asset expanded.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @returns The cloned and asset expanded item.
     */
    function assetExpandItem<T>(item: T, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    /**
     * Asset expands an item and adds the result to the observable result set.
     *
     * @deprecated assetExpandItemAndAddToResultSet 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * @param item The item to be cloned, asset expanded and added to the result set.
     * @param results The observable result set.
     * @param mapFunc The mapping function to asset expand the items in the source data set.
     * @param context An opaque context object which is passed to the mapping function as the second parameter.
     * @returns The cloned and asset expanded item.
     */
    function assetExpandItemAndAddToResultSet<T>(item: T, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    /**
     * The data set asset expansion mapper is used to watch a data set (typed observable array) and push asset expanded
     * values to a result set (untyped observable array).
     */
    module DataSetAssetExpansionMapper {
        /**
         * Connects a dataset to a set of results with a mapper and a cancellation flag.
         *
         * @deprecated DataSetAssetExpansionMapper 04/30/2020 - No longer supported. This was used specifically for BrowseV1 and is no longer required.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param lifetime The LifetimeManager for this observable to react to data set.
         * @param dataSet The source data set (typed observable array).
         * @param results The result set (untyped observable array).
         * @param mapFunc The mapping function to asset expand the items in the source data set.
         * @param context An opaque context object which is passed to the mapping function as the second parameter.
         * @returns The knockout subscription for the connection (used to dispose on cancel).
         */
        function connectDataSet<T>(lifetimeManager: MsPortalFx.Base.LifetimeManager, dataSet: KnockoutObservableArray<T>, results: KnockoutObservableArray<any>, mapFunc: (value: T, context?: any) => AssetDetails, context?: any): Obsolete;
    }
}

// FILE: MsPortalFx\Services\Services.Data.d.ts
declare module MsPortalFx.Services {
    /**
     * The data set subscription is used to watch a data set (typed observable array) and call callback functions for
     * insert/remove as values change.  The insert/remove callbacks include the include (handles 'sort' issues) and
     * helps maintain value order if copying the data set into another data set.
     */
    class DataSetSubscription {
        /**
         * Subscribes to a dataset to a set of results with callbacks for insert/remove.
         *
         * @param lifetimeManager  the lifetime of the subscription
         * @param sourceDataSet The source data set (typed observable array).
         * @param insertFunc The insert function.
         * @param removeFun The remove function.
         * @param context An opaque context object which is passed to the callback functions as the context parameter.
         * @returns a disposable lifetime Manager on the source data set must be disposed when complete.
         */
        static subscribeDataSet<T>(lifetimeManager: MsPortalFx.Base.LifetimeManager, sourceDataSet: KnockoutObservableArray<T>, insertFunc?: (value: T, index: number, context?: any) => void, removeFunc?: (value: T, index: number, context?: any) => void, context?: any): MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Inserts an item into the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to insert.
         * @param index The index in the data set where to insert the value.
         */
        static insertItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
        /**
         * Removes an item from the destination data set at the given index.
         *
         * @param destinationDataSet The destination data set.
         * @param value The value to remove.
         * @param index The index in the data set where to remove the value.
         */
        static removeItem<T>(destinationDataSet: KnockoutObservableArray<T>, value: T, index: number): void;
    }
}

// FILE: MsPortalFx\Services\Services.GalleryService.d.ts
declare module MsPortalFx.Services.Gallery {
    import FxGalleryService = MsPortalFx.Services.Gallery;
    import AzureResourceManager = MsPortalFx.Azure.ResourceManager;
    let noSubCreateCategoryId: string;
    /**
     * Constants for the gallery.
     */
    module Constants {
        /**
         * Constants for the gallery create parameters.
         */
        let GalleryParametersKey: string;
        /**
         * Constants for the gallery create options.
         */
        let GalleryOptionsKey: string;
    }
    /**
     * The interface for the gallery service view model.
     */
    interface GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @returns A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: GalleryItem): Promise<{
            readonly $schema: "https://catalogapi.azure.com/schemas/2018-02-12/UIDefinition.json#";
            readonly createDefinition: {
                readonly createBlade: {
                    readonly name: string;
                    readonly extension: string;
                };
                readonly startboardPart: {
                    readonly name: string;
                    readonly extension: string;
                };
                readonly startboardPartKeyId: string;
            };
        }>;
    }
    /**
     * The base gallery service view model.
     */
    class BaseGalleryServiceViewModel implements FxGalleryService.GalleryServiceContract {
        /**
         * Runs a gallery create pre-check before launching the create flow. This enables extensions
         * to run a pre-check on the create flow and launch an alternative blade instead.
         *
         * @param galleryItem The gallery item that the create flow belongs to.
         * @returns A Jquery promise that is always resolved, either with the dynamic blade selection
         *      object or null.
         */
        galleryCreatePreCheck(galleryItem: FxGalleryService.GalleryItem): ReturnType<FxGalleryService.GalleryServiceContract["galleryCreatePreCheck"]>;
    }
    /**
     * Gallery item model.
     */
    interface GalleryItem extends StringMap<any> {
        /**
         * The Identity of the gallery item.
         */
        identity: string;
        /**
         * The Publisher name.
         */
        publisher: string;
        /**
         * Gets or sets Publisher display name.
         */
        publisherDisplayName: string;
        /**
         * Gets or sets item name.
         */
        itemName: string;
        /**
         * Gets or sets item type.
         */
        itemType?: string;
        /**
         * The item display name.
         */
        itemDisplayName: string;
        /**
         * The item version.
         */
        version: string;
        /**
         * The item summary.
         */
        summary: string;
        /**
         * The item long summary.
         */
        longSummary?: string;
        /**
         * The item description.
         */
        description: string;
        /**
         * The resource group name the gallery item belongs to.
         */
        resourceGroupName: string;
        /**
         * The uri to the ui definition file.
         */
        uiDefinitionUri: string;
        /**
         * The item artifacts, includes the CSM templates.
         */
        artifacts: Artifact[];
        /**
         * The list of category IDs the gallery item belongs to.
         */
        categoryIds: string[];
        /**
         * The list of screenshot image Uris provided for the item.
         */
        screenshotUris: string[];
        /**
         * The list of Links provided for the item.
         */
        links: LinkProperties[];
        /**
         * The dictionary of icon image Uris by icon type.
         */
        iconFileUris: StringMap<string>;
        /**
         * The dictionary of additional properties to be displayed.
         */
        properties?: StringMap<string>;
        /**
         * Gallery item products.
         */
        products?: AzureResourceManager.GalleryItemProduct[];
        /**
         * The marketing material used to link to other marketing portals.
         */
        marketingMaterial?: MarketingMaterial;
        /**
         * The dictionary of metadata properties to be used by the extension.
         */
        metadata?: StringMap<string>;
        /**
         * Indicates if the package is currently in preview.
         */
        isPreview?: boolean;
    }
    /**
     * The artifact type.
     */
    enum ArtifactType {
        /**
         * Template artifact type, used by CSM.
         */
        template = 0,
        /**
         * Fragment artifact type, used by CSM.
         */
        fragment = 1,
        /**
         * Custom artifact, consumed by the extension ownner.
         */
        custom = 3,
        /**
         * Metadata artifact, consumed by the extension ownner.
         */
        metadata = 4
    }
    /**
     * Gallery artifact model.
     */
    interface Artifact {
        /**
         * The artifact name.
         */
        name: string;
        /**
         * The URI to the artifact file.
         */
        uri: string;
        /**
         * The artifact type.
         */
        type: string;
    }
    /**
     * The artifact type.
     */
    interface MarketingMaterial {
        /**
         * The path to the marketing material.
         */
        path: string;
    }
    /**
     * Link properties model.
     */
    interface LinkProperties {
        /**
         * The id of the link.
         */
        id: string;
        /**
         * The display name of the link.
         */
        displayName: string;
        /**
         * The URI of the link.
         */
        uri: string;
    }
    /**
     * Gallery product (offer) model.
     *
     * @deprecated GalleryItemProduct - Use MsPortalFx.Azure.ResourceManager.GalleryItemProduct instead.
     */
    interface GalleryItemProduct extends AzureResourceManager.GalleryItemProduct {
    }
    /**
     * Gallery offer pricing details model.
     * Used to retrieve the pricing information for a gallery offer.
     *
     * @deprecated GalleryItemOfferPricingDetails - Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPricingDetails instead.
     */
    interface GalleryItemOfferPricingDetails extends AzureResourceManager.GalleryItemOfferPricingDetails {
    }
    /**
     * Gallery offer plan.
     *
     * @deprecated GalleryItemOfferPlan - Use MsPortalFx.Azure.ResourceManager.GalleryItemOfferPlan instead.
     */
    interface GalleryItemOfferPlan extends AzureResourceManager.GalleryItemOfferPlan {
    }
    /**
     * The model for gallery parameters. All values must be strings.
     */
    interface GalleryParameters {
        /**
         * The selected CSM template id.
         */
        selectedTemplateId: string;
        /**
         * The inline deployment template JSON.
         */
        templateJson: string;
        /**
         * The subscription id.
         */
        subscriptionId: string;
        /**
         * The resource group name.
         */
        resourceGroupName: string;
        /**
         * The location/region.
         */
        resourceGroupLocation: string;
        /**
         * An array of the resource types being created.
         * Use JSON.stringify() to convert the string[] into a string.
         */
        resourceProviders: string;
        /**
         * The resource id for the primary resource to be created.
         */
        primaryResourceId?: string;
        /**
         * The deployment name.
         */
        deploymentName?: string;
    }
    /**
     * The base gallery data model. The parameter collection data model on the UI
     * elements (forms, wizards, etc.) used for gallery create should extend this.
     */
    class GalleryDataModel {
        /**
         * The gallery deployment parameters.
         */
        galleryParameters: {
            /**
             * The selected CSM template id.
             */
            selectedTemplateId: KnockoutObservable<string>;
            /**
             * The inline deployment template JSON.
             */
            templateJson: KnockoutObservable<string>;
            /**
             * The subscription id.
             */
            subscriptionId: KnockoutObservable<string>;
            /**
             * The resource group name.
             */
            resourceGroupName: KnockoutObservable<string>;
            /**
             * The location/region.
             */
            resourceGroupLocation: KnockoutObservable<string>;
            /**
             * An array of the resource types being created.
             * Use JSON.stringify() to convert the string[] into a string.
             */
            resourceProviders: KnockoutObservable<string>;
            /**
             * The resource id for the primary resource to be created.
             */
            primaryResourceId: KnockoutObservable<string>;
            /**
             * The deployment name.
             */
            deploymentName: KnockoutObservable<string>;
        };
    }
    /**
     * The context from which a gallery create is kicked off.
     *
     * @deprecated LaunchingContext - Use MsPortalFx.Azure.ResourceManager.LaunchingContext instead.
     */
    interface LaunchingContext extends AzureResourceManager.LaunchingContext {
    }
    /**
     * Gallery item information extracted from the gallery item and passed over to the extension.
     *
     * @deprecated GalleryItemExtract - Use MsPortalFx.Azure.ResourceManager.GalleryItemExtract instead.
     */
    interface GalleryItemExtract extends AzureResourceManager.GalleryItemExtract {
    }
}

// FILE: MsPortalFx\Services\Services.GeneralSettings.d.ts
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    interface IGeneralSettings extends StringMap<KnockoutObservableBase<any>> {
        /**
         * Current theme.
         */
        "fxs-theme": KnockoutReadOnlyObservableBase<FxBase.Themes.Theme>;
    }
    /**
     * Get general settings from Shell
     */
    function getSettings(): Promise<IGeneralSettings>;
}

// FILE: MsPortalFx\Services\Services.Images.d.ts
declare module MsPortalFx.Services.Image {
    /**
     *  Datatype used for rendering SVGs.
     */
    function newImageData(kind: SvgType, options?: any): MsPortalFx.Base.Image;
    /**
     * List of available SVG's.
     */
    const enum SvgType {
        Blank = 0,
        Custom = 1,
        ImageUri = 2,
        ActiveDirectory = 3,
        Add = 4,
        BadgeError = 6,
        BadgeNone = 7,
        BadgeSuccess = 8,
        BadgeWarning = 9,
        Book = 10,
        Bug = 11,
        Check = 12,
        CloudService = 13,
        Controls = 14,
        Cubes = 15,
        Database = 16,
        Delete = 17,
        Discard = 19,
        Download = 20,
        Filter = 22,
        FolderBlank = 23,
        FolderCube = 24,
        FolderWebsite = 25,
        Ftp = 26,
        Gear = 27,
        Grid = 28,
        Guide = 29,
        Heart = 30,
        Hyperlink = 31,
        Info = 32,
        JourneyHub = 33,
        Key = 34,
        Link = 35,
        Location = 36,
        Lock = 37,
        Media = 38,
        MediaFile = 39,
        Mobile = 40,
        Monitoring = 41,
        Notification = 42,
        Pending = 43,
        Person = 44,
        PersonWithFriend = 45,
        Pin = 46,
        Powershell = 47,
        Properties = 48,
        Question = 49,
        Refresh = 51,
        Save = 52,
        Search = 53,
        SearchGrid = 54,
        ShellClose = 55,
        ShellCollapse = 56,
        ShellDefaultBlade = 57,
        ShellMaximize = 58,
        ShellRestore = 59,
        SslCustomDomains = 60,
        Start = 61,
        Stop = 62,
        Storage = 63,
        Store = 64,
        Subtract = 65,
        Swap = 66,
        TeamProject = 67,
        Toolbox = 68,
        Unlock = 69,
        Unpin = 70,
        VirtualMachine = 71,
        Website = 72,
        WebsitePower = 73,
        Canceled = 74,
        Clock = 75,
        Error = 77,
        InfoAlert = 78,
        Paused = 79,
        Queued = 80,
        AddTeamMember = 82,
        Attachment = 83,
        AvatarDefault = 84,
        AvatarUnknown = 85,
        Backlog = 86,
        BacklogPoly = 87,
        BadgePending = 88,
        BadgeCanceled = 89,
        BadgeDisabled = 90,
        BadgeUnknown = 91,
        BillingHub = 92,
        Builds = 93,
        Code = 94,
        CodePoly = 95,
        Commit = 96,
        CommitPoly = 97,
        Disable = 98,
        Edit = 99,
        Favorite = 101,
        File = 102,
        GearFlat = 103,
        GetMoreLicense = 104,
        GetStarted = 105,
        Go = 108,
        History = 109,
        Inactive = 110,
        Log = 112,
        Pause = 113,
        Postpone = 114,
        Release = 115,
        Request = 116,
        Retain = 117,
        Scale = 118,
        Tasks = 119,
        Triangle = 120,
        Upload = 121,
        UnknownBadge = 122,
        CreateHub = 125,
        BrowseHub = 126,
        HomeHub = 127,
        JourneysHub = 128,
        AlertsHub = 129,
        Help = 130,
        BadgeStopped = 131,
        Connect = 132,
        Disconnect = 133,
        PolyAppInsights = 135,
        PolyAvailabilitySet = 136,
        PolyBackup = 137,
        PolyBrowser = 138,
        PolyCustomDomain = 139,
        PolyGlobe = 140,
        PolyIpAddress = 141,
        PolyLaunchPortal = 142,
        PolyLoadBalancer = 143,
        PolyLoadTest = 144,
        PolyLog = 145,
        PolyLogDiagnostics = 146,
        PolyLogStreaming = 147,
        PolyNetworkInterfaceCard = 148,
        PolyResourceDefault = 149,
        PolyResourceLinked = 150,
        PolyServerFarm = 151,
        PolySqlDataBaseServer = 152,
        PolyTfsVcRepository = 153,
        PolyWebHosting = 154,
        PolyWebsiteStaging = 155,
        PolyWebTest = 156,
        Redo = 157,
        ShellChevron = 158,
        Tools = 159,
        Wrench = 160,
        AzureQuickstart = 161,
        Publish = 162,
        PolyAutomation = 164,
        PolySqlDatabase = 165,
        PolyTrafficManager = 166,
        PolyWebEnvironment = 167,
        PolyWebJobs = 168,
        ShellDots = 169,
        BadgeErrorOutline = 170,
        BadgeInfoOutline = 171,
        BadgeSuccessOutline = 172,
        BadgeWarningOutline = 173,
        DownloadFlat = 174,
        BadgeStoppedOutline = 175,
        Ellipsis = 176,
        PolyClearDBDatabase = 178,
        PolyResourceGroup = 179,
        PolyWorkflow = 180,
        LogoBitbucket = 181,
        LogoDropbox = 185,
        LogoGit = 187,
        LogoGitHub = 189,
        LogoVisualStudio = 191,
        MonitoringFlat = 193,
        PolyCertificate = 194,
        PolyClock = 195,
        PolyControlsHorizontal = 196,
        PolyInputOutput = 197,
        PolyModule = 198,
        PolyPowerUp = 199,
        PolySupport = 200,
        PolyTrafficManagerDisabled = 201,
        PolyTrafficManagerEnabled = 202,
        PolyVersions = 203,
        TrendDown = 204,
        TrendUp = 205,
        Variables = 206,
        PolyResourceGroupList = 208,
        BadgeUnknownOutline = 209,
        HeartPulse = 211,
        LogoExternalRepositoryBox = 212,
        PolyDevConsole = 213,
        PolyProductionReadyDb = 214,
        PolyWebSlots = 215,
        PowerUp = 216,
        GuideFlat = 218,
        Support = 219,
        ShellCornerCheck = 221,
        PolyGlobeError = 222,
        PolyGlobeSuccess = 223,
        PolyGlobeWarning = 224,
        InfoFlat = 225,
        Signout = 226,
        LaunchCurrent = 227,
        Feedback = 228,
        LogoRedis = 229,
        PolyCache = 230,
        PolyBlobBlock = 231,
        PolyBlobPage = 232,
        PolyStorageContainer = 233,
        PolyStorageQueue = 234,
        PolyTable = 235,
        WebHostingPlan = 236,
        PolyExtensions = 237,
        BadgeUpdateOutline = 238,
        PolyBranch = 240,
        PolyChart = 241,
        PolyDiscs = 244,
        PolyVirtualNetwork = 245,
        Tags = 246,
        ShellGear = 247,
        SearchFlat = 248,
        PolyCounter = 250,
        PolyProcessExplorer = 251,
        BadgeFailed = 252,
        BadgeFailedOutline = 253,
        PolyFile = 254,
        PolyFiles = 255,
        PolyImage = 256,
        TripleArrow = 257,
        LogoMicrosoftSquares = 258,
        ArrowDown = 260,
        ArrowLeft = 261,
        ArrowRight = 262,
        ArrowUp = 263,
        Columns = 264,
        FolderAlternate = 265,
        FlatKey = 266,
        Mail = 267,
        Message = 268,
        Query = 270,
        SaveAll = 271,
        Undo = 272,
        ShellHeaderDots = 273,
        ErrorIcon = 274,
        PolyManagementPortal = 276,
        LogoChannel9 = 277,
        LogoStackOverflow = 278,
        Diagnostics = 279,
        PolySSD = 280,
        Star = 283,
        Trash = 284,
        Globe = 285,
        CaretDown = 286,
        CaretUp = 287,
        ResourceRole = 288,
        ShellMinimize = 289,
        PolyStorageAzureFiles = 290,
        PolyPower = 291,
        BadgeCritical = 292,
        BadgeCriticalOutline = 293,
        Preview = 294,
        LoadingEllipsisSquare = 295,
        Customize = 296,
        Collapse = 298,
        Expand = 299,
        PolyApiManagement = 301,
        PolyBizTalk = 302,
        PolyCdn = 303,
        PolyEventHub = 304,
        PolyMobileEngagement = 305,
        PolyOperationalInsights = 306,
        PolyRemoteApp = 307,
        PolyScheduler = 308,
        PolyServiceBus = 309,
        PolySiteRecovery = 310,
        PolyStorSimple = 311,
        PolyStreamAnalytics = 312,
        Hamburger = 313,
        ShellCustomize = 314,
        BadgeErrorSolid = 315,
        BadgeInfoSolid = 316,
        BadgeWarningSolid = 317,
        AddTile = 318,
        SmileyHappy = 319,
        SmileyNeutral = 320,
        SmileySad = 321,
        ShellMiniSize = 322,
        ShellFullscreen = 323,
        ShellShare = 324,
        ShellTrashOutline = 327,
        LoadingSpinner = 328,
        PolyOwl = 332,
        Console = 333,
        AzurePortal = 334,
        Home = 335,
        PolyAdvisor = 336,
        Functions = 337,
        Copy = 338,
        Insert = 339,
        PolyEventGrid = 340,
        Notifications = 342,
        StatusUpsell = 343,
        AllServices = 344,
        DoubleChevron = 345,
        ShellPeekMode = 346,
        ShellExitPeekMode = 347,
        Line = 348,
        FilterRemove = 349,
        PolyDashboard = 350,
        ResourceFlat = 351,
        PolyWorkbooks = 352,
        PolyLogAnalytics = 353,
        Reimage = 354,
        Capture = 355,
        Move = 356,
        PolyCostAlerts = 357,
        PolyCostAnalysis = 358,
        PolyCostBudgets = 359,
        HideItems = 360,
        ShowItems = 361,
        PolyInsights = 362,
        NotificationBell = 363,
        BadgeUnknownSolid = 366,
        CloudUpload = 367,
        ShellContentErrorGeneric = 368,
        ShellContentErrorNotFound = 369,
        ShellContentErrorUnauthorized = 370,
        PolyLearn = 371,
        BadgeUpsell = 372,
        BadgeUpdate = 373,
        BadgeCanceledOutline = 374,
        BadgeDisabledOutline = 375,
        BadgeNoneOutline = 376,
        BadgePendingOutline = 377,
        BadgeUpsellOutline = 378,
        ThemeAzure = 379,
        ThemeBlue = 380,
        ThemeDark = 381,
        ThemeLight = 382,
        Alert = 383,
        QuickStartPoly = 384,
        AllServicesPoly = 385,
        TagsPoly = 386,
        View = 387,
        AddSubscription = 388,
        ManageAccess = 389,
        StudentTools = 390,
        Print = 394,
        Json = 395,
        BlankDashboard = 396,
        Unshare = 397,
        MoveAcrossResourceGroups = 399,
        MoveAcrossSubscriptions = 400,
        MoveAcrossRegions = 401,
        PolySuccessCheckmark = 402,
        PolyAzurePortal = 403,
        AzureGithub = 404,
        OpenInMobile = 405,
        FreeTrialVariant1 = 406,
        FreeTrialVariant2 = 407,
        FreeTrialVariant3 = 408,
        NumberSvgMarker = 899,
        RasterizedSvgMarker = 999
    }
}

// FILE: MsPortalFx\Services\Services.Rpc.d.ts
interface EventHandlerContracts {
    "rpc"?: {
        registerEndPoints(): void;
    };
}
declare module MsPortalFx.Services.Rpc {
    interface EndPointRegistrationOptions {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback.
         * If a falsy value is specified then all extensions are allowed to invoke this callback.
         */
        allowedOrigins: string[];
    }
    /**
     * Registers the given callback with the given callback name. The callback will now be callable over RPC using this name.
     *
     * @param callbackName The callback name.
     * @param callback The callback function.
     */
    function registerCallback(callbackName: string, callback: Function, options?: EndPointRegistrationOptions): void;
    /**
     * Invokes the RPC endpoint with the given callback name in the given extension.
     *
     * @param extensionName The extension name.
     * @param callbackName The callback name.
     * @param args The args of the callback.
     */
    function invokeCallback<T>(extensionName: string, callbackName: string, ...args: any[]): Promise<T>;
    module EventHandler {
        /**
         * A decorator that is used to specify that the annotated class should be used to handle
         * RPC related events originating from the framework.
         *
         * @param contractName The name of the contract to be handled.
         */
        function Decorator<TContractName extends "rpc">(contractName: TContractName): (_: new (...args: any[]) => EventHandlerContracts[TContractName]) => void;
    }
}

// FILE: MsPortalFx\Services\Services.Telemetry.d.ts
/**
 * Telemetry logging facilities.
 */
declare module MsPortalFx.Services {
    import FxBase = MsPortalFx.Base;
    import FxTelemetry = FxBase.Diagnostics.Telemetry;
    import TelemetryEventProcessor = FxTelemetry.TelemetryEventProcessor;
    function getTelemetryEventProcessor(uri?: string, extensionName?: string): TelemetryEventProcessor;
    function getConsoleTelemetryEventProcessor(): TelemetryEventProcessor;
}

// FILE: MsPortalFx\SharedSettings.d.ts
declare module MsPortalFx.Settings {
    /**
     * Interface for shared settings that can be used by other extensions.
     */
    interface SharedSettings {
        links: SharedLinks;
    }
    /**
     * Interface for blade deep links or external links.
     */
    interface SharedLinks {
        /**
         * Link to the account portal.
         */
        accountPortal: string;
        /**
         * Link to the classic portal.
         */
        classicPortal: string;
        /**
         * Link to create support request.
         */
        createSupportRequest: string;
        /**
         * Link to open help and support.
         */
        helpAndSupport: string;
        /**
         * Link to manage support requests.
         */
        manageSupportRequests: string;
        /**
         * Link to submit an idea.
         */
        submitAnIdea: string;
        /**
         * Link to privacy and terms.
         */
        privacyAndTerms: string;
        /**
         * Link to privacy statement.
         */
        privacyStatement: string;
        /**
         * Link to promotional communications manager.
         */
        promotionalCommunicationsManager: string;
        /**
         * Link to learn related resources.
         */
        learnRelatedResources: string;
        /**
         * Link to resource groups overview
         */
        resourceGroupOverview: string;
        /**
         * Link to azure roadmap
         */
        roadmap: string;
        /**
         * Link to time range filter granularity.
         */
        filteringGranularity: string;
    }
    /**
     * Gets the shared settings that are used by other extensions as well
     *
     * @returns The info for the currently signed in user and directory.
     */
    function getSharedSettings(): Promise<MsPortalFx.Settings.SharedSettings>;
}

// FILE: TypeReferences.d.ts

// FILE: MsPortalFx\UI\UI.AssetManager.d.ts
declare module MsPortalFx.UI.AssetManager {
    /**
     * Notifies the shell that an asset has been deleted.
     *
     * @param assetType Type of the asset that was deleted.
     * @param assetId Identifier of the asset that was deleted.
     * @param extensionName Optional extension name of the asset that was deleted.
     */
    function notifyAssetDeleted(assetType: string, assetId: any, extensionName?: string): void;
    /**
     * Notifies the shell that one or more assets has been deleted.
     *
     * @param asset An array of asset triplets.
     */
    function notifyAssetDeletedBulk(assets: MsPortalFx.Assets.AssetTriplet[]): void;
    /**
     * Notifies the shell that one or more resources has been deleted.
     *
     * @param resourceId A single or an array of resource IDs.
     */
    function notifyResourceDeleted(resourceId: string | string[]): void;
}

// FILE: MsPortalFx\UI\UI.Feedback.d.ts
declare module FxImpl {
    interface OpenFeedbackPaneOptions {
        feedbackType: FeedbackType;
        resourceId?: string;
        data?: any;
    }
    const enum FeedbackType {
        Default = 0,
        ResourceDeleted = 1
    }
    /**
     * The RPC endpoint for requesting  feedback by opening the context pane.
     */
    const feedbackEndPoint: Rpc.ActionEndPointDefinition<OpenFeedbackPaneOptions>;
}

// FILE: MsPortalFx\UI\UI.NotificationManager.d.ts
declare module FxImpl.NotificationManager {
    import Rpc = FxImpl.Rpc;
    /**
     * Interface for the parameters to be used with the addNotificationEndPoint.
     */
    interface AddNotificationParameters {
        notifications: MsPortalFx.UI.NotificationManager.Notification[];
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface AddNotification2Parameters {
        id: string;
        name: string;
        status: string;
        subStatus: string;
        assetId: any;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addNotification2EndPoint.
     */
    interface UpdateNotificationParameters {
        id: string;
        propertyName: string;
        propertyValue: any;
    }
    /**
     * Interface for server event.
     */
    interface ServerEvent {
        operationName: string;
        source: string;
        status: string;
        subStatus: string;
        correlationId: string;
        assetId: string;
        timestamp: Date;
        properties: StringMap<string>;
    }
    /**
     * Interface for the parameters to be used with the addServerEventsEndPoint.
     */
    interface AddServerEventsParameters {
        serverEvents: ServerEvent[];
    }
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    let addNotificationsEndPoint: Rpc.ActionEndPointDefinition<AddNotificationParameters>;
    /**
     * The RPC endpoint that lets extensions send notifications.
     */
    let addNotification2EndPoint: Rpc.ActionEndPointDefinition<AddNotification2Parameters>;
    /**
     * The RPC endpoint that lets extensions update a notification.
     */
    let updateNotificationEndPoint: Rpc.ActionEndPointDefinition<UpdateNotificationParameters>;
    /**
     * The RPC endpoint that lets hubsextension send server events.
     */
    let addServerEventsEndPoint: Rpc.ActionEndPointDefinition<AddServerEventsParameters>;
    /**
     * Test dispatcher to use when if required when setting up senders.
     */
    let rpcClient: Rpc.Client;
}
declare module MsPortalFx.UI.NotificationManager {
    /**
     * The notification class.
     */
    class Notification2 {
        /**
         * The notification name.
         */
        private _name;
        /**
         * The autogenerated notification id.
         */
        private _id;
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param name The name of the notification.
         */
        constructor(name: string);
        /**
         * Creates a new notification. This should not be called directly, please use the create() method to create a new notification.
         *
         * @param state The status and substatus of the notification.
         * @param assetId The asset id associated with the notification. It is only used if an asset type is specified for the notification.
         * @param properties The notification properties. This is used to format the description.
         */
        raise(state: {
            status: string;
            subStatus?: string;
        }, assetId?: any, properties?: StringMap<string>): void;
        /**
         * Updates the correlation id on the notification.
         *
         * @param correlationId The correlation id.
         */
        updateCorrelationId(correlationId: string): void;
        /**
         * Updates the progress of the notification. This is only shown when a progress notification is being shown.
         *
         * @param percentComplete The percent complete.
         */
        reportProgress(percentComplete: number): void;
    }
    /**
     * Creates a new notification with the specified name.
     *
     * @param notificationName The notification name defined in PDL.
     * @returns Notification object.
     */
    function create(notificationName: string): MsPortalFx.UI.NotificationManager.Notification2;
    /**
     * The notification state.
     */
    enum NotificationState {
        /**
         * An information notification
         */
        Information = 0,
        /**
         * A warning notification
         */
        Warning = 1,
        /**
         * An error notification
         */
        Error = 2,
        /**
         * An in progress notification
         */
        InProgress = 3,
        /**
         * A success notification
         */
        Success = 4
    }
    /**
     * The notification client details are properties on a notification which are client-local only and not stored
     * on the server. These properties should NOT be set when creating and adding notifications to the system.
     */
    interface NotificationClientDetails {
        /**
         * The asset owner for the notification.
         */
        assetOwner?: string;
        /**
         * The asset type for the notification.
         */
        assetType?: string;
        /**
         * The blade name override for the notification.
         */
        bladeName?: string;
        /**
         * The blade extension override for the notification.
         */
        bladeExtension?: string;
    }
    /**
     * The notification model.
     */
    class Notification {
        /**
         * The notification source which is a globally unique identifier.
         */
        source: string;
        /**
         * The notification event type. The combination of source.eventtype will uniquely identify a notification.
         */
        eventType: string;
        /**
         * The notification state - Information, Warning, Error, InProgress.
         */
        state: NotificationState;
        /**
         * The notification label. This should be localized by the formatter.
         */
        label: string;
        /**
         * The notification timestamp.
         */
        timestamp: Date;
        /**
         * The notification description. This will have a default message but this can be overridden by the
         * message provided by the extension.
         */
        description: string;
        /**
         * A list of arguments used to string.format() the description.
         * When the extension provides a description, these arguments will be used to format the description.
         */
        descriptionArgs: string[];
        /**
         * The subscription Id associated with the notification.
         */
        subscriptionId: string;
        /**
         * The operation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        operationId: string;
        /**
         * The correlation Id of the operation associated with the notification. Any new notification that is added
         * with an existing operation id, will be updated instead of creating a new notification.
         */
        correlationId: string;
        /**
         * The percentage of operation completed. If this value exists, a deterministic progress bar is shown.
         * If not, a non-deterministic progress icon is shown with a description.
         */
        percentOperationComplete: number;
        /**
         * The asset id associated with the notification. This will be used to launch the resource blade when the
         * notification is clicked.
         */
        assetId: any;
        /**
         * Flag indicating if the notification is a recommendation.
         */
        isRecommendation: any;
        /**
         * Additional event details.
         */
        eventDetails: any;
        /**
         * Additional properties.
         */
        additionalProperties: any;
        /**
         * The client details are the client-side details for the notification which are not stored. These properties
         * should NOT be set when creating and adding notifications to the system.
         */
        clientDetails: NotificationClientDetails;
        /**
         * Creates a new notification.
         *
         * @param source The notification source. This will be a unique identifier for the source of this notification.
         * @param eventType The notification event type.
         * @param state The notification state. Can be information, warning, error or inprogress.
         * @param descriptionArgs The description arguments used to format this notification.
         * @param subscriptionId The subscription id of the notification.
         * @param operationId The operation id, if the notification is associated with an operation.
         * @param percentOperationComplete The %age of operation completed, used only if this operation state is in progress.
         * @param assetId The ID of the asset associated with this notification.
         */
        constructor(source: string, eventType: string, state: NotificationState, descriptionArgs?: string[], subscriptionId?: string, operationId?: string, percentOperationComplete?: number, assetId?: any);
    }
    /**
     * Adds a single notification to the UI.
     *
     * @param notification The notification to add.
     */
    function addNotification(notification: Notification): void;
    /**
     * Adds notifications to the UI.
     *
     * @param notifications The list of notifications to add.
     */
    function addNotifications(notifications: Notification[]): void;
}

// FILE: MsPortalFx\UniqueIdUtility.d.ts
declare module FxImpl {
    /**
     * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
     *
     * @param prefix An optional prefix for the GUID.
     * @param omitDashes Do not include dashes between the GUID sections.
     * @returns New GUID.
     */
    function createGuid(prefix?: string, omitDashes?: boolean): string;
}

// FILE: MsPortalFx\Util\ColorUtil.d.ts
declare module MsPortalFx.ColorUtil {
    enum AllRawColorCode {
        "Hex_fcd116" = 0,
        "Hex_eb3c00" = 1,
        "Hex_ba141a" = 2,
        "Hex_b4009e" = 3,
        "Hex_442359" = 4,
        "Hex_002050" = 5,
        "Hex_0072c6" = 6,
        "Hex_008272" = 7,
        "Hex_007233" = 8,
        "Hex_7fba00" = 9,
        "Hex_a0a5a8" = 10,
        "Hex_fff100" = 11,
        "Hex_ff8c00" = 12,
        "Hex_e81123" = 13,
        "Hex_ec008c" = 14,
        "Hex_68217a" = 15,
        "Hex_00188f" = 16,
        "Hex_00bcf2" = 17,
        "Hex_00b294" = 18,
        "Hex_009e49" = 19,
        "Hex_bad80a" = 20,
        "Hex_bbc2ca" = 21,
        "Hex_fffc9e" = 22,
        "Hex_ffb900" = 23,
        "Hex_dd5900" = 24,
        "Hex_f472d0" = 25,
        "Hex_9b4f96" = 26,
        "Hex_4668c5" = 27,
        "Hex_6dc2e9" = 28,
        "Hex_00d8cc" = 29,
        "Hex_55d455" = 30,
        "Hex_e2e584" = 31,
        "Hex_d6d7d8" = 32,
        "Hex_807900" = 33,
        "Hex_804600" = 34,
        "Hex_740912" = 35,
        "Hex_760046" = 36,
        "Hex_34113d" = 37,
        "Hex_000c48" = 38,
        "Hex_005e79" = 39,
        "Hex_084c41" = 40,
        "Hex_063d20" = 41,
        "Hex_3d460a" = 42,
        "Hex_32383f" = 43,
        "Hex_bfb500" = 44,
        "Hex_bf6900" = 45,
        "Hex_ae0d1a" = 46,
        "Hex_b10069" = 47,
        "Hex_4e195c" = 48,
        "Hex_00126b" = 49,
        "Hex_008db5" = 50,
        "Hex_00856f" = 51,
        "Hex_0f5b2f" = 52,
        "Hex_8ba208" = 53,
        "Hex_464f59" = 54,
        "Hex_fcf37e" = 55,
        "Hex_ffba66" = 56,
        "Hex_f1707b" = 57,
        "Hex_f466ba" = 58,
        "Hex_a47aaf" = 59,
        "Hex_6674bc" = 60,
        "Hex_66d7f7" = 61,
        "Hex_66d1bf" = 62,
        "Hex_66c592" = 63,
        "Hex_d6e86c" = 64,
        "Hex_8f9ca8" = 65,
        "Hex_fffccc" = 66,
        "Hex_ffe8cc" = 67,
        "Hex_facfd3" = 68,
        "Hex_fbcce8" = 69,
        "Hex_e1d3e4" = 70,
        "Hex_ccd1e9" = 71,
        "Hex_ccf2fc" = 72,
        "Hex_ccf0ea" = 73,
        "Hex_ccecdb" = 74,
        "Hex_f0f7b2" = 75,
        "Hex_63707e" = 76,
        max = 77
    }
    enum ColorCode {
        "a1" = 0,
        "b1" = 1,
        "c1" = 2,
        "d1" = 3,
        "e1" = 4,
        "f1" = 5,
        "g1" = 6,
        "h1" = 7,
        "i1" = 8,
        "j1" = 9,
        "k1" = 10,
        "a0" = 11,
        "b0" = 12,
        "c0" = 13,
        "d0" = 14,
        "e0" = 15,
        "f0" = 16,
        "g0" = 17,
        "h0" = 18,
        "i0" = 19,
        "j0" = 20,
        "k0" = 21,
        "a2" = 22,
        "b2" = 23,
        "c2" = 24,
        "d2" = 25,
        "e2" = 26,
        "f2" = 27,
        "g2" = 28,
        "h2" = 29,
        "i2" = 30,
        "j2" = 31,
        "k2" = 32,
        "a0s2" = 33,
        "b0s2" = 34,
        "c0s2" = 35,
        "d0s2" = 36,
        "e0s2" = 37,
        "f0s2" = 38,
        "g0s2" = 39,
        "h0s2" = 40,
        "i0s2" = 41,
        "j0s2" = 42,
        "k0s2" = 43,
        "a0s1" = 44,
        "b0s1" = 45,
        "c0s1" = 46,
        "d0s1" = 47,
        "e0s1" = 48,
        "f0s1" = 49,
        "g0s1" = 50,
        "h0s1" = 51,
        "i0s1" = 52,
        "j0s1" = 53,
        "k0s1" = 54,
        "a0t1" = 55,
        "b0t1" = 56,
        "c0t1" = 57,
        "d0t1" = 58,
        "e0t1" = 59,
        "f0t1" = 60,
        "g0t1" = 61,
        "h0t1" = 62,
        "i0t1" = 63,
        "j0t1" = 64,
        "k0t1" = 65,
        "a0t2" = 66,
        "b0t2" = 67,
        "c0t2" = 68,
        "d0t2" = 69,
        "e0t2" = 70,
        "f0t2" = 71,
        "g0t2" = 72,
        "h0t2" = 73,
        "i0t2" = 74,
        "j0t2" = 75,
        "k0t2" = 76,
        max = 77
    }
    /**
     * Returns the RawColorString (#0072c6) that can be used in the css or less from the index of the color code.
     * Note: AllRowColorCode["Hex_fcd116"] === 0 and AllRowColorCode[0] === "Hex_fcd116"
     * For example:
     *   getRawColorString(ColorCode.a1) will return "#fcd116".
     * This is same as
     *   getRowColorString(AllRawColorCode.Hex_fcd116) will return "#fcd116".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @returns Css style of color hex code string. For example: "#fcd116".
     */
    function getRawColorString(colorIndex: number): string;
    /**
     * Returns the ColorCode string ("a1") base on the index number.
     * Note: ColorCode["a1"] === 0 and ColorCode[0] === "a1"
     * For example:
     *   getColorCodeString(ColorCode.a1) will return "a1".
     * This is same as
     *   getColorCodeString(AllRawColorCode.Hex_fcd116) will return "a1".
     * This is because both ColorCode.a1 and AllRawColorCode.Hex_fcd116 both are 0.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number or numeric number.
     * @returns Ux string code. For example: "a1".
     */
    function getColorCodeString(colorIndex: number): string;
    /**
     * Returns the RawColorString (0072c6) that can be use in the data coding.
     * Handles all different possible form of hex color code and format of string.
     * For example:
     *   getRawColorCode("fcd116") will return "fcd116".
     *   getRowColorString("#fcd116") will return "fcd116".
     *   getRowColorString("Hex_fcd116") will return "fcd116".
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @returns Css color hex code string. For example: "fcd116".
     */
    function getRawColorCode(rawColorData: string): string;
    /**
     * Returns the RawColorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getRawColorIndex("fcd116") will return 0.
     *   getRowColorString("#fcd116") will return 0.
     *   getRowColorString("Hex_fcd116") will return 0.
     *   If not in the above format, it will return null.
     *
     * @param rawColorData String data of any hex string code.
     * @returns Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getRawColorIndex(rawColorData: string): number;
    /**
     * Returns the colorIndex (0 base index) that can be used in for indexing ColorCode or RawColorCode.
     * For example:
     *   getColorIndex("fcd116") will return 0.
     *   getColorIndex("#fcd116") will return 0.
     *   getColorIndex("Hex_fcd116") will return 0.
     *   getColorIndex("a1") will return 0.
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code.
     * @returns Index for either Enum ColorCode or RawColorCode. For example: 0. This number will be less than 77 (max) if not, returns null.
     */
    function getColorIndex(colorData: string): number;
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSet("fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("#fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("Hex_fcd116") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSet("a1") will return ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *
     *   If invalid data is given, it will return null.
     *
     * @param colorData String data of any hex string code. The can be "fcd116", "#fcd116", "Hex_fcd116", or "a1".
     * @param rawColorData Optional boolean indicates that if you want to get the rowColorData. If set, this function returns ["#807900","#bfb500","fff100", "#fcf37e", "#fffccc"] instead of ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     * @returns Array of the color code. Typicically. ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     */
    function getColorCodeTintSet(colorData: string, rawColorData?: boolean): string[];
    /**
     * Returns the Array of the Tint set corresponding to this color code.
     * For example:
     *   getColorCodeTintSetIndex(0) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(11) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *   getColorCodeTintSetIndex(22) will return [33,44, 11, 55, 66] which corresponds to ["a0s2","a0s1","a0", "a0t1", "a0t2"].
     *      ....   (0, 11, 22, 33, 44, 55, 66) all return the same set because they are same color system in MsColorWheel.
     *   If invalid data is given, it will return null.
     *
     * @param colorIndex Index of the color. Can be either ColorCode Enum or AllRowColorCode number.
     * @returns Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getColorCodeTintSetIndex(colorIndex: number): number[];
    /**
     * Returns the main color wheel color (33) colors. This exclude the set of Tint/Shade.
     *
     * @returns Array of the color code index. Typicically. [0, 1, 2, ..., 32]
     */
    function getAllColorCodeIndexes(): number[];
    /**
     * Returns the Array of ms color wheel color set with a start point. This is very useful for color wheel.
     * For example:
     *   getRotatedArray<number>([33,44, 11, 55, 66], 2) will return [11, 55, 66, 33, 44].
     *
     * @param data Array of color number, code, represents a color wheel.
     * @param start Index of start point.
     * @returns Array of the color code index. Typicically. [33, 44, 11, 55, 66]
     */
    function getRotatedArray<T>(data: T[], start?: number): T[];
    /**
     * Returns the gradient color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code index.
     */
    function getGradientColorCodeIndexes(start?: number): number[];
    /**
     * Returns the rainbow color wheel color (27) colors index. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Line Chart where the colors DO overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code index.
     */
    function getRainbowColorCodeIndexes(start?: number): number[];
    /**
     * Returns the gradient color wheel color (27) colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code string array ["#fcd116", .....]
     */
    function getRawGradientColorCode(start?: number): string[];
    /**
     * Returns the gradient color wheel color (27) raw colors string. This excludes the set of Tint/Shade.
     * Ux specifies this to be used as default for the Donut and BarChart where the colors don't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code string array [a0,a1,b2,b0,c2,b1,c0,c1,d0,d1,e2,e0,e1,f1,f0,g1,g0,g2,h2,h0,h1,i1,i0,i2,j1,j0,j2,]
     */
    function getRainbowColorCode(start?: number): string[];
    /**
     * Returns the rainbow color wheel color (27) colors string.  This exclude the set of Tint/Shade.
     * Ux specifies this to used as default for the Donut and barChart where the color doesn't overlap with each other.
     *
     * @param start Index of start point of this 27 color.
     * @returns Array of the color code string array ["#fcd116", .....]
     */
    function getRawRainbowColorCode(start?: number): string[];
}

// FILE: MsPortalFx\Util\DateUtil.d.ts
declare module MsPortalFx.DateUtil {
    /**
     * Used to specify date/time range in which user can select date/time.
     */
    class DateTimeRange {
        /**
         * Start date/time in local timezone.
         */
        startDateTime: KnockoutObservable<Date>;
        /**
         * End date/time in local timezone.
         */
        endDateTime: KnockoutObservable<Date>;
        /**
         * Creates a DateTimeRange object
         *
         * @param startDateTime The start date/time in local timezone
         * @param endDateTime The end date/time in local timezone
         */
        constructor(startDateTime?: Date, endDateTime?: Date);
    }
}

// FILE: MsPortalFx\Util\UnitConversion.d.ts
declare module MsPortalFx.UnitConversion {
    import FxUnitConversionUtil = MsPortalFx.UnitConversionUtil;
    import FxIntl = MsPortalFx.Intl;
    enum Unit {
        None = 0,
        Percentage = 1,
        Bytes = 2,
        Kilobytes = 3,
        Megabytes = 4,
        Gigabytes = 5,
        Terabytes = 6,
        Petabytes = 7,
        BytesPerDay = 8,
        BytesPerHour = 9,
        BytesPerMinute = 10,
        BytesPerSecond = 11,
        KilobytesPerSecond = 12,
        MegabytesPerSecond = 13,
        GigabytesPerSecond = 14,
        TerabytesPerSecond = 15,
        PetabytesPerSecond = 16,
        Count = 17,
        Thousand = 18,
        Million = 19,
        Billion = 20,
        Trillion = 21,
        MicroSeconds = 22,
        MilliSeconds = 23,
        Seconds = 24,
        Minutes = 25,
        Hours = 26,
        Days = 27,
        CountPerDay = 28,
        CountPerHour = 29,
        CountPerMinute = 30,
        CountPerSecond = 31,
        ThousandPerSecond = 32,
        MillionPerSecond = 33,
        BillionPerSecond = 34,
        TrillionPerSecond = 35,
        Bytes_SI = 36,
        Kilobytes_SI = 37,
        Megabytes_SI = 38,
        Gigabytes_SI = 39,
        Terabytes_SI = 40,
        Petabytes_SI = 41,
        BytesPerDay_SI = 42,
        BytesPerHour_SI = 43,
        BytesPerMinute_SI = 44,
        BytesPerSecond_SI = 45,
        KilobytesPerSecond_SI = 46,
        MegabytesPerSecond_SI = 47,
        GigabytesPerSecond_SI = 48,
        TerabytesPerSecond_SI = 49,
        PetabytesPerSecond_SI = 50
    }
    /**
     * Returns the most appropriate unit for formatting the value.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @returns The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @returns The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @returns The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and auto converts to appropriate scaled unit and returns a globalized string with converted value and scaled unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the originalUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @returns The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValue(value: number, originalUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * This API takes in a value of specified unit and converts to the specified target unit and returns a globalized string with converted value and target unit.
     *
     * @param value The original value to be converted.
     * @param originalUnit The original unit of the value.
     * @param toUnit The target unit to which the value should be converted.
     * @param numberFormat Optional parameter specifying the globalized number format options for min/max precision. By default the API truncates to 2 decimal places.
     * @param displayFormat Optional display format to specify the converted value and scaled unit.
     *                      {0} is converted value
     *                      {1} is the string representation of target unit
     *                      default format is "{0} {1}". Eg. 256 KB
     * @param defaultZeroUnit Optionally specify the unit to display for 0 value. By default the 0 value will show the toUnit.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @returns The globalized string representation of auto scaled value and unit.
     */
    function getConvertedValueForTargetUnit(value: number, originalUnit: Unit, toUnit: Unit, numberFormat?: FxIntl.NumberFormatOptions, displayFormat?: string, defaultZeroUnit?: Unit, displaySIUnit?: boolean): string;
    /**
     * Convert MsPortal Unit to internal Unit which has expanded enumaration values.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversion.Unit
     * @returns MsPortalFx.UnitConversionUtil.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertUnitToInternalConversionUnit(unit: Unit): FxUnitConversionUtil.Unit;
    /**
     * Converts the internal ConversionUnitUtil's Unit to public Unit.
     * MsPortal.UnitConversion.Unit have to keep the 0 base enum with no gap due to .d.ts generation which remove the number from the enum.
     * As result, MsPortal.UnitConversion.Unit should not be directly pass into the UnitConversionUtil routines.
     *
     * @param MsPortalFx.UnitConversionUtil.Unit
     * @returns MsPortalFx.UnitConversion.Unit
     *
     * Note this odd looking code leverage TypeScript enum speciality.  TypeScript Enum setup 2 map
     *  map 1
     *   MsPortalFx.UnitConversion.Unit.Count === 17
     *   this is equvalient to
     *   MsPortalFx.UnitConversion.Unit["Count"] === 17
     *
     *   The reverse map: NumberMap.
     *   MsPortalFx.UnitConversion.Unit[17] === "Count"
     * This code leverage 2nd map.  In the above example, unitString get "Count", then we use utilUnit["Count"] to get the viva enum.
     */
    function _convertInternalConversionUnitToUnit(unit: FxUnitConversionUtil.Unit): Unit;
}

// FILE: MsPortalFx\Util\UnitConversionUtil.d.ts
declare module MsPortalFx.UnitConversionUtil {
    /**
     * Returns the most appropriate unit for formatting the value. Used internally by various controls.
     *
     * @param value The value to find the unit.
     * @param originalUnit The original unit of the value.
     * @returns The unit allowing to display the value shortly.
     */
    function getAppropriateUnit(value: number, originalUnit: Unit, defaultZeroUnit?: Unit): Unit;
    /**
     * Return the conversion factor from one unit to another.  Used internally by various controls.
     *
     * @param orignalUnit The original unit.
     * @param unit The unit to be converted to.
     * @returns The conversion factor used to divide from the originalUnit to the unit.
     */
    function getConversionFactor(originalUnit: Unit, toUnit: Unit): number;
    /**
     * Returns a string representation of the Unit enum.  Used internally by various controls.
     *
     * @param unit The unit to be represented with a string.
     * @param displaySIUnit Optionally specify that SI equivalent unit string should be returned for binary unit. Eg. GB instead of GiB.
     * @returns The string representation.
     */
    function toString(unit: Unit, displaySIUnit?: boolean): string;
}
declare namespace MsPortalFx.UnitConversionUtil {
    const Unit: typeof import("Fx/Units").Unit;
    type Unit = import("Fx/Units").Unit;
}
declare namespace FxImpl.UnitConversionUtil {
    const higherByteOffset: number;
    const perTimeBit: number;
    const UnitType: typeof import("FxInternal/Units").UnitType;
    type UnitType = import("FxInternal/Units").UnitType;
}

// FILE: MsPortalFx\Utilities.d.ts
declare module FxImpl {
    /**
     * Internal implementation of memoizePromise.
     * Do not use.
     * Please use memoizePromise from the "Fx" module instead.
     */
    function memoizePromise<T, TResult extends Promise<any>>(callback: (input?: T) => TResult, options?: {
        cacheFactory?: MsPortalFx.MemoizeCacheFactory<T, TResult>;
        onError?: MsPortalFx.MemoizeOnError<T, TResult>;
    }): MsPortalFx.MemoizedV<T, TResult>;
}
declare module MsPortalFx {
    const uncurryThis: (f: (...args: any[]) => any) => ((...args: any[]) => any);
    const applyCall: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    const applyUncurry: (f: (...args: any[]) => any, target: any, args: any[] | IArguments) => any;
    function isEmptyObject(obj: any): obj is Object;
    /**
     * Shortcut for Object.keys(obj || {}).length.
     *
     * @returns number.
     */
    function keysLength(obj: Object): number;
    /**
     * Determines whether an object has properties on it.
     * Will return true for the following inputs: [], {}, "", 0, 1, true, false, new Date(), function() {}.
     * Will return false for the following inputs: [1], {a:1}, "123".
     *
     * @returns boolean.
     */
    function isEmpty(obj: Object): boolean;
    /**
     * Detect a value is Disposable.
     *
     * @param value The value to check against value.dispose is a function.
     * @returns boolean.
     */
    function isDisposable(value: any): value is {
        dispose: Func<void>;
    };
    /**
     * Detect a value is null.
     *
     * @param value The value to check against null.
     * @returns boolean.
     */
    function isNull(value: any): boolean;
    /**
     * Detect a value is undefined.
     *
     * @param value The value to check against undefined.
     * @returns boolean.
     */
    function isUndefined(value: any): boolean;
    /**
     * Indicates whether the specified object is not null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function notNullOrUndefined(value: any): boolean;
    /**
     * Checks if the string is null, undefined or whitespace.
     *
     * @param  value The target string.
     * @returns true if the string is null, undefined or whitespace; otherwise, false.
     */
    function isNullOrWhiteSpace(value: string): boolean;
    /**
     * Checks if the number is valid and not NaN, null or undefined.
     *
     * @param  value The target number.
     * @returns true if the number is valid and not NaN, null or undefined; otherwise, false.
     */
    function isNumeric(value: number): value is number;
    interface IMap<K, V> extends Map<K, V> {
        clear(): void;
        delete(key: K): boolean;
        forEach(callbackfn: (value: V, index: K, map: IMap<K, V>) => void, thisArg?: any): void;
        has(key: K): boolean;
        get(key: K): V;
        set(key: K, value: V): this;
        size: number;
    }
    var Map: {
        new <K, V>(): IMap<K, V>;
    };
    interface Memoized<TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (): TResult;
        /**
         * Disposes the memoized results.
         */
        dispose(): void;
        clear(): void;
    }
    interface MemoizedV<T, TResult> {
        /**
         * Executes the memoized calback.
         *
         * @returns The memoized result.
         */
        (input?: T): TResult;
        /**
         * Dispose/Clear the cache the memoized results.
         */
        dispose(): void;
        clear(): void;
        /**
         * Delete particular Memoized Value.
         */
        delete(input: T): boolean;
        /**
         * access the map
         */
        map(): Map<T, any>;
    }
    interface MemoizeCallback<T, TR> {
        (input?: T): TR;
    }
    interface MemoizeOnError<T, TR> {
        (err: Error, input: T, map: IMap<T, TR>): boolean;
    }
    interface MemoizeCacheFactory<T, TR> {
        (): IMap<T, TR>;
    }
    interface MemoizeOption<T, TResult> {
        checkResult?: (result: TResult, input: T, map: IMap<T, TResult>) => boolean;
        noDebugCheck?: boolean;
        cacheFactory?: MemoizeCacheFactory<T, TResult>;
        onError?: MemoizeOnError<T, TResult>;
    }
    /**
     * Memoize the specified callback.
     *
     * @param callback The function to memoize.
     * @param checkResult Optional return true to keep the result in the map.  If missing, it will remember it
     * @param cacheFactory to provide the call back for create the Map.  Note Map have to support ES6 Map API. and support "undefined" if your input can be "undefined"
     * @param onError provide the onError handler, it will allow you to decide what to do with Error
     * @returns The memoized function call.
     */
    const memoize: <T, TResult>(callback: (input?: T) => TResult, options?: MemoizeOption<T, TResult>) => MemoizedV<T, TResult>;
    /**
     * Retries a promise a given number of times with a given delay between retries from a factory.
     *
     * @param factory The factory for the promise.
     * @param retries The number of retries before the promise is rejected.
     * @param delayBetweenRetries The delay in milliseconds between retries.
     * @returns A promise for the result.
     */
    function retryPromise<T>(factory: () => Promise<T>, retries: number, delayBetweenRetries: number): Promise<T>;
    /**
     * Requests the specified module.
     *
     * @param moduleId The module id.
     * @returns A promise for the module.
     */
    function require<TModule extends keyof ModuleMap>(moduleId: TModule): Promise<ModuleMap[TModule]>;
    /**
     * Requests the specified module.
     *
     * @param moduleId The module id.
     * @param localRequire Use local require.
     * @param ignoreErrors Ignore errors for this module.
     * @returns A promise for the module.
     */
    function require<T>(moduleId: string, localRequire?: LocalRequire): Promise<T>;
    /**
     * Requests the specified module.
     *
     * @param moduleId The module id.
     * @param onLoaded Callback that is called when the module is loaded. If already loaded it is called synchronously.
     * @param onError Callback that is called when there is an error loading the module.
     */
    function require<T>(moduleId: string, onLoaded?: (loadedModule: T) => void, onError?: (error: any) => void): void;
    /**
     * Returns the first element of the sequence.
     *
     * @returns The element
     */
    function first<T>(array: ReadonlyArray<T>): T;
    /**
     * Returns the last element of the sequence.
     *
     * @returns The element
     */
    function last<T>(array: ReadonlyArray<T>): T;
    /**
     * Merge multiple T, T[] into a combine T[] exclude null or undefined arguments.
     *
     * @param data, a list fo T, T[]
     * @returns concatenated array.
     */
    const merge: <T>(...data: (T | T[])[]) => T[];
    /**
     * Projects each element of a sequence to a sequence and flattens the resulting sequences into one sequence.
     *
     * @param selector The projection function.
     * @returns A flattened array.
     */
    function mapMany<T, TResult>(array: ReadonlyArray<T>, selector: (source: T) => ReadonlyArray<TResult>): TResult[];
    /**
     * Sorts an array using a stable sort algorithm.
     *
     * This method returns a new array, it does not sort in place.
     *
     * @param compare The Compare function.
     * @returns Sorted array.
     */
    function stableSort<T>(array: ReadonlyArray<T>, compare: (a: T, b: T) => number): T[];
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     * @returns The string map of key => item for the source array.
     */
    function extendArrayIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: ReadonlyArray<T>, getKeyCallback?: (item: T, index?: number) => string, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): StringMap<U>;
    function extendArrayIntoMap<T, U>(objToExtend: NumberMap<U>, sourceItems: ReadonlyArray<T>, getKeyCallback?: (item: T, index?: number) => number, getValueCallback?: (item: T, index?: number, key?: string) => U, onlyIfNotExist?: boolean): NumberMap<U>;
    /**
     * Extends from  a source array into an existing string map of key => item.
     *
     * @param objToExtend The target object to be extended.
     * @param sourceArray The source array to convert to a map properties of target object.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the key for the item, otherwise the item itself is used.
     * @param  onlyIfNotExist If true, only Extend the value in array if the existing slot is still undefine. (This behaves like type script argument default value, it only fill in if the value is undefined.)
     * @returns The string map of key => item for the source array.
     */
    function extendStringMapIntoMap<T, U>(objToExtend: StringMap<U>, sourceItems: StringMap<T>, getValueCallback?: (item: T, key?: string) => U, onlyIfNotExist?: boolean): StringMap<U>;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     * @returns The function that will return string map base on the arguments index order of keys
     */
    function getStringMapFunc(...keys: string[]): Func<StringMap<any>>;
    function getStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object lightweight constructor
     *
     * @param keys the ordered argument keys
     * @returns The function that will return string map base on the arguments index order of keys
     */
    function applyStringMapFunc(keys: string[]): Func<StringMap<any>>;
    /**
     * Helpers funciton to create a object of type NameValue<N, T>
     *
     * @param name name
     * @param value value
     * @returns an object of NameValue<N, T>
     */
    const getNameValue: <N, T>(name: N, value: T) => NameValue<N, T>;
    /**
     * Get a list of typeScript Enum into Array
     *
     * @param tsEnumeration The Type script Enum Array
     * @param sort optional whether to sort by enum's value
     * @returns all NameValue<string, number>[] for this typeScriptEnum
     */
    function getEnumArray(tsEnumeration: any, sort?: boolean): NameValue<string, number>[];
    /**
     * Checks if given dates are equal.
     *
     * @param left Left hand side date.
     * @param left Right hand side date.
     * @returns True if left date is equal to right date.
     */
    function areEqualDates(left: any, right: any): boolean;
    /**
     * Round down the date.getTime() to seconds
     *
     * @param date.
     * @returns the getTime in seconds
     */
    function toSeconds(date: Date): number;
    /**
     * Returns 'true' if 'data' is an observable array (including KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @returns 'true' if the supplied data is an observable array.
     */
    function isObservableArray<TV, TO extends KnockoutObservableArray<TV> = KnockoutObservableArray<TV>>(data: TO | TV): data is TO;
    type ArrayOrObservableArray<T> = T[] | KnockoutObservableArray<T> | KnockoutObservableBase<T[]>;
    /**
     * Returns 'true' if 'data' is an array or observable array (including T[], KnockoutObservableArray<T> and KnockoutObservableBase<T[]>).
     *
     * @param data The data.
     * @returns 'true' if the supplied data is an array or an observable array.
     */
    function isArrayOrObservableArray<TV, TO extends ArrayOrObservableArray<TV> = ArrayOrObservableArray<TV>>(data: TO | TV): data is TO;
    /**
     * Returns a GUID such as xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx.
     *
     * @returns New GUID.
     */
    const newGuid: () => string;
    /**
     * Returns a function that can generate globally unique identifiers.
     * Generates a new guid every 4096 calls and concatenates it with an
     * auto incrementing number.  This maintains a complient GUID 4 format
     * if no prefix is added.
     *
     * @returns a globally unique string generating function.
     */
    function getUniqueIdGenerator(prefix?: string): () => string;
    /**
     * Returns a function that can generate unique id under the prefix
     * Concatenates prefix with an auto incrementing number.
     *
     * @returns a unique string generating function which return a prefix with auto incrementing number
     */
    function getIdGenerator(prefix: string): () => string;
    /**
     * Returns a globally unique identifier string.
     * Lighter-weight than newGuid.
     *
     * @returns a globally unique string.
     */
    const getUniqueId: () => string;
    /**
     * Rounds a number to the specified precision.
     *
     * @param numr The number to round.
     * @param precision The precision to round the number to. Defaults to 0.
     * @returns The rounded number.
     */
    function round(num: number, precision?: number): number;
    /**
     * Truncates a number to the integer part.
     *
     * @param value The number to truncate.
     * @returns The integer number.
     */
    function truncate(value: number): number;
    /**
     * Returns the result of the boolean exclusive-or operator.
     *
     * @param a First operand.
     * @param b Second operand.
     * @returns true if the arguments have different values, false otherwise.
     */
    function xor(a: boolean, b: boolean): boolean;
    /**
     * Generates a random integer between min and max inclusive.
     *
     * @param min The minimum integer result.
     * @param max The maximum integer result.
     * @returns A random integer.
     */
    function random(min: number, max: number): number;
    /**
     * Helper function to set a object property as observable if not exists, if is already an observable, set the observableValue.
     *
     * @param obj the object to set property on .
     * @param key A property name.
     * @param value Optional,  of the observable will be. when not provided. this observable will reset to undefeined.
     */
    function setObjPropAsObservable(obj: StringMap<any>, key: string, value?: any): void;
    /**
     * Returns a boolean reflecting whether two scalar values (not object-typed, not array-typed, not function-typed)
     * are equal.  Accounts for the fact that JavaScript Date derives from Object.
     * The caller is responsible for supplying exclusively number-, string- or Date-typed values here.
     *
     * @param left The first scalar value.
     * @param right The second scalar value.
     * @returns A boolean reflecting whether the two scalar values are equal.
     */
    function areEqual<T>(left: T, right: T): boolean;
    /**
     * Verifies that two arrays are equal.
     *
     * @param array1 The array to check.
     * @param array2 The array to compare the first array to.
     * @returns A value indicating whether or not the two arrays are equal.
     */
    function arrayEquals<T>(array1: T[], array2: T[]): boolean;
    type GetTypeOfValues = "string" | "number" | "boolean" | "symbol" | "undefined" | "object" | "function" | "null" | "date" | "array" | "regexp";
    function getTypeOf(x: any): GetTypeOfValues;
    function deepEquals<T>(a: T, b: T, peek?: boolean): boolean;
    /**
     * Checks if a given value is an object or not.
     *
     * @param value Value to test.
     * @returns True if value is an object, false otherwise.
     */
    function isObject(value: any): value is Object;
    /**
     * Maps each value of the input object. Values that map to null or undefined are skipped.
     *
     * @param obj Input object whose properties are to be mapped.
     * @param callback Invoked for each property of the object to perform the mapping.
     * @param arg An Optional value that can be passed to callback.
     * @returns An array of mapped values.
     */
    function map<T, U>(obj: StringMap<T>, callback: (item: T, key?: string, arg?: any) => U, arg?: any): U[];
    /**
     * Shallow copy from a key/value pairs object.
     *
     * @param dest An un-typed object to be populated.
     * @param src An un-typed object with values to populate.
     * @param scopes Scoped down the list for shallowCopy
     */
    function shallowCopyFromObject(dest: Object, src: Object, scopes?: string[]): void;
    /**
     * Determines if the current string ends with the given string.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
     * http://jsperf.com/string-prototype-endswith/18
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the end of this string.
     * @param position Optional. Search within this string as if this string were only this long; defaults to this string's actual length, clamped within the range established by this string's length.
     * @returns A value indicating whether or not the input string ends with the search string.
     */
    function endsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Compares the current string to another string and returns a value indicating their relative ordering.
     *
     * @param input The input string to compare.
     * @param other The value to compare the input string to.
     * @param locales The optional array of locale values that will be passed to localeCompare.
     * @param options The options supported by localeCompare.
     * @returns 0, if the strings are equal; a negative number if the current string is ordered before value; a positive non-zero number if the current string is orered after value.
     */
    function localeCompareIgnoreCase(input: string, other: string, locales?: string[], options?: CollatorOptions): number;
    /**
     * Repeats the string the specified number of times.
     *
     * @param input The input string.
     * @param count The number of times to repeat the string.
     * @returns The result string.
     *  http://jsperf.com/repeatstring2
     */
    function repeat(input: string, count: number): string;
    /**
     * reverse the string.
     *
     * @param input The input string.
     * @returns The result string.
     */
    function reverse(input: string): string;
    /**
     * Return a function that will perform join with that separator
     *
     * @returns a function that will join the parts together with the character, for example.
     *   joinPaths = getJoinFunc("/");
     *   joinByDash = getJoinFunc("-");
     *
     *  joinPaths("a", "b", "c") will return  "a/b/c";
     *  joinByDash("a", "b", "c") will return  "a-b-c";
     */
    function getJoinFunc(sep: string): (...parts: string[]) => string;
    /**
     * Return a function that will perform quote the input.  (Mimizer helper).
     *
     * @returns a function that will join the parts together with the character(s).
     *   For example.
     *     quote = getQuoteFunc("'");
     *     parenthesis = getQuoteFunc("(", ")");
     *     poMarker = getQuoteFunc("####");
     *
     * quote("abc") will return "'abc'";
     * parenthesis("abc") will return "(abc)";
     * poMarker("abc") will return "####abc####";
     */
    function getQuoteFunc(prefix: string, suffix?: string): (input: string) => string;
    /**
     * Replaces all instances of a value in a string.
     *
     * @param input The input string.
     * @param searchValue The value to replace.
     * @param replaceValue The value to replace with.
     * @returns A new string with all instances of searchValue replaced with replaceValue.
     */
    function replaceAll(input: string, searchValue: string, replaceValue: string): string;
    /**
     * Replaces multiple instances of search values and replacement values in a string.
     *
     * @param input The input string.
     * @param replacementMap A string map where each key represents the string to replace, and that key's value represents the value to replace it with.
     * @returns A new string with replacementMap values replaced.
     */
    function replaceMany(input: string, replacementMap: StringMap<string>): string;
    /**
     * Splits a string into the specified number of parts.
     * Differs from string.split in that it leaves the last part containing the remaining string (with separators in it).
     * string.split truncates the extra parts.
     *
     * @param input The string to be split.
     * @param separator A string that identifies the character or characters to be used as the separator.
     * @param limit A value used to limit the number of elements returned in the array.
     * @returns An array of strings whose length is at most the value of limit.
     */
    function split(input: string, separator: string, limit: number): string[];
    /**
     * Trims all occurrences of the given set of strings off the end of the input.
     */
    const trimEnd: (input: string, ...values: string[]) => string;
    /**
     * Trims all occurrences of the given set of strings off the start of the input.
     */
    const trimStart: (input: string, ...values: string[]) => string;
    /**
     * Ensures that the given string ends with the suffix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the suffix is appended and the result is returned.
     */
    function ensureSuffix(input: string, suffix: string): string;
    /**
     * Ensures that the given string starts with the prefix provided.
     * If it already does, it just returns the input string.
     * If it does not, then the prefix is applied and the result is returned.
     */
    function ensurePrefix(input: string, prefix: string): string;
    /**
     * Joins strings in the components array with the specified separator between them.
     * Ignores empty/falsy entries in the components array.
     * If a leading (or trailing) separator is desired, prefix (or suffix)
     * the array of components with an entry that is a separator.
     */
    function pathJoin(pathSeparator: string, ...pathComponents: string[]): string;
    function pathJoin(pathSeparator: string, pathComponents: string[]): string;
    /**
     * Parse an uri and return the Authority of the uri.
     *
     * @param uri The string of uri.
     * @returns Authority of the uri.
     */
    function getUriAuthority(uri: string, includePort?: boolean): string;
    /**
     * Verify if one Url is subdomain of another Url.
     *
     * @param domain The string of domain.
     * @param subdomain The string of subdomain
     * @returns True if subdomain is subdomain of domain.
     */
    function isSubdomain(domain: string, subdomain: string): boolean;
    /**
     * Returns whether the given URI is an absolute URI.
     *
     * @param uri The URI.
     * @returns A boolean value indicating whether the URI is absolute.
     */
    function isUriAbsolute(uri: string): boolean;
    /**
     * Attempts to execute the callback if the promise is already resolved or rejected,
     * otherwise, waits for the promise resolution or rejection.
     * Currently can only call back synchronously for Q.Promise.
     *
     * @param promise The promise to be resolved or rejected.
     * @param onFinally The callback to be executed.
     * @returns A promise.
     */
    function tryImmediateFinally<T>(promise: PromiseLike<T>, onFinally: () => any): Promise<T>;
    /**
     * Generates a function that returns the provided input.
     */
    function wrap<T>(e: T): Func<T>;
    /**
     * Returns whether the given data is primitive data type.
     * ECMAScript 6 standard defines 6 primitive data types: Boolean, Null, Undefined, Number, String, Symbol(new in ECMAScript 6)
     *
     * @param data The input data.
     * @returns A boolean value indicating whether the data is primitive data type.
     */
    function isPrimitive(data: any): data is Primitive;
    /**
     * Applies polyfills as properties to the prototype of the given object.
     * If force is specified the polyfills will overwrite any existing properties.
     */
    function polyfill(kind: {
        prototype: Object;
    }, fills: Object, force?: boolean): void;
    /**
     * Get a readonly map that is a faster alternative to cast a string to small and non-negative integers.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/int-to-string-map/4, http://jsperf.com/cast-int-to-string-in-loop.
     *
     * The StringToIntMap is mainly used to convert string to const enum. For example:
     * const enum Fruit {
     *   Unknown = 0,
     *   Apple = 1,
     *   Banana = 2,
     *   Max = 3
     * }
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(stringToIntMap["1"], Fruit.Apple);
     * strictEqual(stringToIntMap["2"], Fruit.Banana);
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The object have one to one mapping between the string and the corresponding integer. e.g. {"0":0,"1":1,"2":2,"3":3,"4":4, ... }.
     */
    function getIntToStringMap(requiredMaxInteger: number): string[];
    /**
     * Get a readonly map that is a faster alternative to cast a small and non-negative integer to string.
     * - Doesn't support negative integer since the performance is significantly decreased for negative integer.
     * - The JSperf links: http://jsperf.com/parseint-vs-map-lookup/2, http://jsperf.com/parseint-vs-map-lookup-2
     *
     * The intToStringMap is mainly used to convert const enum to string. For example:
     * const enum Fruit {
     *     Unknown = 0,
     *     Apple = 1,
     *     Banana = 2,
     *     Max = 3
     * }
     *
     * var stringToIntMap = utilities.getStringToIntMap(Fruit.Max);
     * strictEqual(intToStringMap[Fruit.Unknown], "0");
     * strictEqual(intToStringMap[Fruit.Apple], "1");
     *
     * @param requiredMaxInteger The required max integer.
     * @returns The array to have increment integer in string representation. e.g. ["0","1","2","3","4", ...].
     */
    function getStringToIntMap(requiredMaxInteger: number): StringMap<number>;
    /**
     * Makes a shallow clone of the source object with the same prototype and rebinds all functions
     * on the clone to use the source object as 'this'.
     *
     * @param object The source object.
     * @returns The cloned object.
     */
    function cloneAndRebindFunctions<T>(object: T): T;
    /**
     * Takes a value and lower cases recursively.
     * For a string, returns the lower case string (non-value remains non-value).
     * For an object, recursively converts all string properties to lower case strings, including arrays of values.
     * For an array, returns an array with all string values converted to lower case.
     *
     * @param source The source value to make lower case.
     * @returns The lower case value.
     */
    function lowerCaseAllStrings(source: any): any;
    /**
     * Clones the source object.
     *
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @param noWrapPrimitives If true, top-level primitives such as 'null' will be returned unchanged. If false, top-level primitives will be converted into objects. Defaults to false.
     * @returns A new cloned object.
     */
    function clone<T>(source: T): T;
    function clone<T>(source: T, deep: boolean): T;
    function clone<T>(source: T, deep: boolean, noWrapPrimitives: boolean): T;
    /**
     * Encodes html string.
     *
     * @param value The string to encode.
     * @returns The encoded string.
     */
    const encodeHtml: (value?: any) => string;
    /**
     * Encodes the input into a string that is properly escaped.
     *
     * @param value Input to encode.
     * @returns Encoded string.
     */
    function encodeAttribute(value?: any): string;
    /**
     * Generates a deterministic string representation for an object.
     *
     * For objects with single properties, the default serialization is used.
     *   For example: {"prop":value}
     * For objects with multiple properties, an array is used to mantain a deterministic order of (sorted) properties.
     *   For example: { b:2, a:1 } => {#:[{a:1},{b:2}]}
     *
     * @param obj Object to serialize.
     * @param properties Optional root properties to include in the
     * @returns String representation of object.
     */
    function toSortedString(obj: any, rootProperties?: string[]): string;
    /**
     * Parses a string generated by "toSortedString" method and rehydrates the original object.
     *
     * Similar to JSON.stringify/parse, the rehydrated object will have all the properties
     * from original object, except properties that were set to 'undefined' when serializing.
     *
     * @param sortedString Sorted string.
     * @returns Deserialized object.
     */
    function parseSortedString(sortedString: string): any;
    /**
     * Disposes various properties of a view model object.
     *
     * @param viewModel The view model.
     */
    function disposeViewModelProperties(viewModel: any): void;
    /**
     * Determines whether or not the specified property represents a serializable property.
     *
     * @param propertyName The property name to check.
     * @returns True if it's serializable property; false if not.
     */
    function isSerializableProperty(propertyName: string): boolean;
    /**
     * Converts a source array to a string map of key => item.
     *
     * @param sourceArray The source array to convert to a map.
     * @param getKeyCallback The callback used to provide the key for the item.
     * @param getValueCallback The optional callback used to provide the value for the item, otherwise the item itself is used.
     * @returns The string map of key => item for the source array.
     */
    function convertArrayToMap<T>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string): StringMap<T>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string, getValueCallback: (item: T, index?: number, key?: string) => U): StringMap<U>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => string, getValueCallback?: (item: T, index?: number, key?: string) => U): StringMap<U>;
    function convertArrayToMap<T>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number): NumberMap<T>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number, getValueCallback: (item: T, index?: number, key?: string) => U): NumberMap<U>;
    function convertArrayToMap<T, U>(sourceItems: ReadonlyArray<T>, getKeyCallback: (item: T, index?: number) => number, getValueCallback?: (item: T, index?: number, key?: string) => U): NumberMap<U>;
    /**
     * Utility to map a knockout projected array to an observable array.
     * Knockout projection which returns observable of array while many view model exposes KnokoutObservableArray.
     * This utility will help in mapping the projected array to ObservableArray.
     *
     * @param lifetime The LifetimeManager reflecting the lifetime of the array that's computed.
     * @param mappedArray Knockout projected array.
     * @returns returns KnockoutObservableArray.
     */
    function thunkArray<T>(lifetime: Base.LifetimeManager, mappedArray: KnockoutObservableBase<T[]>): KnockoutObservableArrayDisposable<T>;
    /**
     * Checks if the given object can be sent through postMessage().
     * E.g., postMessage() does not support functions, Errors, or DOM nodes.
     *
     * @param root The object to check.
     * @returns True if the object can be sent through postMessage()
     */
    function canSendThroughPostMessage(root: any): boolean;
    /**
     * Compares two values.
     * Works for primative types string, date, number, and boolean.
     * Works for observables contining the primative types.
     *
     * @param value The value.
     * @param compareTo The compare to value.
     * @returns An integer indicating if the value is greater or less than the compareTo.
     */
    function compare(value: any, compareTo: any): number;
    /**
     * Initializes a value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @returns The initial value.
     */
    function initValue<T>(value?: T, defaultValue?: T): T;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @returns The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservable<T>, defaultValue?: T): KnockoutObservable<T>;
    /**
     * Initializes an observable value.
     *
     * @param value The value to use.
     * @param defaultValue The value to use when value is undefined.
     * @returns The initial observable value.
     */
    function initObservable<T>(value?: T | KnockoutObservableBase<T>, defaultValue?: T): KnockoutObservableBase<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @returns The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | KnockoutObservableArray<T>, defaultValues?: T[]): KnockoutObservableArray<T>;
    /**
     * Initializes an observable array of values.
     *
     * @param values The values to use.
     * @param defaultValues The values to use when values is undefined.
     * @returns The initial observable values.
     */
    function initObservableArray<T>(values?: T[] | ReadonlyArray<T> | KnockoutReadOnlyObservableArray<T>, defaultValues?: T[]): KnockoutReadOnlyObservableArray<T>;
    let markIgnoreHighDependenciesCount: (koComputed: KnockoutSubscribable<any>) => void;
}
declare namespace MsPortalFx {
    function isPlainObject(obj: any): boolean;
    function jqueryExtend(this: any, ...args: any[]): any;
    /**
     * For testing only. Use Object.keys.
     */
    function _objectKeysPolyfill(o: any): string[];
    function forEachKey<T, U>(obj: StringMap<T>, iterator: (key: string, value: T, context: U) => void, context?: U): U;
    function forEachKey<T, U>(obj: NumberMap<T>, iterator: (key: number, value: T, context: U) => void, context?: U): U;
    /**
     * call value.dispose() if a value is Disposable.
     *
     * @param value The value to call value.dispose()
     * @returns boolean;
     */
    function disposeDisposable(...values: any[]): void;
    /**
     * Indicates whether the specified object is null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    function isNullOrUndefined(value: any): boolean;
    /**
     * Removes all values that equal the given item and returns them as an array
     *
     * @param itemOrPredicate The value or predicate for the item to be removed.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The removed items.
     */
    function remove<T>(array: T[], itemOrPredicate: T | ((value: T) => boolean), startIndex?: number): T[];
    /**
     * Coerce an input into an array if it isn't already one.
     */
    function makeArray<T>(input: T | T[]): T[];
    /**
     * Pushes elements to a target making sure they are unique.
     *
     * @param uniqueTarget The target to push the source elements into.
     * @param source The source elements to push to the target in case they are unique.
     * @param predicate Comparer function to determine if the 2 elements are equal.
     * @param sourceUnique is a flag to optimize the performance, set to true if you know source is unique already.
     */
    function pushUnique<T>(uniqueTarget: T[], source: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean, sourceUnique?: boolean): T[];
    /**
     * Returns a unique set from this array based on the predicate.
     *
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @returns A new array with the unique values.
     */
    function unique<T>(array: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param arrays The list of arrays to get union of.
     * @returns A new array with the unique values.
     */
    function union<T>(...arrays: ReadonlyArray<T>[]): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param other The other array to concatenate with this one.
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @returns A new array with the unique values.
     */
    function union<T>(array: ReadonlyArray<T>, other: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    function union<T>(): T[];
    /**
     * Determines if the current string starts with the given string.
     * http://jsperf.com/string-startswith/49
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the start of this string.
     * @param position Optional. The position in this string at which to begin searching for searchString; defaults to 0.
     * @returns A value indicating whether or not the input string begins with the search string.
     */
    function startsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Attempts to execute on fulfill or on reject callbacks immediately if the promise is already resolved or rejected,
     * or waits for the resolution or the rejection otherwise.
     * Currently can only call back synchronously for Q.Promise.
     *
     * @param promise The promise expected to be resovled or rejected.
     * @param onFulfill The callback to be executed if resolved.
     * @param onReject The callback to be executed if rejected.
     * @returns A promise for the result.
     */
    function tryImmediateResolve<T, TR>(promise: PromiseLike<T>, onFulfill: (value: T) => TR | Promise<TR>, onReject?: (reason?: Error) => any): Promise<TR>;
    /**
     * No-op function.
     */
    function noop(): void;
    /**
     * Identity function.
     *
     * Note: https://en.wikipedia.org/wiki/Identity_function
     */
    function identity<T>(e: T): T;
    /**
     * Returns whether code that could have a performance impact but would assist with development should be enabled.
     */
    let isDiagnosticsEnabled: boolean;
    /**
     * Extends the target object with the properties from source object.
     *
     * @param target The object that is to be extended. This object is modified and returned.
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @returns The same target object (after extension).
     */
    function extend<T, U>(target: T, source: U, deep?: boolean): T & U;
    /**
     * Similar to extend, except does not modify target.
     * Instead returns a clone of target extended with source.
     */
    function extend2<T, U, V, W>(s1: T, s2: U, s3?: V, s4?: W): T & U & V & W;
    /**
     * Generates the current JavaScript call stack.
     * On IE9 there is no stack so we get empty string.
     *
     * Note that by default, for slower platform, IE11 etc, which error doesn't come with that stack.
     * We will not get the call stack for those slow platform even if you set to force.
     * Since for common problem, you should have enough information just by morden browser (chrome, edge, firefox.)
     * Use feature.includeslowgetcallstack to enable call stack capture for those slow browser
     *
     * @param force If true, the call stack is returned even if it is expensive to compute.
     * @param options optional method options
     * @param options.removeStackLevels If set, remove additional N levels from the top of the stack trace.
     * @returns The call stack.
     */
    function getCurrentCallStack(force?: boolean, options?: {
        removeStackLevels?: number;
    }): string;
    /**
     * Generates a property that is not serializable.
     *
     * @param The string to use as part of the property name.
     * @returns The non-serializable property name.
     */
    function generateNonSerializableProperty(str: string): string;
    function getFunctionName(func: Function): string;
    function getObjectConstructorName(obj: Object): string;
    /**
     * Helper function to get the objectDescriptor string.
     * Initial design is to help capture when we try to serialized a object which contains cyclic.
     * But doesn't have enough informaiton for the live site issue to pass on to the right team.
     * The data is intend for event log, thus by default doesn't prinit out the data since value might contains
     * user information and security object.
     * In addition, since the object is already cyclic, it only capture the first level property.
     *
     * You should be wary about the performance. This is equavlent to runtime reflection.
     * In addition, In the deepRecursive Mode, it mark the visisted object as "visited", if the object is been ask the second time to serialized the object again.
     * it will mark it as [potential circular].  The reason is that the object can be cached in legit way in two different property and ko.observable. It will break it out to avoid forever loop.
     * Do not use [potential circular] as detection mechanism, this is mainly for the logging purpose.
     *
     * @param obj the object to get the ObjectDescriptor on
     * @param deepRecursive:recursively get into the object to get the string.
     * @returns string of object representation.
     *   Here is a dump of StackedAreaChart from the sample.
     *   x = ko.dataFor($0).data
     *   getObjectDescriptor(x)
     *   Here is the return string.
     * {
     *  <ViewModel>: {
     *  disabled: <function>observable,
     *  title: <function>observable,
     *  showTitle: <function>observable,
     *  width: <function>observable,
     *  height: <function>observable,
     *  noDataMessage: <string>,
     *  series: <function>observable,
     *  xAxis: <Axis>,
     *  yAxis: <Axis>,
     *  secondaryXAxes: <function>observable,
     *  secondaryYAxes: <function>observable,
     *  views: <function>observable,
     *  legendPosition: <function>observable,
     *  interactionBehavior: <function>observable,
     *  autogenerateSeriesViews: <function>observable,
     *  events: <Events>,
     *  seriesSelections: <function>observable,
     *  seriesHovers: <function>observable,
     *  hoveredID: <function>observable,
     *  enableTrackXSlider: <function>observable,
     *  disableXSliderMouseout: <function>observable,
     *  xSliderCoordinate: <function>observable,
     *  xSliderFilterHoverThreshold: <function>observable
     *  }
     * }
     * In the dev mode, you can pass in the second argument as deepRecursive
     * getObjectDescriptor(x, enableDebugMode /* true* /);
     * {
     *  <ViewModel>: {
     *    disabled: {
     *      <function>observable: <boolean>
     *    },
     *    title: {
     *      <function>observable: <string>
     *    },
     *    showTitle: {
     *      <function>observable: <boolean>
     *    },
     *    width: {
     *      <function>observable: <number>
     *    },
     *    height: {
     *      <function>observable: <number>
     *    },
     *    noDataMessage: <string>,
     *    series: {
     *      <function>observable: <Array[6]>
     *    },
     *    xAxis: {
     *      <Axis>: {
     *        name: {
     *          <function>observable: <string>
     *        },
     *        scale: {
     *          <function>observable: <number>
     *        },
     *        ticks: {
     *          <function>observable: <number>
     *        },
     *        position: {
     *          <function>observable: <number>
     *        },
     *    .... skip...
     * }
     */
    function getObjectDescriptor(obj: any, deepRecursive?: boolean, includePrivate?: boolean): string;
    /**
     * Finds the index of the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The first index that matches the predicate.
     */
    function findIndex<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: ReadonlyArray<T>) => boolean, startIndex?: number): number;
    /**
     * Finds the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The first element that matches the predicate.
     */
    function find<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: T[]) => boolean, startIndex?: number): T;
    /**
     * Escapes regular expression special characters -[]/{}()*+?.\^$|
     *
     * @param str The string to escape.
     * @returns The escaped string.
     */
    function regexEscape(str: string): string;
    /**
     * A function that when invoked returns the milliseconds elapsed since startTimer was called.
     */
    type Timer = import("FxInternal").Timer;
    /**
     * Returns a timer function.
     */
    function startTimer(): Timer;
}

// FILE: MsPortalFx\Utilities.Internal.d.ts
declare module FxImpl {
    /**
     * Converts an object graph into a form that can be JSON-serialized while retaining
     * information about which properties are observable.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param root The root of the object graph that may contain observables.
     * @returns A serializable object.
     */
    function toSerializableObject(root: any): any;
    /**
     * Returns whether the given object was serialized using the toSerializableObject API.
     *
     * @param object Object to test.
     * @returns True if the object was serialized by the Serialization utility.
     */
    function isSerializedObject(object: Object): boolean;
    /**
     * Converts an object previously returned by toSerializableObject into a regular
     * object graph. This recovers the object with the equivalent properties being observable or
     * observable arrays.
     *
     * Note that information about computed properties is not retained: they will be
     * treated as non-computed observables, since the evaluators cannot be serialized
     * in general.
     *
     * @param serializableObject An object previously returned by toSerializableObject (possibly having been passed through JSON serialization).
     * @returns An object graph that may include observables.
     */
    function fromSerializableObject(serializableObject: any): any;
    let _setReportCycleError: (func?: (message: string, root: any) => any) => void;
    interface Resettable {
        reset(): void;
    }
    function registerGlobalState(resettable: Resettable): void;
    function resetGlobalState(): void;
    type ThrowErrorFunction = import("FxInternal").ThrowErrorFunction;
    /**
     * Returns a map of functions that throw errors with the provided messages.
     */
    function getErrorMap(obj: Object): Object;
    /**
     * Used in jquery-2.2.4.js
     * removes ability to use eval if nojqueryeval feature flag is set.  Logs an error if jquery uses eval otherwise.
     *
     * @param code code being evaluated
     * @returns if the eval should be skipped
     */
    function skipEval(code: string, logArea: string): boolean;
    function lowerCaseStringMap<T>(): MapBase<string, T>;
    /**
     * Creates an object with the same keys as object and values generated by running each own enumerable property of object through the callback.
     *
     * @param o The object.
     * @param selector The selector.
     * @returns The projected object.
     */
    function mapValues<K extends string, T, R>(o: ReadonlyTypedStringMap<K, T>, selector: (value: T, key: K, o: ReadonlyTypedStringMap<K, T>) => R): PartialTypedStringMap<K, R>;
    /**
     * Creates an array of elements split into two groups, the first of which contains elements `predicate` returns truthy for, the second of which contains elements `predicate` returns falsey for. The predicate is invoked with one argument: (value).
     *
     * @param o The object.
     * @param partition The predicate.
     * @returns The partitioned array.
     */
    function partition<T>(o: ReadonlyArray<T>, predicate: (o: T) => boolean): [T[], T[]];
    type Deferred<T> = import("FxInternal").Deferred<T>;
    /**
     * Enumerates all the properties in the object, regardless of if they are defined as non-enumerable (the default in ES6+ class methods definition)
     *
     * @param obj the object to get all the methods from
     * @returns all the methods of the object, including the ones in the prototype chain.
     */
    function getAllKeys(obj: any): string[];
}
declare namespace FxImpl {
    const createError: typeof import("FxInternal").createError;
    const defer: typeof import("FxInternal").defer;
    const toPromise: typeof import("FxInternal").toPromise;
}

// FILE: MsPortalFx\ViewModels\ClickableLink.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * MsPortalFx.ViewModels.ClickableLink is obsolete. Use `import { ClickableLink } from "Fx/Composition";` instead.
     * The ClickableLinkContract interface is meant to temporarily bridge type safety while MsPortalFx APIs still use MsPortalFx.ViewModels.ClickableLink.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    interface ClickableLinkContract {
        /**
         * The URI that will be opened.
         */
        uri: KnockoutObservable<string>;
        /**
         * The link target. Target is _blank if unspecified.
         */
        target: KnockoutObservable<string>;
        /**
         * Window features for the new window.
         * See https://developer.mozilla.org/en-US/docs/Web/API/Window/open#Window_features
         */
        windowFeatures?: KnockoutObservable<string>;
        /**
         * Callback triggered after the link is opened.
         *
         * @param keypress Indicates if the link is opened by keypress.
         */
        onLinkOpened: (keypress: boolean) => void;
        /**
         * Telemetry identifier.
         */
        readonly telemetryName?: string;
    }
    /**
     * MsPortalFx.ViewModels.ClickableLink is obsolete. Use `import { ClickableLink } from "Fx/Composition";` instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ClickableLink: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\AzureMediaPlayer.d.ts
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer {
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.Options is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.LogoConfig is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type LogoConfig = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.Source is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Source = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.ProtectionInfo is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ProtectionInfo = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.ProtectionType is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ProtectionType: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.StreamingFormatMimeType is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const StreamingFormatMimeType: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Unsupported.AzureMediaPlayer.ViewModel is obsolete.
     * Use Fx/Controls/Video instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Balloon.d.ts
declare module MsPortalFx.ViewModels.Controls.Balloon {
    /**
     * MsPortalFx.ViewModels.Controls.Balloon.Contract is obsolete. Use Fx/Controls/InfoBalloon instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Balloon.Link is obsolete. Use Fx/Controls/InfoBalloon.Link instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Link: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Balloon.ViewModel is obsolete. Use Fx/Controls/InfoBalloon instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Balloon.Box is obsolete. Use Fx/Controls/InfoBalloon.Box instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Box: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Base {
    interface Contract extends MsPortalFx.Control, MsPortalFx.Base.Disposable {
    }
    interface Options {
        /**
         * Identifier for telemetry. Do not localize. Optional.
         */
        telemetryName?: string | KnockoutObservableBase<string>;
    }
    class ViewModel implements Contract {
        /**
         * Enum that defines the type of the control.
         */
        controlType: ControlType;
        /**
         * Lifetime manager.
         */
        private readonly _ltm;
        /**
         * Identifier for telemetry. Do not localize.
         * This is a union type to allow controls inheriting this property to override the type
         * to either string or KnockoutObservableBase<string>. Prior to moving telemetry to the Base
         * different controls used different types. This is temporary until a new property standardizes
         * the telemetry identifier across all controls.
         */
        telemetryName: string | KnockoutObservableBase<string>;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Method that can be called to explicitly dispose of view model resources.
         */
        dispose(): void;
        /**
         * Lifetime manager instance that is disposed when the widget is disposed.
         */
        get lifetimeManager(): MsPortalFx.Base.LifetimeManager;
        /**
         * Populates the view model from a key/value pairs object.
         * The keys should map to properties on the view model.
         * The values are applied to the corresponding keys.
         *
         * @param object An untyped object with values to populate on the view model.
         */
        populateFromObject(object: Object): void;
        /**
         * Adds a subscription to be cleaned up in the dispose().
         *
         * @param disposable One KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable): void;
        /**
         * Adds a list of computed to be cleaned up in the dispose().
         *
         * @param disposable Array of KnockoutDisposable to be added to this._disposables.
         */
        _addDisposablesToCleanUp(disposable: MsPortalFx.Base.Disposable[]): void;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Base\Loadable.d.ts
declare module MsPortalFx.ViewModels.Controls.Loadable {
    interface Options {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading?: KnockoutObservableBase<boolean>;
    }
    interface Contract extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservableBase<boolean>;
    }
    class ViewModel extends MsPortalFx.ViewModels.Controls.Base.ViewModel implements Contract {
        /**
         * Indicates if the widget is currently disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the widget is currently loading data.
         */
        loading: KnockoutObservableBase<boolean>;
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
        /**
         * Creates a Base ViewModel.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param loading Default loading state.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, loading?: boolean);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Command.d.ts

// FILE: MsPortalFx\ViewModels\Controls\Control.d.ts
declare module MsPortalFx {
    /**
     * Contract identifying a control as something that can be created via the pcControl binding.
     */
    interface Control {
        /**
         * Enum that defines the type of the control.
         */
        readonly controlType: MsPortalFx.ViewModels.ControlType;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ControlType.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Type of control.
     */
    const enum ControlType {
        /**
         * Value indicates field has not been set to an appropriate control type.
         */
        Invalid = 0,
        /**
         * Control is a section.
         */
        Section = 1,
        /**
         * Control is a text box.
         */
        TextBox = 2,
        /**
         * Control is a drop down field.
         */
        DropDown = 3,
        /**
         * Control is an options group field.
         */
        OptionsGroup = 4,
        /**
         * Control is a password field.
         */
        Password = 5,
        /**
         * Control is a slider.
         */
        Slider = 6,
        /**
         * Control is a check box.
         */
        CheckBox = 7,
        /**
         * Control is a multiselect drop down field.
         */
        MultiselectDropDown = 8,
        /**
         * Control is a range slider.
         */
        RangeSlider = 9,
        /**
         * Control is a numeric text box.
         */
        NumericTextBox = 10,
        /**
         * Control is a selector field.
         */
        Selector = 11,
        /**
         * Control is a filter combo.
         */
        FilterCombo = 12,
        /**
         * Control is multi-line text box.
         */
        MultiLineTextBox = 13,
        /**
         * Control is a dynamic section.
         */
        DynamicSection = 15,
        /**
         * Control is an attachment control.
         */
        Attachment = 16,
        /**
         * Control is a history control.
         */
        History = 19,
        /**
         * Control is an artifact links control (used by VSO).
         */
        ArtifactLinks = 20,
        /**
         * Control is a splitter control.
         */
        Splitter = 21,
        /**
         * Control is a tri state check box.
         */
        TriStateCheckBox = 22,
        /**
         * Control is a custom html.
         */
        CustomHtml = 23,
        /**
         * Control is a time picker.
         */
        TimePicker = 24,
        /**
         * Control is a date picker.
         */
        DatePicker = 25,
        /**
         * Control is a date/time picker.
         */
        DateTimePicker = 26,
        /**
         * Control is a date/time range picker.
         */
        DateTimeRangePicker = 27,
        /**
         * Control is an OAuth button.
         */
        OAuthButton = 29,
        /**
         * DockedBalloon control.
         */
        DockedBalloon = 32,
        /**
         * DiffEditor control.
         */
        DiffEditor = 33,
        /**
         * Editor control.
         */
        Editor = 37,
        /**
         * pcCheckBox control.
         */
        pcCheckBox = 39,
        /**
         * CopyableLabel control.
         */
        CopyableLabel = 40,
        /**
         * pcDropDown control.
         */
        pcDropDown = 42,
        /**
         * pcFilterCombo control.
         */
        pcFilterCombo = 43,
        /**
         * pcMultiLineTextBox control.
         */
        pcMultiLineTextBox = 45,
        /**
         * pcMultiselectDropDown control.
         */
        pcMultiselectDropDown = 46,
        /**
         * pcNumericTextBox control.
         */
        pcNumericTextBox = 47,
        /**
         * pcOptionPicker control.
         */
        pcOptionPicker = 48,
        /**
         * pcPassword control.
         */
        pcPassword = 49,
        /**
         * pcRangeSlider control.
         */
        pcRangeSlider = 50,
        /**
         * pcSlider control.
         */
        pcSlider = 52,
        /**
         * pcGrid control.
         */
        pcGrid = 54,
        /**
         * pcTreeView control.
         */
        pcTreeView = 57,
        /**
         * LogStream control.
         */
        LogStream = 58,
        /**
         * Scrollbar control.
         */
        Scrollbar = 59,
        /**
         * Toolbar control.
         */
        Toolbar = 62,
        /**
         * Chart control.
         */
        Chart = 63,
        /**
         * Donut control.
         */
        Donut = 65,
        /**
         * Graph control.
         */
        Graph = 67,
        /**
         * Map control.
         */
        Map = 68,
        /**
         * Metrics control.
         */
        Metrics = 69,
        /**
         * PairedTimeline control.
         */
        PairedTimeline = 70,
        /**
         * ProgressBar control.
         */
        ProgressBar = 71,
        /**
         * QuotaGauge control.
         */
        QuotaGauge = 72,
        /**
         * SingleValueGauge control.
         */
        SingleValueGauge = 73,
        /**
         * StepGauge control.
         */
        StepGauge = 74,
        /**
         * Console control.
         */
        Console = 75,
        /**
         * DeleteAssetConfirmation control.
         */
        DeleteAssetConfirmation = 76,
        /**
         * HeroBanner control.
         */
        HeroBanner = 77,
        /**
         * InfoBox control.
         */
        InfoBox = 78,
        /**
         * Notice control.
         */
        Notice = 79,
        /**
         * FileDownloadButton control.
         */
        FileDownloadButton = 82,
        /**
         * HotSpot control (pcHotSpot)
         */
        HotSpot = 84,
        /**
         * CreatorAndSelectorV2 control.
         */
        CreatorAndSelectorV2 = 85,
        /**
         * RangeSelection control.
         */
        RangeSelection = 86,
        /**
         * Link InfoBox control.
         */
        LinkInfoBox = 87,
        /**
         * Link HotSpot control.
         */
        LinkHotSpot = 88,
        /**
         * Preview tag control.
         */
        PreviewTag = 89,
        /**
         * CustomValueSlider control.
         */
        CustomValueSlider = 91,
        /**
         * DayPicker control.
         */
        DayPicker = 92,
        /**
         * Search control.
         */
        SearchBox = 93,
        /**
         * Paired timeline badge control
         */
        PairedTimelineBadges = 94,
        /**
         * Spec Comparison Table
         */
        SpecComparisonTable = 95,
        /**
         * MapV2 Control
         */
        MapV2 = 96,
        /**
         * Simple chart
         */
        SimpleChart = 97,
        /**
         * GroupDropDown control.
         */
        GroupDropDown = 98,
        /**
         * DurationPicker control
         */
        DurationPicker = 99,
        /**
         * Simple button
         */
        SimpleButton = 100,
        /**
         * Text Block
         */
        TextBlock = 101,
        /**
         * List 2
         */
        List2 = 104,
        /**
         * Tree 2
         */
        Tree2 = 105,
        /**
         * Async FileUpload
         */
        AsyncFileUpload = 106,
        /**
         * Wizard
         */
        Wizard = 107,
        /**
         * IFrame control.
         */
        IFrame = 108,
        /**
         * Media Player control
         */
        MediaPlayer = 109,
        /**
         * Markdown control.
         */
        Markdown = 110,
        /**
         * Custom Range Slider
         */
        CustomRangeSlider = 111,
        /**
         * PartPinner control.
         */
        PartPinner = 112,
        /**
         * IFrame control.
         */
        IFrameV2 = 113,
        /**
         * Resource filter control.
         */
        ResourceFilter = 114,
        /**
         * Menu control.
         */
        Menu = 115,
        /**
         * Video control.
         */
        Video = 116,
        /**
         * Custom control.
         */
        CustomControl = 117,
        /**
         * Legend control.
         */
        Legend = 118,
        /**
         * Menu control.
         */
        HeatMap = 119,
        /**
         * Essentials control.
         */
        Essentials = 120,
        /**
         * Intune application file control.
         */
        IntuneAppFileUpload = 121,
        /**
         * Monitor Chart control.
         */
        MonitorChart = 122,
        /**
         * Pill (horizontal item) list control.
         */
        PillList = 123,
        /**
         * Resource dropdown control
         */
        ResourceDropDown = 124,
        /**
         * Editable grid control.
         */
        EditableGrid = 125,
        /**
         * MonitorChartV2 control.
         */
        MonitorChartV2 = 126,
        /**
         * Accordion control.
         */
        Accordion = 127,
        /**
         * Pill control.
         */
        Pill = 128,
        /**
         * Pill collection control.
         */
        PillCollection = 129,
        /**
         * ArrayGrid control.
         */
        ArrayGrid = 130,
        /**
         * DataGrid control.
         */
        DataGrid = 131,
        /**
         * PagedDataGrid control.
         */
        PagedDataGrid = 132,
        /**
         * SequentialDataGrid control.
         */
        SequentialDataGrid = 133,
        /**
         * Summary control.
         */
        Summary = 134,
        /**
         * PricingControl control.
         */
        PricingControl = 135,
        /**
         * Tags control.
         */
        TagsByResource = 136,
        /**
         * ArmErrorList control.
         */
        ArmErrorList = 137,
        /**
         * Docs control.
         */
        DocsControl = 138,
        /**
         * Storage File Share dropdown
         */
        FileShareDropDown = 201,
        /**
         * Storage Account dropdown
         */
        StorageAccountDropDown = 202,
        /**
         * Blob Container dropdown
         */
        BlobContainerDropDown = 203,
        /**
         * Metric Grid (Used as part of MonitorChart)
         */
        MetricGrid = 204,
        /**
         * Toggle control
         */
        Toggle = 205,
        /**
         * Recommendations control
         */
        Recommendations = 206,
        /**
         * Splitter2 control
         */
        Splitter2 = 207,
        /**
         * ClipboardButton control
         */
        ClipboardButton = 208,
        /**
         * Pager control
         */
        Pager = 209,
        /**
         * Management group dropdown
         */
        ManagementGroupDropDown = 210,
        /**
         * Tab Menu control.
         */
        TabMenu = 211,
        /**
         * Pager2 control
         */
        Pager2 = 212
    }
}

// FILE: MsPortalFx\ViewModels\Controls\DockedBalloon.d.ts
declare module MsPortalFx.ViewModels.Controls.DockedBalloon {
    /**
     * MsPortalFx.ViewModels.Controls.DockedBalloon.Type is obsolete. Use Fx/Controls/InfoBalloon instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Type: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.DockedBalloon.Contract is obsolete. Use Fx/Controls/InfoBalloon instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.DockedBalloon.ViewModel is obsolete. Use Fx/Controls/InfoBalloon instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Documents\Editor.d.ts
declare module MsPortalFx.ViewModels.Controls.Documents.Editor {
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Type of editor content.
     * Used to enable language specific editor features like colorization.
     */
    const ContentType: Obsolete;
    type ContentType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor options.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Definition of a custom content type.
     * See https://microsoft.github.io/monaco-editor/monarch.html
     */
    type CustomContentType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a tokenizer rule.
     * Rules can have the following forms:
     *
     *     {regex: regex, action: action }
     *          CustomContentTypeTokenizationRegexRule
     *
     *     { include: state }
     *         CustomContentTypeTokenizationIncludeRule
     *
     *     [regex, action]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action: { regex: regex, action: action }
     *
     *     [regex, action, next]
     *         Shorthand for CustomContentTypeTokenizationRegexRule with action having next: { regex: regex, action: action{ next: next } }
     */
    type CustomContentTypeTokenizationRule = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a regular expression tokenization rule.
     * When regex matches against the current input, then action is applied to set the token class.
     */
    type CustomContentTypeTokenizationRegexRule = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Used for nice organization of your rules and expands to all the rules defined in state.
     * This is pre-expanded and has no influence on performance.
     * Many samples include the '@whitespace' state for example.
     */
    type CustomContentTypeTokenizationIncludeRule = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The scalar rule actions that are allowed.
     */
    type CustomContentTypeTokenizationRuleScalarAction = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a rule action.
     * An action can have the following forms:
     *
     *     { token: tokenclass }
     *         CustomContentTypeTokenizationRuleTokenAction
     *
     *     { cases: { guard1: action1, ..., guardN: actionN } }
     *         CustomContentTypeTokenizationRuleCasesAction
     *
     *     string
     *         Shorthand for CustomContentTypeTokenizationRuleTokenAction with token only: { token: string }.
     *
     *     [action1,...,actionN]
     *         An array of N actions.
     */
    type CustomContentTypeTokenizationRuleAction = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * An object that defines the token class used with CSS rendering.
     */
    type CustomContentTypeTokenizationRuleTokenAction = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The final kind of action object is a cases statement.
     * A cases object contains an object where each field functions as a guard.
     * Each guard is applied to the matched input and as soon as one of them matches, the corresponding action is applied.
     * Note that since these are actions themselves, cases can be nested.
     * Cases are used for efficiency: for example, we match for identifiers and then test whether the identifier is possibly a keyword or builtin function:
     *
     *     [/[a-z_\$][a-zA-Z0-9_\$]<asterisk>/,
     *         { cases: { '@typeKeywords': 'keyword.type'
     *                  , '@keywords': 'keyword'
     *                  , '@default': 'identifier' }
     *         }
     *     ]
     *
     * The guards can consist of:
     *
     *     "@keywords"
     *         The attribute keywords must be defined in the language object and consist of an array of strings.
     *         The guard succeeds if the matched input matches any of the strings.
     *         (Note: all cases are pre- compiled and the list is tested using efficient hash maps).
     *         Advanced: if the attribute refers to a single string (instead of an array) it is compiled to a regular expression which is tested against the matched input.
     *
     *     "@default"
     *         (or "@" or "") The default guard that always succeeds.
     *
     *     "@eos"
     *         Succeeds if the matched input has reached the end of the line.
     *
     *     "regex"
     *         If the guard does not start with a @ (or $) character it is interpreted as a regular expression that is tested against the matched input.
     *         Note: the regex is prefixed with ^ and postfixed with $ so it must match the matched input entirely.
     *         This can be used for example to test for specific inputs, here is an example from the Koka language which uses this to enter various tokenizer states based on the declaration:
     *
     *         [/[a-z](\w|\-[a-zA-Z])<asterisk>/,
     *             { cases: { '@keywords': {
     *                         cases: { 'alias': { token: 'keyword', next: '@alias-type' }
     *                                , 'struct': { token: 'keyword', next: '@struct-type' }
     *                                , 'type|cotype|rectype': { token: 'keyword', next: '@type' }
     *                                , 'module|as|import': { token: 'keyword', next: '@module' }
     *                                , '@default': 'keyword' }
     *                        }
     *               , '@builtins': 'predefined'
     *               , '@default': 'identifier' }
     *             }
     *         ]
     *
     *         Note the use of nested cases to improve efficiency.
     *         Also, the library recognizes simple regular expressions like the ones above and compiles them efficiently.
     *         For example, the list of words type| cotype | rectype is tested using a Javascript hashmap/ object.
     *
     *     (Advanced) In general, a guard has the form [pat][op]match, with an optional pattern, and operator (which are $# and ~ by default).
     *     The pattern can be any of:
     *
     *     $#
     *         (default) The matched input (or the group that matched when the action is an array).
     *
     *     $n
     *         The nth group of the matched input, or the entire matched input for $0.
     *
     *     $Sn
     *         The nth part of the state, i.e.$S2 returns foo in a state @tag.foo.
     *         Use $S0 for the full state name.
     *
     *     The above patterns can actually occur in many attributes and are automatically expanded.
     *     Attributes where these patterns expand are token, next, nextEmbedded, switchTo, and log.
     *     Also, these patterns are expanded in the match part of a guard.
     *
     *     The guard operator op and match can be any of:
     *
     *      ~regex or !~regex
     *          (default for op is ~) Tests pat against the regular expression or its negation.
     *
     *      "@attribute" or "!@attribute"
     *          Tests whether pat is an element (@), or not an element (!@), of an array of strings defined by attribute.
     *
     *      ==str or != str
     *          Tests if pat is equal or unequal to the given string str.
     *
     *      For example, here is how to check if the second group is not equal to foo or bar: $2!~foo | bar, or if the first captured group equals the name of the current lexer state: $1 == $S0.
     *
     *      If both op and match are empty and there is just a pattern, then the guard succeeds if the pattern is non- empty.
     *      This can be used for example to improve efficiency.
     *      In the Koka language, an upper case identifier followed by a dot is module name, but without the following dot it is a constructor.
     *      This can be matched for in one go using:
     *
     *      [/([A-Z](?:[a-zA-Z0-9_]|\-[a-zA-Z])*)(\.?)/,
     *          { cases: { '$2': ['identifier.namespace', 'keyword.dot']
     *                   , '@default': 'identifier.constructor' }}
     *      ]
     */
    type CustomContentTypeTokenizationRuleCasesAction = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines suggestions for code completion in a custom language.
     */
    type CustomContentTypeSuggestSupport = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines a code suggestion snippet for a custom language.
     */
    type CustomContentTypeSuggestSupportSnippet = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Auto Complete matcher for custom content type.
     */
    type CustomContentTypeAutoCompleteMatcher = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Auto indent matcher for custom content type.
     */
    type CustomContentTypeAutoIndentMatcher = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * JSON schema
     */
    type JSONSchema = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * JSON configuration.
     */
    type JSONConfiguration = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines an extra library for intellisense in the typescript editor.
     */
    type TypeScriptExtraLib = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * The typescript script target.
     */
    const TypeScriptScriptTarget: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * TypeScript compiler options.
     */
    type TypeScriptCompilerOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * TypeScript editor configuration.
     */
    type TypeScriptConfiguration = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor configuration.
     */
    type Configuration = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor view model contract.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  A position in the text editor.  Same properties as a Monaco IPosition interface
     */
    type EditorPosition = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  Editor marker definition
     */
    const MarkerSeverity: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  Editor marker definition
     */
    type EditorMarker = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete.
     * Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     *  A Range of text in the text editor. Same properties as a Monaco IRange interface
     */
    type EditorRange = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Documents.Editor and its associated types are obsolete. Use Fx/Controls/Editor instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Editor view model implementation.
     */
    const ViewModel: Obsolete;
    type ViewModel = Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\EditableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.EditableControl {
    interface Contract<TValue> extends Loadable.Contract {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
    }
    class ViewModel<TValue> extends Loadable.ViewModel implements Contract<TValue> {
        /**
         * Name attribute of the control to use with form.
         */
        name: string;
        /**
         * Value held by the control. Can be any type.
         */
        value: KnockoutObservable<TValue>;
        /**
         * Original value of the field. Controls edited state.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Creates an editable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownload.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownload {
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Type = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Status: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DownloadProgressDialogOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type UriCallbackConfirmationDialogOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type UriCallbackErrorMessage = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Context: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\FileDownload\ViewModels.FileDownloadButton.d.ts
declare module MsPortalFx.ViewModels.Controls.FileDownloadButton {
    /**
     * MsPortalFx.ViewModels.Controls.FileDownloadButton is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.FileDownloadButton is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Forms\CopyableLabel.d.ts
declare module MsPortalFx.ViewModels.Controls.Forms.CopyableLabel {
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * This control is no longer supported. Use Fx/Controls/CopyableLabel instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Internal\IFrame.d.ts
declare const enum IframeEnum {
    DefaultTimeOutInMs = 30000
}
/**
 * The Public ViewModel.
 */
declare module MsPortalFx.ViewModels.Controls.Internal.IFrame {
    /**
     * The scroll options.
     *
     * @deprecated Options has been deprecated. Please migrate to Fx/Controls/FrameControl for this scenario.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * The enum is not a const enum and hence not marking it as obsolete for November 2020 SDK release to maintain runtime compatability.
     */
    enum Scroll {
        /**
         * Only when needed.
         */
        Auto = 1,
        /**
         * Always provide a scroll bar.
         */
        Yes = 2,
        /**
         * Never provide a scoll bar.
         */
        No = 3
    }
    /**
     * MsPortalFx.ViewModels.Controls.Internal.IFrame is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FrameControl.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Internal.IFrame is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FrameControl.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    class ViewModel<TItem, TSelection> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements Contract<TItem, TSelection>, MsPortalFx.Base.Disposable {
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * Shows the column header.
         */
        showHeader: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items: KnockoutObservableArray<TItem>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage: KnockoutObservable<string>;
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions: number;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionsOptions: ExtensionsOptions<TItem, TSelection>;
        /**
         * The list of sortBy data.
         */
        sortByList: KnockoutObservableArray<SortBy>;
        /**
         * Row metadata associated to rows in the grid (editState, selected, disabled, groupId).
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private rowMetadata;
        /**
         * The selectable set used for selection and activation.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
        /**
         * The created items for editable grids.
         */
        createdItems: KnockoutObservableArray<TItem>;
        /**
         * Aria label for the grid control
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Callback for getting the aria label for a row
         */
        getRowAriaLabel: (item: TItem) => string;
        /**
         * list of properties that should trigger updating the aria label when changed
         */
        rowAriaLabelDependencies?: string[];
        rowAdd: JQueryEventHandler;
        /**
         * The resetCallback will be populated internally by the Grid control.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * Observable used to add a new empty row to the grid.
         * This property doesn't start with underscore since it needs to passed on to shell iframe.
         * The extended contract in the control has this as a property on the interface to consume changes.
         */
        private addEmptyRow;
        private _addCreatedLocked;
        private _resetHandler;
        private _pendingResetCallbackPromise;
        private _editScope;
        private _msPortalFxActions;
        /**
         * Creates the view model that drives the Grid portal control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         * @param items The observable list of items to be displayed in the grid.
         * @param extensions The bitmask of grid plugins to load.
         * @param extensionsOptions Options for extensions.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, items: KnockoutObservableArray<TItem>, extensions?: number, extensionsOptions?: ExtensionsOptions<TItem, TSelection>);
        /**
         * Gets the row metadata for an item.
         *
         * @param item The grid item whose metadata is requested.
         * @returns Row metadata associated to the item.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * Option to reset the view model state for rebind scenarios.
         * Extension authors can override this method if Grid's default reset action doesn't meet their requirements.
         * This method will be called when DataNavigator's resetNavigation method is called.
         * The reset() method will internally invoke the resetCallback set by the grid control.
         * For pageable extension, calling reset will set empty array to the items, invoke data navigator's resetLoadByContinuationToken method
         * and invoke loadByContinuationToken method to fetch new data.
         */
        reset(): Promise<any>;
        /**
         * Disposes the grid view model.
         */
        dispose(): void;
        private _createMetadataForItem;
        private _create;
        private _addCreated;
        private _markForDelete;
        private _addInitialCreatedRow;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Base.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Extensions {
        /**
         * Plugin to have sortable columns.
         */
        SortableColumn = 1,
        /**
         * Plugin to have selectable rows.
         */
        SelectableRow = 2,
        /**
         * Plugin to have right-clickable row.
         */
        RightClickableRow = 4,
        /**
         * Plugin to group rows by column value.
         */
        Groupable = 8,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        EditableRow = 16,
        /**
         * Plugin to have filterable rows.
         */
        Filterable = 32,
        /**
         * Plugin to have reorder rows.
         */
        ReorderRow = 64,
        /**
         * Plugin to have a shortcut to the item context menu displayed in the row.
         */
        ContextMenuShortcut = 128,
        /**
         * Plugin to handle and display large items in sequential pages.
         */
        Pageable = 256,
        /**
         * Plugin to display hierarchical items.
         */
        Hierarchical = 512,
        /**
         * Plugin to control scrolling behavior.
         * This plugin is always enabled.
         * It is no longer a requirement to specify this plugin explicitly.
         * The options can be used to control vertical and horizontal scrolling behavior.
         */
        Scrollable = 1024,
        /**
         * Plugin to enable hover index communication with other parts.
         */
        Hoverable = 2048,
        /**
         * Plugin to have resizable columns.
         */
        ResizableColumn = 4096
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Gets the aria label for a row
         */
        getRowAriaLabel?: (item: TItem) => string;
        /**
         * list of properties that should trigger updating the aria label when changed
         */
        rowAriaLabelDependencies?: string[];
    }
    interface RowMetadata<T> {
        /**
         * One entry representing the item.
         */
        item: T;
        /**
         * Css class associated with the row.
         */
        cssClass?: KnockoutObservable<string>;
        /**
         * The row accessibility label.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    interface Column {
        /**
         * Name of the column displayed in the header.
         */
        name?: KnockoutObservable<string>;
        /**
         * String mapping to the item key.
         */
        itemKey: string;
        /**
         * Formatter used when displaying one cell.
         */
        format?: Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: FormatOptions;
        /**
         * Declare this column is activatable.  The control will automatic apply activatable style through this column.
         */
        activatable?: KnockoutObservableBase<boolean>;
        /**
         * Css class associated with the column.
         */
        cssClass?: string;
        /**
         * The column width.
         * Percentage '%', pixel 'px', and fractional 'fr' units are supported.
         * Pixel widths are rendered at the specified width.
         * Percentage widths are relative to the available space in the container.
         * Fractional widths are used divide up the remaining space proportionally.
         * When undefined the width is treated as '1fr' which equally divides the space between all visible columns of undefined width.
         * Fractional and percentage widths will use minWidth when horizontal scrolling is enabled.
         */
        width?: KnockoutObservable<string>;
        /**
         * The column recommended minimum width.
         * The default is determined by UX and may change.
         * Fractional and percentage columns will be limited to this minimum when the grid width changes.
         * Pixel width columns do not resize on width changes.
         * Users may still size resizable columns smaller than the minimum.
         * Generally you should not have to set this unless you know all the data in the column will be relatively small or large.
         */
        minWidth?: number;
        /**
         * Indicate this column text need to support ellipse
         */
        enableEllipse?: KnockoutObservableBase<boolean>;
        /**
         * Enable cell content to height 100%
         */
        fullHeight?: KnockoutObservableBase<boolean>;
        /**
         * Forward-compat for Grid2.
         * No use in Grid1.
         */
        id?: string;
        /**
         * Hides the column in collapsed state.
         */
        hiddenInCollapsed?: KnockoutObservableBase<boolean>;
        /**
         * Callback for getting the aria label for a cell
         */
        getCellAriaLabel?: (item: any) => string;
        /**
         * Aria label for column header.
         * Only required for accessibility when the column name (header text) is empty.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * Grid reset callback.
     */
    interface GridResetCallback {
        (): Promise<any>;
    }
    /**
     * Generic grid callback interface.
     */
    interface GridCallback {
        (): Promise<any>;
    }
    interface ExtensionContract extends Loadable.Contract {
        /**
         * The bitmask of plugins to be loaded.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensions?: number;
    }
    interface ContractBase<TItem> {
        /**
         * Shows the column header.
         */
        showHeader?: boolean;
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<TItem>;
    }
    interface Contract<TItem, TSelection> extends ContractBase<TItem>, ExtensionContract {
        /**
         * Summary of the table.
         */
        summary: KnockoutObservable<string>;
        /**
         * No rows message when no items are displayed.
         */
        noRowsMessage?: KnockoutObservable<string>;
        /**
         * Options used to configure the loaded plugins.
         * Updating this property after the widget is initialized will have no effect.
         */
        extensionsOptions?: ExtensionsOptions<TItem, TSelection>;
        /**
         * Gets the row metadata for an item.
         *
         * @param item The grid item whose metadata is requested.
         * @returns Row metadata associated to the item.
         */
        getRowMetadata(item: TItem): RowMetadata<TItem>;
        /**
         * Option to reset the view model state for rebind scenarios.
         * Extension authors can override this method if Grid's default reset action doesn't meet their requirements.
         * This method will be called when DataNavigator's resetNavigation method is called.
         * The reset() method will internally invoke the resetCallback set by the grid control.
         * For pageable extension, calling reset will set empty array to the items, invoke data navigator's resetLoadByContinuationToken method
         * and invoke loadByContinuationToken method to fetch new data.
         */
        reset(): Promise<any>;
        /**
         * The resetCallback will be populated internally by the Grid control.
         */
        resetCallback: KnockoutObservableBase<GridResetCallback>;
        /**
         * The list of sortBy data.
         */
        sortByList: KnockoutObservableArray<SortBy>;
    }
}
declare module FxImpl.ViewModels.Controls.Lists.Grid {
    /**
     * Internal grid interface.
     */
    interface Actions {
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ContextMenuShortcut.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface RowMetadata<T> {
        /**
         * Indicates if the row should show allow showing the context menu by shortcut button or keyboard shortcut.
         */
        canShowMenu?: KnockoutObservableBase<boolean>;
    }
    interface ContextMenuShortcutOptions<T> {
        /**
         * Callback to specify if row should support a context menu.
         */
        canShowMenu?: (item: T) => boolean;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ContextMenuShortcut grid extension.
         */
        contextMenuShortcut?: ContextMenuShortcutOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.EditableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    const enum EditableRowPlacement {
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        Bottom = 0,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        Top = 1
    }
    interface Column {
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        editableFormat?: Obsolete;
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        editableFormatOptions?: Obsolete;
    }
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type EditableRowMetadata = Obsolete;
    interface RowMetadata<T> {
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        editState?: Obsolete;
    }
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type EditScopeModel<T> = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type EditableRowOptions<T> = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type EditableRowExtensionOptions<TItem, TSelection> = Obsolete;
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        editableRow?: Obsolete;
    }
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type EditableRowContract<TItem, TSelection> = Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FieldInfo.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type TextFormFieldInfo = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type CheckBoxFormFieldInfo = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type DropDownItem<T> = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type DropDownGroup<T> = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type DropDownFormFieldInfo<T> = Obsolete;
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are oboslete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type GroupDropDownFormFieldInfo<T> = Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Filterable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Format used when filtering a grid.
         */
        filterableFormat?: Format;
        /**
         * Format options associated with the filterableFormat.
         */
        filterableFormatOptions?: FormatOptions;
    }
    interface FilterableOptions {
        /**
         * Whether the filter search box close button is visible or not.
         */
        searchBoxCloseButtonVisible?: KnockoutObservableBase<boolean>;
        /**
         * The placeholder text to be shown in the search box.
         */
        searchBoxPlaceholder?: KnockoutObservable<string>;
        /**
         * Whether the filter search box is visible or not.
         */
        searchBoxVisible?: KnockoutObservableBase<boolean>;
        /**
         * The subset of visible column names to search through.
         */
        searchableColumns?: KnockoutObservableArray<string>;
        /**
         * The query string of the searchbox.
         */
        queryString?: KnockoutObservableBase<string>;
        serverFilter?: KnockoutObservableBase<boolean>;
        /**
         * Specify a delay timeout to control when filter value change notification should be done.
         * For server filtering, based on the backend processing capabilities, fine tune this value.
         * For slow backends, have this value higher so that repeated callbacks to backends are not made.
         */
        valueUpdateDelayTimeout?: KnockoutObservableBase<number>;
    }
    interface FilterableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the filterable plugin.
         */
        filterable?: FilterableOptions;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the filterable plugin.
         */
        filterable?: FilterableOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.FocusableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface FocusableRowMetadata<T> extends RowMetadata<T> {
        /**
         * Indicates if the row is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    interface RowMetadata<T> {
        /**
         * Indicates if the row is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    interface FocusableOption {
        focusable?: KnockoutObservableBase<boolean>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Formatters.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum Format {
        /**
         * HTML format, raw HTML is allowed.
         */
        Html = 1,
        /**
         * Text format, HTML gets encoded.
         * The value can also be simple text or a KnockoutObservable object.
         */
        Text = 2,
        /**
         * Short time format, outputs something similar to 11:20 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortTime = 100,
        /**
         * Long time format, outputs something similar to 11:20:19 AM.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongTime = 101,
        /**
         * Short date format, outputs something similar to 7/18/2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        ShortDate = 102,
        /**
         * Long date format, outputs something similar to Thursday, July 18, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        LongDate = 103,
        /**
         * Month and day format, outputs something similar to July 18.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        MonthDay = 104,
        /**
         * Year and month format, outputs something similar to July, 2013.
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        YearMonth = 105,
        /**
         * Custom date format, outputs the format based on formatOptions.dateFormat
         * The value can be a number (milliseconds since 1970), text understood by new Date(text) or a Date.
         */
        CustomDate = 106,
        /**
         * URI format, outputs a clickable URI.
         * The value can be an URI, or this format: { uri: string; text: string; target?: string } .
         */
        Uri = 107,
        /**
         * Icon format, outputs an icon with optionally text beside it.
         * The value can be an icon URI, or this format: { uri: string; text?: string; } .
         */
        Icon = 108,
        /**
         * Icon Lookup format, outputs an icon based on a dictionary you provide in formatOptions.iconLookup.
         * The value is the key that matches the iconLookup dictionary.
         * The iconLookup dictionary can be { key: iconUri, ... } or { key: { uri: string, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        IconLookup = 109,
        /**
         * Text Lookup format, outputs text based on a dictionary you provide in formatOptions.textLookup.
         * The value is the key that matches the textLookup dictionary.
         * The textLookup dictionary is { key: text, ... } .
         */
        TextLookup = 110,
        /**
         * Svg icon format, outputs an svg icon with optional text beside it.
         * The value can be an SVG, or this format: { svg: MsPortalFx.Base.Image; text?: string; } .
         */
        SvgIcon = 111,
        /**
         * Svg icon lookup format, outputs an icon based on a dictionary you provide in formatOptions.svgIconLookup.
         * The value is the key that matches the svgIconLookup dictionary.
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        SvgIconLookup = 112,
        /**
         * Visually represents a percentage (values between 0-100) with a bar.
         */
        PercentageBar = 113,
        /**
         * Displays globalized numbers
         */
        Number = 114,
        /**
         * Html Bindings format, uses a template defined in formatOptions.htmlBindingsTemplate and apply the binding defined in formatOptions.htmlBindingsViewModel.
         * The value can be anything that the view model can understand. See the HtmlBindingsType for more details.
         */
        HtmlBindings = 1000
    }
    enum HtmlBindingsType {
        /**
         * Will return an object containing the following:
         * { value: any, settings?: CellFormatterSettings }
         *
         * The value is the one from your itemKey, the settings vary depending on which plugin is loaded into the grid.
         */
        Default = 0,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        CheckBox = 1,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        TextBox = 2,
        /**
         * CheckBox ViewModel which maps your data with the state of the row, selected/unselected for checked/unchecked.
         */
        CheckBoxRowSelection = 4,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        DropDown = 5,
        /**
         * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        GroupDropDown = 6
    }
    /**
     * Controls the location of text in a PercentageBar formatter.
     */
    const enum PercentageBarTextLocation {
        /**
         * Text is not displayed in the formatter.
         */
        None = 0,
        /**
         * Text is displayed above the bar.
         */
        Above = 1,
        /**
         * Text is displayed below the bar.
         */
        Below = 2,
        /**
         * Text is displayed over the bar.
         */
        Overlay = 3
    }
    interface TextAndSvg {
        /**
         * SVG icon.
         */
        svg: MsPortalFx.Base.Image;
        /**
         * Value representing the text.
         */
        text?: string;
        /**
         * Css value for height of svg icon.
         */
        height?: string;
        /**
         * Css value for width of svg icon.
         */
        width?: string;
    }
    interface PercentageBarOptions {
        /**
         * Determines if a distinct background for the bar is drawn so the user can see exactly where 100% would be.
         * Accepts color codes like "a2" and "f0".  See the color palette style guide for more info.
         * Defaults to null, which is transparent
         */
        backgroundColor?: string;
        /**
         * Sets the default percentage bar color. Accepts color codes like "a2" and "f0".
         * See the color palette style guide for more info.
         */
        barColorDefault?: string;
        /**
         * The location of text in relation to the bar.  by default, text labels are not displayed, equivalent to PercentageBarTextLocation.None.
         */
        textLocation?: PercentageBarTextLocation;
        /**
         * If set, this key is used to specify a label for the bar. If not set, the value from the column is used as the text for the bar.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        textKey?: any;
        /**
         * Specifies a property name on the row item that will contain a color code like "a2" or "f0" that should be used for the bar on that particular row.
         * This is similar to how you specify where a column value comes from using Column.itemKey.
         */
        barColorKey?: string;
    }
    /**
     * @deprecated The EditableRow grid extension/plugin and associated control formatters are obsolete.  Please use the "Fx/Controls/EditableGrid" control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type HtmlBindingsData = Obsolete;
    interface FormatOptions {
        /**
         * Date format if using the CustomDate.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DateTimeFormat
         * string entries are deprecated.
         * http://msdn.microsoft.com/en-us/library/az4se3k1.aspx
         */
        dateFormat?: string | MsPortalFx.Intl.DateTimeFormatOptions;
        /**
         * Number format.
         * Accepts standard javascript formats: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat
         * Not specifying any format options causes the default globalization formatter to be used.
         */
        numberFormat?: MsPortalFx.Intl.NumberFormatOptions;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the iconUri or an object as such { uri: string, text?: string } .
         */
        iconLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value is the text mapped to the value.
         */
        textLookup?: any;
        /**
         * Dictionary with key matching the value of the itemKey.
         * The value can be either the MsPortalFx.Base.Image or an object as such { uri: MsPortalFx.Base.Image, text?: string } .
         * The svgIconLookup dictionary can be { key: MsPortalFx.Base.Image, ... } or { key: { svg: MsPortalFx.Base.Image, text?: string }, ... } .
         * Optionally, you can have a key called "##DEFAULT##" to display any value not mapped by your dictionary.
         */
        svgIconLookup?: any;
        /**
         * Can specify the default color and toggle background of the percentage bar.
         */
        percentageBar?: PercentageBarOptions;
        /**
         * HTML which applyBindings will be executed on.
         * To know which variables will be available, see the HtmlBindingsType.
         */
        htmlBindingsTemplate?: string;
        /**
         * ViewModel bound to the htmlBindingsTemplate.
         */
        htmlBindingsType?: HtmlBindingsType;
        /**
         * Data required by the specified htmlBindingType for rendering the HtmlBinding.
         */
        htmlBindingsData?: any;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Groupable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    enum SortFunction {
        /**
         * Uses the built-in Array.sort() function.
         */
        Default = 0,
        /**
         * Uses the getTime() value of Date object to sort.
         */
        DateTime = 1,
        /**
         * Uses the setting list sorting, that ensures some groups are prioritized over others.
         */
        SettingListGroupOrder = 9999
    }
    interface GroupableRowMetadata<T> extends RowMetadata<T> {
        /**
         * The ID of the group, typically mapping to a unique value in the column being grouped by.
         */
        groupId?: KnockoutObservable<string>;
    }
    interface RowMetadata<T> {
        /**
         * The ID of the group, typically mapping to a unique value in the column being grouped by.
         */
        groupId?: KnockoutObservable<string>;
    }
    interface Group {
        /**
         * The unique value corresponding to the group.
         * This value will be passed to the formatter.
         */
        value: any;
        /**
         * The format used to display the group header.
         * By default, the plain text formatter is used if none is specified.
         */
        format?: Format;
        /**
         * The format used to sort the group header.
         * By default, it matches the group.format.
         */
        sortFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        formatOptions?: FormatOptions;
        /**
         * Format options associated with the chosen sortFormat.
         */
        sortFormatOptions?: FormatOptions;
    }
    interface GroupableOptions {
        /**
         * The item field/column in the data set that the groups map to/are created from.
         * When groups are determined automatically, uniqueness is determined by taking the toString() of the
         * value this key maps to for each item.
         */
        groupKey: KnockoutObservable<string>;
        /**
         * Format used when displaying group headers.
         * By default, the plain text formatter is used.
         */
        headerFormat?: Format;
        /**
         * Format options associated with the chosen header format.
         */
        headerFormatOptions?: FormatOptions;
        /**
         * An observable array of Group objects, to be rendered in indexed order.
         * If this array is not provided, it is inferred from the column values mapped to groupKey.
         */
        groups?: KnockoutObservableArray<Group>;
        /**
         * Format used when displaying the group header for groupless items.
         * By default, the plain text formatter is used if none is specified.
         */
        noGroupLabelFormat?: Format;
        /**
         * Format options associated with the chosen format.
         */
        noGroupLabelFormatOptions?: FormatOptions;
        /**
         * Sort order to display groups in (Unsorted, Ascending, or Descending).
         */
        sortOrder?: KnockoutObservableBase<SortOrder>;
        /**
         * Sort function to apply to the group values. Defaults to the built-in sort function.
         */
        sortFunction?: SortFunction;
        /**
         * callback to get the aria label of a group.
         */
        getGroupAriaLabel?: (groupValue: any) => string;
    }
    interface GroupableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the groupable plugin.
         */
        groupable?: GroupableOptions;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the groupable plugin.
         */
        groupable?: GroupableOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hierarchical.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface Column {
        /**
         * Indicate that the column should be displayed as a hierarchy with expand/collapse indicators.
         */
        hierarchical?: boolean;
    }
    interface HierarchicalItem {
        /**
         * Depth of item nesting.
         * Zero for top-level items.
         */
        depth: KnockoutObservableBase<number>;
        /**
         * Indicates if the item is expandable.
         * Undefined indicates expandability is unknown yet.
         */
        expandable: KnockoutObservableBase<boolean>;
        /**
         * Indicates if the item is expanded or collapsed.
         */
        expanded: KnockoutObservableBase<boolean>;
    }
    interface Hierarchy<THierarchicalItem extends HierarchicalItem> {
        /**
         * The items to display in the grid.
         */
        items: KnockoutObservableBase<THierarchicalItem[]>;
        /**
         * Expands a hierarchy item.
         *
         * @param item The item to expand.
         */
        expand: (item: THierarchicalItem) => void;
        /**
         * Collapses a hierarchy item.
         *
         * @param item The item to expand.
         */
        collapse: (item: THierarchicalItem) => void;
        /**
         * Expands all hierarchy items.
         */
        expandAll: () => void;
        /**
         * Collapses all hierarchy items.
         */
        collapseAll: () => void;
    }
    interface HierarchicalOptions<THierarchicalItem extends HierarchicalItem> {
        /**
         * Provides the hierarchical data to the grid.
         */
        hierarchy: Hierarchy<THierarchicalItem>;
    }
    interface HierarchicalExtensionOptions<THierarchicalItem extends HierarchicalItem, TSelection> extends ExtensionsOptions<THierarchicalItem, TSelection> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions<THierarchicalItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the hierarchical plugin.
         */
        hierarchical?: HierarchicalOptions<TItem & HierarchicalItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Hoverable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface HoverableOption extends FocusableOption {
        /**
         * The name of a property on the grid item that holds the id to use for hover.
         */
        hoverIDKey?: KnockoutObservableBase<string>;
        /**
         * The id of the currently hovered item or null.
         */
        hoveredID?: KnockoutObservableBase<string>;
    }
    interface FocusableRowHoverExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the hoverable plugin.
         */
        hoverable?: HoverableOption;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the hoverable plugin.
         */
        hoverable?: HoverableOption;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Pageable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    /**
     * Defines the pageable options.
     */
    enum PageableType {
        /**
         * Sequential will load a "Load more" button.
         */
        Sequential = 0,
        /**
         * Pageable will load a paging control allowing to go on different pages.
         */
        Pageable = 1
    }
    interface PageableOptions<TItem> {
        /**
         * Type of pager to load with the extension.
         */
        type?: PageableType;
        /**
         * Optionally change the label text that's displayed to load more data for squential pageable type.
         */
        label?: KnockoutObservableBase<string>;
        /**
         * Optionally show or hide the load more display label for squential pageable type.
         */
        showLabel?: KnockoutObservableBase<boolean>;
        /**
         * Specifies the data source which supports pageable data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
        itemsPerPage?: KnockoutObservable<number>;
        /**
         * @deprecated pagerMaxPages is deprecated.  This is ignored with the current user experience.
         */
        pagerMaxPages?: number;
    }
    interface PageableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the pageable plugin.
         */
        pageable?: PageableOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the pageable plugin.
         */
        pageable?: PageableOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ReorderRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ReorderRowEventObject<T> {
        /**
         * Metadata for moved row items.
         */
        rowMetadata: RowMetadata<T>[];
        /**
         * 0-Index position where the row got dropped.
         */
        position: number;
    }
    interface ReorderRowOptions<TItem> {
        /**
         * Disables the reorder plugin. Defaults to false.
         */
        disabled?: KnockoutObservableBase<boolean>;
        /**
         * Automatically reorder rows after a drop happened. If set to false, the developer needs to change the inner view model.
         * Defaults to true.
         */
        automaticallyReorderRows?: boolean;
        /**
         * Callback when a row gets reordered.
         *
         * @param evt Event used for the row reordering.
         * @param args Reordered row object.
         */
        rowReorder?: (evt: JQueryEventObject, args: ReorderRowEventObject<TItem>) => void;
    }
    interface ReorderRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ReorderRow grid extension.
         */
        reorderRow?: ReorderRowOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ReorderRow grid extension.
         */
        reorderRow?: ReorderRowOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.ResizableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ResizableColumn extends Column {
        /**
         * Disables resizable for a specific column.
         */
        disableResizable?: KnockoutObservable<boolean>;
        /**
         * Column displays a resize handle.
         */
        hasHandle?: KnockoutObservable<boolean>;
    }
    interface ResizableColumnOptions<TItem> {
        "--noUnusedLocals"?: TItem;
        /**
         * Indicates if columns are resizable. Defaults to true.
         */
        resizable?: KnockoutObservable<boolean>;
    }
    interface ResizableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ResizableColumn grid extension.
         */
        resizableColumn?: ResizableColumnOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the ResizableColumn grid extension.
         */
        resizableColumn?: ResizableColumnOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.RightClickableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface RightClickableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
    }
    interface ExtensionsOptions<TItem, TSelection> {
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.Scrollable.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    interface ScrollableOptions<TItem> {
        /**
         * Specifies the data source which supports random data access.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
        /**
         * Enables or disables horizontal scrolling.
         * By default horizontal scrolling is enabled to meet accessibility requirements.
         * When enabled flexible width columns (%/fr) will maintain a minimum width.
         * Pixel width columns will remain their specified widths when the grid is resized.
         * If the total required width is greater than the grid width a horizontal scroll bar is shown.
         * If you don't ever want a horizontal scrollbar this can be set to false and horizontal overflow will be clipped.
         */
        horizontal?: boolean;
        /**
         * Enables or disables vertical scrolling.
         * For backwards compatibility vertical scrolling is enabled by default when:
         *   scrollable options are provided
         *   or the scrollable plugin is explicitly specified
         * For backwards compatibility vertical scrolling is disabled by default when:
         *   scrollable options are not provided
         *   and the scrollable plugin is not explicitly specified.
         * If you do not want the default behavior set this option explicitly.
         */
        vertical?: boolean;
    }
    interface ScrollableExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the scrollable plugin.
         */
        scrollable?: ScrollableOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the scrollable plugin.
         */
        scrollable?: ScrollableOptions<TItem>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SelectableRow.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    const enum RowSelectionMode {
        /**
         * Indicates that the user cannot select or unselect rows by clicking.
         */
        Off = 0,
        /**
         * Indicates that the user can select one row at at time by clicking.
         */
        Single = 1,
        /**
         * Indicates that the user can select and unselect multiple rows at at time by clicking and control-clicking.
         */
        Multiple = 2,
        /**
         * Indicates that the user can toggle selection on multiple rows
         */
        MultipleToggle = 3
    }
    /**
     * Link data for browser navigation.
     */
    interface Link {
        /**
         * The uri to open when the link is activated.
         */
        uri: string;
        /**
         * The target to use them the link is activated.
         */
        target?: string;
    }
    interface SelectableRowMetadata<T> extends FocusableRowMetadata<T> {
        /**
         * Indicates if the row is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates the columnKey if the row is activated. null if deactivated.
         */
        activated?: KnockoutObservableBase<string>;
        /**
         * Additional information for this Activated cell.
         */
        activatedInfo?: KnockoutObservableBase<string>;
        /**
         * Link that is invoked when row is clicked or space bar is pressed instead of blade activation.
         */
        link?: KnockoutObservableBase<Link>;
        /**
         * This can be set to 'false' to suppress the default activation behavior (which is to open a child Blade) for the associated row.
         * This should be used in tandem with the 'SelectableRowExtensionOptions.onRowClicked' callback
         * to supply activation behavior (often, in-place activation) that is custom to the extension.
         */
        useDefaultActivation?: KnockoutObservableBase<boolean>;
    }
    interface RowMetadata<T> {
        /**
         * Indicates if the row is selected.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * Indicates the columnKey if the row is activated. null if deactivated.
         */
        activated?: KnockoutObservableBase<string>;
        /**
         * Additional information for this Activated cell.
         */
        activatedInfo?: KnockoutObservableBase<string>;
        /**
         * Link that is invoked when row is clicked or space bar is pressed instead of blade activation.
         */
        link?: KnockoutObservableBase<Link>;
        /**
         * This can be set to 'false' to suppress the default activation behavior (which is to open a child Blade) for the associated row.
         * This should be used in tandem with the 'SelectableRowExtensionOptions.onRowClicked' callback
         * to supply activation behavior (often, in-place activation) that is custom to the extension.
         */
        useDefaultActivation?: KnockoutObservableBase<boolean>;
    }
    interface SelectableRowEventObject<T> {
        /**
         * Selected row.
         */
        selected?: SelectableRowMetadata<T>;
        /**
         * Unselected row.
         */
        unselected?: SelectableRowMetadata<T>[];
    }
    /**
     * Options for the SelectableRow grid extension.
     */
    interface SelectableRowOptions<TItem, TSelection> {
        /**
         * Specifies what type of selectability is allowed for rows.
         */
        selectionMode?: RowSelectionMode;
        /**
         * Disables selecting all rows at once by the header checkbox
         * and ctrl+a when in multiselect selection mode.
         */
        disableSelectAll?: boolean;
        /**
         * A function that determines if an item matches a selection.
         *
         * @param item The grid row item to be matched.
         * @param selection The selection to match the item to.
         * @returns True if the item matches the selection; else false.
         */
        itemMatchesSelection?: (item: TItem, selection: TSelection) => boolean;
        /**
         * A factory function that creates a selection based on an item.
         *
         * @param item The grid row item for which selection needs to be created.
         * @returns The selection for the specified item.
         */
        createSelection?: (item: TItem) => TSelection;
        /**
         * Selection state that has been previously saved as part of view state for this grid.
         */
        initialSelection?: MsPortalFx.ViewModels.SetSelection<TSelection>;
        /**
         * Currently Activated Column Key.
         */
        activatedColumnKey?: KnockoutObservableBase<string>;
        /**
         * Primary Activate Column Key.  This is to support double click, context menu and activateOnSelected.
         */
        primaryActivateColumnKey?: KnockoutObservableBase<string>;
        /**
         * Indicates that the row should activate when selected.
         */
        activateOnSelected?: KnockoutObservableBase<boolean>;
        /**
         * Callback when a row gets selected.
         *
         * @param evt Event used for the row selection.
         * @param args Selected and unselected objects.
         */
        rowSelect?: (evt: JQueryEventObject, args: SelectableRowEventObject<TItem>) => void;
        /**
         * Disable require Ctrl or Shift Key for Single Mode mode to toggle selection on Click.
         */
        disableRequireSingleModeAssistKey?: KnockoutObservable<boolean>;
        /**
         * Enable selectable cursor to move to next or previous selected item.
         */
        enableSelectableCursor?: KnockoutObservableBase<boolean>;
        /**
         * Method that may designate links for row items.
         * When a link is returned the link will be opened when clicking on the row instead of blade activation.
         */
        linkProvider?: (litetime: MsPortalFx.Base.LifetimeManager, item: TItem) => KnockoutObservableBase<Link>;
        /**
         * Supplies context menu commands for a grid row.
         *
         * @param dataItem The row data item.
         * @param commandLifetime The lifetime manager for command related allocations.
         * @returns An array of toolbar items for the row commands.
         */
        supplyCommands?: (dataItem: TItem, commandLifetime: MsPortalFx.Base.LifetimeManager) => MsPortalFx.ToolbarItemContract[];
        /**
         * If set this will leave activated & selected items in a selected state after they are deactivated.
         * This defaults to true for single select mode & false for multiselect modes.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    interface SelectableRowExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the SelectableRow grid extension. If null, rows will not be selectable.
         */
        selectableRow?: SelectableRowOptions<TItem, TSelection>;
        /**
         * Add custom click handler for grid row.
         */
        onRowClicked?: (item: TItem) => void;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * Options for the SelectableRow grid extension. If null, rows will not be selectable.
         */
        selectableRow?: SelectableRowOptions<TItem, TSelection>;
        /**
         * Add custom click handler for grid row.
         */
        onRowClicked?: (item: TItem) => void;
    }
    interface SelectableContract<TItem, TSelection> extends Contract<TItem, TSelection> {
        /**
         * Items displayed in the table based on the column definitions when selection is enabled.
         * It is set in the constructor. Do not directly replace it.
         */
        selectableData: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Grid1\Grid1.SortableColumn.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.Grid {
    const enum SortOrder {
        /**
         * Column is unsorted.
         */
        Unsorted = 0,
        /**
         * Column is sorted ascending.
         */
        Ascending = 1,
        /**
         * Column is sorted descending.
         */
        Descending = 2
    }
    interface SortBy {
        /**
         * The item key to sort by.
         */
        itemKey: string;
        /**
         * The direction of the sort either ascending or descending.
         */
        sortOrder: SortOrder;
    }
    interface Column {
        /**
         * Indicates if the column is sortable.
         */
        sortable?: boolean;
        /**
         * Sort order.
         */
        sortOrder?: KnockoutObservable<SortOrder>;
    }
    interface SortableColumnOptions<TItem> {
        /**
         * The sort callback.
         */
        sortCallback?: (sortByList: SortBy[]) => void;
        /**
         * Specifies the data source.
         */
        dataNavigator?: MsPortalFx.Data.DataNavigator<TItem>;
    }
    interface SortableColumnExtensionOptions<TItem, TSelection> extends ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the sortable plugin.
         */
        sortableColumn?: SortableColumnOptions<TItem>;
    }
    interface ExtensionsOptions<TItem, TSelection> {
        /**
         * The options to configure the sortable plugin.
         */
        sortableColumn?: SortableColumnOptions<TItem>;
    }
}
declare module FxImpl.ViewModels.Controls.Lists.Grid {
    /**
     * Internal grid interface.
     */
    interface Actions {
        /**
         * Internal grid action.
         */
        sort?(sortByList: MsPortalFx.ViewModels.Controls.Lists.Grid.SortBy[]): Promise<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Lists\Tree1\TreeView.d.ts
declare module MsPortalFx.ViewModels.Controls.Lists.TreeView {
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" LoadMoreItemsResult instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.TreeContinuationTokenQueryResult.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type TreeContinuationTokenQueryResult = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" ItemMetadata instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.ItemMetadata.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ItemMetadata = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" htmlTemplates option instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.ItemTemplate.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ItemTemplate = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Options instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.Extensions.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Extensions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" SequentialLoadingOptions instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.LoadableByContinuationTokenOptions.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type LoadableByContinuationTokenOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" SelectionMode instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.SelectionMode.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type SelectionMode = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" SelectionOptions instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.SelectableOptions.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type SelectableOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Contract and Options such as selectedItems and selectedPaths instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.SelectableData.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type SelectableData = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" DeferredLoadingOptionsinstead of MsPortalFx.ViewModels.Controls.Lists.TreeView.OnDemandLoadableOptions.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type OnDemandLoadableOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type OnDemandLoadableData = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Options instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.ExtensionOptions.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ExtensionsOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Item instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.Item.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Item = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Contract instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.Contract.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ToggleNodeCallback = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type InternalTreeContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" Contract instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.Contract.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Lists.TreeView is obsolete.
     * Please use "Fx/Controls/TreeView" instead of MsPortalFx.ViewModels.Controls.Lists.TreeView.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\PartPinner.d.ts
declare module MsPortalFx.ViewModels.Controls.PartPinner {
    /**
     * MsPortalFx.ViewModels.Controls.PartPinner.Options is obsolete. Use `import * as FxPinner from "Fx/Pinner";` instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.PartPinner.ViewModel is obsolete. Use `import * as FxPinner from "Fx/Pinner";` instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\SpecComparisonTable.d.ts
declare module MsPortalFx.ViewModels.Controls.SpecComparisonTable {
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SpecComparisonTable and its associated types are obsolete.
     * Please use Fx/Controls/DataGrid, Fx/Controls/EditableGrid, or a custom implementation instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Header background colors
     */
    const Colors: Obsolete;
    type Colors = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SpecComparisonTable and its associated types are obsolete.
     * Please use Fx/Controls/DataGrid, Fx/Controls/EditableGrid, or a custom implementation instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Table header
     */
    type Header = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SpecComparisonTable and its associated types are obsolete.
     * Please use Fx/Controls/DataGrid, Fx/Controls/EditableGrid, or a custom implementation instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Table row
     */
    type Row = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.SpecComparisonTable and its associated types are obsolete.
     * Please use Fx/Controls/DataGrid, Fx/Controls/EditableGrid, or a custom implementation instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
    type ViewModel = Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ValidatableControl.d.ts
declare module MsPortalFx.ViewModels.Controls.ValidatableControl {
    let DefaultDelayValidationTimeout: number;
    interface Contract<TValue> extends EditableControl.Contract<TValue>, MsPortalFx.ViewModels.Controls.Validators.Validatable<TValue> {
    }
    class ViewModel<TValue> extends EditableControl.ViewModel<TValue> implements Contract<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<MsPortalFx.ViewModels.Controls.Validators.ValidationState>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<MsPortalFx.ViewModels.Controls.Validators.Validator<TValue>>;
        /**
         * List of current validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * Creates a validatable control.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Validators.d.ts
declare module MsPortalFx.ViewModels.Controls.Validators {
    const escapeRegExpOperators: typeof regexEscape;
    /**
     * ValidationState represents the current validation state when list of validators are run.
     */
    const enum ValidationState {
        /**
         * Default validation state.
         */
        None = 0,
        /**
         * Validation failed.
         */
        Invalid = 1,
        /**
         * Validation succeeded.
         */
        Valid = 2,
        /**
         * Validation pending during async validation calls.
         */
        Pending = 3
    }
    interface Validatable<TValue> {
        /**
         * Indicates if validation should be skipped or not.
         */
        enableValidation: KnockoutObservable<boolean>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Indicates the current validation state. The validation state is useful when there are async validators and
         * validation completion should be notified.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Validators to apply to the value when validating.
         */
        validators: KnockoutObservableArray<Validator<TValue>>;
        /**
         * List of current validation results.
         */
        validationResults?: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
    }
    interface ValidationPlacement<TValue> {
        /**
         * Initializes the ValidationPlacement.
         *
         * @param element The widget element.
         * @param validatable Interface containing validation specific validators and valid flag.
         */
        initialize(element: JQuery, validatable: Validatable<TValue>): void;
        /**
         * Destroys the artifacts related to the validation placement.
         */
        dispose(): void;
        /**
         * Dispose() has been called.
         */
        isDestroyed(): boolean;
        /**
         * Triggers when the errorMessages ViewModel property changes.
         *
         * @param newValue Array of validation error messages.
         */
        onErrorMessageChanged(newValue: string): void;
        /**
         * Triggers when the validationState ViewModel property changes.
         *
         * @param newValue Current ValidationState value.
         */
        onValidationStateChanged(newValue: ValidationState): void;
    }
    /**
     * Validator base class. Used to define validators that can be attached to an
     * validatable control view model to validate the value.
     */
    class Validator<TValue> {
        private readonly _ltm;
        /**
         * Validation rule error message.
         */
        message: KnockoutObservable<string>;
        /**
         * Indicates if the value was valid the last time validate was called.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * Indicates if the current validation state.
         */
        validationState: KnockoutObservable<ValidationState>;
        /**
         * Evaluates if the value is valid (works cross IFRAME).
         */
        validate: KnockoutObservable<TValue>;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Constructs a validator.
         *
         * @param message Describes the validation rule.
         */
        constructor(message?: string);
        /**
         * Releases resources held by the validator.
         */
        dispose(): void;
        /**
         * Determines if the value is valid.
         * Should be overridden in derived classes.
         *
         * @param value The value to check.
         * @returns Indicates the current validation state.
         */
        _validate(value: TValue): ValidationState;
    }
}

// FILE: MsPortalFx\ViewModels\Controls\ValueUpdateTrigger.d.ts
declare module MsPortalFx.ViewModels.Controls {
    /**
     * MsPortalFx.ViewModels.Controls.ValueUpdateTrigger is obsolete. Use Fx/Controls instead of MsPortalFx Controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Enum to indicate when to trigger value updates.
     */
    const ValueUpdateTrigger: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.BaseHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * MsPortalFx.ViewModels.Controls.HotSpot.BaseViewModel is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const BaseViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.BaseInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.Size is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Size: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.BaseInfoBoxOptions is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type BaseInfoBoxOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.BaseViewModel is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const BaseViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation {
    /**
     * MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation.GridOptions is obsolete.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The options of the grid.
     */
    type GridOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation.Options is obsolete.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The options of the view model.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.DeleteAssetConfirmation.ViewModel is obsolete.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * View model for the DeleteAssetConfirmation control.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Hotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * MsPortalFx.ViewModels.Controls.HotSpot.ViewModel is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.InfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.ViewModel is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.LinkHotspot.d.ts
declare module MsPortalFx.ViewModels.Controls.HotSpot {
    /**
     * MsPortalFx.ViewModels.Controls.HotSpot.LinkHotSpotOptions is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type LinkHotSpotOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.HotSpot.LinkViewModel is obsolete.
     * Use fxclick directly in your HTML template instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const LinkViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.LinkInfoBox.d.ts
declare module MsPortalFx.ViewModels.Controls.InfoBox {
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.LinkInfoBoxOptions is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type LinkInfoBoxOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.InfoBox.LinkViewModel is obsolete. Use the Fx/Controls/Infobox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const LinkViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Notice.d.ts
declare module MsPortalFx.ViewModels.Controls.Notice {
    /**
     * MsPortalFx.ViewModels.Controls.Notice and its associated types are obsolete. Please use Fx/Controls/CustomHtml instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * Types of images for the notice control.
     */
    type ImageType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Notice and its associated types are obsolete. Please use Fx/Controls/CustomHtml instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\ViewModels.Wizard.d.ts
declare module MsPortalFx.ViewModels.Controls.Wizard {
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.WizardStepSelection is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type WizardStepSelection = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.StepState is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type StepState = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.StepInput is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type StepInput = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.StepOutput is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type StepOutput = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.WizardState is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type WizardState = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.SelectorStep is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const SelectorStep: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.Contract is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.WizardStepBase is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type WizardStepBase = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.WizardStep is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const WizardStep: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.ViewModel is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.WizardMode is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const WizardMode: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Wizard.StepType is obsolete and no longer a supported navigation/layout model. Please redesign the affected blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const StepType: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Chart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Chart {
    /**
     * Defines chart types.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ChartType has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ChartType {
        /**
         * Line chart type.
         */
        Line = 0,
        /**
         * Area chart type.
         */
        Area = 1,
        /**
         * Scatter chart type.
         */
        Scatter = 2,
        /**
         * Stacked bar chart type.
         */
        StackedBar = 3,
        /**
         * Grouped bar chart type.
         */
        GroupedBar = 4,
        /**
         * Split bar chart type.
         */
        SplitBar = 5,
        /**
         * Stacked area chart type.
         */
        StackedArea = 6
    }
    /**
     * Defines interpolation of lines of the line chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Interpolation has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum Interpolation {
        /**
         * The series interpolation when data points are connected by straight lines.
         */
        Linear = 0,
        /**
         * The series interpolation when data points are connected by smooth curves. The monotone is a mode of D3 interpolation style.
         */
        Monotone = 1,
        /**
         * The series interpolation when series are connected by two lines: the first one (from the left side) is horizontal and the second one is vertical.
         */
        StepAfter = 2
    }
    /**
     * Defines line styles of the line chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineStyle has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LineStyle {
        /**
         * The series line is solid.
         */
        Solid = 0,
        /**
         * The series line is dotted.
         */
        Dotted = 1,
        /**
         * The series line is dashed.
         */
        Dashed = 2,
        /**
         * The series line is a trendline.
         */
        Trendline = 3,
        /**
         * The series line is a usage threshold.
         */
        UsageThreshold = 4,
        /**
         * The series line is a warning threshold.
         */
        WarningThreshold = 5
    }
    /**
     * Display type for optional line and coordinate plots for stacked area charts.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineState has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LineState {
        /**
         * Display stacked area chart line with coordinate points. Use this for old api behavior showLines(true).
         */
        ShowLineWithPoints = 0,
        /**
         * Hide stacked area chart line. Use this for old api behavior showLines(false).
         */
        HideLine = 1,
        /**
         * Display stacked area chart line with the point nearest to x slider only.
         */
        ShowLineWithXHoverPoint = 2
    }
    /**
     * Defines hatching patterns of the area chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AreaHatchingPattern has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AreaHatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is hatched with main diagonal (\) thin lines. Alternate name aligning with new enums - CounterDiagonalThinLine.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched with horizontal think lines. Alternate name aligning with new enums - HorizontalThickLine
         */
        DottedHatching = 3,
        /**
         * The area is hatched with main diagonal (\) thin lines.
         */
        MainDiagonalThinLine = 4,
        /**
         * The area is hatched with horizontal thin lines.
         */
        HorizontalThinLine = 5,
        /**
         * The area is hatched with vertical thin lines.
         */
        VerticalThinLine = 6,
        /**
         * The area is hatched with main diagonal (\) thick lines.
         */
        MainDiagonalThickLine = 7,
        /**
         * The area is hatched with counter diagonal (/) thick lines.
         */
        CounterDiagonalThickLine = 8,
        /**
         * The area is hatched with vertical thick lines.
         */
        VerticalThickLine = 9,
        /**
         * The area is hatched with main diagonal (\) lines in a smoothed out pattern.
         */
        MainDiagonalSmoothLine = 10,
        /**
         * The area is hatched with counter diagonal (/) lines in a smoothed out pattern.
         */
        CounterDiagonalSmoothLine = 11,
        /**
         * The area is hatched with horizontal lines in a smoothed out pattern.
         */
        HorizontalSmoothLine = 12,
        /**
         * The area is hatched with vertical lines in a smoothed out pattern.
         */
        VerticalSmoothLine = 13,
        /**
         * The area has square pattern.
         */
        Square = 14,
        /**
         * The area has diagonal square pattern.
         */
        DiagonalSquare = 15,
        /**
         * The area has circle pattern.
         */
        Circle = 16,
        /**
         * The area has quarter circle(quadrant) pattern.
         */
        Quadrant = 17
    }
    /**
     * Defines the various sub-types for bar chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.BarChartType has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum BarChartType {
        /**
         * The data series will be rendered as stacked bars for each x value.
         */
        Stacked = 0,
        /**
         * The data series will be rendered as grouped bars for each x value.
         */
        Grouped = 1,
        /**
         * The data series which has positive and negative values will be rendered with axis in the center of the chart.
         */
        Split = 2
    }
    /**
     * Indicates where the chart axis should be visually positioned on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AxisPosition has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AxisPosition {
        /**
         * The axis should not be displayed in the chart.
         */
        None = 0,
        /**
         * The axis should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The axis should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The axis should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The axis should be displayed vertically and aligned left of the chart.
         */
        Left = 4
    }
    /**
     * XSlider, chart click interaction behavior options
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.InteractionBehavior has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    enum InteractionBehavior {
        /**
         * All Interaction is enabled
         */
        All = 0,
        /**
         * Opt out XSlider behavior
         */
        XSlider_Off = 1,
        /**
         * Opt out XSlider callout Text. Not Yet Implemented.
         */
        XSlider_noCallout = 2,
        /**
         * Opt out any interaction in ChartArea.
         */
        ChartArea_Off = 4,
        /**
         * Opt out any ChartArea Click-select behavior. Not Yet Implemented.
         */
        ChartArea_noClick = 8,
        /**
         * Opt out any ChartArea hover behavior. Not Yet Implemented.
         */
        ChartArea_noHover = 16
    }
    /**
     * Indicates where the chart legend should be visually positioned on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LegendPosition has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum LegendPosition {
        /**
         * The chart legend should not be displayed in the chart.
         */
        None = 0,
        /**
         * The legend should be displayed horizontally above the chart.
         */
        Top = 1,
        /**
         * The legend should be displayed vertically and aligned right of the chart.
         */
        Right = 2,
        /**
         * The legend should be displayed horizontally below chart.
         */
        Bottom = 3,
        /**
         * The legend should be displayed vertically and aligned left of the chart.
         */
        Left = 4
    }
    /**
     * Specifies the data label context.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.DataLabelContext has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum DataLabelContext {
        /**
         * The data label should be displayed near the max value of the series.
         */
        Max = 0,
        /**
         * The data label should be displayed near the min value of the series.
         */
        Min = 1,
        /**
         * The data label should be displayed near the first value of the series.
         */
        First = 2,
        /**
         * The data label should be displayed near the last value of the series.
         */
        Last = 3,
        /**
         * The data label should be displayed near every value of the series.
         */
        Every = 4,
        /**
         * The data label should be displayed near custom points.
         */
        Custom = 5
    }
    /**
     * Specifies the data label style.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.DataLabelStyle has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum DataLabelStyle {
        /**
         * The data label should be displayed as a callout.
         */
        Callout = 0,
        /**
         * The data label should be displayed as a badge.
         */
        Badge = 1
    }
    /**
     * Specifies the scale used on the axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Scale has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum Scale {
        /**
         * Specify this scale for discrete values where the values will be mapped 1:1 on the axis.
         */
        Ordinal = 0,
        /**
         * Specify this scale for continuous values like numeric values in the series which may or may not be sorted.
         */
        Linear = 1,
        /**
         * Specify this scale for date / time values in the series which may or may not be sorted.
         */
        Time = 2,
        /**
         * Logarithmic scale for numeric values
         */
        Log = 3
    }
    /**
     * Specifies where the axis label should be displayed.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AxisLabelPosition has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum AxisLabelPosition {
        /**
         * The labels are not displayed.
         */
        None = 0,
        /**
         * The labels are displayed at the low end of the axis.
         */
        Low = 1,
        /**
         * The labels are displayed at the high end of the axis.
         */
        High = 2
    }
    /**
     * Specifies conditions checked on rendering a series view.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ConditionOperator has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ConditionOperator {
        /**
         * The view should be rendered for series segments exceeding the argument of the condition.
         */
        GreaterThan = 0,
        /**
         * The view should be rendered for series segments not exceeding the argument of the condition.
         */
        LessThan = 1
    }
    /**
     * Specifies series type.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesType has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum SeriesType {
        /**
         * The series is defined as a set of pairs of x and y values.
         */
        General = 0,
        /**
         * The series is used to draw a horizontal line and is defined as with the y value.
         */
        HorizontalLine = 1,
        /**
         * The series is used to draw a vertical line and is defined as with the x value.
         */
        VerticalLine = 2,
        /**
         * The series has uniform intervals between x-values. It is defined by the start x-value, the grain and the array of y-values.
         */
        Uniform = 3
    }
    /**
     * Specifies the scope of metrics rules.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleScope has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleScope {
        /**
         * The default scope if other rules are not specified.
         */
        Default = 0,
        /**
         * A single data point is in the scope.
         */
        Point = 2,
        /**
         * Multiple data points from the same series are in the scope.
         */
        MultiplePointsSingleSeries = 3,
        /**
         * Multiple data points from multiple series are in the scope.
         */
        MultiplePointsMultipleSeries = 4
    }
    /**
     * Specifies the aggregation scope of a metric rule.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleAggregationScope has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleAggregationScope {
        /**
         * All selected series should be aggregated into a common metric.
         */
        AllTogether = 0,
        /**
         * All selected series should be aggregated separate metrics.
         */
        AllSeparately = 1,
        /**
         * A metric should be aggregated over a single series.
         */
        SingleSeries = 2
    }
    /**
     * Specifies the aggregation type of a metric rule.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleAggregationType has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum MetricRuleAggregationType {
        /**
         * An x-value of the point selected.
         */
        CurrentXValue = 0,
        /**
         * An y-value of the point selected.
         */
        CurrentYValue = 1,
        /**
         * Min of y-value of points selected.
         */
        MinY = 2,
        /**
         * Max of y-value of points selected.
         */
        MaxY = 3,
        /**
         * Average of y-value of points selected.
         */
        AverageY = 4,
        /**
         * Sum of y-value of points selected.
         */
        SumY = 5,
        /**
         * Count of points selected.
         */
        Count = 6,
        /**
         * Custom value.
         */
        CustomValue = 7
    }
    /**
     * Defines the event data associated with chart event notifications.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.EventData<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface EventData<TX, TY> {
        /**
         * Name of the series.
         */
        seriesName: string;
        /**
         * The value of the current target element.
         */
        value: ChartItem<TX, TY>;
    }
    /**
     * This interface specifies data label properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.DataLabelContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DataLabelContract<TX, TY> {
        "--noUnusedLocals"?: TX | TY | any;
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This interface specifies data label properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.DataLabel<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class DataLabel<TX, TY> implements DataLabelContract<TX, TY> {
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
        /**
         * Defines the data label style.
         */
        style: KnockoutObservable<DataLabelStyle>;
        /**
         * Defines the data label formatter. {0} for series name, {1} for the x-value, {2} for the y-value. X and y values are formatted (date / number) the same way as the corresponding axis tick labels are.
         */
        formatter: KnockoutObservable<string>;
    }
    /**
     * This class specifies custom data label properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.CustomDataLabelContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface CustomDataLabelContract<TX, TY> extends DataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * This class specifies custom data label properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.CustomDataLabel<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class CustomDataLabel<TX, TY> extends DataLabel<TX, TY> implements CustomDataLabelContract<TX, TY> {
        /**
         * Defines the chart items for the data label.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Defines the data label context.
         */
        context: KnockoutObservable<DataLabelContext>;
    }
    /**
     * This interface specifies the chart axis properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AxisOptions<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AxisOptions<T> {
        /**
         * Defines the type of the axis label.
         */
        scale?: Chart.Scale | KnockoutObservable<Chart.Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: boolean | KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding?: number | KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks?: boolean | KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines?: boolean | KnockoutObservable<boolean>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat?: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[];
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter?: string | KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min?: T | KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max?: T | KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit?: UnitConversion.Unit | KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: boolean | KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding?: number;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding?: number;
    }
    /**
     * This interface specifies the chart axis properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AxisContract<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain?: KnockoutObservableBase<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to auto scale Unit
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservableBase<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservableBase<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservableBase<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit?: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
    }
    /**
     * This class specifies the chart axis properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Axis<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Axis<T> implements AxisContract<T> {
        /**
         * Name of the axis.
         */
        name: KnockoutObservable<string>;
        /**
         * Defines the type of the axis label.
         */
        scale: KnockoutObservable<Scale>;
        /**
         * If set to true, the axis labels are reversed from displaying min-max to max-min.
         * Default is set to false.
         */
        reverseDomain: KnockoutObservable<boolean>;
        /**
         * A value indicating how many tick marks should be displayed.
         * This value is just a hint and actual tick marks shown will be approximated based on scale.
         */
        ticks: KnockoutObservable<number>;
        /**
         * Defines the position for the axis.
         */
        position: KnockoutObservable<AxisPosition>;
        /**
         * Defines the position index for the placement of the axis when multiple axes should be displayed on the same side.
         * A value of 0 will be placed inner most close to the chart area and value of 1 will be placed further away from
         * the chart area based on the axis label padding.
         */
        positionIndex: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        showAxis: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show the axis and all its associated entities like name, label, tick marks etc.
         */
        autoScaleUnit: KnockoutObservableBase<boolean>;
        /**
         * Show the axis name.
         */
        showName: KnockoutObservable<boolean>;
        /**
         * Defines the position at which to show the axis labels.
         */
        showLabel: KnockoutObservable<AxisLabelPosition>;
        /**
         * Defines the padding size for axis labels.
         * Temporary changed to 50px to fit 1000.0A/BC"
         */
        labelPadding: KnockoutObservable<number>;
        /**
         * Defines the rotation angle. By default the labels will be shown horizontally.
         * Typical rotation angle used is from 0 (horizontal) to -90 (vertically down).
         */
        rotateLabel: KnockoutObservable<number>;
        /**
         * A value indicating whether or not to show the line for the axis.
         */
        showAxisLine: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show tick marks.
         */
        showTickMarks: KnockoutObservable<boolean>;
        /**
         * A value indicating whether or not to show grid lines.
         */
        showGridLines: KnockoutObservable<boolean>;
        /**
         * Defines the format to parse the string typed data.
         * The string value can either be a date or a number representation and the specified format will be used to parse the string value to the respective date or number type.
         */
        inputFormat: KnockoutObservable<string>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * Note: outputFormat will be deprecated as we move towards using standard APIs for globalization.
         */
        outputFormat: KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the x axis labels need to be uniformly formatted, then a DateTimeFormatOptions can be set in Axis' formatOptions property.
         * For time scale, if the x axis labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The formatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric axis labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Defines the format to display the data in axis label.
         * The data can be a date or number and the output format will define how the data should be displayed in the axis label.
         * The formatter will use xSliderOutputFormat.date if data is instanceof Date.  It use the basic mechanism as Multi-Time Axis formatting as in
         * http://bl.ocks.org/mbostock/4149176 except for consistency. Please use the DataUtil format.
         * If it is a type of value, it will use the first element of the array.
         */
        xSliderOutputFormat: KnockoutObservable<string[]>;
        /**
         * xSliderFormatOptions is a union type which can take NumberFormatOptions for number values or a multi-format array DateTimeFormatOptions[] for date values.
         * By default chart formats dates based on axis label date resolution and uses a default globalized multi-formatters similar to http://bl.ocks.org/mbostock/4149176
         * For time scale, if the xSlider labels format should differ based on date/time resolution, the chart's default multi-format can be over ridden by specifying an array of DateTimeFormatOptions for different time resolution.
         *     - The xSliderFormatOptions array mimics D3 multi format array - http://bl.ocks.org/mbostock/4149176.
         *     - Specify one or more DateTimeFormatOptions in the index position for the different date resolution - [ms, sec, min, hour, week, daysOfMonth, month, year].
         *     - Specify one of the standard DateTimeFormat patterns or custom option.
         *     - Eg.  [, DateTimeFormat.longTimePattern, { hour: "numeric", minute: "numeric" }, , , DateTimeFormat.shortDatePattern, , DateTimeFormat.fullDateTimePattern];
         *     - Empty values are allowed for various time resolution and chart will pick the format option specified in the higher resolution for the corresponding empty date resolutions.
         * For linear scale, specify NumberFormatOption to format the precision of the numeric xSlider labels.
         *     - By default a min fraction 0 and max fraction 2 is used.
         */
        xSliderFormatOptions: KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions[]>;
        /**
         * Specify the axis label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be transformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        displayLabelFormatter: KnockoutObservable<string>;
        /**
         * Specify the axis xSlider label formatter which will be used to display the axis values.
         * By default the format string is "{0}".
         * Number values will be represented with specified numeric precision and can be tranformed to string with a formatter to represent say units.
         * String values can be transformed to a different label value using the formatter.
         * Date values will be transformed to the specified outputDateFormat.
         */
        xSliderCalloutDisplayFormatter: KnockoutObservableBase<string>;
        /**
         * Optionally specify the minimum value for the axis domain.
         */
        min: KnockoutObservable<T>;
        /**
         * Optionally specify the maximum value for the axis domain.
         */
        max: KnockoutObservable<T>;
        /**
         * Specify the unit of the axis.
         */
        unit: KnockoutObservable<UnitConversion.Unit>;
        /**
         * Specify if SI unit should be displayed instead of binary unit. Eg. GB instead of GiB for UnitConversion.Unit.Gigabytes.
         * The auto scaled axis/metrics value will still be in the multiple of specified base unit. This option will impact only the unit display string.
         */
        displaySIUnit: KnockoutObservable<boolean>;
        /**
         * The default padding of the axis.
         */
        defaultAxisPadding: KnockoutObservable<number>;
        /**
         * If specified (non-null), overrides the default axis padding with a custom value.
         */
        customAxisPadding: KnockoutObservable<number>;
        /**
         * If true, all the axis labels except the current slider value will be hidden.
         */
        hideAxisLabelsOnXSliderHover: KnockoutObservableBase<boolean>;
        constructor(position?: AxisPosition, scale?: Scale);
    }
    /**
     * Defines a contract for spans such as time spans or number spans. It is used to provide a uniform subtraction operation for numbers and for dates used in uniform series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SpanContract<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SpanContract<T> {
        "--noUnusedLocals"?: T | any;
        [others: string]: any;
    }
    /**
     * Defines the date span used for subtraction date/time intervals from dates.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.DateSpan has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class DateSpan implements SpanContract<Date> {
        /**
         * The number of years in the span.
         */
        years: number;
        /**
         * The number of months in the span.
         */
        months: number;
        /**
         * The number of days in the span.
         */
        days: number;
        /**
         * The number of hours in the span.
         */
        hours: number;
        /**
         * The number of minutes in the span.
         */
        minutes: number;
        /**
         * The number of seconds in the span.
         */
        seconds: number;
        /**
         * The number of milliseconds in the span.
         */
        milliseconds: number;
        /**
         * Creates a new instance of the DateSpan.
         *
         * @param years The number of years in the span.
         * @param months The number of months in the span.
         * @param days The number of dates in the span.
         * @param hours The number of hours in the span.
         * @param minutes The number of minutes in the span.
         * @param seconds The number of seconds in the span.
         * @param milliseconds The number of milliseconds in the span.
         */
        constructor(years: number, months: number, days?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number);
    }
    /**
     * Defines the date span used for subtraction numbers from numbers. Need to provide a uniform interface of setting spans at uniform series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.NumberSpan has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class NumberSpan implements SpanContract<number> {
        /**
         * The span value.
         */
        value: number;
        /**
         * Creates a new instance of the NumberSpan.
         *
         * @param value The span value.
         */
        constructor(value: number);
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesBaseContract has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This base class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesBase has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesBase implements SeriesBaseContract {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The name of the series.
         */
        name: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a single series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesContract<TX, TY> extends SeriesBaseContract {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Series<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Series<TX, TY> extends SeriesBase implements SeriesContract<TX, TY> {
        /**
         * The data source for the chart.
         */
        values: KnockoutObservableArray<ChartItem<TX, TY>>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.UniformSeriesContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UniformSeriesContract<TX, TY> extends SeriesBase {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a single uniform series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.UniformSeries<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class UniformSeries<TX, TY> extends SeriesBase implements UniformSeriesContract<TX, TY> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The start (smallest) x-value of the series.
         */
        startXValue: KnockoutObservable<TX>;
        /**
         * The span between two x neighbor x values. It is a number if TX is number and a number of milliseconds is TX is DateTime.
         */
        span: KnockoutObservable<SpanContract<TX>>;
        /**
         * The array of y-values.
         */
        yValues: KnockoutObservableArray<TY>;
        /**
         * Name of X-axis associated with the data series' xValue.
         */
        xAxisName: KnockoutObservable<string>;
        /**
         * Name of Y-axis associated with the data series' yValue.
         */
        yAxisName: KnockoutObservable<string>;
    }
    /**
     * This interface defines the chart input data for a line series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineSeriesContract<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineSeriesContract<T> extends SeriesBase {
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
     * This class defines the chart input data for a line series and its associated axis.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineSeries<T> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineSeries<T> extends SeriesBase implements LineSeriesContract<T> {
        /**
         * The type of the series.
         */
        type: KnockoutObservable<SeriesType>;
        /**
         * The data source for the line.
         */
        value: KnockoutObservable<T>;
        /**
         * Name of axis associated with the data series' value.
         */
        axisName: KnockoutObservable<string>;
    }
    /**
     * Specifies a chart item selection within a metric.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleContract has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    /**
     * Specifies a chart item selection within a metric.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleOptions has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleOptions {
        /**
         * Specifies the scope of the rule.
         */
        scope?: MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics?: MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
    }
    /**
     * MetricRule's single metric contract.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleMetricContract has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: any | KnockoutObservable<any>;
    }
    /**
     * MetricRule's single metric options.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleMetricOptions has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface MetricRuleMetricOptions {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope?: MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType?: MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName?: string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor?: boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode?: string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern?: AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values if DateFormatOptions is not specified a built-in multi-formatter for dates will be used.
         * For number values if NumberFormatOptions is not specified a built-in format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions?: MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title?: string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit?: string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue?: string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon?: any | KnockoutObservable<any>;
    }
    /**
     * Specifies a chart item selection within a metric.
     * Note: "any" in the union type is added as a workaround to avoid compiletime ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRule has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class MetricRule implements MetricRuleContract {
        /**
         * Specifies the scope of the rule.
         */
        scope: any | MetricRuleScope | KnockoutObservable<MetricRuleScope>;
        /**
         * Specifies the scope series of the rule. If nothing specified, looks for a (single) series specified.
         */
        scopeSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies a list of metrics to be generated if the rule condition is met.
         */
        metrics: any | MetricRuleMetricContract[] | KnockoutObservableArray<MetricRuleMetricContract>;
        /**
         * Creates an instance of metric rule.
         *
         * @param options Specify the properties on MetricRule that extension author will be using to set / get / update.
         *                If the view model property needs to be observably updated then initialize with observable.
         *                If the view model property needs to be statically set one time, use non observable.
         *                If the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleOptions);
        private _initOptions;
        private _initLegacyDefaults;
    }
    /**
     * ViewModel for metric rule.
     * Note: "any" in the union type is added as a workaround to avoid ton of compile time breaks due to union between standard type and observable (function).
     * Retaining the actual union types matching the signature of the contract/options.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.MetricRuleMetric has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class MetricRuleMetric implements MetricRuleMetricContract {
        /**
         * Specifies the aggregation scope of the rule.
         */
        aggregationScope: any | MetricRuleAggregationScope | KnockoutObservable<MetricRuleAggregationScope>;
        /**
         * Specifies the aggregation of the rule.
         */
        aggregationType: any | MetricRuleAggregationType | KnockoutObservable<MetricRuleAggregationType>;
        /**
         * Specifies the aggregation series name of the rule. This is applied only if the aggregation scope is SingleSeries.
         */
        aggregationSeriesName: any | string | KnockoutObservable<string>;
        /**
         * Specifies if the bar color should be displayed or not.
         */
        showBarColor: any | boolean | KnockoutObservable<boolean>;
        /**
         * Specifies the color code of the rule. If nothing is specified, tries to get the color code from the current aggregation series.
         */
        colorCode: any | string | KnockoutObservable<string>;
        /**
         * Specifies the hatching pattern of the rule. If nothing is specified, tries to get the hatching pattern from the current aggregation series.
         */
        hatchingPattern: any | AreaHatchingPattern | KnockoutObservable<AreaHatchingPattern>;
        /**
         * Specifies the output formatter of the rule.
         * Note: This option will be deprecated. Please use the globalized date time format.
         */
        outputFormat: any | string | KnockoutObservable<string>;
        /**
         * formatOption is a union type which can take NumberFormatOptions for number values, or DateTimeFormatOptions for date values.
         * For date values, if DateFormatOptions is not specified, the charts default multi-formatter for the date's resolution will be used.
         * For number values, if NumberFormatOptions is not specified, a default format option with a min fraction 0 and max fraction 2 is used.
         */
        formatOptions: any | MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions | KnockoutObservableBase<MsPortalFx.Intl.NumberFormatOptions | MsPortalFx.Intl.DateTimeFormatOptions>;
        /**
         * Specifies the metric title of the rule.
         */
        title: any | string | KnockoutObservable<string>;
        /**
         * Specifies the metric unit of the rule.
         */
        unit: any | string | KnockoutObservable<string>;
        /**
         * Specifies the value of the metric if the custom value option is chosen for aggregation.
         */
        customValue: any | string | KnockoutObservable<string>;
        /**
         * The default info balloon of the metric rule.
         */
        defaultInfoBalloon: any | KnockoutObservable<any>;
        /**
         * Creates an instance of metric rule metrics.
         *
         * @param options Specify the properties on MetricRuleMetric that extension author will be using to set / get / update.
         *                If this needs to be observably updated then initialize with observable.
         *                If a view model property needs to be statically set one time, use non observable.
         *                if the view model property is not touched and default behavior is fine, don't initialize the property. That will avoid sending it across iframe boundary.
         */
        constructor(options?: MetricRuleMetricOptions);
        private _initOptions;
        private _initLegacyDefaults;
    }
    /**
     * Identifies a series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesIdContract has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Identifies a series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesId has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesId implements SeriesIdContract {
        /**
         * Specifies the view index.
         */
        chartViewIndex: KnockoutObservable<number>;
        /**
         * Specifies the series view index.
         */
        seriesViewIndex: KnockoutObservable<number>;
    }
    /**
     * Specifies a chart item selection within a series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesSubsetContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesSubsetContract<TX, TY> extends SeriesId {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Specifies a chart item selection within a series.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesSubset<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesSubset<TX, TY> extends SeriesId implements SeriesSubsetContract<TX, TY> {
        /**
         * Specifies an array of chart items selected.
         */
        chartItems: KnockoutObservableArray<ChartItem<TX, TY>>;
    }
    /**
     * Chart Event call back.
     *
     * @param x The number of x coordinate
     * @param y The number of y coordinate.
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ChartEventCallBack<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartEventCallBack {
        (x?: number, y?: number): void;
    }
    /**
     * Chart Event call back.
     *
     * @param x The pixel value of x coordinate
     * @param y The pixel value of y coordinate.
     * @param xValue The x axis value at the x coordinate.
     * @param yValue The y axis value at the y coordinate.
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ChartEventCallbackEx<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartEventCallbackEx<TX, TY> {
        (x?: number, y?: number, xValue?: TX, yValue?: TY): void;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.EventsContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallbackEx<TX, TY>;
    }
    /**
     * Defines the default event notification supported by the chart.
     * Line and bar chart can provide additional events by extending the base events.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Events<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Events<TX, TY> implements EventsContract<TX, TY> {
        /**
         * MouseEnter on the plot area.
         */
        plotAreaMouseEnter: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaMouseLeave: ChartEventCallbackEx<TX, TY>;
        /**
         * MouseLeave on the plot area.
         */
        plotAreaClick: ChartEventCallbackEx<TX, TY>;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesChartEventsContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesChartEventsContract<TX, TY> {
        /**
         * Click on a point.
         */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by line / area / scatter plot charts.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesChartEvents<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesChartEvents<TX, TY> implements SeriesChartEventsContract<TX, TY> {
        /**
         * Click on a point.
         */
        pointClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a point.
         */
        pointMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a point.
         */
        pointMouseLeave: (data: EventData<TX, TY>) => any;
        /**
         * Click on a series.
         */
        seriesClick: (data: EventData<TX, TY>) => any;
        /**
         * MouseEnter on a series.
         */
        seriesMouseEnter: (data: EventData<TX, TY>) => any;
        /**
         * MouseLeave on a series.
         */
        seriesMouseLeave: (data: MsPortalFx.ViewModels.Controls.Visualization.Chart.EventData<TX, TY>) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.BarChartEventsContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Defines the event notification supported by bar chart.
     * Users should provide a handler for each of the event notification hooks defined here.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.BarChartEvents<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BarChartEvents<TX, TY> implements BarChartEventsContract<TX, TY> {
        /**
         * Click on a bar.
         */
        barClick: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseEnter on a bar.
         */
        barMouseEnter: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
        /**
         * MouseLeave on a bar.
         */
        barMouseLeave: (eventData: EventData<TX, TY>, allBarsEventData?: EventData<TX, TY>[]) => any;
    }
    /**
     * Specifies the condition used on rendering a series view.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.RenderingConditionContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * Specifies the condition used on rendering a series view.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.RenderingCondition<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class RenderingCondition implements RenderingConditionContract {
        /**
         * The name of the series to be compared with.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The condition operator.
         */
        conditionOperator: KnockoutObservable<ConditionOperator>;
        /**
         * The interpolation for the series.
         */
        interpolation: KnockoutObservable<Interpolation>;
    }
    /**
     * This base interface defines how a series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservableBase<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabelContract<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingConditionContract>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend.
         */
        hideFromLegend: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.SeriesView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SeriesView<TX, TY> implements SeriesViewContract<TX, TY> {
        /**
         * The name of the series.
         */
        seriesName: KnockoutObservable<string>;
        /**
         * The display name of the series.
         */
        displayName: KnockoutObservable<string>;
        /**
         * The name of the "CSS" class for the series.
         */
        cssClass: KnockoutObservable<string>;
        /**
         * Data labels for the series.
         */
        dataLabels: KnockoutObservableArray<DataLabel<TX, TY>>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Specify the display formatter to show the value in the tooltip.
         * Formatter by default will add the x, y value and the associated series name. Eg, "Series: '{0}' Point: {1} Value: {2}".
         * The default formatter is borrowed from Microsoft Excel and seems to be valuable.
         * {0} will be populated with the series name.
         * {1} will be populated with the x value.
         * {2} will be populated the y value.
         */
        tooltipFormatter: KnockoutObservable<string>;
        /**
         * Specifies an array of rendering conditions to be checked for rendering the view.
         */
        renderingConditions: KnockoutObservableArray<RenderingCondition>;
        /**
         * Indicates if the series is selectable.
         */
        selectable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hoverable.
         */
        hoverable: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is hidden from the legend
         */
        hideFromLegend: KnockoutObservable<boolean>;
        /**
         * Indicates if the series is autoGenerated
         */
        autoGenerated: boolean;
    }
    /**
     * This interface defines the how a line chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineChartSeriesViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineChartSeriesViewContract<TX, TY> {
        "--noUnusedLocals"?: TX | TY | any;
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
     * This class defines the how a line chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineChartSeriesView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements LineChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the line type for the series in the current view.
         */
        lineStyle: KnockoutObservable<LineStyle>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
        /**
         * Optionally show a circle for the data point.
         */
        showDataPoints: KnockoutObservable<boolean>;
    }
    /**
     * This base interface defines the how an area chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AreaChartSeriesViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AreaChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
    }
    /**
     * This base class defines the how an area chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AreaChartSeriesView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AreaChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements AreaChartSeriesViewContract<TX, TY> {
        /**
         * Defines the interpolation type for the series in the current view.
         */
        interpolation: KnockoutObservable<Interpolation>;
        /**
         * Defines the hatching pattern type for the series in the current view.
         */
        areaHatchingPattern: KnockoutObservable<AreaHatchingPattern>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This base class defines the how a stacked area chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.StackedAreaChartSeriesView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedAreaChartSeriesView<TX, TY> extends AreaChartSeriesView<TX, TY> {
    }
    /**
     * This base interface defines the how a scatter chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ScatterChartSeriesViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ScatterChartSeriesViewContract<TX, TY> extends SeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
    }
    /**
     * This base class defines the how a scatter chart series should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ScatterChartSeriesView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ScatterChartSeriesView<TX, TY> extends SeriesView<TX, TY> implements ScatterChartSeriesViewContract<TX, TY> {
        /**
         * Defines the radius of circles.
         */
        radius: KnockoutObservable<number>;
        /**
         * Optionally show a tooltip box on mouse hover over the data point.
         */
        showTooltip: KnockoutObservable<boolean>;
    }
    /**
     * This interface defines the how a chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ViewContract<TX, TY, TView extends SeriesView<TX, TY> = SeriesView<TX, TY>> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<TView>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): TView;
    }
    /**
     * This class defines the how a chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.View<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class View<TX, TY, TView extends SeriesView<TX, TY> = SeriesView<TX, TY>> implements ViewContract<TX, TY, TView> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<TView>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): TView;
    }
    /**
     * This interface defines the how a line chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface LineChartViewContract<TX, TY> extends ViewContract<TX, TY, LineChartSeriesView<TX, TY>> {
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a line chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.LineChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class LineChartView<TX, TY> extends View<TX, TY, LineChartSeriesView<TX, TY>> implements LineChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<LineChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): LineChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AreaChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AreaChartViewContract<TX, TY> extends ViewContract<TX, TY, AreaChartSeriesView<TX, TY>> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This interface defines the how an area chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.AreaChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AreaChartView<TX, TY> extends View<TX, TY, AreaChartSeriesView<TX, TY>> implements AreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<AreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): AreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a stacked chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.StackedChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StackedChartViewContract<TX, TY> extends View<TX, TY, StackedAreaChartSeriesView<TX, TY>> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
    }
    /**
     * This class defines the how a stacked chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.StackedChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedChartView<TX, TY> implements StackedChartViewContract<TX, TY> {
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): StackedAreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a stacked area chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.StackedAreaChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StackedAreaChartViewContract<TX, TY> extends StackedChartViewContract<TX, TY> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show StackedLine charts for the StackedArea charts.
         */
        lineState: KnockoutObservableBase<LineState>;
    }
    /**
     * This class defines the how a stacked area chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.StackedAreaChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StackedAreaChartView<TX, TY> implements StackedAreaChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<StackedAreaChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Whether to show stacked lines for the stacked areas.
         */
        lineState: KnockoutObservable<LineState>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): StackedAreaChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a scatter chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ScatterChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ScatterChartViewContract<TX, TY> extends ViewContract<TX, TY, ScatterChartSeriesView<TX, TY>> {
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a scatter chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ScatterChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ScatterChartView<TX, TY> extends View<TX, TY, ScatterChartSeriesView<TX, TY>> implements ScatterChartViewContract<TX, TY> {
        static defaultChartType: ChartType;
        /**
         * Specify the chart type for this view.
         */
        chartType: KnockoutObservable<ChartType>;
        /**
         * The current view spans over multiple series specified in this array.
         */
        seriesView: KnockoutObservableArray<ScatterChartSeriesView<TX, TY>>;
        /**
         * Specify the event handlers for this view.
         */
        events: SeriesChartEvents<TX, TY>;
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): ScatterChartSeriesView<TX, TY>;
    }
    /**
     * This interface defines the how a bar chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.BarChartViewContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BarChartViewContract<TX, TY> extends View<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEventsContract<TX, TY>;
    }
    /**
     * This class defines the how a bar chart view should be rendered on the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.BarChartView<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BarChartView<TX, TY> extends View<TX, TY> implements BarChartViewContract<TX, TY> {
        /**
         * A padding ratio which is relative to bar size. The ratio will be used as padding between two bars.
         */
        barPaddingRatio: KnockoutObservable<number>;
        /**
         * When enabled, the series data can be of varying length.
         * Enabling this option will involve multiple data transformation to fill in missing values for stacking bars.
         * Disable this option to speed up rendering if all data series have the same xValues.
         */
        enableSparseSeries: KnockoutObservable<boolean>;
        /**
         * Defines the type of bar chart that needs to be rendered.
         */
        barChartType: KnockoutObservable<BarChartType>;
        /**
         * The span for the x-axis.
         */
        xAxisSpan: KnockoutObservable<SpanContract<TX>>;
        /**
         * Specify the event handlers for this view.
         */
        events: BarChartEvents<TX, TY>;
        constructor(barChartType: BarChartType);
        /**
         * Helper function to create a seriesView that corresponds to this view.
         */
        newSeriesView(dataSeries?: SeriesBaseContract): SeriesView<TX, TY>;
    }
    /**
     * This interface defines a single data point for the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ChartItemContract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
    }
    /**
     * This class defines a single data point for the chart.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ChartItem<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ChartItem<TX, TY> implements ChartItemContract<TX, TY> {
        /**
         * The X value for an item.
         */
        xValue: TX;
        /**
         * The Y values for an item for all series.
         */
        yValue: TY;
        constructor(xValue: TX, yValue: TY);
    }
    /**
     * This interface defines the input data for the chart, axes and its properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.Contract<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract<TX, TY, TXAxis extends AxisContract<TX> = Axis<TX>, TYAxis extends AxisContract<TY> = Axis<TY>> extends MsPortalFx.ViewModels.Controls.Loadable.Contract {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart. If width is 0 then the chart will pick up container's width.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart. If height is 0 then the chart will pick up container's height.
         */
        height: KnockoutObservable<number>;
        /**
         * The sizeChanged notification, should only get update from UI. User should not set it.
         */
        sizeChanged: KnockoutObservable<{
            width: number;
            height: number;
        }>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         * To maintain runtime back compat, union type is used.
         */
        noDataMessage: string | KnockoutObservableBase<string>;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBaseContract>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<TXAxis>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<TYAxis>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<ViewContract<TX, TY>>;
        /**
         * Set to 'none' to hide the legend. NOTE: Legend will always be shown to the right of the chart if it's visible.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        legendWidth: KnockoutObservableBase<number>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: EventsContract<TX, TY>;
        /**
         * Metrics used by the control.
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.Contract;
        /**
         * show/hide this metrics
         */
        showMetrics: KnockoutObservableBase<boolean>;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubsetContract<TX, TY>>;
        /**
         * Specifies the items being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesIdContract>;
        /**
         * Metric rules used by the control
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData: KnockoutObservableBase<boolean>;
        /**
         * Aria label for the chart.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria description for the chart.
         */
        ariaDesc: KnockoutObservableBase<string>;
    }
    /**
     * This class defines the input data for the chart, axes and its properties.
     *
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Chart.ViewModel<TX, TY> has been deprecated.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel<TX, TY> extends Loadable.ViewModel implements Contract<TX, TY> {
        /**
         * The title of the chart.
         */
        title: KnockoutObservable<string>;
        /**
         * Optionally show the title of the chart.
         * The property is temporary ignored.
         */
        showTitle: KnockoutObservable<boolean>;
        /**
         * The width of the chart.
         */
        width: KnockoutObservable<number>;
        /**
         * The height of the chart.
         */
        height: KnockoutObservable<number>;
        /**
         * The sizeChanged notification, should only get update from UI. User should not set it.
         */
        sizeChanged: KnockoutObservable<{
            width: number;
            height: number;
        }>;
        /**
         * Override default no data message ('No data to display').
         * The message will be shown when noData is set to true.
         * To maintain runtime back compat, union type is used.
         */
        noDataMessage: string | KnockoutObservableBase<string>;
        /**
         * Provide an array of data series.
         */
        series: KnockoutObservableArray<SeriesBase>;
        /**
         * The X-axis of the chart. This will be the primary X-axis for the chart.
         */
        xAxis: Axis<TX>;
        /**
         * The Y-axis of the chart. This will be the primary Y-axis for the chart.
         */
        yAxis: Axis<TY>;
        /**
         * An array of secondary X-axis that can be optionally disabled.
         */
        secondaryXAxes: KnockoutObservableArray<Axis<TX>>;
        /**
         * An array of secondary Y-axis that can be optionally disabled.
         */
        secondaryYAxes: KnockoutObservableArray<Axis<TY>>;
        /**
         * An array of views that should be rendered on the chart.
         */
        views: KnockoutObservableArray<View<TX, TY, SeriesView<TX, TY>>>;
        /**
         * The position where the legend should be placed. None option will not display the legend.
         */
        legendPosition: KnockoutObservable<LegendPosition>;
        /**
         * Optionally specify the legendWidth.
         * By default, its set to 0 and default legend width of 105px will be used.
         */
        legendWidth: KnockoutObservableBase<number>;
        /**
         * the interaction behavior
         */
        interactionBehavior: KnockoutObservable<InteractionBehavior>;
        /**
         * A value indicating whether or not to auto generate SeriesViews when there is no SeriesViews provided
         */
        autogenerateSeriesViews: KnockoutObservableBase<boolean>;
        /**
         * Events supported by the control.
         */
        events: Events<TX, TY>;
        /**
         * Metrics used by the control
         */
        metrics: MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel;
        /**
         * show/hide this metrics
         */
        showMetrics: KnockoutObservableBase<boolean>;
        /**
         * Specifies selections on the chart.
         */
        seriesSelections: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies all the items related to hover on the chart.
         */
        seriesHovers: KnockoutObservableArray<SeriesSubset<TX, TY>>;
        /**
         * Specifies the item being hovered on the chart.
         */
        hoveredID: KnockoutObservableArray<SeriesId>;
        /**
         * Metric rules used by the control.
         */
        metricsRules: KnockoutObservableArray<MetricRule>;
        /**
         * Enable Track XSlider coordination.
         */
        enableTrackXSlider: KnockoutObservableBase<boolean>;
        /**
         * If enableTrackXSlider() is true, the xSliderCoordinate is reported in this variable.
         */
        xSliderCoordinate: KnockoutObservableBase<number>;
        /**
         * If xSlider is enabled, Distance from the nearest datapoint in your chart that will trigger the hover animation as a ratio (xSliderFilterHover) of the width of the chart.
         * For example, .05 means that the distance between the selected chartData can't be bigger than 0.05 * width of the chart.
         * This number can't be bigger than .5 or less than 0.  It will fall back to default behavior.
         */
        xSliderFilterHoverThreshold: KnockoutObservableBase<number>;
        /**
         * Aria label for the chart.
         */
        readonly ariaLabel: KnockoutObservable<string>;
        /**
         * Aria description for the chart.
         */
        readonly ariaDesc: KnockoutObservable<string>;
        static defaultYAxisLabelPadding: number;
        static getDefaultSeriesViewCreator<TX, TY>(chartType: ChartType): (dataSeries: SeriesBaseContract, view: View<TX, TY>) => SeriesView<TX, TY>;
        /**
         * Toggle noData property to show/hide the no data message. Default message is 'No data to display'.
         * Default message can be overridden by setting noDataMessage property.
         */
        noData: KnockoutObservableBase<boolean>;
        private _seriesHelpers;
        /**
         * Creates a chart.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Map.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Map {
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Extensions: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Location: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Link = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type LinkType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ItemContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Item: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ItemType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ItemMetadataContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type HexagonLayoutItemMetadataContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ItemMetadata: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const HexagonLayoutItemMetadata: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type HexagonLayoutOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ExtensionOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Events: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.Map is obsolete.
     * Please use Fx/Controls/Map instead of MsPortalFx.ViewModels.Controls.Visualization.Map.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\Metrics.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.Metrics {
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Size is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Size of the metrics.
     */
    const enum Size {
        /**
         * Shows small metrics - Font: 20px, Height: 32px, Margin: 14px.
         */
        Small = 0,
        /**
         * Shows medium metrics - Font: 40px, Height: 35px, Margin: 30px.
         */
        Medium = 1,
        /**
         * Shows large metrics - Font: 40px, Height: 45px, Margin: 22px.
         */
        Large = 2,
        /**
         * Shows Xlarge metrics - Font: 40px, Height: 45px, Margin: 25px.
         */
        XLarge = 3,
        /**
         * Shows extra small metrics - Font: 20px, Height: 30px, Margin: 12px.
         */
        ExtraSmall = 4
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Orientation is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Orientation of the metrics.
     */
    const enum Orientation {
        /**
         * Metrics will be displayed horizontally.
         */
        Horizontal = 0,
        /**
         * Metrics will be displayed vertically.
         */
        Vertical = 1
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Alignment is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Alignment of the metrics.
     */
    const enum Alignment {
        /**
         * Top edge for vertical alignment.
         */
        Top = 1,
        /**
         * Left edge for horizontal alignment.
         */
        Left = 2,
        /**
         * Right edge for horizontal alignment.
         */
        Right = 4,
        /**
         * Bottom edge for vertical alignment.
         */
        Bottom = 8
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.HatchingPattern is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Defines hatching patterns.
     * New hatching patterns are not supported in MsPortalFx namespace. To get the latest supported hatching pattern, migrate to AMD creation pattern.
     */
    const enum HatchingPattern {
        /**
         * The area is solid.
         */
        Solid = 0,
        /**
         * The area is cross hatched.
         */
        CrossHatching = 1,
        /**
         * The area is diagonal hatched.
         */
        DiagonalHatching = 2,
        /**
         * The area is hatched horizontally like a dotted line.
         */
        DottedHatching = 3
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Layout is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     *
     * Layout of the metrics.
     */
    const enum Layout {
        /**
         * In wrap layout the metrics will flow to the next row.
         * The height will expand for the overflow metrics.
         */
        Wrap = 0,
        /**
         * Enable scrolling logic to scroll through overflow metrics.
         */
        Scroll = 1
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.SingleMetricContract is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleMetric.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SingleMetricContract extends Loadable.Contract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon: KnockoutObservableBase<any>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: KnockoutObservableBase<MsPortalFx.ViewModels.Controls.Visualization.Metrics.HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.SingleMetricOption is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleMetric.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SingleMetricOption extends Loadable.Options {
        /**
         * The value of the setting.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit?: string | KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption?: string | KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon?: any | KnockoutObservableBase<any>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass?: string | KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern?: HatchingPattern | KnockoutObservableBase<HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment?: Alignment | KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.SingleMetric is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/SingleMetric.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SingleMetric extends Loadable.ViewModel implements SingleMetricContract {
        /**
         * The value of the setting.
         */
        value: KnockoutObservableBase<string>;
        /**
         * The unit of the setting.
         */
        unit: KnockoutObservableBase<string>;
        /**
         * The caption of the setting.
         */
        caption: KnockoutObservableBase<string>;
        /**
         * The info balloon of the setting.
         */
        infoBalloon: KnockoutObservableBase<any>;
        /**
         * explicit hide the InfoBalloom even if the infoBalloon exists
         */
        hideInfoBalloon: KnockoutObservableBase<boolean>;
        /**
         * Color of the vertical bar beside the metric.
         */
        barCssClass: KnockoutObservableBase<string>;
        /**
         * Show the vertical bar besides the metric.
         */
        showBarColor: KnockoutObservableBase<boolean>;
        /**
         * Defines the hatching pattern.
         */
        hatchingPattern: KnockoutObservableBase<HatchingPattern>;
        /**
         * Unit alignment.
         * Defaults to right & bottom.
         */
        unitAlignment: KnockoutObservableBase<Alignment>;
        /**
         * Caption alignment. Currently only support Top or Bottom.
         * Defaults to Top.
         */
        captionAlignment: KnockoutObservableBase<Alignment>;
        /**
         * The hide of the metric.
         */
        hide: KnockoutObservableBase<boolean>;
        /**
         * Indicates if this metric should be prioritized.
         * For example if it represents a series that is currently hovered by the user.
         */
        prioritized: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Specifies the prefix string for narrator to announce the content's context like 'Metric item' or 'Donut center text' etc.
         */
        ariaLivePrefix: KnockoutObservableBase<string>;
        /**
         * A flag to indicate aria-live attribute is turned on or off for narrator to read the metric value.
         * The flag will be updated by the control during control/metrics interactions.
         */
        _msPortalFxAriaLive: KnockoutReadOnlyObservableBase<boolean>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: SingleMetricOption);
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.VisualContract is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface VisualContract extends Loadable.Contract {
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         */
        size: KnockoutObservableBase<Size>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservableBase<boolean>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Contract is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Contract extends VisualContract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.Options is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options extends Loadable.Options {
        /**
         * Metrics items to display
         */
        items?: SingleMetric[] | KnockoutObservableArray<SingleMetric>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation?: Orientation | KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         * This is deprecated. The parent control is responsible for styling the metrics in accordance with the size.
         */
        size?: Size | KnockoutObservableBase<Size>;
        /**
         * Layout enum specifies whether metrics items should reflow or have custom scrolling ux.
         * The 'layout' property is honored only for horizontal orientation (and ignored otherwise).
         */
        layout?: Layout | KnockoutObservable<Layout>;
        /**
         * The visibility of the metrics.
         */
        visible?: boolean | KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Controls.Visualization.Metrics.ViewModel is deprecated.
     * Please migrate to the AMD creation pattern using Fx/Controls/Metrics.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ViewModel extends Loadable.ViewModel implements Contract {
        /**
         * Metrics items to display
         */
        items: KnockoutObservableArray<SingleMetric>;
        /**
         * The orientation of the items in the metrics.
         */
        orientation: KnockoutObservableBase<Orientation>;
        /**
         * The size of the items in the metrics.
         * This is deprecated. The parent control is responsible for styling the metrics in accordance with the size.
         */
        size: KnockoutObservableBase<Size>;
        /**
         * Layout enum specifies whether metrics items should reflow or have custom scrolling ux.
         * The 'layout' property is honored only for horizontal orientation (and ignored otherwise).
         */
        layout: KnockoutObservable<Layout>;
        /**
         * The visibility of the metrics.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * The optional alternate text to be read by screen-reader
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Aria live flag to turn on or off live region for each metric.
         * The flag will be used for Chart/metrics interactions.
         */
        _msPortalFxAriaLive: KnockoutObservableBase<boolean>;
        /**
         * Creates a metric view model.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: Options);
    }
}

// FILE: MsPortalFx\ViewModels\Controls\Visualization\SimpleChart.d.ts
declare module MsPortalFx.ViewModels.Controls.Visualization.SimpleChart {
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SimpleChart is obsolete.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type SeriesViewOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SimpleChart is obsolete.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type SeriesOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SimpleChart is obsolete.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Series: Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SimpleChart is obsolete.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type SimpleChartOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Controls.Visualization.SimpleChart is obsolete.
     * Please migrate to Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Fields\Base\EditableComboField.d.ts
declare module MsPortalFx.ViewModels {
    import PositioningAlignment = MsPortalFx.ViewModels.Forms.Base.EditableComboBox.PositioningAlignment;
    interface EditableComboFormField<T> extends EditableFormField<T> {
    }
    /**
     * Base class for combo fields
     */
    class EditableComboField<T> extends EditableField<T> implements EditableComboFormField<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservable<string>;
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param emptyValueText Optional. Watermark text to display over the form field when it's empty.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], emptyValueText?: string, infoBalloonContent?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\Field.d.ts
declare module MsPortalFx.ViewModels {
    interface FormField<T> extends FormElement {
        /**
         * Label for the field.
         */
        label?: KnockoutObservableBase<string | HtmlContent>;
        /**
         * Label position for the field.
         */
        labelPosition?: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Initial value for the field.
         */
        initialValue?: KnockoutObservableBase<T>;
        /**
         * Current value of the field.
         */
        value?: KnockoutObservableBase<T>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation?: KnockoutObservableBase<boolean>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<FormValidation>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled?: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent?: KnockoutObservable<string | HtmlContent>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation?: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation?: KnockoutObservable<number>;
        /**
         * A function through which the enclosing form will dispose this field.  The field's 'initialValue' and 'value'
         * observables should be disposed if they are disposable.
         */
        dispose(): void;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
    }
    class Field<T> extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel implements FormField<T> {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Label for the field.
         */
        label: KnockoutObservable<string | HtmlContent>;
        /**
         * Label for the field.
         */
        labelPosition: KnockoutObservable<MsPortalFx.ViewModels.Forms.LabelPosition>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<FormValidation>;
        /**
         * A list of validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string | HtmlContent>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        _msPortalFxClearValidation: KnockoutObservable<() => Promise<any>>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => Promise<boolean>>;
        _enableValidationReactor: KnockoutComputed<void>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         * yet loaded.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string, defaultValue?: T);
        /**
         * Clears validation on the field.
         *
         * @returns A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Promise<any>;
        /**
         * Triggers validation on the field.
         *
         * @returns A promise that is resolved when the validation has been triggered.
         */
        triggerValidation(): Promise<boolean>;
        setDirty(value: boolean): void;
    }
    interface NullableFormField<T> extends FormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutObservableBase<boolean>;
    }
    class NullableField<T> extends Field<T> implements NullableFormField<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface EditableFormField<T> extends NullableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservableBase<boolean>;
    }
    class EditableField<T> extends NullableField<T> implements EditableFormField<T> {
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface GroupsFormField<T> extends FormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
    }
    class GroupsField<T> extends Field<T> implements GroupsFormField<T> {
        /**
         * A list of groups to categorize the selectable options.
         */
        groups: KnockoutObservableArray<Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of groups to categorize the options field value.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IGroup<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface OptionsFormField<T> extends FormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
    }
    class OptionsField<T> extends Field<T> implements OptionsFormField<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param values A list of options the user will choose the field value from.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, values: Forms.IDisablableOption<T>[], validations?: FormValidation[], infoBalloonContent?: string);
    }
    interface SliderBaseFormField<T> extends FormField<T> {
        /**
         * Minimum value of the slider.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
    }
    class SliderBaseField<T> extends Field<T> implements SliderBaseFormField<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param minValue Minimum value for the field.
         * @param maxValue Maximum value for the field.
         * @param validations A list of validations to be applied to the field.
         * @param showStepMarkers If true step markers will be shown on the slider.
         * @param defaultValue An optional, default value of type T, used when the EditScope underlying the enclosing Form isn't
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors?: any, label?: string, minValue?: number, maxValue?: number, validations?: FormValidation[], showStepMarkers?: boolean, infoBalloonContent?: string, defaultValue?: T, step?: number);
    }
    interface TypableFormField<T> extends NullableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: any;
    }
    class TypableField<T> extends EditableField<T> implements TypableFormField<T> {
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: any;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param fieldValueAccessors Accessor functions to retrieve observables reflecting original and editable
         * values for the field.  Acquire this using 'createFieldValueAccessors' on the form containing this field.
         * @param label Text for the label for this form field.
         * @param validations Optional. A list of validations to be applied to the field.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, fieldValueAccessors: any, label: string, validations?: FormValidation[], infoBalloonContent?: string);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormElement.d.ts
declare module MsPortalFx.ViewModels {
    interface FormElement extends MsPortalFx.ViewModels.Controls.Base.Contract {
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * When changed forces validation on the field.
         */
        validate: KnockoutObservable<number>;
        /**
         * Clears validations on the control.
         */
        clearValidation(): Promise<any>;
        /**
         * Triggers validations on the control.
         */
        triggerValidation(): Promise<boolean>;
        /**
         * Internal view model properties.
         */
        _msPortalFxClearValidation: KnockoutObservable<() => Promise<any>>;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormGroup.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IGroup<T> {
        /**
         * Id specifying the groupby key for a group of options.
         */
        key: string;
        /**
         * User friendly label for the grouping.
         */
        text: KnockoutObservable<string>;
        /**
         * Disable state of this group.
         */
        disabled: KnockoutObservable<boolean>;
        /**
         * Selectable state of this group.
         */
        selected?: KnockoutObservable<boolean>;
        /**
         * A list of options the use can select the field value from.
         * Dynamic update of options array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        options: KnockoutObservableArray<ISelectableOption<T>>;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface IOption<T> {
        /**
         * Text for the drop down option.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value for the drop down option.
         */
        value: T;
        /**
         * Optional alternate text for screen readers if the text is not explicit enough.
         */
        ariaLabel?: KnockoutObservableBase<string>;
    }
    interface IDisablableOption<T> extends IOption<T> {
        /**
         * Dropdown option can be disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    class Option<T> implements IOption<T> {
        /**
         * Text for list item.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Value bound for list item when the item is selected.
         */
        value: T;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         */
        constructor(text: KnockoutObservableBase<string> | string, value: KnockoutObservableBase<T> | T);
    }
    class DisablableOption<T> extends Option<T> implements IDisablableOption<T> {
        /**
         * Item is disabled.
         */
        disabled: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         */
        constructor(text: KnockoutObservableBase<string> | string, value: KnockoutObservableBase<T> | T, disabled?: KnockoutObservableBase<boolean> | boolean);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormOptionFormatSetting.d.ts
declare module MsPortalFx.ViewModels {
    interface FormOptionFormatSetting {
        /**
         * Formatter used when displaying the drop down option.
         */
        format?: MsPortalFx.ViewModels.Controls.Lists.Grid.Format;
        /**
         * Formatter options associated with the formatters.
         */
        formatOptions?: MsPortalFx.ViewModels.Controls.Lists.Grid.FormatOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Base\FormSelectableOption.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface ISelectableOption<T> extends IDisablableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected?: KnockoutObservableBase<boolean>;
    }
    class SelectableOption<T> extends DisablableOption<T> implements ISelectableOption<T> {
        /**
         * Option is selected. Recommended to use manipulate value to update selection.
         * NOTE: Updates active selected for OptionsGroup control only.
         */
        selected: KnockoutObservableBase<boolean>;
        /**
         * @param text The text data binding for the item.
         * @param value The value data binding for the item.
         * @param disabled The item is disabled.
         * @param selected The item is selected.
         */
        constructor(text: string | KnockoutObservableBase<string>, value: T | KnockoutObservableBase<T>, disabled?: boolean | KnockoutObservableBase<boolean>, selected?: boolean | KnockoutObservableBase<boolean>);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\CaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface CaseInsensitiveComparisonValidationOptions extends StaticMessageValidationOptions {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    interface CaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class CaseInsensitiveComparisonValidation extends StaticMessageValidation implements CaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLowerCase() to compare two values.
         *
         * @param compareTo The value the field will be compared to.
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message?: string);
        /**
         * Validation that uses toLowerCase() to compare two values.
         *
         * @param options The options fot the CaseInsensitiveComparisonValidation.
         */
        constructor(options: CaseInsensitiveComparisonValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsCharactersValidationOptions extends StaticMessageValidationOptions {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    interface ContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class ContainsCharactersValidation extends StaticMessageValidation implements ContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         *
         * @param options The options for the ContainsCharactersValidation.
         */
        constructor(options: ContainsCharactersValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface ContainsValidationOptions extends StaticMessageValidationOptions {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    interface ContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class ContainsValidation extends StaticMessageValidation implements ContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         *
         * @param searchString The search string to match.
         * @param message Validation rule error message.
         */
        constructor(searchString: string, message?: string);
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         *
         * @param options The options for the ContainsValidation.
         */
        constructor(options: ContainsValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\CustomValidation.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface for a typed validation
     */
    interface CustomValidationOptionsV<TValue> {
        /**
         * Function that returns whether the data is valid or not.
         *
         * @param value The field value to validate.
         * @returns The promise to validate the value.
         */
        validate: (value: TValue) => Promise<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * The default message that is shown to the user if a message is not included as part of the validation result.
         */
        message?: string;
    }
    type CustomValidationOptions = CustomValidationOptionsV<any>;
    /**
     * The interface for a typed validation
     */
    interface CustomFormValidationV<TValue> extends MsPortalFx.ViewModels.FormValidation {
        /**
         * Function that returns whether the data is valid or not.
         *
         * @param value The field value to validate.
         * @returns The promise to validate the value.
         */
        validate: (value: TValue) => Promise<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * The default message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
    }
    type CustomFormValidation = CustomFormValidationV<any>;
    /**
     * A typed custom validation
     */
    class CustomValidationV<TValue> extends Validation implements CustomFormValidationV<TValue> {
        /**
         * Function that returns whether the data is valid or not.
         */
        validate: (value: TValue) => Promise<ValidationResult>;
        /**
         *  The default message that is shown to the user if a message is not included as part of the validation result.
         */
        message: string;
        /**
         * Constructs a custom validation.
         *
         * @param message The validation message.
         * @param validate The validation callback.
         */
        constructor(message: string, validate: (value: TValue) => Promise<ValidationResult>);
        /**
         * Constructs a custom validation.
         *
         * @param options The options for the CustomValidation.
         */
        constructor(options: CustomValidationOptionsV<TValue>);
    }
    class CustomValidation extends CustomValidationV<any> implements CustomFormValidation {
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\EqualsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface EqualsValidationOptions<T> extends StaticMessageValidationOptions {
        /**
         * The value the field value will be compared to.
         */
        compareTo: T;
    }
    interface EqualsFormValidation<T> extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: T;
    }
    class EqualsValidation<TValue> extends StaticMessageValidation implements EqualsFormValidation<TValue> {
        /**
         * The value the field value will be compared to.
         */
        compareTo: TValue;
        /**
         * Constructs a validator that compares if the value is equal to a provided value.
         *
         * @param compareTo The value or accessor to get the value to compare to.
         * @param message Validation rule error message.
         */
        constructor(compareTo: TValue, message?: string);
        /**
         * Constructs a validator that compares if the value is equal to a provided value.
         *
         * @param options The options for the EqualsValidation.
         */
        constructor(options: EqualsValidationOptions<TValue>);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\FormValidationType.d.ts
declare module MsPortalFx.ViewModels {
    const enum FormValidationType {
        /**
         * Value indicates field has not been set to an appropriate validation type.
         */
        Invalid = 0,
        /**
         * Validation is a value required validation.
         */
        Required = 1,
        /**
         * Validation is a regular expression validation.
         */
        RegExMatch = 2,
        /**
         * Validator that checks if the value does not match a regular expression.
         */
        NotRegExMatch = 3,
        /**
         * Constructs a validator that checks that the value contains at least one case insensitive match of a search string.
         */
        Contains = 4,
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         */
        NotContains = 5,
        /**
         * Constructs a validator that checks that the value contains at least one character from a character set.
         */
        ContainsCharacters = 6,
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         */
        NotContainsCharacters = 7,
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         */
        HasDigit = 8,
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         */
        HasLetter = 9,
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         */
        HasUpperCaseLetter = 10,
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         */
        HasLowerCaseLetter = 11,
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         */
        HasPunctuation = 12,
        /**
         * Constructs a base comparison validator that compares the control value to a provided value.
         */
        Equals = 13,
        /**
         * Constructs a validator that checks that the value length is between min and max.
         */
        LengthRange = 14,
        /**
         * Constructs a validator that checks that the value length is at least min.
         */
        MinLength = 15,
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         */
        MaxLength = 16,
        /**
         * Constructs a validator that checks whether the value is a number.
         */
        Numeric = 17,
        /**
         * Constructs a validator that checks whether the value is within the range defined by min and max number.
         */
        Range = 18,
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         */
        MinValue = 19,
        /**
         * Constructs a validator that checks whether the value is less than or equal to the specified maximum number.
         */
        MaxValue = 20,
        /**
         * Validation is implemented by extension author.
         */
        Custom = 21,
        /**
         * Constructs a validator that uses toLowerCase() to compare two values.
         */
        CaseInsensitiveComparison = 22,
        /**
         * Constructs a validator that uses toLocaleLowerCase() to compare two values.
         */
        LocaleAwareCaseInsensitiveComparison = 23,
        /**
         * Contructs a validator that validates an absolute http/https URI.
         */
        Uri = 24
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasDigitValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasDigitValidationOptions extends StaticMessageValidationOptions {
    }
    interface HasDigitFormValidation extends StaticMessageFormValidation {
    }
    class HasDigitValidation extends StaticMessageValidation implements HasDigitFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks that the value has at least one digit from 0 to 9.
         *
         * @param options The options for the HasDigitValidation.
         */
        constructor(options?: HasDigitValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLetterValidationOptions extends StaticMessageValidationOptions {
    }
    interface HasLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLetterValidation extends StaticMessageValidation implements HasLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks that the value has at least one upper or lower case letter from A to Z or a to z.
         * (Not Unicode)
         *
         * @param options The options for the HasLetterValidation.
         */
        constructor(options?: HasLetterValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasLowerCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasLowerCaseLetterValidationOptions extends StaticMessageValidationOptions {
    }
    interface HasLowerCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasLowerCaseLetterValidation extends StaticMessageValidation implements HasLowerCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks that the value has at least one lower case letter from a to z.
         * (Not Unicode)
         *
         * @param options The options for the HasLowerCaseLetterValidation.
         */
        constructor(options?: HasLowerCaseLetterValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasPunctuationValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasPunctuationValidationOptions extends StaticMessageValidationOptions {
    }
    interface HasPunctuationFormValidation extends StaticMessageFormValidation {
    }
    class HasPunctuationValidation extends StaticMessageValidation implements HasPunctuationFormValidation {
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks that the value contains at least one punctuation character from:
         * ! @ # $ % ^ & * ( ) _ + - = { } | [ ] \ : " ; ' < > , . ? / ~ `
         *
         * @param options The options for the HasPunctuationValidation.
         */
        constructor(options?: HasPunctuationValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\HasUpperCaseLetterValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface HasUpperCaseLetterValidationOptions extends StaticMessageValidationOptions {
    }
    interface HasUpperCaseLetterFormValidation extends StaticMessageFormValidation {
    }
    class HasUpperCaseLetterValidation extends StaticMessageValidation implements HasUpperCaseLetterFormValidation {
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks that the value has at least one upper case letter from A to Z.
         * (Not Unicode)
         *
         * @param options The options for the HasUpperCaseLetterValidation.
         */
        constructor(options?: HasUpperCaseLetterValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\InvalidValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface InvalidValidationOptions extends StaticMessageValidationOptions {
    }
    interface InvalidFormValidation extends StaticMessageFormValidation {
    }
    class InvalidValidation extends StaticMessageValidation implements InvalidFormValidation {
        /**
         * Constructs an instance of the invalid validation which is used to force invalid validation state.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
        /**
         * Constructs an instance of the invalid validation which is used to force invalid validation state.
         *
         * @param options The options for the InvalidValidation.
         */
        constructor(options?: InvalidValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\LengthRangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LengthRangeValidationOptions extends StaticMessageValidationOptions {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    interface LengthRangeFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class LengthRangeValidation extends StaticMessageValidation implements LengthRangeFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is between min and max.
         *
         * @param min The minimum number of characters to be valid. May be null if there is no min.
         * @param max The maximum number of characters to be valid. May be null if there is no max.
         * @param message Validation rule error message.
         */
        constructor(min: number, max: number, message?: string);
        /**
         * Constructs a validator that checks that the value length is between min and max.
         *
         * @param options The options for the LengthRangeValidation.
         */
        constructor(options: LengthRangeValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\LocaleAwareCaseInsensitiveComparisonValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface LocaleAwareCaseInsensitiveComparisonValidationOptions extends StaticMessageValidationOptions {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    interface LocaleAwareCaseInsensitiveComparisonFormValidation extends StaticMessageFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
    }
    class LocaleAwareCaseInsensitiveComparisonValidation extends StaticMessageValidation implements LocaleAwareCaseInsensitiveComparisonFormValidation {
        /**
         * The value the field value will be compared to.
         */
        compareTo: string;
        /**
         * Validation that uses toLocaleLowerCase() to compare two values.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(compareTo: string, message?: string);
        /**
         * Validation that uses toLocaleLowerCase() to compare two values.
         *
         * @param options The options for the LocaleAwareCaseInsensitiveComparisonValidation.
         */
        constructor(options: LocaleAwareCaseInsensitiveComparisonValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MaxLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxLengthValidationOptions extends StaticMessageValidationOptions {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    interface MaxLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
    }
    class MaxLengthValidation extends StaticMessageValidation implements MaxLengthFormValidation {
        /**
         * The maximum number of characters to be valid.
         */
        max: number;
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         *
         * @param max The maximum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
        /**
         * Constructs a validator that checks that the value length is less than or equal to the max.
         *
         * @param options The options for the MaxLengthValidation.
         */
        constructor(options: MaxLengthValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MaxValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MaxValueValidationOptions extends StaticMessageValidationOptions {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    interface MaxValueFormValidation extends StaticMessageFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class MaxValueValidation extends StaticMessageValidation implements MaxValueFormValidation {
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        /**
         * Constructs a validator that checks whether the value is less than than or equal to the specified maximum number.
         *
         * @param max Maximum field value.
         * @param message Validation rule error message.
         */
        constructor(max: number, message?: string);
        /**
         * Constructs a validator that checks whether the value is less than than or equal to the specified maximum number.
         *
         * @param options The options for the MaxValueValidation.
         */
        constructor(options: MaxValueValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MinLengthValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinLengthValidationOptions extends StaticMessageValidationOptions {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
    }
    interface MinLengthFormValidation extends StaticMessageFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
    }
    class MinLengthValidation extends StaticMessageValidation implements MinLengthFormValidation {
        /**
         * The minimum number of characters to be valid.
         */
        min: number;
        /**
         * Constructs a validator that checks that the value length is at least min.
         *
         * @param min The minimum number of characters to be valid.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
        /**
         * Constructs a validator that checks that the value length is at least min.
         *
         * @param options The options for the MinLengthValidation.
         */
        constructor(options: MinLengthValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\MinValueValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface MinValueValidationOptions extends StaticMessageValidationOptions {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
    }
    interface MinValueFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
    }
    class MinValueValidation extends StaticMessageValidation implements MinValueFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         *
         * @param min Minimum field value.
         * @param message Validation rule error message.
         */
        constructor(min: number, message?: string);
        /**
         * Constructs a validator that checks whether the value is greater than or equal to the specified minimum number.
         *
         * @param options The options for the MinValueValidation.
         */
        constructor(options: MinValueValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotContainsCharactersValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsCharactersValidationOptions extends StaticMessageValidationOptions {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    interface NotContainsCharactersFormValidation extends StaticMessageFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
    }
    class NotContainsCharactersValidation extends StaticMessageValidation implements NotContainsCharactersFormValidation {
        /**
         * One or more characters to search for.
         */
        characters: string;
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         *
         * @param characters One or more characters to search for.
         * @param message Validation rule error message.
         */
        constructor(characters: string, message?: string);
        /**
         * Constructs a validator that checks that the value does not contain any characters from a character set.
         *
         * @param options The options for NotContainsCharactersValidation.
         */
        constructor(options: NotContainsCharactersValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotContainsValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotContainsValidationOptions extends StaticMessageValidationOptions {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    interface NotContainsFormValidation extends StaticMessageFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
    }
    class NotContainsValidation extends StaticMessageValidation implements NotContainsFormValidation {
        /**
         * The search string to be searched for.
         */
        searchString: string;
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         *
         * @param search The search string to match.
         * @param message Validation rule error message.
         */
        constructor(searchString: string, message?: string);
        /**
         * Constructs a validator that checks that the value does not contain a case insensitive match of a search string.
         *
         * @param options The options for the NotContainsValidation.
         */
        constructor(options: NotContainsValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NotRegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NotRegExMatchValidationOptions extends StaticMessageValidationOptions {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage?: string | HtmlContent;
    }
    interface NotRegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage?: string | HtmlContent;
    }
    class NotRegExMatchValidation extends StaticMessageValidation implements NotRegExMatchFormValidation {
        /**
         * The regular expression that if matched will cause the field value to fail validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage: string | HtmlContent;
        /**
         * Constructs a validator that checks if the value does not match a regular expression.
         *
         * @param pattern Regular expression to test the value against.
         * @param message Validation rule error message.
         * @param successMessage Validation rule success message.
         */
        constructor(pattern: string, message: string, successMessage?: string);
        /**
         * Constructs a validator that checks if the value does not match a regular expression.
         *
         * @param options Options for the NotRegExMatchValidation.
         */
        constructor(options: NotRegExMatchValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\NumericValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface NumericValidationOptions extends StaticMessageValidationOptions {
    }
    interface NumericFormValidation extends StaticMessageFormValidation {
    }
    class NumericValidation extends StaticMessageValidation implements NumericFormValidation {
        /**
         * Constructs a validator that checks whether the value is a number.
         *
         * @param message Validation rule error message.
         */
        constructor(message?: string);
        /**
         * Constructs a validator that checks whether the value is a number.
         *
         * @param options Options for the NumericValidation.
         */
        constructor(options?: NumericValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RangeValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RangeValidationOptions extends StaticMessageValidationOptions {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    interface RangeFormValidation extends StaticMessageFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
    }
    class RangeValidation extends StaticMessageValidation implements RangeFormValidation {
        /**
         * Minimum field value that is considered valid.
         */
        min: number;
        /**
         * Maximum field value that is considered valid.
         */
        max: number;
        /**
         * Constructs a range validation.
         *
         * @param min The range minimum.
         * @param max The range maximum.
         * @param message The validation message.
         */
        constructor(min: number, max: number, message?: string);
        /**
         * Constructs a range validation.
         *
         * @param options Options for the RangeValidation.
         */
        constructor(options: RangeValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RegExMatchValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RegExMatchValidationOptions extends StaticMessageValidationOptions {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage?: string | HtmlContent;
    }
    interface RegExMatchFormValidation extends StaticMessageFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage?: string | HtmlContent;
    }
    class RegExMatchValidation extends StaticMessageValidation implements RegExMatchFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        pattern: string;
        /**
         * The validation success message.
         */
        successMessage: string | HtmlContent;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param pattern Regular expression pattern to match.
         * @param message The message to show the user when validation fails.
         * @param successMessage The message to show the user when validation succeeds.
         */
        constructor(pattern: string, message: string, successMessage?: string);
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param options The options for the RegExMatchValidation.
         */
        constructor(options: RegExMatchValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\RequiredValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface RequiredValidationOptions extends StaticMessageValidationOptions {
    }
    interface RequiredFormValidation extends StaticMessageFormValidation {
    }
    class RequiredValidation extends StaticMessageValidation implements RequiredFormValidation {
        /**
         * Constructs and instance of the required validation which will ensure value is non-empty.
         *
         * @param message The message to show the user when validation fails.
         */
        constructor(message?: string);
        /**
         * Constructs and instance of the required validation which will ensure value is non-empty.
         *
         * @param options Options for the RequiredValidation.
         */
        constructor(options?: RequiredValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\StaticMessageValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface StaticMessageValidationOptions {
        /**
         * The default message to be displayed when validation fails.
         */
        message?: string | HtmlContent;
    }
    interface StaticMessageFormValidation extends FormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string | HtmlContent;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid?: KnockoutObservable<boolean>;
    }
    class StaticMessageValidation extends Validation implements StaticMessageFormValidation {
        /**
         * The message to be displayed when validation fails.
         */
        message: string | HtmlContent;
        /**
         * Indicates whether an empty value is valid or not.
         */
        isEmptyValid: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param type The form validation type.
         * @param message The message to show the user when validation fails.
         */
        constructor(type: FormValidationType, message: string);
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param type The form validation type.
         * @param options Options for the StaticMessageValidation.
         */
        constructor(type: FormValidationType, options?: StaticMessageValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\UriValidation.d.ts
declare module MsPortalFx.ViewModels {
    interface UriValidationOptions extends StaticMessageValidationOptions {
        /**
         * The url must be an https address.
         */
        requireHttps?: boolean;
    }
    interface UriFormValidation extends StaticMessageFormValidation {
        /**
         * The url must be an https address.
         */
        requireHttps?: boolean;
    }
    class UriValidation extends StaticMessageValidation implements UriFormValidation {
        /**
         * The regular expression field value must match to pass validation.
         */
        options: UriValidationOptions;
        /**
         * The url must be an https address.
         */
        requireHttps?: boolean;
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param message The message to show the user when validation fails.
         * @param options Options for the uri validator.
         */
        constructor(message?: string, options?: UriValidationOptions);
        /**
         * Constructs and instance of the regular expression validation which ensure value matches regular expression.
         *
         * @param options Options for the uri validator.
         */
        constructor(options?: UriValidationOptions);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\Validation.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Retuns a ValidationResult.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResult(err?: string): ValidationResult;
    /**
     * Returns a validation result promise.
     * If the error message is not a string, returns a success result.
     * Else returns an invalid result with the error message.
     */
    function getValidationResultPromise(err?: string): Promise<ValidationResult>;
    interface FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
        /**
         * Maps the value of the control to the value you want to be validated
         *
         * @param value the value of the control
         * @returns the value to be validated
         */
        map?(value: any): any;
    }
    class Validation implements FormValidation {
        /**
         * The type of validation to be performed.
         */
        type: FormValidationType;
        /**
         * Maps the value of the control to the value to be validated
         *
         * @param value the value of the control
         * @returns the value to be validated
         */
        map?(value: any): any;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param type The validation type.
         */
        constructor(type: FormValidationType);
    }
}

// FILE: MsPortalFx\ViewModels\Fields\Validation\ValidationResult.d.ts
declare module MsPortalFx.ViewModels {
    interface ValidationResult {
        /**
         * Whether or not the field is valid.
         */
        valid: boolean;
        /**
         * The message to show the current state of the validation.
         */
        message?: string | HtmlContent;
        /**
         * Validation state.
         */
        state?: MsPortalFx.ViewModels.Controls.Validators.ValidationState;
        /**
         * Validation type.
         */
        type?: MsPortalFx.ViewModels.FormValidationType;
    }
}

// FILE: MsPortalFx\ViewModels\FileDownload\FileDownload.d.ts
declare module MsPortalFx.ViewModels.FileDownload {
    import FxNet = MsPortalFx.Base.Net2;
    /**
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum Type {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2
    }
    /**
     * File download status with http response codes.
     *
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Status {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    /**
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UriCallbackConfirmationDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        uriCallbackProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        uriCallbackProgressText?: string;
        /**
         * MessageBox title string to indicate if file should be downloaded or canceled.
         */
        downloadTitle?: string;
        /**
         * MessageBox description string to indicate if file should be downloaded or canceled.
         */
        downloadText?: string;
        /**
         * MessageBox default button text.
         */
        defaultButtonText?: string;
        /**
         * MessageBox cancel button text.
         */
        cancelButtonText?: string;
    }
    /**
     * Error notification messages for uri callback errors.
     * When uri callback error fails, reject the promise and provide the needed error messages and it will be shown in the hubs notification.
     *
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UriCallbackErrorMessage {
        /**
         * Optionally specify the title text for error notification message.
         */
        title?: string;
        /**
         * Optionally specify the description text for error notification message.
         */
        description?: string;
    }
    /**
     * Options for a file download.
     *
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface Options {
        /**
         * URI for the file download.
         */
        targetUri?: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback?: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Optionally specify whether to add default authorization tokens or options for getting authorization tokens.
         */
        addDefaultAuthorizationToken?: boolean | MsPortalFx.Base.Net2.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<Type>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart?: () => void;
        /**
         * Callback executed on download end
         */
        onEnd?: (status: Status) => void;
    }
    /**
     * Contract for a file download control.
     *
     * @deprecated MsPortalFx.ViewModels.FileDownload has been deprecated.
     * Please migrate to Fx/Controls/FileDownload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Context {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservableBase<string>;
        /**
         * Optionally specify options for getting authorization tokens.
         */
        authorizationOptions: FxNet.AuthorizationOptions;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<Type>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<Status>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * Callback executed on download start
         */
        onStart: () => void;
        /**
         * Callback executed on download end
         */
        onEnd: (status: Status) => void;
        /**
         * FileDownload command constructor.
         *
         * @param options.
         */
        constructor(options: Options);
    }
}

// FILE: MsPortalFx\ViewModels\FileUpload\FileUpload.d.ts
declare module MsPortalFx.ViewModels.FileUpload {
    import DynamicBladeSelection = MsPortalFx.ViewModels.DynamicBladeSelection;
    const defaultFullFileUploadMaxSize = 2097152;
    const defaultFullFileUploadChunkSize = 2097152;
    const defaultStreamFileUploadMaxSize = 10737418240;
    const defaultStreamFileUploadChunkSize = 1048576;
    const defaultBlobStoreUploadMaxSize: number;
    const defaultAppendBlobStoreUploadMaxSize: number;
    const defaultPageBlobStoreUploadMaxSize = 1099511627776;
    const defaultAzureFileServiceUploadMaxSize = 1099511627776;
    const defaultBlobStoreUploadChunkSize = 2097152;
    const pageBlobPageSize = 512;
    const defaultResumableTrackingChunkSize: number;
    /**
     * Specifies how the file content should be uploaded.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum UploadType {
        /**
         *  Full file content will be read. Use this option only for small file sizes less than 2 MB.
         */
        Full = 0,
        /**
         * File content will be read in chunks and provided to user in chunks.
         * Use this option to read large files and if user wants control over where to post the content.
         */
        Stream = 1,
        /**
         *  File upload to block blob store.
         */
        BlockBlobStore = 2,
        /**
         *  File upload to page blob store.
         */
        PageBlobStore = 3,
        /**
         *  File upload to append blob store.
         */
        AppendBlobStore = 4,
        /**
         *  File upload to Azure file service.
         */
        FileService = 5
    }
    /**
     * Specifies how the file content should be read and encoded in memory.
     * These options mimics the html5 file reader options to read the file content.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ContentType {
        /**
         * By default, file content will be read and stored as binary data in an ArrayBuffer.
         */
        Default = 0,
        /**
         * The file content will be read as plain text.
         * By default the string is encoded in 'UTF-8' format. Use the optional encoding parameter to specify a different format.
         */
        Text = 1,
        /**
         * The file content will be available in an ArrayBuffer.
         */
        ArrayBuffer = 2,
        /**
         * The file content will be encoded in the data uri scheme. Use this option for images and if those need to be directly shown in img tag.
         */
        DataUri = 3
    }
    /**
     * File upload status.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum UploadStatus {
        /**
         * Invalid.
         */
        Invalid = 0,
        /**
         * Pending.
         */
        Pending = 1,
        /**
         * Uploading.
         */
        Uploading = 2,
        /**
         * Paused.
         */
        Paused = 3,
        /**
         * Complete.
         */
        Complete = 4,
        /**
         * Canceled.
         */
        Canceled = 5,
        /**
         * Aborted.
         */
        Aborted = 6
    }
    /**
     * Upload action performed on upload task. This enum is used internally by upload framework.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum UploadAction {
        /**
         * No-op.
         */
        None = 0,
        /**
         * Pause the current upload task.
         */
        Pause = 1,
        /**
         * Resume the current upload task.
         */
        Resume = 2,
        /**
         * Cancel the current upload task
         */
        Cancel = 3,
        /**
         * Dispose the current upload task.
         */
        Dispose = 4,
        /**
         * Add selected file to upload task array.
         */
        AddUploadTasks = 5,
        /**
         * Reset Upload task array.
         */
        ResetUploadTasks = 6,
        /**
         * Complete the current upload task.
         * This action is used for streaming file upload to indicate the completion of the upload.
         */
        Complete = 7,
        /**
         * Abort the current upload task.
         * This action is used for aborting the current upload due to runtime errors.
         */
        Abort = 8,
        /**
         * Gets the next file chunk for streaming upload.
         * This action is used for streaming file upload to get the next file chunk.
         */
        GetNextChunk = 9
    }
    /**
     * Access tier values for blob.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum BlobAccessTier {
        /**
         * Optimized for storing data that is accessed frequently.
         */
        Hot = 0,
        /**
         * Optimized for storing data that is infrequently accessed and stored for at least 30 days.
         */
        Cool = 1,
        /**
         * Optimized for storing data that is rarely accessed and stored for at least 180 days with flexible latency requirements
         */
        Archive = 2
    }
    /**
     * Resource strings to override the default messages.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ResourceStrings {
        /**
         * Override the default validation message for invalid allowed file extension.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileExtensionInvalidErrorMessage?: string;
        /**
         * Override the default validation message for file size greater than provided max file size.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         * {1} - Max file size.
         * {2} - File size.
         */
        fileSizeInvalidErrorMessage?: string;
        /**
         * Override the default message when runtime file read error occurs.
         * The message can optionally specify a format string and control will substitue the params.
         * {0} - Name of the selected file.
         */
        fileReadAbortedErrorMessage?: string;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadContext {
        /**
         * Specify how/where the file should be uploaded.
         */
        type: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    /**
     * The file upload context options around how/where to upload and size limits.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StreamFileUploadOptions extends FullFileUploadOptions {
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning?: boolean;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BlobStoreFileUploadOptions<T> extends FullFileUploadOptions {
        /**
         * Specify how/where the file should be uploaded.
         */
        type?: UploadType;
        /**
         * Specify how the file content should be read and encoded in memory.
         */
        contentType?: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding?: string;
        /**
         * Specify the maximum file size that can be uploaded in bytes.
         */
        maxFileSize?: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded in bytes.
         */
        chunkSize?: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category?: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget?: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade?: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable?: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications?: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings?: ResourceStrings;
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context?: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext?: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand?: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback?: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri?: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext?: AuthorizationContext<T>;
        /**
         * Specifies access tier for blob.
         */
        accessTier?: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders?: ReadonlyStringMap<string>;
    }
    /**
     * Defines how the uploaded file content will be available for the user.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadContent {
        /**
         * File upload type. The content will be different for each file upload type.
         */
        type: UploadType;
        /**
         * Specifies how the content will be represented in memory.
         */
        contentType: ContentType;
    }
    /**
     * Holds the full file uploaded content.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FullFileUploadContent extends UploadContent {
        /**
         * The full file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
    }
    /**
     * Holds the streamed file chunks and start/end bytes.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface StreamFileUploadContent extends UploadContent {
        /**
         * The chunked file content will be available in memory and its content will be represented in the format specified by contentType.
         */
        content: any;
        /**
         * The startbyte of the chunk.
         */
        startByte: number;
        /**
         * The endbyte of the chunk.
         */
        endByte: number;
    }
    /**
     * File upload result will hold the upload status, current progress and upload content.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadResult {
        /**
         * The current status of the upload task.
         */
        status: UploadStatus;
        /**
         * The percent complete of the upload task.
         */
        progressPercent: number;
        /**
         * File upload content will be available in memory based on the specified upload type and content type.
         */
        data: UploadContent;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: string;
    }
    /**
     * Each file upload task is represented by a unique key. This is used for all management operations to locate the uploads.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadKey {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
    }
    /**
     * Context info sent as part of various upload task actions.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ActionContext {
    }
    /**
     * Resumable context needed to resume uploads across browser session.
     * This is an optional property in ResumeContext and presence of this property in ResumeContext indicates the intent to resume an upload after browser refresh/crash/close.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ResumableContext {
        /**
         * Upload key of the initial upload which was stopped due to browser refresh/crash/close.
         * The upload id is used to lookup the persisted/tracked uploaded byte resumable information.
         */
        originalUploadKey: UploadKey;
    }
    /**
     * Optional context information passed to the resume API.
     * Resume is called to start a new upload, start a new upload overriding upload context, resume an in-memory paused upload and resume an upload across browser session.
     * Resume context provides adequate context to enable above resume scenarios.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ResumeContext extends ActionContext {
        /**
         * Optional upload context information to override the default upload context specified in the view model.
         * For multi-select scenarios the default context will be applied to all uploads.
         * If upload type or content type needs to be overridden for a particular upload,
         * a new upload context information can be sent as part of resume context.
         */
        uploadContext?: UploadContext;
        /**
         * For resuming the upload across browser refresh/crash/close scenario, pass in the resumableContext with the upload key for the paused upload.
         * A list of paused uploads due to browser refresh/crash/close will be made avaiable via getResumableUploadInfo API which will have all necessary information including the upload key.
         */
        resumableContext?: ResumableContext;
    }
    /**
     * Optional abort context information sent when upload is aborted.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AbortContext extends ActionContext {
        /**
         * An error message / reason for aborting the file upload.
         */
        reason?: string;
    }
    /**
     *  Optional dispose context information sent when upload is disposed.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DisposeContext extends ActionContext {
        /**
         * Optional flag to indicate if resumable info needs to be deleted.
         * Setting it to true will cleanup both in-memory resumable info as well as persisted/tracked resumable info unless there is an ongoing upload with that upload key.
         */
        resumable?: boolean;
    }
    /**
     * Optional chunk context sent when fetching the next file chunk via GetNextChunk API.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ChunkContext extends ActionContext {
        /**
         * Optionally specify the start byte offset.
         */
        startByte?: number;
        /**
         * Optionally specify the chunk size otherwise the default 2 MB will be used.
         */
        chunkSize?: number;
    }
    /**
     * Upload action callback interface used by the upload widget.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadActionCallback {
        /**
         * Upload action callback interface used by the upload widget.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param action Upload action that needs to be performed like resume/pause/cancel/dispose.
         */
        (uploadKeys: UploadKey[], action: UploadAction, context?: ActionContext): Promise<any>;
    }
    /**
     * Streaming upload callback interface used by the upload widget.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface GetNextChunkCallback {
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param uploadKeys Array of unique identifier for the each upload task.
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @returns Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        (uploadKey: UploadKey, startByte?: number, chunkSize?: number): Promise<StreamFileUploadContent>;
    }
    /**
     * File information.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FileInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SelectedFileContract extends FileInfoContract {
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
    }
    /**
     * Upload information.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadInfoContract {
        /**
         * Unique id for each upload task.
         */
        id: KnockoutReadOnlyObservableBase<string>;
        /**
         * Upload category tag provided by extension.
         */
        category: KnockoutReadOnlyObservableBase<string>;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Upload type.
         */
        type: KnockoutReadOnlyObservableBase<UploadType>;
        /**
         * Upload destination like target blob store uri .
         */
        target: KnockoutReadOnlyObservableBase<string>;
        /**
         * The current status of the upload task.
         */
        status: KnockoutReadOnlyObservableBase<UploadStatus>;
        /**
         * The total bytes that have been uploaded/streamed.
         */
        uploadedBytes: KnockoutReadOnlyObservableBase<number>;
        /**
         * The percent complete of the upload task. The values will be in 0-100 range.
         */
        progressPercent: KnockoutReadOnlyObservableBase<number>;
        /**
         * Error messages to indicate the runtime errors.
         */
        errorMessage?: KnockoutReadOnlyObservableBase<string>;
    }
    /**
     * File upload details, status and content.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume: () => void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose: () => void;
        /**
         * Method to cancel the current file upload.
         */
        cancel: () => void;
        /**
         * Method to pause the current file upload.
         */
        pause?: () => void;
    }
    /**
     * Async file upload task with upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @returns Promise indicating the success or failure or the operation.
         */
        resume: (context?: ResumeContext) => Promise<any>;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        pause?: () => Promise<any>;
        /**
         * Method to cancel the current file upload.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        cancel: () => Promise<any>;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        complete: () => Promise<any>;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @returns Promise indicating the success or failure or the operation.
         */
        abort: (context?: AbortContext) => Promise<any>;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        dispose: () => Promise<any>;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @returns Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk: (startByte?: number, chunkSize?: number) => Promise<StreamFileUploadContent>;
    }
    /**
     * View model contract for file upload.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * UploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<UploadTaskContract>;
    }
    /**
     * Defines SAS uri info needed for periodic SAS uri renewal.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface SasUriInfo {
        /**
         * Specify the SAS uri
         */
        uri: string;
        /**
         * Specify the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OauthHeaderInfo {
        /**
         * Specifies the URI including the blob.
         */
        uri: string;
        /**
         * Bearer token with permissions to write to this Storage Account.
         */
        authorizationHeader: string;
        /**
         * Specifies the expiration time. Normalize the expiration time in UTC.
         * The renewal time calculation is based on current UTC time vs the provided expiration time.
         */
        expirationDate?: Date;
        /**
         * Optionally specify a time interval in seconds to renew the SAS uri before the expiration time.
         * Due to network delays and server time skew, it would be ideal to renew the SAS uri couple of minutes earlier than the expiration time.
         * If this is not specified a default value of 5 minutes will be used and renewal callback will be invoked 5 minutes before the expiration time.
         *
         * Provide the time in seconds.
         */
        renewalTimeBeforeExpiry?: number;
        /**
         * Optionally specify whether this token can be renewed or not.
         */
        renew?: boolean;
    }
    /**
     * The type of Authorization used in making the upload call to the BlobStore.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum BlobStoreAuthorizationType {
        /**
         * Authorization using an Open Authorization (Bearer token) standard.
         */
        Oauth = 0,
        /**
         * Authorization using a Shared Access Signature..
         */
        SAS = 1
    }
    /**
     * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface AuthorizationContext<T> {
        /**
         * Call to fetch required credentials for the given container or storage account.
         *
         * @param fileInfo Metadata about the current file being uploaded. This can be used to renew the correct authorization for that file.
         * @param context The context object specified by the extension to this control. This may be used to pass back specific information needed to fetch authorization in renew scenario.
         * @returns A Promise with either the SASUri info or the OAUTHHeader info depending on the type of authentication this control should use.
         */
        fetchAuthorization: (fileInfo: FileInfoContract, context: T) => Promise<SasUriInfo | OauthHeaderInfo>;
    }
    /**
     * API to get the list of upload information for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of upload information.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): Promise<UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of resumable upload information.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getResumableUploadInfos(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): Promise<UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys and/or category id.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns Promise which contains the array of AsyncUploadTask objects.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getAsyncUploadTasks(lifetime: MsPortalFx.Base.LifetimeManager, uploadKeys: UploadKey[], category?: string): Promise<AsyncUploadTaskContract[]>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @returns A promise indicating success or failure of the management operation.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function invokeUploadAction<TResult>(uploadKey: UploadKey, action: UploadAction, context?: ActionContext): Promise<TResult>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the start byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @returns A promise indicating success or failure of the operation.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getNextChunk(uploadKey: UploadKey, startByte?: number, chunkSize?: number): Promise<StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo on successful completion.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function registerRenewSasUriCallback<T>(callback: (fileInfo: FileInfoContract, context?: T) => Promise<SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function registerRenewAuthorizationCallback<T>(callback: (authorizationType: MsPortalFx.ViewModels.FileUpload.BlobStoreAuthorizationType, fileInfo: FileUpload.FileInfoContract, context?: T) => Promise<FileUpload.SasUriInfo | FileUpload.OauthHeaderInfo>): void;
    /**
     * Full file upload context.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class FullFileUploadContext implements UploadContext {
        /**
         * Full file will be read and the entire content will be available in memory.
         */
        type: UploadType;
        /**
         * File content will be stored by default in an array buffer.
         */
        contentType: ContentType;
        /**
         * Optionally specify the encoding for Text content type like "UTF-8", "UTF-16" etc.
         * This parameter will be used directly for HTML5 file reader's readAsText method.
         */
        encoding: string;
        /**
         * Specify the maximum file size that can be uploaded.
         * Recommended max file is less than 2 MB for this upload type.
         */
        maxFileSize: number;
        /**
         * Specify the maximum chunk size the file should be chunked and uploaded.
         * Default chunk size should be same as maxFileSize for fill file download.
         */
        chunkSize: number;
        /**
         * Optionally specify a category id to distinguish extension specific uploads.
         * Uploads are handled asyncronously in shell and if each extension needs to have extension specific management operation on existing uploads,
         * extension name or some unique keyword can be specified in category property.
         */
        category: string;
        /**
         * Optionally specify the upload destination string which will be used for various upload status notifications.
         * By default, for Azure blob store uploads, the destination blob path will be used.
         * For Streaming uploads, a default streaming upload string will be used.
         */
        uploadTarget: string;
        /**
         * Optionally specify the extension specific management blade that will be launched when upload notification message is clicked.
         * Extension can provide either DynamicBladeSelection or a deep link.
         */
        notificationBlade: string | DynamicBladeSelection;
        /**
         * Optionally specify if upload control should track the uploaded bytes information to enable resuming uploads across browser refresh/crash/close.
         * Opt into this option for large files like VHD or large package so that in event of browser refresh/crash/close, the upload can resume from last recorded uploaded bytes.
         * The tracked bytes will differ from actual uploaded byte. For all Azure storage, the controls handles resuming the uploads properly.
         * For stream uploads, the onus is on the extension to handle the difference in uploaded bytes state and make the destination upload operation idempotent or
         * query the destination to find its successful uploaded bytes and drop the chunks if needed.
         */
        resumable: boolean;
        /**
         * Optionally disable the default progress notifications for streaming upload.
         * Extension can choose to send their own progress notifications.
         * This options is applicable only for streaming upload.
         */
        disableNotifications: boolean;
        /**
         * Resource strings to override the default messages.
         */
        resourceStrings: ResourceStrings;
        constructor(options?: FullFileUploadOptions);
    }
    /**
     * Stream file upload context. File will be read in chunks and chunked content will be available in memory.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class StreamFileUploadContext extends FullFileUploadContext implements UploadContext {
        /**
         * A flag to indicate if the upload is long running asynchronous streaming upload that's done in the background by the extension (uploads beyond blade lifetime).
         * If this flag is enabled then the framework will keep the extension alive as long as file chunks are read actively.
         */
        longRunning: boolean;
        /**
         * Initialize default properties for stream file upload context.
         */
        constructor(options?: StreamFileUploadOptions);
    }
    /**
     * BlobStore file upload context. File will be uploaded directly to blob store specified by the SAS uri.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BlobStoreFileUploadContext<T> extends FullFileUploadContext implements UploadContext {
        /**
         * Sas uri command context that will be passed to the execute method of the sasUriCommand.
         * User can optionally set the needed context before starting the file upload.
         */
        context: KnockoutObservableBase<T>;
        /**
         * If this property is set to true, FileInfoContract object will be passed to Sas uri command.
         * In a multi-select sceanrio, extension authors may want to generate unique file level SAS uri and can use the file name provided in the context.
         * If this property is set to false, user provided context information will be passed.
         * By default this options is set to true and FileInfoContract object will be passed.
         */
        useDefaultFileInfoContext: KnockoutObservableBase<boolean>;
        /**
         * Specify the command to fetch the SAS uri for the target blob store where file will be uploaded.
         * Execute method on the command should provide the SAS uri with correct permissions and calculate the expiration time from the time it was invoked.
         */
        sasUriCommand: KnockoutObservableBase<MsPortalFx.ViewModels.Commands.Command<T>>;
        /**
         * A flag to indicate if SAS uri should be periodically renewed or not.
         * By default this is false and upload framework invoke sasUriCommand once during the start of the upload.
         * If this flag is set to true, then extension should register a SAS uri renewal callback method using registerRenewSasUriCallback API during extension initialization.
         * Upload framework will invoke the callback to get SAS uri, expiration time and invoke the callback again based on the provided expiration time.
         */
        useRenewSasUriCallback: boolean;
        /**
         * Optionally specify if SAS uri should be updated with selected file name.
         * By default, the unique blob SAS uri is expected. If the extension provides container SAS uri or account SAS uri and
         * need to include the selected filename, set this property to be true.
         */
        addFilenameToSasUri: KnockoutObservable<boolean>;
        /**
         * Specify the calback to fetch the authorization context needed to upload the specified blob to the blob store.
         */
        authorizationContext: AuthorizationContext<T>;
        /**
         * Specify the access tier for blob.
         */
        accessTier: BlobAccessTier | KnockoutObservableBase<BlobAccessTier>;
        /**
         * Optionally specify any http headers that need to be sent with the upload. The headers will be applied to every http request in the upload process, which includes
         * resume, commit and cancel requests. The framework will not check the content of the headers, and it is the caller's responsibility to avoid overwriting standard
         * headers, or adding unsupported headers. This was added to support Storage extension requirements, and typically most extensions should not be using this feature.
         */
        customHeaders: ReadonlyStringMap<string>;
        /**
         * Initialize default properties for blob store file upload context.
         */
        constructor(options?: BlobStoreFileUploadOptions<T>);
    }
    /**
     * UploadTask represent the file details, status, upload progress and content.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class UploadTask implements UploadTaskContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * The object representing the uploaded status/content for this file.
         */
        uploadResult: KnockoutObservableBase<UploadResult>;
        /**
         * An internal enum to track the upload action.
         */
        _msPortalFxUploadAction: KnockoutObservableBase<UploadAction>;
        /**
         * An internal counter to track the upload action.
         */
        _msPortalFxActionTrigger: KnockoutObservableBase<number>;
        /**
         * Method to start the initial file upload and resume the paused file upload.
         */
        resume(): void;
        /**
         * Method to pause the current file upload.
         */
        pause(): void;
        /**
         * Method to cancel the current file upload.
         */
        cancel(): void;
        /**
         * Method to dispose the current file upload. Dispose will cacel the ongoing upload and will do the needed cleanup.
         */
        dispose(): void;
    }
    /**
     * AsyncUploadTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadTask instance will be returned when getAsyncUploadTasks is called by extension.
     * AsyncUploadTask interacts directly with the shell APIs exposed to interact with global file upload manager.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AsyncUploadTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         */
        constructor(uploadInfo: UploadInfoContract);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @returns Promise indicating the success or failure or the operation.
         */
        resume(context?: ResumeContext): Promise<any>;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        pause(): Promise<any>;
        /**
         * Method to cancel the current file upload.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        cancel(): Promise<any>;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        complete(): Promise<any>;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @returns Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): Promise<any>;
        /**
         * Method to dispose the current file upload. Dispose will cancel the ongoing upload and will do the needed cleanup.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        dispose(): Promise<any>;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @returns Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): Promise<StreamFileUploadContent>;
    }
    /**
     * AsyncUploadWidgetTask represent the upload info details like file info, status and progress.
     * Supports upload management methods like resume/pause/cancel/dispose.
     * AsyncUploadWidgetTask is used by the upload widget to manage temprorary UX interaction around file selection.
     * The management operations supported by AsyncUploadWidgetTask will go through the widget and widget will delegate the call to global upload manager.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class AsyncUploadWidgetTask implements AsyncUploadTaskContract {
        /**
         * Upload information properties with file info, status and progress.
         */
        uploadInfo: UploadInfoContract;
        /**
         * Callback to handle upload management operations. The callback is populated by the upload widget which will then delegate the needed action to the global upload manager.
         */
        _msPortalFxActionCallback: KnockoutObservableBase<UploadActionCallback>;
        /**
         * Callback to handle streaming uploads to fetch the next file chunk.
         */
        _msPortalFxGetNextChunkCallback: KnockoutObservableBase<GetNextChunkCallback>;
        /**
         * Creates and instance of AsyncUploadTask.
         *
         * @param uploadInfo Upload information.
         * @param uploadActionCallback Callback to invoke management operation on the upload widget.
         */
        constructor(uploadInfo: UploadInfoContract, uploadActionCallback: UploadActionCallback, getNextChunkCallback: GetNextChunkCallback);
        /**
         * Method to start the initial file upload and resume the paused file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @param context The context needed override default upload context and also to resume across browser sessions for interrupted large file uploads.
         * @returns Promise indicating the success or failure of the operation.
         */
        resume(context?: ResumeContext): Promise<any>;
        /**
         * Method to pause the current file upload.
         * In memory Pause/Resume is operation is supported. Pause/Resume across browser session is not currently supported.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        pause(): Promise<any>;
        /**
         * Method to cancel the current file upload.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        cancel(): Promise<any>;
        /**
         * Method to complete the current file upload.
         * This is used for streaming file upload to indicate the completion of current file upload.
         * The promise will be rejected if complete operation is called for Azure storage uploads.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        complete(): Promise<any>;
        /**
         * Method to abort the current file upload.
         * Abort method is invoked when there is any runtime error and the upload should be aborted.
         * Abort will move the upload status to aborted.
         *
         * @param context The abort context specify the reason for aborting the file upload.
         * @returns Promise indicating the success or failure or the operation.
         */
        abort(context?: AbortContext): Promise<any>;
        /**
         * Method to dispose the current file upload. Dispose will abort the ongoing upload and will do the needed cleanup.
         *
         * @returns Promise indicating the success or failure or the operation.
         */
        dispose(): Promise<any>;
        /**
         * Method to get the next file chunk for streaming file uploads.
         * The promise will be rejected if getNextChunk operation is called for Azure storage uploads.
         *
         * @param startByte  Optionally specify the start byte offset.
         * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
         * @returns Promise<StreamFileUploadContent> indicating the success or failure or the operation.
         *         Successful resolution of promise will return the StreamFileUpoadContent with startByte, endByte and the actual data.
         */
        getNextChunk(startByte?: number, chunkSize?: number): Promise<StreamFileUploadContent>;
        private _invoke;
        _execCallback<U>(callbackOb: KnockoutObservableBase<UploadActionCallback | GetNextChunkCallback>, ...args: any[]): Promise<U>;
    }
    /**
     * SelectedFile is the extension representation of the user selected file via browse dialog.
     * The SelectedFile has the core file properties that will be surfaced to the extension.
     * The actual file handles cannot be passed back and forth across iframe and widget / global upload manager will retain the actual handles.
     *
     * @deprecated MsPortalFx.ViewModels.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class SelectedFile implements SelectedFileContract {
        /**
         * Unique id for each upload task.
         */
        id: string;
        /**
         * The name of the file.
         */
        name: string;
        /**
         * The mimetype of the file.
         */
        mimetype: string;
        /**
         * The size of the file, in bytes.
         */
        size: number;
        /**
         * Selected file can be uploaded if valid is true.
         * valid flag can be set by the control if any of the standard validations around file size and permission issues fails. The corresponding upload task status will be set to Invalid.
         * valid flag can be set by extension based on the custom validation added by the extension.
         * If extension sets the flag to false, the corresponding upload task status will be marked as Invalid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Creates and instance of SelectedFile.
         *
         * @param fileInfo File information.
         */
        constructor(fileInfo: FileInfoContract);
    }
}

// FILE: MsPortalFx\ViewModels\FileUpload\Internal\Internal.FileUpload.UploadManager.d.ts
declare module FxImpl.FileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import Rpc = FxImpl.Rpc;
    import FxLifetime = MsPortalFx.Base.LifetimeManager;
    /**
     * Upload info params used in shell APIs to get the list of uploads.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadInfoParams {
        /**
         * Array of upload keys.
         */
        uploadKeys: FxFileUpload.UploadKey[];
        /**
         * Upload category tag provided by extension.
         */
        category?: string;
        /**
         * Get resumable upload information. This is a optional param and when set to true will get the resumable uplaod information.
         */
        resumable?: boolean;
    }
    /**
     * Upload info list.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadInfoList {
        /**
         * Array of upload infos.
         */
        uploads: FxFileUpload.UploadInfoContract[];
    }
    /**
     * Upload action params is used to specify what management operation to perform on file uploads.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadActionParams {
        /**
         * Unique upload identifier to lookup the async upload task.
         */
        uploadKey: FxFileUpload.UploadKey;
        /**
         * Upload management operation enum.
         */
        action: FxFileUpload.UploadAction;
        /**
         * Upload management action specific context information.
         */
        context?: FxFileUpload.ActionContext;
    }
    /**
     * Parameters that will be passed when SAS uri renewal RPC method is invoked.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadRenewSasUriParams<T> {
        /**
         * A FileInfoContract object will be passed.
         */
        fileInfo: FxFileUpload.FileInfoContract;
        /**
         * Extension can optionally provide additional data to the SAS uri callback in the UploadContext's context property.
         */
        context?: T;
    }
    /**
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface UploadRenewAuthorizationParams<T> extends UploadRenewSasUriParams<T> {
        authorizationType: FxFileUpload.BlobStoreAuthorizationType;
    }
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager.
     * ProxiedObjectTypeDefinition is used so that upload info with observable properties can be proxied across via the acquireObject call.
     * The enpoint is used to get the list of upload information for a given set of upload keys.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const getUploadInfosEndPoint: Rpc.ProxiedObjectTypeDefinition<UploadInfoParams, UploadInfoList>;
    /**
     * Rpc endpoint for communicating with the shell's global file upload manager to perform upload management operations.
     * The endpoint is used to perform Resume/Pause/Cancel/Dispose action on an existing async upload in shell.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const uploadActionEndPoint: Rpc.ActionEndPointDefinition<UploadActionParams>;
    /**
     * Rpc endpoint for Shell to communicate with the extension to invoke a SAS uri renewal callback.
     * This endpoint will be registered by the extension. The extension can be unloaded while the upload is in progress.
     * This endpoint registration will load the extension and then invoke the registered callback.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const uploadRenewSasUriEndPoint: Rpc.FuncEndPointDefinition<UploadRenewSasUriParams<any>, FxFileUpload.SasUriInfo>;
    /**
     * Rpc endpoint for Shell to communicate with the extension to invoke an authorization renewal callback.
     * This endpoint will be registered by the extension. The extension can be unloaded while the upload is in progress.
     * This endpoint registration will load the extension and then invoke the registered callback.
     *
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const uploadRenewAuthorizationEndPoint: Rpc.FuncEndPointDefinition<UploadRenewAuthorizationParams<any>, FxFileUpload.SasUriInfo | FxFileUpload.OauthHeaderInfo>;
    /**
     * API to perform Resume/Pause/Cancel/Dispose action on an existing async upload task in shell.
     * This API uses Rpc uploadActionEndPoint to communicate with the shell's global file upload manager.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param action Management operation like Resume/Pause/Cancel/Dispose.
     * @param context Optionally pass in action specific context like ResumeContext, AbortContext, DisposeContext or ChunkContext.
     * @returns A promise indicating success or failure of the management operation.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function invokeUploadAction(uploadKey: FxFileUpload.UploadKey, action: FxFileUpload.UploadAction, context?: FxFileUpload.ActionContext): Promise<any>;
    /**
     * API to get the list of upload information for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of upload information.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Promise<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of resumable upload information for given set of upload keys and/or category id.
     * In the event of browser refresh or close/open, list of ongoing / crashed uploads can be fetched by the getResumableUploadInfos API.
     * An opt-in resumable option should be enabled to track file upload information across browser session/refresh.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the resumable upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns A promise which contains the array of resumable upload information.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getResumableUploadInfos(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Promise<FxFileUpload.UploadInfoContract[]>;
    /**
     * API to get the list of AsyncUploadTask for given set of upload keys.
     * This API uses Rpc getUploadInfosEndPoint to communicate with the shell's global file upload manager.
     *
     * @param lifetime A lifetime manager to manage the lifetime of the proxied upload info objects.
     * @param uploadKeys An array of UploadKey for which the upload information needs to be fetched.
     * @param category Upload category tag provided by extension.
     * @returns Promise which contains the array of AsyncUploadTask objects.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getAsyncUploadTasks(lifetime: FxLifetime, uploadKeys: FxFileUpload.UploadKey[], category?: string): Promise<FxFileUpload.AsyncUploadTaskContract[]>;
    /**
     * API to get next file chunk for asyncronous streaming upload.
     *
     * @param uploadKey A unique identifier for the upload task.
     * @param startByte  Optionally specify the starting byte offset.
     * @param chunkSize Optionally specify the chunk size otherwise the default 2 MB will be used.
     * @returns A promise indicating success or failure of the operation.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function getNextChunk(uploadKey: FxFileUpload.UploadKey, startByte?: number, chunkSize?: number): Promise<FxFileUpload.StreamFileUploadContent>;
    /**
     * API to register a SAS uri renewal callback which will be called when the SAS uri is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the
     * SAS uri renewal for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo on successful completion.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function registerRenewSasUriCallback(callback: (fileInfo: FxFileUpload.FileInfoContract, context?: any) => Promise<FxFileUpload.SasUriInfo>): void;
    /**
     * API to register an authorization renewal callback which will be called when the current authorization is near expiration.
     * Extension should register this callback once during extension initialization.
     * The context information passed to the callback should have sufficient information to handle the OAUTH or SAS renewal
     * for all file uploads from that extension.
     * In async file upload scenario, extension can be unloaded. In that case, the underlying framework will load the extension and invoke the callback.
     *
     * @param authorizationType: The type of authorization to renew.
     * @param fileInfo A FileInfoContract object will be passed to the callback.
     * @param context Extension can optionally provide additional data via UploadContext's context property.
     * @returns A promise returning the SasUriInfo or OauthHeaderInfor on successful completion.
     * @deprecated FxImpl.FileUpload has been deprecated.
     * Please migrate to Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    function registerRenewAuthorizationCallback(callback: (authorizationType: FxFileUpload.BlobStoreAuthorizationType, fileInfo: FxFileUpload.FileInfoContract, context?: any) => Promise<FxFileUpload.SasUriInfo | FxFileUpload.OauthHeaderInfo>): void;
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Base.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Input {
    interface Options<T> extends LabelAndBalloon.Options {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations?: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue?: KnockoutObservableBase<T>;
        /**
         * Name used in telemetry.
         */
        telemetryName?: string;
        /**
         * When set to true, only changes made by the end user are considered dirty.
         * This should not be set when using an edit scope.
         */
        viewModelValueChangesAreClean?: boolean;
        /**
         * Show validation error message below the control (false by default).
         */
        showValidationMessagesBelowControl?: boolean;
    }
    class ViewModel<T> extends LabelAndBalloon.ViewModel {
        /**
         * A list of validations that should be applied to the form field.
         */
        validations: KnockoutObservableArray<MsPortalFx.ViewModels.FormValidation>;
        /**
         * A list of validation results.
         */
        validationResults: KnockoutReadOnlyObservableArray<MsPortalFx.ViewModels.ValidationResult>;
        /**
         * Specifies text that will be displayed in an info balloon next to the field's label.
         */
        infoBalloonContent: KnockoutObservable<string | HtmlContent>;
        /**
         * Default value for the field. NOT HONORED when control is used with an editscope (the editscope data supplies the initial value).
         */
        defaultValue: KnockoutObservableBase<T>;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservable<boolean>;
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutObservable<boolean>;
        /**
         * Turns validation on and off for the form field.
         */
        enableValidation: KnockoutObservableBase<boolean>;
        /**
         * When changed this signals to the control validation should occur.
         */
        validate: KnockoutObservable<number>;
        /**
         * Current value of the field.
         */
        value: KnockoutObservableBase<T>;
        /**
         * Initial value for the field.
         */
        initialValue: KnockoutObservableBase<T>;
        /**
         * The global validation for the control will be delayed for the specified timeout value after a value update notification is received.
         * Set the timeout value when continous value update on key press is enabled.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         * Whether the field is enabled or not.
         */
        enabled: KnockoutObservable<boolean>;
        /**
         * Whether validation should be performed on a control. Switching to true will trigger immediate validation.
         */
        performValidation: KnockoutObservable<boolean>;
        /**
         * When changed triggers validation on the field if it has not been run.
         */
        ensureValidation: KnockoutObservable<number>;
        /**
         * Name used in telemetry.
         */
        telemetryName: string;
        /**
         * Show validation error message below the control.
         */
        showValidationMessagesBelowControl: boolean;
        _msPortalFxViewModelValueChangesAreClean: boolean;
        _msPortalFxWidgetValue: KnockoutObservable<T>;
        _msPortalFxClearValidation: KnockoutObservable<() => Promise<any>>;
        _msPortalFxTriggerValidation: KnockoutObservable<() => Promise<boolean>>;
        _enableValidationReactor: KnockoutComputed<void>;
        _options: Base.Input.Options<T>;
        private _editScopeAccessors;
        private _form;
        private _previousEditScope;
        private _dirtyLifetime;
        private _originalDirty;
        protected resetDirtyComputed(dirtyComputedFunc: () => void): void;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the Field is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the Field control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, formOrOptions: Form.ViewModel<any>, pathOrAccessor: any, options?: Options<T>);
        /**
         * Set the EditScopeAccessors used to integrate with EditScope for original and edited values.
         * Note: In most cases, it's best to use the observablePath parameter when instantiating a field, which
         *  will automatically configure the field with EditScopeAccessors. Use this override only if you know what you're doing.
         *
         * @param editScopeAccessors The EditScopeAccessors instance to be used for the original and edited values of this field.
         * @param form Optional. The form whose edit scope drives the editScopeAccessors (if one exists).
         */
        _setEditScopeAccessors(editScopeAccessors: EditScopeAccessors<T>, form?: Form.ViewModel<T>): void;
        /**
         * Clears validation on the field.
         *
         * @returns A promise that is resolved when the validation has been cleared.
         */
        clearValidation(): Promise<any>;
        /**
         * A helper function for triggering validation of the control.
         *
         * @returns A promise that is resolved when the validation has been completed.
         */
        triggerValidation(): Promise<boolean>;
        private _initializeFieldStateObservables;
        private _newThisValueBinding;
        private createValueSubscriptions;
        setDirty(value: boolean): void;
        private setValue;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\EditScopeAccessors.d.ts
declare module MsPortalFx.ViewModels.Forms {
    interface EditScopeAccessors<TValue> extends MsPortalFx.Data.EditScopeAccessors<TValue> {
    }
    module EditScopeAccessors {
        /**
         * Describes how to read and write values on an edit scope.
         */
        interface Options<TEditScope, TValue> {
            /**
             * Reads data from an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope.
             * @returns The value that this edit scope accessor supplies.
             */
            readFromEditScope: (editScopeData: TEditScope) => TValue;
            /**
             * Writes data to an edit scope.
             *
             * @param editScopeData The root data object held by the edit scope. This method should write the new value to this object.
             * @param newValue The value to be written. Typically this comes from a UI element whose value has changed.
             */
            writeToEditScope: (editScopeData: TEditScope, newValue: TValue) => void;
        }
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Editable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Editable {
    interface Options<T> extends Input.Options<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText?: KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Nullable.ViewModel<T> {
        /**
         * Text displayed in the field when the form value is empty.
         */
        emptyValueText: KnockoutObservableBase<string>;
        /**
         * Whether the field is currently being edited.
         */
        editing: KnockoutObservable<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\EditableComboBox.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.EditableComboBox {
    const enum PositioningAlignment {
        /**
         * Left edge for horizontal alignment, top edge for vertical alignment.
         */
        LeftTop = 3,
        /**
         * Right edge for horizontal alignment, top edge for vertical alignment.
         */
        RightTop = 5,
        /**
         * Left edge for horizontal alignment, bottom edge for vertical alignment.
         */
        LeftBottom = 10,
        /**
         * Right edge for horizontal alignment, bottom edge for vertical alignment.
         */
        RightBottom = 12
    }
    interface Options<T> extends Editable.Options<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment?: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment?: PositioningAlignment;
    }
    /**
     * Base class for combo fields
     */
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * Alignment used for drop popup.
         */
        popupAlignment: PositioningAlignment;
        /**
         * Alignment used for input.
         */
        inputAlignment: PositioningAlignment;
        /**
         * Constructs and instance of an editable combo field.
         * (Base class for other combo fields)
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the EditableComboField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: EditableComboBox.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Form.d.ts
declare module MsPortalFx.ViewModels.Forms.Form {
    enum EditScopeObservableType {
        Original = 0,
        Editable = 1
    }
    /**
     * @deprecated Form.FieldValueAccessorType is deprecated Use EditScopeObservableType instead.
     * This type will be removed in the future.
     */
    type FieldValueAccessorType = EditScopeObservableType;
    interface InternalEditScopeAccessors extends EditScopeAccessors<any>, FxImpl.Data.InternalEditScopeAccessors {
        createdByBaseFormClass: boolean;
    }
    /**
     * The function type for those lambdas that are passed to Form's 'createEditScopeAccessor' and 'createCustomEditScopeAccessor'.
     * See Form.createEditScopeAccessor and Form.createCustomEditScopeAccessor.
     */
    interface ObservableAccessorFunction<T, TValue> {
        (data: T, lifetimeManager: MsPortalFx.Base.LifetimeManager, type: EditScopeObservableType): KnockoutObservableBase<TValue>;
    }
    /**
     * A view model representing a form.
     */
    class ViewModel<T> implements MsPortalFx.Base.Disposable {
        /**
         * Whether the form element is valid.
         */
        valid: KnockoutComputed<boolean>;
        /**
         * The list of form sections contained in the form.
         */
        sections: KnockoutObservableArray<Base.Section>;
        /**
         * When set to true, changes to viewmodel values initiated by the extension will also write to the initial value of the edit scope.
         * What this means is that the control will not appear dirty to the user, nor will there be an alert if the user does not change the value in the control.
         */
        viewModelValueChangesSetDefaultValues: boolean;
        private _editScope;
        private _getNestedData;
        protected readonly _ltm: MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Creates a Form instance.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param editScope An optional observable that supplies an EditScope to the form (for instance, as master
         * selection changes for this details form).  If not supplied here, then the 'editScope' property should be set
         * before using this view model.
         * @param getNestedData An optional function that returns a nested object from which fields will be retrieved,
         * given either the original or editable root object of the EditScope.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, editScope?: KnockoutObservable<MsPortalFx.Data.EditScope<any>>, getNestedData?: (data: any) => T);
        /**
         * Sets the view model's edit scope observable.
         *
         * @param editScope An observable that supplies an EditScope to the form (for instance, as master selection
         * changes for this details form).
         */
        set editScope(editScope: KnockoutObservable<MsPortalFx.Data.EditScope<any>>);
        /**
         * Gets the view model's edit scope observable.
         *
         * @returns The view model's edit scope observable.
         */
        get editScope(): KnockoutObservable<MsPortalFx.Data.EditScope<any>>;
        dispose(): void;
        _createEditScopeAccessorFromPath<TValue>(observablePath: string): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @returns EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is used by both forms fields and collectors.
         *
         * @param observableAccessor A function which accesses a property on the edit scope.  ie: (data) => { return data.myProperty }
         * @returns EditScopeAccessors instance used by a form field and/or by collectors.
         */
        createEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the options passed in.
         * Use createEditScopeAccessor instead of this method wherever possible.
         *
         * @param options Methods for reading and writing to an edit scope.
         * @returns EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(options: EditScopeAccessors.Options<T, TValue>): EditScopeAccessors<TValue>;
        /**
         * Creates an EditScopeAccessors instance used both to retrieve original/editable values from an EditScope and to write one or more values back to the EditScope.
         * This is an advanced option without runtime validation of the observableAccessor lambda.
         * Use createEditScopeAccessor instead of this method wherever possible
         *
         * @param observableAccessor A function which accesses the observable.
         * @returns EditScopeAccessors instance used by a form field.
         */
        createCustomEditScopeAccessor<TValue>(observableAccessor: ObservableAccessorFunction<T, TValue>): EditScopeAccessors<TValue>;
        protected static _logEditScopeAccessorError(message: string): void;
        private _createEditScopeAccessorFromAccessorFunction;
        private _createEditScopeAccessorFromOptions;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Groups.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Groups {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of groups to categorize the selectable options.
         * Dynamic update of groups array is not yet supported for multiselect dropdown.
         * Consumers must initialize the groups before widget instantiation.
         */
        groups: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IGroup<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the GroupsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the GroupsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Groups.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\LabelAndBalloon.d.ts
declare module MsPortalFx.ViewModels.Forms {
    import FxForms = MsPortalFx.ViewModels.Forms;
    /**
     * The position of the label in a form element.
     * Note: Only works within Sections. Check samples here: https://localhost:55555/Portal/#blade/SamplesExtension/LabelPositionFormsBlade
     */
    enum LabelPosition {
        /**
         * A top aligned label. Default.
         */
        Top = 0,
        /**
         * A left aligned label.
         */
        Left = 1,
        /**
         * An invisible label.
         */
        Hidden = 2
    }
    /**
     * The position of the sublabel in a form element.
     */
    enum SubLabelPosition {
        /**
         * A Bottom aligned sublabel. Default.
         */
        Bottom = 0,
        /**
         * A right aligned sublabel.
         */
        Right = 1
    }
    module Base.LabelAndBalloon {
        /**
         * Options to render a form element with a label and info balloon.
         */
        interface Options extends MsPortalFx.ViewModels.Controls.Loadable.Options {
            /**
             * Label for the field.
             */
            label?: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Label position for the field.
             */
            labelPosition?: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel position for the field.
             */
            subLabelPosition?: KnockoutObservableBase<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel?: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies sanitized HTML that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent?: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent?: KnockoutObservable<any>;
            /**
             * Specifies whether to hide the validation check marks.
             */
            hideValidationCheck?: KnockoutObservableBase<boolean> | boolean;
            /**
             * A custom css class to apply to the control.
             */
            cssClass?: string | KnockoutObservableBase<string>;
            /**
             * Whether the form element is visible.
             */
            visible?: boolean | KnockoutObservableBase<boolean>;
        }
        /**
         * Implements LabelAndBalloonContract.
         */
        class ViewModel extends MsPortalFx.ViewModels.Controls.Loadable.ViewModel {
            /**
             * Label for the field.
             */
            label: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Label for the field.
             */
            labelPosition: KnockoutObservable<FxForms.LabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabelPosition: KnockoutObservableBase<FxForms.SubLabelPosition>;
            /**
             * SubLabel for the field.
             */
            subLabel: string | HtmlContent | KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies text that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonContent: KnockoutObservableBase<string | HtmlContent>;
            /**
             * Specifies Link object that will be displayed in an info balloon next to the field's label.
             */
            infoBalloonLinkContent: KnockoutObservable<any>;
            /**
             * Specifies whether to hide the validation check marks.
             */
            hideValidationCheck: KnockoutObservableBase<boolean> | boolean;
            /**
             * A custom css class to apply to the control.
             */
            readonly cssClass: KnockoutObservableBase<string>;
            /**
             * Whether the form element is visible.
             */
            readonly visible: KnockoutObservableBase<boolean>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxLeftLabelWidth: KnockoutObservable<number>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxRequired: KnockoutObservable<boolean>;
            /**
             * Internal implementation detail.
             */
            _msPortalFxOldControl: boolean;
            /**
             * Abstract base class. Do not use this class directly.
             *
             * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
             * @param label Optional. Text for the label for this form field.
             * @param infoBalloonContent Optional. A list of validations to be applied to the field.
             */
            constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: LabelAndBalloon.Options);
        }
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Nullable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Nullable {
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Whether the field is empty.
         */
        empty: KnockoutComputed<boolean>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the NullableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the NullableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Editable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Options.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Options {
    interface Options<T> extends Input.Options<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options?: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * A list of options the use can select the field value from.
         */
        options: KnockoutObservableArray<MsPortalFx.ViewModels.Forms.IDisablableOption<T>>;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the OptionsField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the OptionsField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\SectionBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base {
    interface Section {
        /**
         * Indicates if the sections or controls within the widget are currently valid.
         */
        valid: KnockoutObservableBase<boolean>;
        /**
         * Whether the form element is dirty.
         */
        dirty: KnockoutObservableBase<boolean>;
        /**
         * Clears validations on the control.
         */
        clearValidation(): Promise<any>;
        /**
         * Triggers validations on the control.
         */
        triggerValidation(): Promise<boolean>;
        /**
         * Enum that defines the type of the control.
         */
        readonly controlType: MsPortalFx.ViewModels.ControlType;
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\SliderBase.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Slider {
    interface Options<T> extends Input.Options<T> {
        /**
         * Minimum value of the slider.
         */
        min?: number | KnockoutObservableBase<number>;
        /**
         * Maximum value of the slider.
         */
        max?: number | KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step?: number | KnockoutObservableBase<number>;
        /**
         * Displays a marker for each step.
         */
        showStepMarkers?: boolean | KnockoutObservableBase<boolean>;
        /**
         * Optional text for screen reader, name for this slider.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    class ViewModel<T> extends Input.ViewModel<T> {
        /**
         * Minimum value for the field.
         */
        min: KnockoutObservableBase<number>;
        /**
         * Maximum value for the field.
         */
        max: KnockoutObservableBase<number>;
        /**
         * Determines the size or amount of each interval or step the slider takes between min and max.
         */
        step: KnockoutObservableBase<number>;
        /**
         * Whether to show step markers on the slider field.
         */
        showStepMarkers: KnockoutObservableBase<boolean>;
        /**
         * Text for screen reader, name for this slider.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs an instance of a slider form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the SliderBaseField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the SliderBaseField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\Base\Typable.d.ts
declare module MsPortalFx.ViewModels.Forms.Base.Typable {
    interface Options<T> extends Editable.Options<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout?: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger?: any;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed?: (value: T) => void;
    }
    class ViewModel<T> extends Editable.ViewModel<T> {
        /**
         * When value update trigger is set to fire on every keypress this is the timeout between value updates before validation runs.
         * Specify the timeout in milliseconds.
         */
        delayValidationTimeout: KnockoutObservable<number>;
        /**
         *  Trigger value update notifications based on enum option.
         *  By default, value will be updated on blur. This can be changed to receive continous updates on each key stroke.
         */
        valueUpdateTrigger: any;
        /**
         * Event is triggered when user presses the enter key.
         */
        onEnterPressed: (value: T) => void;
        /**
         * Abstract base class. Do not use this class directly.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the EditableField is contained.
         * @param pathOrAccessor The path to the value on the EditScope to be bound to this field, or the accessor to the edit scope property.
         * @param options Optional The set of options to configure the EditableField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<T>, pathOrAccessor: any, options?: Typable.Options<T>);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CheckBox.d.ts
declare module MsPortalFx.ViewModels.Forms.CheckBox {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.CheckBox.Options. Use Fx/Controls/CheckBox instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    interface Options extends Base.Input.Options<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel?: boolean;
        /**
         * Aria label for the CheckBox.
         */
        ariaLabel?: string | KnockoutObservableBase<string>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.CheckBox.ViewModel. Use Fx/Controls/CheckBox instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    class ViewModel extends Base.Input.ViewModel<boolean> {
        /**
         * Display the label inline with the checkbox.
         */
        inlineLabel: boolean;
        /**
         * Aria label for CheckBox.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Constructs a standalone instance of a CheckBox form field.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param observablePath The path to the value on the EditScope to be bound to this field.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, observablePath: string, options?: CheckBox.Options);
        /**
         * Constructs an instance of a CheckBox form field integrated with EditScope.
         *
         * @param lifetimeManager A LifetimeManager object that will notify when the data is no longer being used by the caller.
         * @param form The form element within which the CheckBoxField is contained.
         * @param accessor Used to read and write values to the edit scope.  Use Form.createEditScopeAccessor methods to create this object.
         * @param options Optional The set of options to configure the CheckBoxField control.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, form: Form.ViewModel<any>, accessor: MsPortalFx.ViewModels.Forms.EditScopeAccessors<boolean>, options?: CheckBox.Options);
    }
}

// FILE: MsPortalFx\ViewModels\Forms\CreatorAndSelectorV2.d.ts
declare module MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2 {
    /**
     * MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2.Mode is obsolete.
     * CreatorAndSelectorV2 is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const Mode: Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2.CreatorAndSelectorValue is obsolete.
     * CreatorAndSelectorV2 is no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type CreatorAndSelectorValue = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2.Options is obsolete.
     * Please migrate to Fx/Controls/PasswordBox.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.CreatorAndSelectorV2.ViewModel is obsolete.
     * Please migrate to Fx/Controls/PasswordBox.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\CustomHtml.d.ts
declare module MsPortalFx.ViewModels.Forms.CustomHtml {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.CustomHtml.Viewmodel is obsolete. Please use Fx/Controls/CustomHtml instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * CustomHtml form element view model.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DatePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DatePicker {
    /**
     * MsPortalFx.ViewModels.Forms.DatePicker.Options is obsolete.
     * Please use Fx/Controls/DatePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.DatePicker.ViewModel is obsolete.
     * Please use the Fx/Controls/DatePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DateTimePicker.d.ts
declare module MsPortalFx.ViewModels.Forms.DateTimePicker {
    /**
     * MsPortalFx.ViewModels.Forms.DateTimePicker.Options is obsolete.
     * Please use the Fx/Controls/DateTimePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.DateTimePicker.ViewModel is obsolete.
     * Please use the Fx/Controls/DateTimePicker instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\DropDown.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.DropDown {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.DropDown.Options is obsolete. Use Fx/Controls/DropDown instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.DropDown.ViewModel is obsolete. Use Fx/Controls/DropDown instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\FilterComboBox.d.ts
declare module MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox {
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type FilterComboViewModel = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type HierarchicalFormOption = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Column = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type FilterOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DatasetType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type AlgorithmType = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type SearchFilterContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const HierarchicalFormOptionItem: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const Node: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const SearchFilter: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const TreeSearchFilter: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const SearchFilterPrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const TreeSearchFilterPrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const FilterFactory: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const PrefixTree: any;
    /**
     * MsPortalFx.ViewModels.Obsolete.Forms.FilterComboBox control is no longer supported. Use Fx/Controls/ComboBox instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: any;
}

// FILE: MsPortalFx\ViewModels\Forms\MultiLineTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.MultiLineTextBox {
    /**
     * MsPortalFx.ViewModels.Forms.MultiLineTextBox.Options is obsolete.
     * Please use Fx/Controls/MultiLineTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.MultiLineTextBox.ViewModel is obsolete.
     * Please use Fx/Controls/MultiLineTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\NumericTextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.NumericTextBox {
    /**
     * MsPortalFx.ViewModels.Forms.NumericTextBox.Options is obsolete.
     * Please use Fx/Controls/NumericTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.NumericTextBox.ViewModel is obsolete.
     * Please use Fx/Controls/NumericTextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\OAuthButton.d.ts
declare module MsPortalFx.ViewModels.Forms.OAuthButton {
    /**
     * MsPortalFx.ViewModels.Forms.OAuthButton is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/OAuthButton.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.OAuthButton is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/OAuthButton.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\OptionsGroup.d.ts
declare module MsPortalFx.ViewModels.Forms.OptionsGroup {
    /**
     * MsPortalFx.ViewModels.Forms.OptionsGroup.Options is obsolete. Use Fx/Controls/OptionsGroup instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.OptionsGroup.ViewModel is obsolete. Use Fx/Controls/OptionsGroup instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\PasswordBox.d.ts
declare module MsPortalFx.ViewModels.Forms.PasswordBox {
    /**
     * MsPortalFx.ViewModels.Forms.PasswordBox is obsolete.
     * Please migrate to Fx/Controls/PasswordBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.PasswordBox is obsolete.
     * Please migrate to Fx/Controls/PasswordBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\Section.d.ts
declare module MsPortalFx.ViewModels.Forms.Section {
    /**
     * MsPortalFx.ViewModels.Forms.Section.Options is obsolete. Please use the Fx/Controls/Section.Options instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.SectionStyle is obsolete. Please use the Fx/Controls/Section instead, which no longer supports SectionStyle.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const SectionStyle: Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.TabStyle is obsolete. Please use the Fx/Controls/Section instead, which no longer supports TabStyle.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const TabStyle: Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.SubmitEvent is obsolete. Please use the Fx/Controls/Section instead, which no longer supports SubmitEvent.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type SubmitEvent = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.SubmitEventResult is obsolete. Please use the Fx/Controls/Section instead, which no longer supports SubmitEventResult.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type SubmitEventResult = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.PopulateSection is obsolete. Please use the Fx/Controls/Section instead, which no longer supports PopulateSection.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type PopulateSection = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Section.ViewModel is obsolete. Please use the Fx/Controls/Section instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\Selector.d.ts
declare module MsPortalFx.ViewModels.Forms.Selector {
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Selector.OptionsBase is obsolete and no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type OptionsBase = Obsolete;
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Selector.Options is obsolete and no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Selector.ClicableOptions is obsolete and no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type ClickableOptions = Obsolete;
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Selector.ViewModelBase is obsolete and no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModelBase: Obsolete;
    /**
     * @deprecated MsPortalFx.ViewModels.Forms.Selector.ViewModel is obsolete and no longer a supported navigation/layout model. Please redesign the blades for better full screen blade experiences.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\Slider.d.ts
declare module MsPortalFx.ViewModels.Forms.Slider {
    /**
     * MsPortalFx.ViewModels.Forms.Slider.Options is obsolete.
     * Please use the Fx/Controls/Slider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.Slider.ViewModel is obsolete.
     * Please use the Fx/Controls/Slider instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\StaticSection.d.ts
declare module MsPortalFx.ViewModels.Forms.StaticSection {
    /**
     * MsPortalFx.ViewModels.Forms.StaticSection.ViewModel is obsolete. Please use the Fx/Controls/Section instead.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\TextBox.d.ts
declare module MsPortalFx.ViewModels.Forms.TextBox {
    /**
     * MsPortalFx.ViewModels.Forms.TextBox.Options is obsolete.
     * Please use Fx/Controls/TextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.TextBox.ViewModel is obsolete.
     * Please use Fx/Controls/TextBox.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Forms\ViewModels.AsyncFileUpload.d.ts
declare module MsPortalFx.ViewModels.Forms.AsyncFileUpload {
    import FxFileUpload = MsPortalFx.ViewModels.FileUpload;
    import UploadAction = FxFileUpload.UploadAction;
    function execUpload(callback: FxFileUpload.UploadActionCallback, selectedFiles: FxFileUpload.SelectedFile[], action: UploadAction): Promise<any>;
    /**
     * MsPortalFx.ViewModels.Forms.AsyncFileUpload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Options = Obsolete;
    /**
     * MsPortalFx.ViewModels.Forms.AsyncFileUpload is obsolete.
     * Please migrate to the AMD creation pattern using Fx/Controls/FileUpload.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Model.ReactModel.d.ts
declare module MsPortalFx.Models {
    interface Action<T = any> {
        type: T;
    }
    interface AnyAction extends Action {
        [extraProps: string]: any;
    }
    /**
     * A store is an object that holds the application's state tree.
     * There should only be a single store in a Redux app, as the composition
     * happens on the reducer level.
     *
     * @template S The type of state held by this store.
     * @template A the type of actions which may be dispatched by this store.
     */
    interface AsyncStore<S = any, A extends Action = AnyAction> {
        /**
         * Dispatches an action. It is the only way to trigger a state change.
         *
         * The `reducer` function, used to create the store, will be called with the
         * current state tree and the given `action`. Its return value will be
         * considered the **next** state of the tree, and the change listeners will
         * be notified.
         *
         * The base implementation only supports plain object actions. If you want
         * to dispatch a Promise, an Observable, a thunk, or something else, you
         * need to wrap your store creating function into the corresponding
         * middleware. For example, see the documentation for the `redux-thunk`
         * package. Even the middleware will eventually dispatch plain object
         * actions using this method.
         *
         * @param action A plain object representing “what changed”. It is a good
         *   idea to keep actions serializable so you can record and replay user
         *   sessions, or use the time travelling `redux-devtools`. An action must
         *   have a `type` property which may not be `undefined`. It is a good idea
         *   to use string constants for action types.
         * @returns For convenience, the same action object you dispatched.
         *
         * Note that, if you use a custom middleware, it may wrap `dispatch()` to
         * return something else (for example, a Promise you can await).
         */
        dispatch(action: A): A;
        /**
         * Reads the state tree managed by the store.
         *
         * @returns The current state tree of your application.
         */
        getState(): S;
        /**
         * Adds a change listener. It will be called any time an action is
         * dispatched, and some part of the state tree may potentially have changed.
         * You may then call `getState()` to read the current state tree inside the
         * callback.
         *
         * You may call `dispatch()` from a change listener, with the following
         * caveats:
         *
         * 1. The subscriptions are snapshotted just before every `dispatch()` call.
         * If you subscribe or unsubscribe while the listeners are being invoked,
         * this will not have any effect on the `dispatch()` that is currently in
         * progress. However, the next `dispatch()` call, whether nested or not,
         * will use a more recent snapshot of the subscription list.
         *
         * 2. The listener should not expect to see all states changes, as the state
         * might have been updated multiple times during a nested `dispatch()` before
         * the listener is called. It is, however, guaranteed that all subscribers
         * registered before the `dispatch()` started will be called with the latest
         * state by the time it exits.
         *
         * @param listener A callback to be invoked on every dispatch.
         * @param selector A function that takes in state and returns a single property of the state you are interested in,
         * the callback will only be called if the references of the selector have changed.
         * @returns A function to remove this change listener.
         */
        subscribe(listener: () => void): () => void;
    }
    interface Options<S = {}, A extends Action = AnyAction, FunctionMap extends Common.ValidatedFunctionMap<FunctionMap> = {}> {
        lifetime: MsPortalFx.Base.LifetimeManager;
        asyncStore: Promise<AsyncStore<S, A>>;
        functionProxy: Common.FunctionProxy<FunctionMap>;
        getExperimentation: () => Promise<import("Fx/Experimentation").Experimentation>;
        viewParameters: ReadonlyStringMap<any>;
        diContainer: import("Fx/DependencyInjection").Container;
    }
    /**
     * A model class that is linked to the equivelant ReactView view.
     */
    class React<S = {}, A extends Action = AnyAction, FunctionMap extends Common.ValidatedFunctionMap<FunctionMap> = {}> {
        lifetime: MsPortalFx.Base.LifetimeManager;
        asyncStore: Promise<AsyncStore<S, A>>;
        functionProxy: Common.FunctionProxy<FunctionMap>;
        constructor(reactModelArguments: Options<S, A, FunctionMap>);
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\Internal\ProvisioningTelemetry.d.ts
declare module FxImpl.ProvisioningTelemetry {
    import FxBase = MsPortalFx.Base;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    import TelemetryEvent = Telemetry.TelemetryEvent;
    const ActionModifier: {
        Failed: string;
        Succeeded: string;
    };
    const ProvisioningStatus: {
        NoPromise: string;
        Resolved: string;
        UnknownFailure: string;
    };
    /**
     * Sets up the Shell-side counterpart to the Provisioner telemetry submitter.
     */
    function registerTelemetrySubmissionHandler(): void;
    /**
     * Traces create deployment start/end/preflight events.
     */
    function traceDeployment(entry: TelemetryEvent): void;
    /**
     * Traces provisioning started event.
     */
    function traceProvisioningStarted(event?: TelemetryEvent): TelemetryEvent;
    /**
     * Traces provisioning ended event.
     */
    function traceProvisioningEnded(event: TelemetryEvent): TelemetryEvent;
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\Internals.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import FxBase = MsPortalFx.Base;
    /**
     * The model for the "collector" parameter collection binding.
     */
    class CollectorBindingInternals {
        /**
         * The inputs from the collector to the provider.
         */
        inputs: KnockoutObservable<ParameterCollectionInput>;
        /**
         * The errors passed down from the colletor to the provider.
         */
        errors: KnockoutObservable<ParameterCollectionError[]>;
    }
    /**
     * The model for the "provider" parameter collection binding.
     */
    class ProviderBindingInternals {
        /**
         * The outputs of the provider to the collector.
         */
        outputs: KnockoutObservable<ParameterCollectionOutput>;
        /**
         * A Guid that when changes, triggers the process of commiting the changes in the provider
         * and sending them to the collector.
         */
        commit: KnockoutObservable<string>;
    }
    /**
     * The contract for the parameter collection "collector" binding.
     */
    interface ParameterCollectorBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: CollectorBindingInternals;
    }
    /**
     * The contract for the parameter collection "provider" binding.
     */
    interface ParameterProviderBinding {
        /**
         * Private internal data. Do not use.
         */
        privateFpTcBI: ProviderBindingInternals;
    }
    interface IProvisioner {
        /**
         * The mapped outputs generated by processing the outputs using the mapOutputsForProvisioning function.
         */
        mappedOutputs: ParameterCollectionOutput;
        /**
         * Executes the provisioning command.
         *
         * @param data The parameter collection outputs from the create flow that will be used in the provisioning process.
         * @param options The options used for the provisioning process.
         * @returns A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): Promise<any>;
    }
    /**
     * The provisioner, an entity responsible for executing a provisioning command at the end of a
     * parameter collection process.
     */
    class Provisioner implements FxBase.Disposable {
        /**
         * The deployment response on starting provisioning.
         */
        deploymentResponse: any;
        private _provisioningEntity;
        private _data;
        private _options;
        private _executionDeferred;
        private readonly _lifetimeManager;
        private _mappedOutputs;
        /**
         * Constructs the provisioner.
         *
         * @param provisioningEntity The provisioning entity.
         */
        constructor(provisioningEntity: ProvisioningEntity);
        get mappedOutputs(): ParameterCollectionOutput;
        executeProvisioning(data: ParameterCollectionOutput, options: StringMap<any>): Promise<any>;
        dispose(): void;
        private _beginExecution;
        private _executeProvisioning;
        private _createEventBase;
        private _traceProvisioningStarted;
        private _traceProvisioningEnded;
    }
    /**
     * Provisioning command status.
     */
    enum ProvisioningCommandStatus {
        /**
         * Command has not being executed yet.
         */
        Idle = 0,
        /**
         * Command is in the process of executing.
         */
        InProgress = 1,
        /**
         * Command has been executed and succeeded.
         */
        Succeeded = 2,
        /**
         * Command has been executed and failed.
         */
        Failed = 3
    }
    /**
     * A class that represents a provisioning command.
     */
    interface ProvisioningCommand {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservable<ProvisioningCommandStatus>;
        /**
         * Executes the provisioning command.
         *
         * @param options The options needed to configure/execute the command.
         * @returns A Promise object indicating whether the provisioning command has succeeded or not.
         */
        execute(options: StringMap<any>): Promise<any>;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    interface ProvisioningEntity {
        /**
         * Indicates whether the entity will perform a provisioning command or not.
         * Set this true to enable the provisioning logic.
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        provisionOnStartboardPart?: KnockoutObservable<boolean>;
        /**
         * Private internal data. Do not use.
         */
        privatePcPrBI: ProvisioningEntityBindingInternals;
        /**
         * Executes the provisioning command. Override this method for custom provisioning.
         *
         * @param data The parameter collection outputs from the create flow that will be used in
         *      the provisioning process.
         * @returns A Promise object signaling the completion of the provisioning process.
         */
        executeProvisioning?(data: ParameterCollectionOutput): Promise<any>;
        /**
         * Maps the outputs of the parameter collection flow to what the provisioning command expects.
         * Override this method to implement custom mapping.
         *
         * @param originalOutputs The original outputs of the parameter collection flow.
         * @returns The mapped outputs, to what the provisioning command expects.
         */
        mapOutputsForProvisioning?(originalOutputs: ParameterCollectionOutput): ParameterCollectionOutput;
    }
    /**
     * The contract for a parameter collection entity that also does provisioning.
     */
    class ProvisioningEntityBindingInternals {
        /**
         * Signals fetching the provisioning command from Shell.
         */
        triggerProvisioningCommand: KnockoutObservable<string>;
        /**
         * The name of the extension that contains the provisioning part.
         */
        provisioningPartExtensionName: KnockoutObservable<string>;
        /**
         * The name of the provisioning part in which to do provisioning.
         */
        provisioningPartName: KnockoutObservable<string>;
        /**
         * Signals the start of provisioning on a startboard part using the specified model.
         * If the startboard part is not already present, it is added.
         */
        triggerProvisioningInStartboardPart: KnockoutObservable<any>;
        /**
         * True if provisioning should be done using a provisioning part; else false.
         */
        masterIsProvisioningPart: KnockoutObservable<boolean>;
        /**
         * Force discards the journey when provisioning starts.
         */
        forceDiscardJourney: KnockoutObservable<boolean>;
        /**
         * The fetched provisioning command.
         */
        provisioningCommand: KnockoutObservable<ProvisioningCommand>;
        /**
         * Signal to the shell that an attempt was made to start provisioning.
         */
        provisioningAttempted: KnockoutObservable<any>;
        /**
         * Signal to the shell that provisioning has started. This means that the attempt to start provisioning was
         * successfully and acknowledged by the service.
         */
        provisioningStarted: KnockoutObservable<any>;
        /**
         * Signal to the provisioner that provisioning has completed.
         */
        provisioningCompleted: KnockoutObservable<any>;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ParameterCollectionData.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The model for the parameter collection inputs.
     */
    class ParameterCollectionInput {
        /**
         * The input parameters (key-value pairs).
         */
        inputParameters: StringMap<StringMap<string>>;
        /**
         * The input parameters metadata (key-value pairs). The key is the parameter name.
         */
        inputMetadata: StringMap<StringMap<ParameterMetadata>>;
        /**
         * The options needed to configure the behavior of the provider.
         */
        options: StringMap<any>;
    }
    /**
     * The model for the parameter collection outputs.
     */
    class ParameterCollectionOutput {
        /**
         * The output parameters (key-value pairs).
         */
        outputParameters: StringMap<StringMap<string>>;
    }
    /**
     * The model for a parameter collection metadata object. Useful for generated flows.
     */
    interface ParameterMetadata {
        /**
         * The display name for the parameter.
         */
        displayName: string;
        /**
         * The default value for the parameter.
         */
        defaultValue?: any;
        /**
         * The description for the parameter.
         */
        description?: string;
        /**
         * The text for the tool-tip.
         */
        toolTip?: string;
        /**
         * The UI hint used to find and render a suitable control that will capture the value for
         * the parameter (e.g. password, email, url, date, etc.). Used in generated UIs only, and
         * limited to types supported by controls that already exist in MsPortalFx.
         */
        uiHint?: string;
        /**
         * Constraints for rendering and validating the parameter.
         */
        constraints?: ParameterMetadataConstraints;
    }
    /**
     * The model for a parameter collection metadata constraints.
     */
    interface ParameterMetadataConstraints {
        /**
         * A flag indicating whether this parameter is required or not. Defaults to true.
         */
        required?: boolean;
        /**
         * A flag indicating whether this parameter is hidden or not. Defaults to false.
         */
        hidden?: boolean;
        /**
         * A list of possible values for the parameter (key-value pairs). Could be used for
         * validation and/or populating a list or a drop-down.
         */
        allowedValues?: {
            text: string;
            value: any;
        }[];
        /**
         * The range defining the parameter value.
         */
        range?: {
            lowerBind: number;
            upperBound: number;
        };
        /**
         * The length of the parameter value.
         */
        length?: {
            min: number;
            max: number;
        };
        /**
         * The characters the parameter value must contain.
         */
        containsCharacters?: string;
        /**
         * The characters the parameter value must not contain.
         */
        notContainsCharacters?: string;
        /**
         * Whether the parameter value has at least one digit or not.
         */
        hasDigit?: boolean;
        /**
         * Whether the parameter value has at least one letter or not.
         */
        hasLetter?: boolean;
        /**
         * Whether the parameter value has at least one upper-case letter or not.
         */
        hasUpperCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one lower-case letter or not.
         */
        hasLowerCaseLetter?: boolean;
        /**
         * Whether the parameter value has at least one special character or not.
         */
        hasPunctuation?: boolean;
        /**
         * Whether the parameter value is a number or not.
         */
        numeric?: boolean;
        /**
         * A custom list of constraints (key-value pairs). Useful for custom generated UI.
         */
        custom?: {
            key: string;
            value: string;
        }[];
    }
    /**
     * The model defining a parameter collection error object.
     */
    interface ParameterCollectionError {
        /**
         * The error message.
         */
        errorMessage: string;
        /**
         * The name of the associated parameter, if any.
         */
        parameterName?: string;
    }
    /**
     * A helper class with model transformation methods.
     */
    class Models {
        /**
         * Transforms an editable model object to a list of parameter-sets.
         *
         * @param model The editable model object.
         * @returns The list if parameter-sets.
         */
        static modelToParameters<T extends {}>(model: T): StringMap<StringMap<string>>;
        /**
         * Transforms a list of parameter-sets to an editable model object.
         *
         * @param data The list if parameter-sets.
         * @returns The editable model object.
         */
        static parametersToModel<T extends {}>(data: StringMap<StringMap<string>>): T;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ParameterCollector.d.ts
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * The contract for the parameter collection "collector" role.
     * Enables the implementer to collect parameters from parameter provider(s).
     */
    interface ParameterCollector {
        /**
         * Gets the inputs that will be sent to a given provider when launched.
         *
         * @param providerId The id of the provider.
         * @returns The inputs for the provider.
         */
        getProviderInputs(providerId: string): ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the committing provider.
         * @param outputs The outputs from the provider.
         * @returns A JQuery promise (boolean) indicating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: ParameterCollectionOutput): Promise<boolean>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<ParameterCollectionError[]>;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection.Internal {
    import FxViewModels = MsPortalFx.ViewModels;
    import ParameterCollection = MsPortalFx.ViewModels.ParameterCollection;
    import ParameterCollectionOutput = ParameterCollection.ParameterCollectionOutput;
    /**
     * Class implementing collector-specific functionality.
     */
    class CollectorBase {
        private _provisioner;
        private _previousOutputs;
        private _previousCommit;
        private _previousDetailBladeOutput;
        /**
         * Creates the collector internal instance.
         *
         * @param provisioner The provisioner to use to execute provisioning.
         */
        constructor(provisioner: IProvisioner);
        /**
         * Executed when the provider binding internals have been received.
         *
         * @param providerBindingInternals The provider binding internals.
         * @param options The options for provisioning.
         * @param detailBladeOutput The actionbar output from the detail blade.
         * @param onProviderCommit The onProviderCommit callback to execute when provider commit conditions have been met.
         * @param onCommitSuccessAction The callback to execute if committed successfully.
         * @param onCommitFailedAction The callback to execute if commit failed.
         */
        onProviderBindingInternalsReceived(providerBindingInternals: ProviderBindingInternals, options: StringMap<any>, detailBladeOutput: FxViewModels.ActionBars.Base.ActionBarOutput, onProviderCommit: (selectorId: string, outputs: ParameterCollectionOutput) => Promise<boolean>, onCommitSuccessAction: () => void, onCommitFailedAction: () => void): void;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollection\ViewModels.BaseGalleryButtonPart.d.ts
declare module FxImpl.ViewModels.ParameterCollection {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * The contract for the view model for a parameter collection button part.
     */
    interface BaseGalleryButtonPartContract {
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<any>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<any>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<any>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<any>;
        /**
         * A value used to determine when to call executeCommand.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
    }
    /**
     * The base class for a parameter collection button part (provider only).
     *
     * IMPORTANT: An instance of this class can be used to kick off the create flow (following the
     * Samples Extension). However, once the gallery hub is available, it will invoke the create flows
     * directly with the correct parameters (from the Gallery service) and replace this button.
     */
    class BaseGalleryButtonPartViewModel extends FxViewModels.ButtonPart implements FxBase.Disposable, BaseGalleryButtonPartContract, MsPortalFx.ViewModels.ParameterCollection.ParameterCollector, ParameterCollectionInternal.ParameterCollectorBinding {
        /**
         * The edit scope id.
         */
        editScopeId: KnockoutObservable<string>;
        /**
         * Errors to send to the provider.
         */
        parameterCollectionErrors: KnockoutObservable<MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionError[]>;
        /**
         * Private internal data. Do not use.
         */
        privateFcTpBI: ParameterCollectionInternal.CollectorBindingInternals;
        /**
         * The previously saved state of the wizard.
         */
        savedState: KnockoutObservable<any>;
        /**
         * The current state of the wizard to be saved.
         */
        currentState: KnockoutObservable<any>;
        /**
         * The input data for the current step.
         */
        stepInput: KnockoutObservable<any>;
        /**
         * Output of the current step propagated from it's details blade.
         */
        stepOutput: KnockoutObservable<any>;
        /**
         * A value indicating whether or not to start the command.
         */
        beginExecuteCommand: KnockoutObservable<boolean>;
        _commit: KnockoutObservable<string>;
        private _baseButtonContainer;
        private _baseProviderCommit;
        private _initialLoadComplete;
        protected readonly _ltm: MsPortalFx.Base.DisposableLifetimeManager;
        /**
         * Constructs the view model.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState: any, allowToggleProvisioningLocation?: boolean, isProvisioningPart?: boolean);
        /**
         * Invoked when the Part's inputs change.
         */
        onInputsSet(inputs: any): Promise<any>;
        /**
         * Gets the inputs for a given provider.
         *
         * @param providerId The id of the provider.
         * @returns The inputs for the provider.
         */
        getProviderInputs(providerId: string): MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionInput;
        /**
         * Reacts when a provider commits its output parameters.
         *
         * @param providerId The id of the provider.
         * @param outputs The outputs from the provider.
         * @returns A JQuery promise (boolean) dictating whether to allow or deny the commit action.
         */
        onProviderCommit(providerId: string, outputs: MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionOutput): Promise<boolean>;
        dispose(): void;
        _processStepOutput(stepOutput: any): void;
    }
}
declare module MsPortalFx.ViewModels.ParameterCollection {
    /**
     * @deprecated ParameterCollection.BaseGalleryButtonPartContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    type BaseGalleryButtonPartContract = FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartContract;
    /**
     * @deprecated ParameterCollection.BaseGalleryButtonPartViewModel. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    const BaseGalleryButtonPartViewModel: typeof FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartViewModel;
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollection.Common.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * A message passed from collector to provider when the provider is opened.
     */
    interface ParameterProviderOpenMessage {
        /**
         * Initial data for the provider.
         */
        initialData: any;
        /**
         * Additional configuration for the provider.
         */
        providerConfig: any;
    }
    /**
     * A message passed from provider to collector when a result is available.
     */
    interface ParameterProviderResultMessage {
        /**
         * The result supplied by the parameter provider.
         */
        resultData: any;
    }
    /**
     * A subscriber to the results committed by the provider back to the collector.
     */
    interface ProviderResultSubscriber<TResult> {
        /**
         * A callback on the subscriber to receive the results.
         */
        receiveResult: (result: TResult) => void;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterCollector.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Options for constructing a parameter collector.
     */
    interface ParameterCollectorOptions<TResult> {
        /**
         * The selectable associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * If not specified, this defaults to container.selectable (so it
         * works with selectable parts without configuration).
         *
         * This option is mutually exclusive with 'selectableSet'.
         */
        selectable?: SelectableContract<any>;
        /**
         * The selectable set associated with the same <BladeAction> as this
         * parameter collector. The parameter collector will supply initial
         * data to the child blade when this becomes selected.
         *
         * This option is mutually exclusive with 'selectable'.
         */
        selectableSet?: SelectableSet<any, any>;
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @returns Initial data for the child blade.
         */
        supplyInitialData?(activatedItem: any): TResult;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @returns Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(activatedItem: any): any;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult?(result: TResult, activatedItem: any): void;
        /**
         * Provides an easy way to integrate a parameter collector with an EditScope.
         *
         * The collector will supply initial data to the provider from this edit scope
         * property, and will automatically insert the provider's output into this edit
         * scope property. The net result is that your parameter collector will act as
         * an editor for the specified edit scope property.
         *
         * If you specify this option, do not also specify either supplyInitialData or
         * receiveResult.
         */
        formFieldValueAccessor?: Forms.EditScopeAccessors<TResult>;
        /**
         * For internal use only
         */
        fxInternalFI?: boolean;
    }
    /**
     * A parameter collector opens a child blade, supplies initial data to it, and may later
     * receive back completed data.
     */
    class ParameterCollector<TResult> {
        private bladeCaller;
        /**
         * Constructs an instance of ParameterCollector.
         *
         * @param inputsCallbackRegistrar The container to register with for callbacks
         * @param options Options for the instance.
         */
        constructor(inputsCallbackRegistrar: InputsCallbacksRegistrar, options: ParameterCollectorOptions<TResult>);
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.ParameterProvider.d.ts
declare module MsPortalFx.ViewModels {
    import FxData = MsPortalFx.Data;
    import ActionBarOutput = MsPortalFx.ViewModels.ActionBars.Base.ActionBarOutput;
    /**
     * The default parameter provider commit arguments with the action bar output.
     */
    interface ParameterProviderActionBarCommitArgs {
        /**
         * The action bar output.
         */
        actionBarOutput: ActionBarOutput;
    }
    /**
     * Options for constructing a parameter provider.
     */
    interface ParameterProviderOptions<TResult, TEditScope> {
        /**
         * A callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @returns The desired initial edit scope data.
         */
        mapIncomingDataForEditScope?(dataFromCollector: TResult): TEditScope;
        /**
         * An asynchronous callback that supplies the initial data for the provider's edit scope.
         * This callback is mandatory, and must account for the possibility of the
         * collector supplying incomplete information (or none at all) by returning
         * the complete initial state for the edit scope.
         *
         * @param dataFromCollector The incoming initial data from the parameter collector, or null if the collector did not supply any.
         * @returns The desired initial edit scope data.
         */
        mapIncomingDataForEditScopeAsync?(dataFromCollector: TResult): Promise<TEditScope>;
        /**
         * The metadata type corresponding to the TResult generic parameter. This is
         * used to configure the edit scope.
         */
        editScopeMetadataType?: string;
        /**
         * A mapping function that converts outgoing data from the provider's edit scope
         * into the format you wish to return to the collector.
         *
         * Note that the object received by the parameter collector will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed in a serialized form.
         *
         * @param editScopeData The data currently held by the parameter provider.
         * @param commitArgs The optional commit arguments.
         * @returns The data that should be returned to the calling parameter collector.
         */
        mapOutgoingDataForCollector(editScopeData: TEditScope, commitArgs?: any): TResult;
        /**
         * A callback invoked when the user dismisses the provider. If you need to begin a
         * provisioning operation that adds a startboard part and collapses the current
         * journey, you can do so in this callback. You should not commence any other
         * server-side operation from this callback, because the blade will have closed
         * before it completes, so the user would not be able to see the result.
         *
         * @param editScopeData The data stored in the provider's edit scope.
         */
        commitResult?(editScopeData: TEditScope): void;
    }
    /**
     * A parameter provider receives parameters from its parent blade, then later, when the user clicks
     * on an action bar, supplies a result object to the parent blade and closes.
     */
    class ParameterProvider<TResult, TEditScope> {
        private bladeCallable;
        protected defaultActionBarInput: KnockoutObservable<any>;
        private _options;
        private _configFromCollector;
        private _hasSentResult;
        private _editScopeId;
        private _editScopeCache;
        private _editScopeView;
        private _getResultSubscribers;
        /**
         * Constructs an instance of ParameterProvider.
         *
         * @param container The container associated with the part or other composition item hosting this parameter provider.
         * @param options Options for the instance.
         */
        constructor(container: ContainerContract, options: ParameterProviderOptions<TResult, TEditScope>);
        /**
         * The edit scope holding the data being edited in this provider blade.
         */
        get editScope(): KnockoutObservable<FxData.EditScope<TEditScope>>;
        /**
         * The arbitrary configuration object supplied by the collector, if any.
         */
        get configFromCollector(): KnockoutObservable<any>;
        protected getResultsBeforeCommit(subscriber: Internal.ProviderResultSubscriber<TResult>): void;
        protected getResults(): TResult;
        private _prepareEditScopeWithInitialData;
        private _setUpActionBarWatcher;
        private _discardEditScopeAndSendResult;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.PickerBase.d.ts
declare module MsPortalFx.ViewModels.ParameterCollectionV3.Pickers {
    import FxViewModels = MsPortalFx.ViewModels;
    import Grid = FxViewModels.Controls.Lists.Grid;
    /**
     * Picker base module
     */
    module PickerBase {
        /**
         * Options for the create new blade launched from the picker.
         *
         * Create new will be an entry at the top of the picker and will launch a blade.
         * This blade has to implement a Parameter Provider V3 and return data in the same type as the picker.
         */
        interface CreateNewOptions<TDataModel> {
            /**
             * The title to show for the create new entry.
             */
            title: string;
            /**
             * The blade to launch when the create new entry is selected.
             * This blade has to implement Parameter Provider V3 to receive inputs and send outputs.
             */
            dynamicBladeSelection: FxViewModels.DynamicBladeSelection;
            /**
             * Optional method to supply intial data to the provider in the create new blade.
             * If this method is implemented, the create new blade will get passed these inputs from the picker.
             */
            supplyInitialData?(): TDataModel;
            /**
             * Optional method to supply config to the provider in the create new blade.
             * By default, the create new blade will get the same inputs that the picker received but this can be
             * overridden by implementing this method.
             */
            supplyProviderConfig?(): any;
            /**
             * Optional method that receives results from the create new provider.
             * Once the create new blade closes, the results received are passed to this method if it is implemented.
             */
            receiveResults?(result: TDataModel): void;
        }
        /**
         * Options for the picker.
         */
        interface Options<TItem, TDataModel> {
            /**
             * The data navigator that returns the list of picker items. It has to be a sequential data navigator for now.
             * This is mutually exclusive with the observable list of items provided.
             */
            dataNavigator?: MsPortalFx.Data.DataNavigatorBase<TItem>;
            /**
             * The list of items shown in the picker.
             * This is mutually exclusive with the data navigator.
             */
            items?: KnockoutObservableArray<TItem>;
            /**
             * Callback to map incoming data to data model.
             *
             * @param data Incoming data that gets written to the edit scope.
             */
            mapIncomingDataToDataModel(data: any): TDataModel;
            /**
             * Callback to load picker items. This is called after the parameter collector is ready.
             *
             * @param pickerInputs List of inputs that the picker defines
             * @param dataModel The data model. If this is set and the picker is multiselect, the items in the data model must be returned in the first page.
             */
            loadPickerItems(pickerOptions: any, dataModel?: TDataModel): void;
            /**
             * Callback to map items to the data model. This is called with a list of selected items.
             *
             * @param items List of selected picker items
             */
            mapItemsToDataModel(items: TItem[]): TDataModel;
            /**
             * Callback to check if a picker item is in or equal the data model.
             *
             * @param item The picker item in the grid
             * @param dataModel The data model.
             */
            isItemInDataModel(pickerItem: TItem, dataModel: TDataModel): boolean;
            /**
             * The text to show for the create new entry.
             */
            createNewOptions?: CreateNewOptions<TDataModel>;
            /**
             * If set to true, allows multiple items to be selected in the picker. Defaults to false.
             * Note that when multi-select is set, the loadPickerItems should return all the pre-selected items in the first page.
             */
            allowMultiSelect?: boolean;
        }
        /**
         * Picker item interface
         */
        interface Item {
            /**
             * The title of the item displayed.
             */
            title: KnockoutObservable<string>;
            /**
             * The sub title of the item.
             */
            subtitle?: KnockoutObservable<string>;
            /**
             * Text next to sub title on the second row.
             */
            detail?: KnockoutObservable<string>;
            /**
             * The icon to display for this picker item.
             */
            icon?: KnockoutObservable<MsPortalFx.Base.Image>;
            /**
             * Flag indicating if the item is disabled.
             */
            disabled?: KnockoutObservableBase<boolean>;
            /**
             * The info balloon shown next to the item.
             */
            infoBalloon?: any;
            /**
             * The item associated with this picker item.
             */
            item: any;
        }
        /**
         * Inputs to picker. Picker implementations can extend this interface to add additional options.
         * But it is expected to contain the options supported by the base picker.
         */
        interface Config {
        }
    }
    /**
     * The base picker class.
     */
    class PickerBase<TItem, TDataModel> extends FxViewModels.Controls.Loadable.ViewModel {
        /**
         * The parameter provider defined in this this part.
         */
        parameterProvider: FxViewModels.ParameterProvider<any, {
            pickedItems: KnockoutObservable<TDataModel>;
        }>;
        /**
         * The parameter collector that gets data for new items.
         */
        addNewItemCollector: FxViewModels.ParameterCollector<TDataModel>;
        /**
         * Flag indicating if the picker allows create new.
         */
        showCreateAction: KnockoutObservable<boolean>;
        /**
         * Add new grid that launches a new blade
         */
        addNewGrid: Grid.ViewModel<any, any>;
        /**
         * The grid that lists the picker items.
         */
        pickerGrid: Grid.ViewModel<TItem, any>;
        /**
         * Option that shows or disables a select button.
         * This is controlled by the multiSelectEnabled flag from the collector and should not be changed by the deriving picker.
         */
        showSelectButton: KnockoutObservable<boolean>;
        /**
         * Used to automatically trigger the select button when single select is enabled.
         */
        triggerSelectAction: KnockoutObservable<string>;
        /**
         * Boolean indicating if an info box should be shown.
         */
        showInfoBox: KnockoutObservable<boolean>;
        /**
         * The info box view model.
         */
        infoBoxViewModel: any;
        private _basicTemplate;
        /**
         * Creates a new instance of the
         */
        constructor(container: PartContainerContract, initialState: any, options: PickerBase.Options<TItem, TDataModel>);
        /**
         * If the picker implementation supports create new and wants to programatically open the create new blade
         * based on certain inputs/config, it can call this method.
         */
        openCreateNewBlade(): void;
        /**
         * If the picker implementation supports create new and wants to programatically disable the create new option
         * based on certain inputs/config, it can call this method.
         */
        disableCreateNewOption(): void;
        private _saveToEditScope;
        /**
         * Create the picker grid.
         */
        private _buildPickerGrid;
        /**
         * Create an add new grid.
         */
        private _buildAddNewGrid;
        /**
         * Gets the data model from the edit scope.
         */
        private get dataModel();
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to select in the grid.
         */
        private _selectGridItem;
        /**
         * Selects the grid item based on given index.
         *
         * @param item Picker item to disable in the grid.
         */
        private _disableGridItem;
    }
}

// FILE: MsPortalFx\ViewModels\ParameterCollectionV3\ViewModels.Provisioner.d.ts
declare module FxImpl.ViewModels.ParameterCollectionV3 {
    import Rpc = FxImpl.Rpc;
    import ParameterCollection = FxImpl.ViewModels.Provisioning;
    interface ProvisioningInitiationId {
        provisionerId: string;
        provisioningRefKey: string;
    }
    interface ProvisioningRequest {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        provisioningPromise: Promise<any>;
        startboardInfo: any;
    }
    interface ProvisioningOperation {
        provisioningPromise: Promise<any>;
        data: any;
    }
    interface ProvisioningPartInitialData {
        provisioningConfig: ParameterCollection.Provisioner.Config;
        provisioningRefKey: string;
        startboardPart: MsPortalFx.ViewModels.ParameterCollectionV3.ExtensionElement;
    }
    let initiateProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningInitiationId>;
    let getProvisioningRequestEndPoint: Rpc.ProxiedObjectTypeDefinition<ProvisioningInitiationId, ProvisioningRequest>;
    let getProvisioningOperationEndPoint: Rpc.ProxiedObjectTypeDefinition<string, ProvisioningOperation>;
    function getProvisioningOperation(provisioningRefKey: string, rpcClient?: Rpc.Client): Promise<ProvisioningOperation>;
    /**
     * Interface for the internal provisioner endpoints.
     */
    interface Provisioner<TData> extends ParameterCollection.Provisioner<TData> {
        traceValidation: (eventType: ParameterCollection.ValidationEvent) => void;
    }
}
declare module FxImpl.ViewModels.Provisioning {
    import FxBase = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import Telemetry = FxBase.Diagnostics.Telemetry;
    type ValidationEvent = "FailedFormValidation" | "FailedArmValidation" | "PassedValidation" | "DeployWithoutValidate";
    /**
     * A class for provisioning resources
     */
    class Provisioner<TData> implements FxBase.Disposable {
        /**
         * The provisioner configuration that the collector passes to the provider part.
         */
        provisioningConfig: KnockoutObservable<Provisioner.Config>;
        /**
         * A promise representing the provisioning operation. The observable is updated with the result
         * of the 'supplyProvisioningPromise' callback.
         */
        provisioningPromise: KnockoutObservable<Promise<any>>;
        /**
         * A flag indicating whether provisioning is happening on the startboard or not.
         */
        provisionOnStartboard: KnockoutObservable<boolean>;
        /**
         * The tracking id of the deployment.
         */
        protected get _telemetryId(): string;
        /**
         * A flag indicating whether provisioning is custom or not custom (going through ARM).
         */
        protected _isCustomProvisioning: boolean;
        /**
         * The launching context.
         */
        protected readonly _launchingContext: MsPortalFx.Azure.ResourceManager.LaunchingContext;
        /**
         * The inputs for the post provisioning blade.
         */
        protected _postProvisioningInputsDeferred: Q.Deferred<Provisioner.PostProvisioningBladeInputs>;
        private static rpcClient;
        private static provisioningRequestsLookup;
        private static provisionersList;
        private static _rpcRegistered;
        protected _actionBar: any;
        protected _actionBarSupportsForceInProgressStatus: boolean;
        protected _actionBarSupportsIsProvisioningBlade: boolean;
        protected _actionBarSupportsProvisionOnStartboardPart: boolean;
        protected _actionBarSupportsSecondaryLinkDisplayText: boolean;
        protected _actionBarSupportsSecondaryLinkValidation: boolean;
        protected _actionBarSupportsShowActionBar: boolean;
        protected _validationEvents: Telemetry.TelemetryEvent[];
        private _options;
        private _provisionerId;
        /**
         * Constructs a new instance of a parameter collection provisioner.
         *
         * @param container The container into which the part containing the provisioner is being placed.
         * @param options The provisioner options.
         */
        constructor(container: FxViewModels.ContainerContract, options: Provisioner.Options<TData>);
        dispose(): void;
        /**
         * Manually start provisioning. This is usually used with collector view models. This must
         * not be used if the provisioner is configured with a provider and an action bar (automatically)
         * triggered). This method uses the 'supplyStartboardInfo' to define a startboard part if you
         * want provisioning to happen on the startboard, or return null or undefined if you want it
         * to run in the background.
         *
         * @param data The provisioning data that will be passed to the provisioning operation.
         * @returns A promise that represents the provisioning operation.
         */
        startProvisioning(data: TData): Promise<any>;
        /**
         * Trace a validation event.
         *
         * @param eventType event to trace
         */
        protected _traceValidation(eventType: ValidationEvent): void;
        protected receiveResult(result: TData): void;
        private _beginProvisioning;
        private _initiateProvisioningRequest;
        private static _registerRpcCallbacks;
        private getProvisioningRequest;
        protected _createEventBase(): Telemetry.TelemetryEvent;
        protected _traceProvisioningStarted(eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
        protected _traceProvisioningEnded(result: any, resolved: boolean, eventData?: Telemetry.TelemetryEvent): Telemetry.TelemetryEvent;
    }
    module Provisioner {
        /**
         * Options for constructing a provisioner.
         */
        interface Options<TData> {
            /**
             * A callback that supplies the promise that represents the provisioning operation.
             *
             * Note that the promise returned cannot be persisted. So in the case when the user closes
             * the browser, navigates away, or loses connection. It's advisable to make the operation as
             * short as possible, make it return some sort of an operation id, and then use that operation
             * id to continuously check on the status of the operation (i.e. poll for updates).
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically, the data is the same data returned to the collector (by the
             *      'mapOutgoingDataForCollector' method). If the provisioner is triggered automatically,
             *      the data is whatever is passed to the 'startProvisioning' method.
             * @returns A promise representing the provisioning operation, that is resolved with data passed
             *      to the provisioning part, if one exists.
             */
            supplyProvisioningPromise: (data: TData) => Promise<any>;
            /**
             * A callback that supplies the provisioner with the startboard info.
             *
             * If provisioning is automatically triggered, and if the user wants provisioning to happen
             * on the startboard, the startboard info returned by used for that purpose. If invalid
             * startboard info is returned, the provisioner will throw an exception and provisioning will
             * fail. Null or undefined are not acceptable.
             *
             * If provisioning is manually triggered, returning null or undefined indicates that you don't
             * want provisioning to happen on the startboard. If you return invalid startboard info, the
             * provisioner will throw an exception. If you return valid startboard info, a provisioning
             * part will be added to the startboard for provisioning to take place.
             *
             * @param data The data that will be used in the provisioning operation. If the provisioner is
             *      triggered automatically (it's hooked up with a provider and an action bar), the data
             *      is the same data returned to the collector (by the 'mapOutgoingDataForCollector'
             *      method). If the provisioner is triggered automatically, the data is whatever was
             *      passed to the 'startProvisioning' method.
             * @returns A startboard info object indicating which provisioning part to use and which
             *      startboard the provisioning part will mutate into.
             */
            supplyStartboardInfo: (data: TData) => any;
            /**
             * The action bar view model. This is the action bar on your provider blade. Defining this
             * property means you also need to define a parameter provider.
             */
            actionBar?: FxViewModels.ActionBars.Base.Contract;
            /**
             * The parameter provider. This is the parameter provider on your provider view model.
             * Defining this property means you also need to define an action bar.
             */
            parameterProvider?: FxViewModels.ParameterProvider<TData, any>;
        }
        /**
         * The parameters for the blade shown following submission of a provisioning request.
         */
        interface PostProvisioningBladeInputs {
            /**
             * The deployment Id.
             */
            readonly deploymentId: string;
            /**
             * The gallery item id.
             */
            readonly galleryItemId: string;
            /**
             * The absolute URI of the medium icon image for the gallery item.
             */
            readonly galleryItemIconUri: string;
            /**
             * The ID of the primary resource being created by the deployment.
             */
            readonly primaryResourceId: string;
            /**
             * The ID of asset type associated with the deployment.
             */
            readonly assetTypeId: string;
            /**
             * The key used to locate the relevant extension-provided content for the blade.
             * If this is provided, the packageId parameter must also be provided.
             */
            readonly provisioningHash?: string;
            /**
             * Metadata about the blade that initiated the deployment.
             */
            readonly createBlade?: {
                /**
                 * The name of the create blade that initiated the deployment.
                 */
                readonly bladeName: string;
                /**
                 * The instance ID of the create blade that initiated the deployment.
                 */
                readonly bladeInstanceId: string;
                /**
                 * The name of the extension containing the create blade that initiated the deployment.
                 */
                readonly extension: string;
                /**
                 * Unique ID for tracking a deployment.
                 */
                readonly telemetryId: string;
            };
        }
        /**
         * The provisioner configuration that a collector can pass to the provider part.
         */
        interface Config {
            /**
             * A flag that indicates whether provisioning is enabled or not.
             * Valid only in the automatic triggering scenario.
             */
            provisioningEnabled: boolean;
            /**
             * (Optional) The startboard info used in the provisioning process.
             */
            startboardProvisioningInfo?: any;
            /**
             * (Optional) Prevents the provisioner from discarding the journey. Only works if
             * provisioning does not happen on the startboard (because choosing to add a part on the
             * startboard means the journey must be discarded). Defaults to false.
             *
             */
            dontDiscardJourney?: boolean;
            /**
             * (Optional) Show the post-create blade after deployment has started.
             */
            launchPostCreate?: boolean;
            /**
             * (Optional) The inputs for the blade to open after deployment has started.
             */
            postProvisioningBladeInputs?: Promise<PostProvisioningBladeInputs>;
        }
    }
    function isValid(startboardInfo: any): boolean;
}
declare module MsPortalFx.ViewModels.ParameterCollectionV3 {
    /**
     * An extension element definition (e.g. part or blade) .
     */
    interface ExtensionElement {
        /**
         * The extension element extension.
         */
        extension: string;
        /**
         * The extension element name.
         */
        name: string;
    }
    /**
     * Obsolete This class is no longer used by the portal
     */
    const StartboardInfo: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.AssetPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that represents an asset part. Extends resizable.
     */
    interface AssetPartContract extends Resizable {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status?: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state?: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
    }
    /**
     * A view model class that respresents an asset part.
     */
    class AssetPart implements AssetPartContract {
        /**
         * The friendly-name of the type.
         */
        assetType: KnockoutObservableBase<string>;
        /**
         * The name of the part.
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * The asset's image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The id of the part.
         */
        assetId: KnockoutObservableBase<any>;
        /**
         * The state of the part.
         */
        status: KnockoutObservableBase<string>;
        /**
         * The colored line beside the part.
         */
        state: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ButtonPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * The interface that defines the view model that respresents a button part. Extends resizable.
     */
    interface ButtonPartContract extends Resizable {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
    }
    /**
     * A view model class that respresents a button part.
     */
    class ButtonPart implements ButtonPartContract {
        /**
         * The title of the part.
         */
        title: KnockoutObservableBase<string>;
        /**
         * A shorter title of the part (for size: mini).
         */
        shortTitle: KnockoutObservableBase<string>;
        /**
         * A description for the part.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon for the the part.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ChartPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * @deprecated MsPortalFx.ViewModels.ChartPart is obsolete.  Please use custom part with Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    const ChartPart: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CollectionPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Collection {
    import BaseFx = MsPortalFx.Base;
    import PartSize = MsPortalFx.Parts.PartSize;
    import FxViewModels = MsPortalFx.ViewModels;
    import FxGrid = FxViewModels.Controls.Lists.Grid;
    /**
     * The modes of the grid in collection part.
     */
    enum GridMode {
        /**
         * Shows no grid. 0 is falsy.
         */
        None = 0,
        /**
         * Shows raw data grid.
         */
        Data = 1,
        /**
         * Shows the aggregated rollup data grid.
         */
        Rollup = 2
    }
    /**
     * The contract for the grid on the collection part.
     */
    interface GridContract {
        /**
         * Column definitions.
         */
        columns: KnockoutObservableArray<FxGrid.Column>;
        /**
         * Items displayed in the table based on the column definitions when selection is disabled.
         * It is set in the constructor. Do not directly replace it.
         */
        items?: KnockoutObservableArray<any>;
    }
    /**
     * The options for the collection part view model
     */
    interface CollectionOptions {
        /**
         * The raw data.
         */
        data: GridContract;
        /**
         * The rollup data.
         */
        rollupData?: GridContract;
        /**
         * Shows the header of the grid.
         */
        showHeader?: boolean;
        /**
         * Options for the SelectableRow grid extension.  If null, rows will not be selectable.
         */
        selectableRowExtensionOptions?: FxGrid.SelectableRowExtensionOptions<any, any>;
        /**
         * The label to show when the grid has no rows.
         */
        noRowsMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally show some HTML when there are no grid rows.
         */
        noRowsHtml?: KnockoutObservableBase<any>;
    }
    /**
     * A view model class that respresents a collection part.
     */
    class ViewModel implements Resizable {
        size: KnockoutObservable<PartSize>;
        alwaysShowRollupCount: KnockoutObservable<boolean>;
        rollupCount: KnockoutObservable<number>;
        selectableData: FxViewModels.SelectableSet<any, any>;
        rollupCountIconUri: KnockoutObservable<string>;
        rollupCountIcon: KnockoutObservableBase<BaseFx.Image>;
        rollupCountLabel: KnockoutObservable<string>;
        /**
         * The mode of the grid.
         */
        gridMode: KnockoutObservable<GridMode>;
        /**
         * The no rows HTML.
         */
        noRowsHtml: KnockoutObservableBase<any>;
        /**
         * Boolean indicating if the grid is empty.
         */
        emptyGrid: KnockoutObservableBase<boolean>;
        _options: CollectionOptions;
        _container: FxViewModels.PartContainerContract;
        private grid;
        private hasMoreData;
        private noRollupCount;
        /**
         * The constructor of the collection part view model.
         */
        constructor(container: FxViewModels.PartContainerContract, options: CollectionOptions);
        private _reactToDataChange;
        private _reactToSizeChange;
        private _updateGrid;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CollectionSummary.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model interface that respresents summary information for a collection of resource instances.
     */
    interface CollectionSummaryContract extends Resizable {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum?: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label?: KnockoutObservableBase<string>;
    }
    /**
     * A view model class that represents summary information for a collection of resource instances.
     */
    class CollectionSummary implements CollectionSummaryContract {
        /**
         * The count of instances of the resource.
         */
        resourceCount: KnockoutObservableBase<number>;
        /**
         * If the resourceCount is a lower limit
         */
        countIsMinimum: KnockoutObservableBase<boolean>;
        /**
         * The description text or resource data.
         */
        description: KnockoutObservableBase<string>;
        /**
         * An icon to an image representing the resource type.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        /**
         * The label associated with the resource count.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The size of the part (makes it adaptive) - Resizable interface.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.CreatePart.d.ts
declare module MsPortalFx.ViewModels {
    interface CreatePartContract extends ButtonPartContract {
        /**
         * The name of the create definition.
         */
        createName: KnockoutObservable<string>;
    }
    class CreatePart extends ButtonPart implements CreatePartContract {
        createName: KnockoutObservable<string>;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.DonutPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Donut {
    /**
     * @deprecated Donut.ItemData. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type ItemData = Obsolete;
    /**
     * @deprecated Donut.GroupInfo. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type GroupInfo = Obsolete;
    /**
     * @deprecated Donut.ItemSetting. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type ItemSetting = Obsolete;
    /**
     * @deprecated Donut.ViewModel. This part is no longer supported. Please use custom part with the Donut, Legend and Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.EditorPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Editor {
    /**
     * @deprecated MsPortalFx.ViewModels.Parts.Editor is obsolete.  Please use a TemplateBlade or CustomPart with an Editor control instead.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.InfoListPart.d.ts
declare module MsPortalFx.ViewModels.Parts.InfoList {
    /**
     * The interface that defines the view model that respresents an InfoList. Extends resizable.
     */
    interface Contract {
        /**
         * The sections.
         */
        sections: KnockoutObservableArray<Section>;
    }
    interface Section {
        /**
         * The icon. Leave null if numbering is preferred.
         */
        icon?: MsPortalFx.Base.Image;
        /**
         * The section header text.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The multi-line description text.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The Link entries.
         */
        links?: Link[];
        /**
         * A section-wide click effect.
         */
        selection?: Link;
    }
    class Link {
        /**
         * Display Text.
         */
        text: KnockoutObservableBase<string>;
        /**
         * The hyperlink target.
         */
        uri: KnockoutObservableBase<string>;
        /**
         * Describes the blade that should be opened when this link is selected.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: string, uri: string);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param uri The target to open in a new browser tab.
         */
        constructor(text: KnockoutObservableBase<string>, uri: KnockoutObservableBase<string>);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: string, bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection);
        /**
         * Construct a link.
         *
         * @param text The display text.
         * @param bladeSelection The blade to open.
         */
        constructor(text: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>);
    }
    /**
     * A view model class that respresents an InfoList Part.
     */
    class ViewModel implements Contract, Base.Disposable {
        /**
         * See Contract.
         */
        sections: KnockoutObservableArray<Section>;
        private selection;
        private bladeLinks;
        constructor(initialState?: any);
        dispose(): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTargetUri The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetUri: string, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param sectionTarget The URI visited or blade opened on click. Text is ignored.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, sectionTargetSelectable: MsPortalFx.ViewModels.DynamicBladeSelection, icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: string, description: string, links: Link[], icon?: MsPortalFx.Base.Image): void;
        /**
         * Adds a section, limiting to the correct format
         *
         * @param title The section title.
         * @param description The multi-line section description.
         * @param links The links provided after the description.
         * @param icon The option of an icon (or else a section number).
         */
        addSection(title: KnockoutObservableBase<string>, description: KnockoutObservableBase<string>, links: any, icon?: MsPortalFx.Base.Image): void;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.PropertiesPart.d.ts
declare module MsPortalFx.ViewModels.Parts.Properties {
    import InternalProperties = FxImpl.ViewModels.Parts.Properties;
    /**
     * Part contract.
     */
    interface Contract {
        /**
         * The collection of properties.
         */
        properties: KnockoutObservableArray<Property>;
    }
    /**
     * Part view model.
     */
    class ViewModel implements MsPortalFx.ViewModels.Parts.Properties.Contract, MsPortalFx.Base.Disposable {
        private _openBladeProperties;
        private _openBladeAsyncProperties;
        private _moveResourceProperties;
        selection: MsPortalFx.ViewModels.SelectableSet<OpenBladeProperty, MsPortalFx.ViewModels.DynamicBladeSelection>;
        asyncSelection: MsPortalFx.ViewModels.SelectableSet<InternalProperties.OpenBladeAsyncProperty, MsPortalFx.ViewModels.DynamicBladeSelection>;
        moveResourceSelection: MsPortalFx.ViewModels.SelectableSet<Property, MsPortalFx.ViewModels.DynamicBladeSelection>;
        properties: KnockoutObservableArray<Property>;
        constructor(initialState?: any);
        /**
         * Sets the properties.
         */
        setProperties(properties: Property[]): void;
        /**
         * Removes all properties.
         */
        removeAllProperties(): void;
        dispose(): void;
    }
    /**
     * Property types.
     */
    const enum PropertyType {
        /**
         * Property with only text.
         */
        Text = 0,
        /**
         * Property with a link.
         */
        Link = 1,
        /**
         * Property with a copy field.
         */
        CopyField = 2,
        /**
         * Property with a callback.
         */
        Callback = 3,
        /**
         * Property to open a blade.
         */
        OpenBlade = 4,
        /**
         * Property to have a list of links.
         */
        MultiLinks = 5,
        /**
         * Property to have an of Svg.
         */
        Image = 6,
        /**
         * Property to have a list of open blade properties.
         */
        MultiOpenBlades = 7,
        /**
         * Property to open an asynchronously determined blade.
         */
        OpenBladeAsync = 8
    }
    /**
     * Supported edit types.
     */
    const enum EditType {
        /**
         * Unknown edit type.
         */
        Unknown = 0,
        /**
         * Allows to edit Resource Group or Subscription properties of a resource.
         */
        MoveResource = 1
    }
    /**
     * Options that can be set for all properties
     */
    interface CommonOptions {
        /**
         * Label of the property.
         */
        label: string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: any;
    }
    /**
     * Options for properties that can launch a blade
     */
    interface OpenBladeOptionalOptions {
        /**
         * Info of the blade to open
         */
        blade?: OpenBlade;
    }
    /**
     * Options for properties that are editable.
     */
    interface EditBladeOptionalOptions {
        /**
         * Info of the blade to open which allows editing property.
         */
        editBlade?: OpenBlade;
    }
    /**
     * Options for an OpenBladeProperty
     */
    interface OpenBladeOptions extends CommonOptions, EditBladeOptionalOptions, OpenBlade {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBlade {
        /**
         * The uri of the link.
         */
        bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection | KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * The display text of the link.
         */
        displayValue?: string | KnockoutObservableBase<string>;
        /**
         * Supported edit type if it's an edit blade.
         */
        editType?: EditType;
        /**
         * The edit link if it's an edit blade.
         */
        showLink?: boolean;
    }
    /**
     * Options for a TextProperty
     */
    interface TextOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Optional icon to display before the text
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a LinkProperty
     */
    interface LinkOptions extends CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
        /**
         * Link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
        /**
         * Target value of the property.
         */
        target?: LinkTargetOptions;
    }
    /**
     * Options for a CopyFieldProperty
     */
    interface CopyFieldOptions extends OpenBladeOptionalOptions, EditBladeOptionalOptions, CommonOptions {
        /**
         * Value of the property.
         */
        value: KnockoutObservableBase<string> | string;
    }
    /**
     * Options for an ImageProperty
     */
    interface ImageOptions extends OpenBladeOptionalOptions, CommonOptions {
        /**
         * The icon for callback and image
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    /**
     * Options for a MultiOpenBladeProperty
     */
    interface MultiOpenBladeOptions extends CommonOptions {
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks: KnockoutObservableArray<OpenBlade>;
    }
    /**
     * Options for a MultiLinksProperty
     */
    interface MultiLinksOptions extends CommonOptions {
        /**
         * The observable array of links for multilinks
         */
        links: KnockoutObservableArray<Link>;
    }
    /**
     * Options for a CallbackProperty
     */
    interface CallbackOptions extends CommonOptions {
        /**
         * Displayed text for the link to execute the callback.
         */
        displayValue: KnockoutObservableBase<string> | string;
        /**
         * The callback for callback
         */
        callback: () => void;
        /**
         * The icon for callback and image
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
    }
    interface MoveResourceOptions extends CopyFieldOptions {
        /**
         * Resource Id
         */
        resourceId: string;
        /**
         * Resource move type
         */
        moveType: MsPortalFx.Azure.ResourceManager.MoveType;
    }
    /**
     * Property base class.
     */
    class Property implements MsPortalFx.Base.Disposable {
        /**
         * Gets the label of the property.
         */
        label: string;
        /**
         * Gets the display value of the property.
         */
        displayValue: KnockoutObservableBase<string>;
        /**
         * Gets the value of the property.
         * Note : this should be a KnockoutObservableBase<string>, but external code uses this
         * as a CopyField ViewModel because this property was an "any" and either a string,
         * or a CopyField ViewModel.  Can't separate them as this API is public and in use.
         */
        value: any;
        /**
         * Gets the value that is copied
         */
        copyableValue: KnockoutObservableBase<string>;
        /**
         * Gets or sets if the property is visible. It is true by default.
         */
        visible: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets if the property value should be wrapped. It is false by default.
         */
        wrappable: KnockoutObservableBase<boolean>;
        /**
         * Gets or sets a link to open another blade.
         */
        bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>;
        /**
         * Get a value reflecting whether the property is loading its value.
         */
        isLoading: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon: any;
        /**
         * Get the type of this property.
         */
        type: PropertyType;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade: OpenBlade;
        /**
         * text for edit blade link.
         */
        editBladeText: string;
        _supportsIsLoading: boolean;
        hasValidBladeSelection: KnockoutComputed<boolean>;
        private readonly _lifetimeManager;
        protected get lifetimeManager(): MsPortalFx.Base.DisposableLifetimeManager;
        constructor(options: InternalProperties.AllOptions);
        /**
         * Get the property type.
         */
        getType(): PropertyType;
        dispose(): void;
    }
    /**
     * Text property class.
     */
    class TextProperty extends Property {
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, value: string);
        constructor(label: string, value: KnockoutObservableBase<string>);
        constructor(options: TextOptions);
        getType(): PropertyType;
    }
    type LinkTargetOptions = "_self" | "_blank";
    /**
     * Link property class.
     */
    class LinkProperty extends Property {
        target: LinkTargetOptions;
        constructor(label: string, uri: string, displayUri?: string);
        constructor(label: string, uri: KnockoutObservableBase<string>, displayUri?: KnockoutObservableBase<string>);
        constructor(options: LinkOptions);
        getType(): PropertyType;
    }
    /**
     * Copy field property.
     */
    class CopyFieldProperty extends Property {
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: string);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, value: KnockoutObservableBase<string>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: CopyFieldOptions);
        getType(): PropertyType;
    }
    /**
     * Callback property class.
     */
    class CallbackProperty extends Property {
        callback: () => void;
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        private callbackWrapper;
        constructor(label: string, displayValue: string, callback: () => void, icon?: MsPortalFx.Base.Image);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, callback: () => void, icon?: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: CallbackOptions);
        getType(): PropertyType;
    }
    /**
     * The property to open a specified blade.
     */
    class OpenBladeProperty extends Property {
        constructor(label: string, displayValue: string, bladeSelection: MsPortalFx.ViewModels.DynamicBladeSelection);
        constructor(label: string, displayValue: KnockoutObservableBase<string>, bladeSelection: KnockoutObservableBase<MsPortalFx.ViewModels.DynamicBladeSelection>);
        constructor(options: OpenBladeOptions);
        getType(): PropertyType;
    }
    /**
     * The property to have a list of open blade properties
     */
    class MultiOpenBladeProperty extends Property {
        /**
         * The observable array of blade links.
         */
        bladeLinks: KnockoutObservableArray<OpenBladeProperty>;
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, label: string, bladeLinks: KnockoutObservableArray<OpenBlade>);
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options: MultiOpenBladeOptions);
        getType(): PropertyType;
    }
    /**
     * The interface of a html link.
     */
    interface Link {
        /**
         * The display text of the link.
         */
        text: string;
        /**
         * The uri of the link.
         */
        uri: string;
    }
    /**
     * The property to have a list of html links
     */
    class MultiLinksProperty extends Property {
        /**
         * The observable array of links.
         */
        links: KnockoutObservableArray<Link>;
        constructor(label: string, links: KnockoutObservableArray<Link>);
        constructor(options: MultiLinksOptions);
        getType(): PropertyType;
    }
    /**
     * The property to have a image
     */
    class ImageProperty extends Property {
        /**
         * The observable image.
         */
        icon: KnockoutObservableBase<MsPortalFx.Base.Image>;
        constructor(label: string, icon: KnockoutObservableBase<MsPortalFx.Base.Image>);
        constructor(options: ImageOptions);
        getType(): PropertyType;
    }
}
declare module FxImpl.ViewModels.Parts.Properties {
    import Properties = MsPortalFx.ViewModels.Parts.Properties;
    /**
     * Values permitted for the target property on an link control.
     */
    type LinkTargetOptions = Properties.LinkTargetOptions;
    /**
     * All options that can be set for a property
     */
    interface AllOptions {
        /**
         * Label of the property.
         */
        label?: string;
        /**
         * Value of the property.
         */
        value?: string | KnockoutObservableBase<string>;
        /**
         * Value that is copied.
         */
        copyableValue?: KnockoutObservableBase<string> | string;
        /**
         * If the property is visible.
         */
        visible?: KnockoutObservableBase<boolean> | boolean;
        /**
         * If the property value should be wrapped.
         */
        wrappable?: KnockoutObservableBase<boolean> | boolean;
        /**
         * Blade link display value of the property.
         */
        displayValue?: KnockoutObservableBase<string> | string;
        /**
         * Blade link display value of the property.
         */
        target?: LinkTargetOptions;
        /**
         * A link to open another blade.
         */
        blade?: Properties.OpenBlade | OpenBladeAsync;
        /**
         * A link to open a blade to edit the property.
         */
        editBlade?: Properties.OpenBlade;
        /**
         * The icon for the property
         */
        icon?: KnockoutObservableBase<MsPortalFx.Base.Image> | MsPortalFx.Base.Image;
        /**
         * A collection of link for multiopenblade
         */
        bladeLinks?: KnockoutObservableArray<Properties.OpenBlade>;
        /**
         * The observable array of links for multilinks
         */
        links?: KnockoutObservableArray<Properties.Link>;
        /**
         * The callback for callback
         */
        callback?: () => void;
        /**
         * Value reflecting whether the property is loading its value.
         */
        isLoading?: KnockoutReadOnlyObservableBase<boolean>;
        /**
         * Info balloon to be shown next to the property.
         */
        infoBalloon?: any;
    }
    /**
     * Options for an OpenBladeAsyncProperty
     */
    interface OpenBladeAsyncOptions extends Properties.CommonOptions, Properties.EditBladeOptionalOptions, OpenBladeAsync {
    }
    /**
     * The interface of a blade link.
     */
    interface OpenBladeAsync {
        /**
         * The display text of the link.
         */
        displayValue: string | KnockoutObservableBase<string>;
        /**
         * The uri of the link.
         */
        resolveBlade: () => Promise<MsPortalFx.ViewModels.DynamicSelection>;
    }
    /**
     * The property to open a blade that is determined asynchronously.
     */
    class OpenBladeAsyncProperty extends Properties.Property {
        resolveBlade: () => Promise<MsPortalFx.ViewModels.DynamicSelection>;
        constructor(options: OpenBladeAsyncOptions);
        getType(): Properties.PropertyType;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ProvisioningPart.d.ts
declare module FxImpl.ViewModels.ProvisioningPart {
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * @deprecated FxImpl.ViewModels.ProvisioningPart.ContentContract. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    interface ContentContract extends MsPortalFx.ViewModels.PartContent {
        /**
         * The title displayed on the provisioning part.
         */
        title: KnockoutObservable<string>;
        /**
         * The description displayed on the provisioning part.
         */
        description: KnockoutObservable<string>;
        /**
         * The URI for the icon displayed on the provisioning part.
         */
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
    }
    /**
     * @deprecated FxImpl.ViewModels.ProvisioningPart.ContentViewModel. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    class ContentViewModel extends FxImpl.ViewModels.ParameterCollection.BaseGalleryButtonPartViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _partContainer;
        /**
         * Creates the view model that drives the content within the unprovisioned part.
         *
         * @param container The view model for the part container.
         * @param initialState The saved state defining the current progress of the wizard.
         * @param allowToggleProvisioningLocation True, if user can choose whether provisioning happens on blade or startboard part; else false.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any, allowToggleProvisioningLocation?: boolean);
        onInputsSet(inputs: any): Promise<any>;
        title: KnockoutObservable<string>;
        description: KnockoutObservable<string>;
        icon: KnockoutObservable<MsPortalFx.Base.Image>;
        /**
         * @deprecated ContentViewModel.enableProvisioning This is no longer supported http://aka.ms/portalfx/breaking
         */
        enableProvisioning: KnockoutObservable<boolean>;
        /**
         * Error message displayed when there is an error during provisioning.
         */
        errorMessage: KnockoutObservable<string>;
        /**
         * @deprecated ContentViewModel.privatePcPrBI This is no longer supported http://aka.ms/portalfx/breaking
         */
        privatePcPrBI: ParameterCollectionInternal.ProvisioningEntityBindingInternals;
        mutate(containerModel: any): void;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.QuickStartPart.d.ts
declare module MsPortalFx.ViewModels {
    interface QuickStartPartContract extends ButtonPartContract {
        /**
         * The color to use for the background of the quickstart button.
         */
        backgroundColor: MsPortalFx.Parts.PartColor;
    }
    class QuickStartPart extends ButtonPart implements QuickStartPartContract {
        backgroundColor: MsPortalFx.Parts.PartColor;
        /**
         * Initialize the part.
         */
        constructor();
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.QuotaGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.QuotaGauge {
    /**
     * MsPortalFx.ViewModels.Parts.QuotaGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/QuotaGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    let MetricColorBarKind: Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.QuotaGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/QuotaGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type MetricContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.QuotaGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/QuotaGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.QuotaGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/QuotaGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.ResourceSummaryPart.d.ts
declare module MsPortalFx.ViewModels.Parts.ResourceSummary {
    /**
     * @deprecated ResourceSummary.includedResourceTypes. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    let includedResourceTypes: {};
    type includedResourceTypes = Obsolete;
    /**
     * @deprecated ResourceSummary.Contract. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Contract = Obsolete;
    /**
     * @deprecated ResourceSummary.GetDynamicBladeSelection. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type GetDynamicBladeSelection = Obsolete;
    /**
     * @deprecated ResourceSummary.Options. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Options = Obsolete;
    /**
     * @deprecated ResourceSummary.ViewModel. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel: Obsolete;
    /**
     * @deprecated ResourceSummary.BuiltinPropertyKind. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Reflects the different built-in properties that are typically displayed in the left-hand column of the
     * ResourceSummary Part.
     */
    const BuiltInPropertyKind: Obsolete;
    /**
     * @deprecated ResourceSummary.Layout. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Layout = Obsolete;
    /**
     * @deprecated ResourceSummary.Options2. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * Options for the ResourceSummary Part view model.
     */
    type Options2 = Obsolete;
    /**
     * @deprecated ResourceSummary.ViewModel2. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    const ViewModel2: Obsolete;
    type ViewModel2 = Obsolete;
}
declare module FxImpl.ViewModels.Parts.ResourceSummary {
    import ResourceSummaryPart = MsPortalFx.ViewModels.Parts.ResourceSummary;
    /**
     * @deprecated ResourceSummary.Dependencies. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     */
    type Dependencies = Obsolete;
    /**
     * @deprecated ResourceSummary.setDependencies. This part is no longer supported. MsPortalFx.ViewModels.Parts.ResourceSummary and its associated types are obsolete. Please use Fx/Controls/Essentials instead.
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * For testing purposes, mocks the dependencies of this ResourceSummary Part view model.
     * @param viewModel The ResourceSummary Part view model.
     * @param dependencies The dependencies.
     */
    function setDependencies(viewModel: ResourceSummaryPart.ViewModel2, dependencies: Dependencies): void;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SettingList.d.ts
declare module MsPortalFx.ViewModels.Parts.SettingList {
    import BaseFx = MsPortalFx.Base;
    import FxViewModels = MsPortalFx.ViewModels;
    import ViewModels = MsPortalFx.ViewModels;
    import Selectable = ViewModels.Selectable;
    import GridFx = ViewModels.Controls.Lists.Grid;
    import PartContainerContract = ViewModels.PartContainerContract;
    function ShouldRemoveSupportSettings(value: boolean): void;
    /**
     * The contract of the setting selection.
     */
    interface SettingSelection extends FxViewModels.DynamicBladeSelection {
        /**
         * The identifier of the setting.
         */
        key: string;
        /**
         * Gets if the setting using parameter collector.
         */
        isParameterCollector: boolean;
    }
    /**
     * The options of the settings.
     */
    interface SettingOptions<TParameterCollectorResult> {
        /**
         * The parameter collector callbacks.
         */
        parameterCollector?: ParameterCollectorSettingOptions<TParameterCollectorResult>;
    }
    /**
     * The options of the parameter collector for the settings.
     */
    interface ParameterCollectorSettingOptions<TResult> {
        /**
         * A callback that supplies initial data for the parameter provider
         * in the child blade each time it opens.
         *
         * Note that the object received by the parameter provider will be a
         * deep clone of the value you give, rather than the original instance,
         * because it is passed (and sometimes stored) in a serialized form.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @returns Initial data for the child blade.
         */
        supplyInitialData(): TResult;
        /**
         * A callback to be invoked when the child blade supplies a result
         * and closes.
         *
         * @param result The result given by the child blade.
         * @param activatedItem The object whose selection launched this parameter collection process. The result refers to that object.
         */
        receiveResult(result: TResult): void;
        /**
         * A callback that supplies additional configuration options for the
         * provider each time it opens. You can use this to pass non-editable
         * data, for example configuring how a form will be displayed.
         *
         * @param activatedItem The selected object that is launching this parameter collection process.
         * @returns Arbitrary configuration options for the child blade.
         */
        supplyProviderConfig?(): any;
    }
    /**
     * The class of the setting list item.
     */
    class Setting {
        /**
         * Gets or sets the display text for the setting.
         */
        displayText: KnockoutObservable<string>;
        /**
         * Gets or sets the icon for the setting.
         */
        icon: KnockoutObservable<BaseFx.Image>;
        /**
         * Gets or sets the keywords for the setting.
         */
        keywords: KnockoutObservableArray<string>;
        /**
         * Gets or sets the group name for the setting.
         */
        group: KnockoutObservable<string>;
        protected aggregatedKeywords: KnockoutObservable<string>;
        private _key;
        private _blade;
        protected _bladeInputs: KnockoutObservableBase<any>;
        protected _extension: KnockoutObservableBase<string>;
        private _options;
        /**
         * Gets the key of the setting.
         */
        get key(): string;
        /**
         * Gets the setting options.
         */
        getOptions(): SettingOptions<any>;
        constructor(key: string, detailBlade: string | KnockoutObservableBase<string>, detailBladeInputs: KnockoutObservableBase<any>, extension?: string | KnockoutObservableBase<string>, options?: SettingOptions<any>);
        /**
         * Gets the setting selection.
         */
        toSelection(): SettingSelection;
    }
    /**
     * The options of the setting list part.
     */
    interface Options {
        /**
         * Indicates whether the export template menu item should be enabled. Enabled by defualt for subscription resources and resource groups.
         */
        enableExportTemplate?: boolean;
        /**
         * Enables the settings for roles and users.
         */
        enableRbac?: boolean;
        /**
         * Enables the settings for help request support.
         */
        enableSupportHelpRequest?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshoot?: boolean;
        /**
         * Enables the settings for troubleshoot support.
         */
        enableSupportTroubleshootV2?: boolean;
        /**
         * Enables the settings for resource health support.
         */
        enableSupportResourceHealth?: boolean;
        /**
         * Enables the settings for the event logs.
         */
        enableSupportEventLogs?: boolean;
        /**
         * Enables the setting for tags.
         */
        enableTags?: boolean;
        /**
         * Enables grouping of the settings.
         */
        groupable?: boolean;
        /**
         * Enables the setting for management certs.
         */
        enableManagementCerts?: boolean;
        /**
         * Enables the setting for access details.
         */
        enableAccessDetails?: boolean;
        /**
         * Enables the setting for resource provider details.
         */
        enableResourceProviders?: boolean;
    }
    abstract class BaseViewModel {
        resourceId: KnockoutObservableBase<string>;
        settingList: GridFx.ViewModel<Setting, SettingSelection>;
        searchBoxPlaceholder: KnockoutObservableBase<string>;
        private _searchText;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        protected isPCv3(): boolean;
        private _updateSettings;
        private _processSettings;
        private _removeSetting;
        private _trace;
    }
    /**
     * The view model of the setting list part.
     */
    class ViewModel extends BaseViewModel {
        /**
         * This is only here to cause compile time breaks between V1 and V2, for migrating from V1 to V2 see
         * https://auxdocs.azurewebsites.net/en-us/documentation/articles/portalfx-blades-bladekinds-settinglist-migration
         */
        protected _1: string;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
    }
    /**
     * The setting list part view model v2 enables the parameter collector V3 for the settings.
     * It is fully back-compatible with setting list part view model v1.
     */
    class ViewModelV2 extends BaseViewModel {
        selectable: Selectable<SettingSelection>;
        pcSelectable: Selectable<SettingSelection>;
        parameterCollector: ViewModels.ParameterCollector<any>;
        protected isPCv3(): boolean;
        constructor(container: PartContainerContract, initialState: any, settings: Setting[] | KnockoutObservableArray<Setting>, options?: Options);
        private _initParameterCollector;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SetupPart.d.ts
declare module FxImpl.ViewModels.SetupPart {
    import ParameterCollectionInternal = MsPortalFx.ViewModels.ParameterCollection.Internal;
    /**
     * Interface for the content of a create part.
     */
    interface ContentContract extends FxImpl.ViewModels.ProvisioningPart.ContentContract {
        /**
         * A parameter collection entity that does provisioning.
         */
        provisioningEntity: ParameterCollectionInternal.ProvisioningEntity;
    }
    /**
     * Base class for the content view model of a create part.
     */
    class Content extends FxImpl.ViewModels.ProvisioningPart.ContentViewModel implements ContentContract, MsPortalFx.Base.Disposable {
        private _setupPartContainer;
        private _previousCommit;
        private _outputs;
        provisioningEntity: ParameterCollectionInternal.ProvisioningEntity;
        /**
         * Creates the view model for the setup part.
         *
         * @param container The view model for the part container.
         * @param initialState The initial state of the part.
         */
        constructor(container: MsPortalFx.ViewModels.PartContainerContract, initialState?: any);
        onInputsSet(inputs: any): Promise<any>;
        /**
         * Allows subclasses to provide a promise that indicates whether to load the content for the setup part
         * or mutate into another part.
         *
         * @returns Null to proceed straight to the content for this part or a promise. If a promise is returned
         * the setup part will wait in a loading state until it is resolved with one of the following values:
         *   * null - The setup part will proceed to load it's content.
         *   * string - The string is the name of a part in this extension's part catalog. The setup part will mutate into that part.
         *   * object - The object must have 'partName' and 'extensionName' properties. The setup part will find the part in the specified extension's part
         * catalog and mutate into that part.
         */
        mutateOnLoad(): Promise<any>;
        /**
         * Mutates setup part into another part.
         *
         * @param newPart The name of the part in the part catalog.
         * @param extensionForPart Name of the extension containing the part. Optional.
         */
        mutate(newPart: string, extensionForPart?: string): void;
        onProviderCommit(providerId: string, outputs: MsPortalFx.ViewModels.ParameterCollection.ParameterCollectionOutput): Promise<boolean>;
        private _loadContent;
        private _executeProvisioningIfApplicable;
    }
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SimpleChartPart.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * @deprecated MsPortalFx.ViewModels.SimpleChartPart is obsolete.  Please use custom part with Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    type SimpleChartPartOptions = Obsolete;
    /**
     * @deprecated MsPortalFx.ViewModels.SimpleChartPart is obsolete.  Please use custom part with Fx/Controls/LineChart or Fx/Controls/BarChart or Fx/Controls/AreaChart or Fx/Controls/ScatterChart.
     * @see {@link https://aka.ms/portalfx/breaking} for more details.
     */
    const SimpleChartPart: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Parts\ViewModels.SingleValueGaugePart.d.ts
declare module MsPortalFx.ViewModels.Parts.SingleValueGauge {
    /**
     * MsPortalFx.ViewModels.Parts.QuotaGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/QuotaGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const MetricColorBarKind: Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.SingleValueGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/SingleValueGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type MetricContract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.SingleValueGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/SingleValueGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * MsPortalFx.ViewModels.Parts.SingleValueGauge is obsolete.
     * Please migrate to AMD creation pattern using Fx/Controls/SingleValueGauge and Fx/Controls/Metrics control instead.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const ViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\Services\Browse.d.ts
declare module MsPortalFx.ViewModels.Services.Browse {
    import FxServices = MsPortalFx.Services;
    /**
     * The browse criteria provides the information for browse as a data contract.
     *
     * @deprecated Services.Browse.Criteria 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Criteria = Obsolete;
    /**
     * The browse operation contract for a running browse.
     *
     * @deprecated Services.Browse.Contract 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the browse service base class.
     *
     * @deprecated Services.Browse.Service 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service<T> {
        initialized: Obsolete;
        results: Obsolete;
        canceled: Obsolete;
        private _dataLifetime;
        private readonly _lifetimeManager;
        constructor();
        /**
         * Disposes any resources owned by this object.
         */
        dispose(): void;
        /**
         * Invoked when the inputs change.
         *
         * @deprecated Service.onInputsSet 04/30/2020 - No longer supported.
         * @param inputs The inputs object with all the input parameters.
         * @returns A promise if there is async loading, else null.
         */
        onInputsSet(_inputs: any): Obsolete;
        /**
         * Connects the data source for the browse to the results.
         *
         * @deprecated Service.connectDataSource 04/30/2020 - No longer supported.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param items The observable array representing the data source.
         * @param mapper The callback function to map the items in the data source to their asset details.
         */
        connectDataSource(items: KnockoutObservableArray<T>, mapper: (value: T) => FxServices.AssetDetails): Obsolete;
        private _releaseDataSub;
    }
    /**
     * The deserialized browse provides a wrapper for the criteria and use current browse flag.
     *
     * @deprecated DeserializedBrowse 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type DeserializedBrowse = Obsolete;
    /**
     * The browse serializer class is used to serialize a use current browse flag to a string.
     *
     * @deprecated BrowseSerializer 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BrowseSerializer {
        /**
         * Serializes the use browse key to a string.
         *
         * @deprecated BrowseSerializer.serialize 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param browseCriteria The browse criteria for the saved browse.
         * @param newBrowse The optional new browse flag for the saved browse (default is false).
         * @param useBrowseKey The optional browse key to use for the saved browse (default is null).
         * @returns The browse serialized as a string value.
         */
        static serialize(browseCriteria: Criteria, newBrowse?: boolean, useBrowseKey?: string): Obsolete;
        /**
         * Deserializes a saved browse to the use current browse flag.
         *
         * @deprecated BrowseSerializer.deserialize 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param savedBrowse The browse that was serialized into a string.
         * @returns An object that will contain the asset owner and type, the new browse flag and use browse key.
         */
        static deserialize(savedBrowse: string): Obsolete;
    }
    /**
     * The browse results view model provides the view model for the results of an initiated browse.
     *
     * @deprecated ResultsViewModel 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ResultsViewModel {
        /**
         * The initialized flag signifies that the initial browse results are initialized.
         *
         * @deprecated ResultsViewModel.initialized 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        initialized: Obsolete;
        /**
         * The results array contains all the results of the browse.
         *
         * @deprecated ResultsViewModel. 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        results: Obsolete;
        /**
         * Creates an instance of the browse results view model.
         *
         * @deprecated ResultsViewModel.results 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param criteria The browse criteria for the browse.
         * @param results The initial collection for the results.
         */
        constructor(criteria: Criteria, results: any[]);
        /**
         * Gets the browse criteria of the browse.
         *
         * @deprecated ResultsViewModel.browseCriteria 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        readonly browseCriteria: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\Services\Diagnostics.d.ts
declare module MsPortalFx.ViewModels.Services.Diagnostics {
    interface HubsDiagnosticsProvider {
        /**
         * Gets the cached permissions for the current logged in user.
         *
         * @returns The promise for the permissions results.
         */
        getPermissions(): Promise<any>;
    }
}

// FILE: MsPortalFx\ViewModels\Services\DynamicBlade.d.ts
declare module MsPortalFx.ViewModels.Services.DynamicBlade {
    /**
     * The dynamic blade contract for an asset.
     *
     * @deprecated Services.DynamicBlade.Contract 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the dynamic blade service base class.
     *
     * @deprecated Services.DynamicBlade.Service 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        extensionName: Obsolete;
        bladeName: Obsolete;
        /**
         * Initialize a new instance of the dynamic blade service.
         */
        constructor();
    }
    /**
     * Prepares a dynamic selection from a dynamic blade service, an asset ID and the extension and asset type names.
     *
     * @deprecated prepareDynamicSelection 04/30/2020 - Dynamic blade service is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     * @param dynamicBladeService The dynamic blade service to check for a blade override.
     * @param assetId The asset ID to use for the selection.
     * @param extensionName The name of the extension that owns the asset type.
     * @param assetTypeName The name of the asset type.
     * @returns A promise to supply the dynamic selection.
     */
    function prepareDynamicSelection(dynamicBladeService: Service, assetId: any, extensionName: string, assetTypeName: string): Obsolete;
}

// FILE: MsPortalFx\ViewModels\Services\GridColumns.d.ts
declare module MsPortalFx.ViewModels.Services.GridColumns {
    /**
     * The global grid columns base columns.
     *
     * @deprecated Services.GridColumns.BaseColumns 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class BaseColumns {
        /**
         * Gets the base columns for assets which do not provide columns or for multiple-asset type grids.
         *
         * @deprecated 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
         * from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        static get base(): Obsolete;
    }
    /**
     * The grid columns usage values.
     *
     * @deprecated Services.GridColumns.Usage 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Usage = Obsolete;
    /**
     * A grid columns definition for an asset.
     *
     * @deprecated Services.GridColumns.Contract 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the grid columns service base class.
     *
     * @deprecated Services.GridColumns.Service 04/30/2020 - Browse V1 is no longer supported and no one is using this, it is safe to remove this
     * from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        includeAssetIcon: Obsolete;
        columns: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\Services\PropertyProvider.d.ts
declare module MsPortalFx.ViewModels.Services.PropertyProvider {
    /**
     * A property definition returned via the property provider.
     */
    interface PropertyDefinition {
        /**
         * The name of the property.
         */
        property: string;
        /**
         * The value of the property.
         */
        value: any;
    }
    /**
     * The property provider contract for providing properties.
     */
    interface Contract {
        /**
         * The result set which will contain the properties provided.
         */
        properties: KnockoutObservableArray<PropertyDefinition>;
    }
    /**
     * Represents the property provider service base class.
     */
    class Service implements Contract {
        properties: KnockoutObservableArray<PropertyDefinition>;
        /**
         * Initialize a new instance of the security service.
         */
        constructor();
        /**
         * Sets a property to the result property set.
         */
        setProperty(property: string, value: any): void;
    }
}

// FILE: MsPortalFx\ViewModels\Services\ResourceTypes.d.ts
declare module MsPortalFx.ViewModels {
    module Services.ResourceTypes {
        /**
         * Determines if a given resource is a tenant level resource.
         *
         * @deprecated Services.ResourceTypes.isTenantResource 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isTenantResource(resource))
         *
         * becomes: if (ArmId.parse(resource).kind === ArmId.Kind.TenantResource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resource The resource to check.
         * @returns Boolean true if the resource is a tenant level resource, otherwise false.
         */
        const isTenantResource: (resource: string) => boolean;
        /**
         * Determines if a given ID is a subscription ID.
         * Eg: /subscriptions/sub123
         *
         * @deprecated Services.ResourceTypes.isSubscriptionId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isSubscriptionId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @returns Boolean true if the ID is a resource group ID, otherwise false.
         */
        const isSubscriptionId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource group ID.
         * Eg: /subscriptions/sub123/resourceGroups/rg123
         *
         * @deprecated Services.ResourceTypes.isResourceGroupId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isResourceGroupId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @returns Boolean true if the ID is a resource group ID, otherwise false.
         */
        const isResourceGroupId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource ID.
         * Eg: /subscriptions/sub123/resourceGroups/rg123/providers/pro123/type123/res123
         *     /subscriptions/sub123/resourceGroups/rg123/providers/pro123/type123/res123[/type456/res456[/type789/res789[...]]]
         *
         * @deprecated Services.ResourceTypes.isResourceId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isResourceId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.Resource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @returns Boolean true if the ID is a resource ID, otherwise false.
         */
        const isResourceId: (id: string) => boolean;
        /**
         * Determines if a given ID is a deployment ID.
         * Supports ids of the form:
         * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
         * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
         *
         * @deprecated Services.ResourceTypes.isDeploymentId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * Deployments are ARM resources with a specific provider and resource type.  You need to check that the:
         * provider = "Microsoft.Resources"
         * resourceTypes = ["deployments"]
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @returns Boolean true if the ID is a deployment ID, otherwise false.
         */
        function isDeploymentId(id: string): boolean;
        /**
         * Determines if a given ID is a tag ID.
         *
         * @deprecated Services.ResourceTypes.isTagId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * recipe: if (isTagId(id))
         *
         * becomes: if (ArmId.parse(id).kind === ArmId.Kind.SubscriptionTagValue)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @returns Boolean true if the ID is a tag ID, otherwise false.
         */
        const isTagId: (id: string) => boolean;
        /**
         * Determines if a given ID is a resource manager ID. This includes resource IDs, resource group IDs,
         * subscription IDs, deployment IDs and tag IDs.
         *
         * @deprecated Services.ResourceTypes.isResourceManagerId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * For resource manager ID, it is simple enough to check is the parsed kind is not invalid:
         *
         * if (ArmId.parse(id).kind !== ArmId.Kind.Invalid) {
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to check.
         * @param supportsSecurity Optional boolean to indicate to only check for resource manager IDs which
         *                         support security (RBAC), default is false.
         * @returns Boolean true if the ID is a resource manager ID, otherwise false.
         */
        function isResourceManagerId(id: string, supportsSecurity?: boolean): boolean;
        /**
         * A resource type mapping for resource types.
         *
         * @deprecated Services.ResourceTypes.MappingContract 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface MappingContract extends Obsolete {
        }
        /**
         * Enum to indicate the current resource status.
         *
         * @deprecated Services.ResourceTypes.ResourceStatus 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type ResourceStatus = Obsolete;
        /**
         * The resource type mapping rejection reason enumeration provides named constants for rejection reason.
         *
         * @deprecated Services.ResourceTypes.MappingRejectionReason 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type MappingRejectionReason = Obsolete;
        /**
         * The resource type mapping rejection interface provides the contract for rejections on the resource type mapping
         * view model.
         *
         * @deprecated Services.ResourceTypes.MappingRejection 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type MappingRejection = Obsolete;
        /**
         * The resource type contract for returning resource type information.
         *
         * @deprecated Services.ResourceTypes.Contract 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type Contract = Obsolete;
        /**
         * Deprecated.
         *
         * @deprecated Services.ResourceTypes.IService 04/30/2020 - No longer supported. This is no longer used and it is safe to remove from your code.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        type IService = Obsolete;
        /**
         * Deprecated.
         *
         * @deprecated Services.ResourceTypes.ISubscriptionDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface ISubscriptionDescriptor {
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription: string;
        }
        /**
         * Deprecated
         *
         * @deprecated Services.ResourceTypes.IResourceGroupDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceGroupDescriptor extends ISubscriptionDescriptor {
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup: string;
        }
        /**
         * Base interface for ARM entities.
         *
         * @deprecated Services.ResourceTypes.IResourceManagerDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceManagerDescriptor {
            /**
             * The provider name for the resource.
             */
            readonly provider: string;
            /**
             * The resource name for the resource.
             */
            readonly resource?: string;
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup?: string;
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription?: string;
            /**
             * The type for the resource (this is the most nested type).
             */
            readonly type?: string;
            /**
             * The collection of types for the resource (from left-to-right from the URI).
             * This will have more than one item for nested resources, one for each level of nesting.
             */
            readonly types: ReadonlyArray<string>;
            /**
             * The collection of resource names for the resource (from left-to-right from the URI).
             * This will have more than one item for nested resources, one for each level of nesting.
             */
            readonly resources: ReadonlyArray<string>;
            /**
             * The resource map maps a partial type to a resource name.
             * For the resource ID: /subscriptions/sub123/resourceGroups/rg123/providers/prov123/type1/resource1/type2/resource2/type3/resource3
             * the map includes:
             * "prov123/type1" => resource1
             * "prov123/type1/type2" => resource2
             * "prov123/type1/type2/type3" => resource3
             */
            readonly resourceMap: StringMap<string>;
        }
        /**
         * Base interface for both tenant and subscription level resources.
         *
         * @deprecated Services.ResourceTypes.IResourceDescriptorBase 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceDescriptorBase extends IResourceManagerDescriptor {
            /**
             * The resource name for the resource.
             */
            readonly resource: string;
            /**
             * The type for the resource (this is the most nested type).
             */
            readonly type: string;
        }
        /**
         * Subscription level resources.
         *
         * @deprecated Services.ResourceTypes.IResourceDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IResourceDescriptor extends IResourceDescriptorBase, IResourceGroupDescriptor {
            /**
             * The resource group name for the resource group.
             */
            readonly resourceGroup: string;
            /**
             * The subscription ID for the resource group.
             */
            readonly subscription: string;
        }
        /**
         * Deprecated.
         *
         * @deprecated Services.ResourceTypes.IDeploymentDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface IDeploymentDescriptor extends IResourceGroupDescriptor {
            /**
             * The deployment name.
             */
            readonly deploymentName: string;
        }
        /**
         * Deprecated.
         *
         * @deprecated Services.ResourceTypes.ITagDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * ArmId interface parsed using ArmId.parse() includes all the properties listed here.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         */
        interface ITagDescriptor extends ISubscriptionDescriptor {
            /**
             * The tag name.
             */
            readonly tagName: string;
            /**
             * The tag name.
             */
            readonly tagValue: string;
        }
        /**
         * Sanitizes a resource ID to prevent PI leakage.
         *
         * @deprecated Services.ResourceTypes.sanitizeId 04/30/2020 - No longer supported. If you need to sanitize a resource ID, the ArmId functionality
         * in the Fx/ResourceManagement module includes a sanitizeId() method.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The ID to sanitize.
         * @returns The sanitized ID.
         */
        function sanitizeId(id: string): string;
        /**
         * Parses a subscription ID into a subscription descriptor.
         *
         * @deprecated Services.ResourceTypes.parseSubscriptionDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The subscription ID to parse.
         * @returns The subscription descriptor object.
         */
        const parseSubscriptionDescriptor: Func1<string, ISubscriptionDescriptor>;
        /**
         * Parses a resource group ID into a resource group descriptor.
         *
         * @deprecated Services.ResourceTypes.parseResourceGroupDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The resource group ID to parse.
         * @returns The resource group descriptor object.
         */
        const parseResourceGroupDescriptor: Func1<string, IResourceGroupDescriptor>;
        /**
         * Parses a resource ID into a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.parseResourceDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The resource ID to parse.
         * @returns The resource descriptor object.
         */
        const parseResourceDescriptor: Func1<string, IResourceDescriptor>;
        /**
         * Parses a resource manager ID into a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.parseResourceManagerDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The resource manager ID to parse.
         * @returns The resource descriptor object.
         */
        const parseResourceManagerDescriptor: Func1<string, IResourceManagerDescriptor>;
        /**
         * Parses a deployment ID into a deployment descriptor.
         *
         * Supports deployment ids of the forms:
         * /subscriptions/{subId}/resourceGroups/{rgName}/providers/Microsoft.Resources/deployments/{deploymentName}
         * /subscriptions/{subId}/resourceGroups/{rgName}/deployments/{deploymentName}
         *
         * @deprecated Services.ResourceTypes.parseDeploymentDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The deployment ID to parse.
         * @returns The deployment descriptor object.
         */
        const parseDeploymentDescriptor: Func1<string, IDeploymentDescriptor>;
        /**
         * Parses a tag ID into a tag descriptor.
         *
         * @deprecated Services.ResourceTypes.parseTagDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(id)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The tag ID to parse.
         * @returns The tag descriptor object.
         */
        const parseTagDescriptor: Func1<string, ITagDescriptor>;
        /**
         * Builds a deployment id from a subscription id, resource group name, and deployment name.
         *
         * @deprecated Services.ResourceTypes.buildDeploymentId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * Deployment IDs use:
         * provider = "Microsoft.Resources"
         * resourceTypes = ["deployments"]
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionId The subscription id for the deployment.
         * @param resourceGroupName The resource group name for the deployment.
         * @param deploymentName The deployment name for the deployment.
         * @returns The deployment id.
         */
        function buildDeploymentId(subscriptionId: string, resourceGroupName: string, deploymentName: string): string;
        /**
         * Builds a subscription ID from a subscription descriptor.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionDescriptor The subscription descriptor.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromDescriptor(subscriptionDescriptor: ISubscriptionDescriptor): string;
        /**
         * Builds a subscription ID from a resource group descriptor.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromResourceGroupDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupDescriptor The resource group descriptor.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromResourceGroupDescriptor(resourceGroupDescriptor: IResourceGroupDescriptor): string;
        /**
         * Builds a subscription ID from a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromResourceDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromResourceDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a subscription ID from a resource group ID.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromResourceGroupId 04/30/2020 - No longer supported.
         *
         * use: ArmId.stringify(ArmId.parse(resourceGroupId), ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupId The resource group ID.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromResourceGroupId(resourceGroupId: string): string;
        /**
         * Builds a subscription ID from a resource ID.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromResourceId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(ArmId.parse(resourceId), ArmId.Kind.Subscription)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The resource ID.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromResourceId(resourceId: string): string;
        /**
         * Builds a subscription ID from it's subscription.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionIdFromSubscriptionName 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: `/subscriptions/${subscription}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscription The subscription for the subscription.
         * @returns The subscription ID.
         */
        function buildSubscriptionIdFromSubscriptionName(subscription: string): string;
        /**
         * Builds a resource group ID from a resource group descriptor.
         *
         * @deprecated Services.ResourceTypes.buildResourceGroupIdFromDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupDescriptor The resource group descriptor.
         * @returns The resource group ID.
         */
        function buildResourceGroupIdFromDescriptor(resourceGroupDescriptor: IResourceGroupDescriptor): string;
        /**
         * Builds a resource group ID from a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.buildResourceGroupIdFromResourceDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The resource group ID.
         */
        function buildResourceGroupIdFromResourceDescriptor(resourceDescriptor: IResourceManagerDescriptor): string;
        /**
         * Builds a resource group ID from a resource ID.
         *
         * @deprecated Services.ResourceTypes.buildResourceGroupIdFromResourceId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(ArmId.parse(resourceId), ArmId.Kind.ResourceGroup)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The resource ID.
         * @returns The resource group ID.
         */
        function buildResourceGroupIdFromResourceId(resourceId: string): string;
        /**
         * Builds a resource group ID from it's subscription and resource group name.
         *
         * @deprecated Services.ResourceTypes.buildResourceGroupIdFromSubscriptionAndResourceGroupName 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: subscription ? `/subscriptions/${subscription}${resourceGroup ? `/resourceGroups/${resourceGroup}` : ``}` : ``
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscription The subscription for the resource group.
         * @param resourceGroup The resource group for the resource group.
         * @returns The resource group ID.
         */
        function buildResourceGroupIdFromSubscriptionAndResourceGroupName(subscription: string, resourceGroup?: string): string;
        /**
         * Builds a subscription entity ID from the subscription ID.
         *
         * @deprecated Services.ResourceTypes.buildSubscriptionFromId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: `/subscriptions/${subscription}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The subscription ID.
         * @returns The subscription entity ID.
         */
        let buildSubscriptionFromId: typeof buildSubscriptionIdFromSubscriptionName;
        /**
         * Builds a resource type from a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.buildResourceTypeFromResourceDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: armId.resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The resource type.
         */
        function buildResourceTypeFromResourceDescriptor(resourceDescriptor: IResourceManagerDescriptor): string;
        /**
         * Builds a resource type from a resource ID.
         *
         * @deprecated Services.ResourceTypes.buildResourceTypeFromResourceId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(resourceId).resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The resource ID.
         * @returns The resource type.
         */
        const buildResourceTypeFromResourceId: (resourceId: string) => string;
        /**
         * Builds a resource type from a resource manager ID.
         *
         * @deprecated Services.ResourceTypes.buildResourceTypeFromResourceManagerId 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.parse(resourceId).resourceType
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The resource ID.
         * @returns The resource type.
         */
        const buildResourceTypeFromResourceManagerId: (resourceId: string) => string;
        /**
         * Builds a resource ID from a resource descriptor.
         *
         * @deprecated Services.ResourceTypes.buildResourceIdFromDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The resource ID.
         */
        function buildResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds the topmost parent resource ID from a resource descriptor with nested types.
         * If the resource is not nested, this will return the resource id.
         *
         * @deprecated  Services.ResourceTypes.buildTopmostParentResourceIdFromDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * For the top-most parent, you need to trim the resource types and IDs to the first item only or use this code:
         *
         * `/subscriptions/${armId.subscription}/resourceGroups/${armId.resourceGroup}/providers/${armId.provider}/${armId.resourceTypes[0]}/${armId.resourceIds[0]}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The topmost parent resource ID.
         */
        function buildTopmostParentResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a parent resource ID from a resource descriptor with nested types.
         * If the resource is not nested, this will throw an error.
         *
         * @deprecated  Services.ResourceTypes.buildParentResourceIdFromDescriptor 04/30/2020 - Please use the ArmId functionality in the Fx/ResourceManagement module instead.
         *
         * use: ArmId.stringify(armId, ArmId.Kind.Resource)
         *
         * For the parent, you need to trim the last resource type and ID.
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceDescriptor The resource descriptor.
         * @returns The parent resource ID.
         */
        function buildParentResourceIdFromDescriptor(resourceDescriptor: IResourceDescriptor): string;
        /**
         * Determines if the given possible parent resource ID is a parent of the given possible child resource ID.
         *
         * @deprecated Services.ResourceTypes.isParentResource 04/30/2020 - Please use this code instead (no equivalent exists):
         *
         * use:
         * const pattern = toLowerCase(parentResourceId) + "/";
         * return startsWith(toLowerCase(childResourceId), pattern);
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param parentResourceId The possible parent resource ID.
         * @param childResourceId The given possible child resource ID.
         * @returns Boolean true if the parent resource ID was a parent of the child resource ID, else false.
         */
        function isParentResource(parentResourceId: string, childResourceId: string): boolean;
        /**
         * Builds an association tag name for the resource manager for the given resource ID with the given prefix.
         *
         * @deprecated Services.ResourceTypes.buildTagName 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * use: `${tagPrefix}:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param tagPrefix The tag prefix for the association tag (should be 'Related' or 'Link').
         * @param resourceDescriptor The resource descriptor for the resource.
         * @returns The tag name string for the link association tag.
         */
        function buildTagName(tagPrefix: string, resourceDescriptor: IResourceDescriptor): string;
        /**
         * Builds a related tag name for the resource manager for the given resource ID.
         *
         * @deprecated Services.ResourceTypes.buildRelatedTagName 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * user: `hidden-related:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourceGroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
         * @returns The tag name string for the related association tag.
         */
        const buildRelatedTagName: (resourceId: string) => string;
        /**
         * Builds a link tag name for the resource manager for the given resource ID.
         *
         * @deprecated Services.ResourceTypes.buildLinkTagName 04/30/2020 - No longer supported. This should not be used by any code but simply use this code
         * (don't parse the resource ID to a resource descriptor).
         *
         * use: `hidden-link:${resourceId}`
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The fully qualified resource ID in the format '/subscriptions/{subID}/resourceGroups/{rgID}/providers/{provID}/{type1}/{name1}[/{typeN}/{nameN}].
         * @returns The tag name string for the link association tag.
         */
        const buildLinkTagName: (resourceId: string) => string;
        /**
         * Compares two subscription ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated Services.ResourceTypes.compareSubscriptionId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (subscriptionId1.toLowerCase() === subscriptionId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionId1 The first subscription ID to compare.
         * @param subscriptionId2 The second subscription ID to compare.
         * @returns Boolean true if the subscription ID's are a match, else boolean false.
         */
        const compareSubscriptionId: (subscriptionId1: string, subscriptionId2: string) => boolean;
        /**
         * Compares two resource group ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated Services.ResourceTypes.compareResourceGroupId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (resourceGroupId1.toLowerCase() === resourceGroupId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupId1 The first resource group ID to compare.
         * @param resourceGroupId2 The second resource group ID to compare.
         * @returns Boolean true if the resource group ID's are a match, else boolean false.
         */
        const compareResourceGroupId: (resourceGroupId1: string, resourceGroupId2: string) => boolean;
        /**
         * Compares two resource ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated Services.ResourceTypes.compareResourceId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (resourceId1.toLowerCase() === resourceId2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId1 The first resource ID to compare.
         * @param resourceId2 The second resource ID to compare.
         * @returns Boolean true if the resource ID's are a match, else boolean false.
         */
        const compareResourceId: (resourceId1: string, resourceId2: string) => boolean;
        /**
         * Compares two resource manager ID's for equality using the resource manager rules of case sensitivity.
         *
         * @deprecated Services.ResourceTypes.compareResourceManagerId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * if (id1.toLowerCase() === id2.toLowerCase()) { }
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id1 The first resource manager ID to compare.
         * @param id2 The second resource manager ID to compare.
         * @returns Boolean true if the resource manager ID's are a match, else boolean false.
         */
        const compareResourceManagerId: (id1: string, id2: string) => boolean;
        /**
         * Builds a lower-case copy of the given resource group ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated Services.ResourceTypes.buildLowerCaseResourceGroupId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * resourceGroupId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupId The resource group ID to create the lower-case copy from.
         * @returns The lower-case copy of the resource group ID.
         */
        const buildLowerCaseResourceGroupId: (resourceGroupId: string) => string;
        /**
         * Builds a lower-case copy of the given subscription ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated Services.ResourceTypes.buildLowerCaseSubscriptionId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * subscriptionId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionId The subscription ID to create the lower-case copy from.
         * @returns The lower-case copy of the subscription ID.
         */
        const buildLowerCaseSubscriptionId: (subscriptionId: string) => string;
        /**
         * Builds a lower-case copy of the given resource ID using the resource manager rules of case sensitivity.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated Services.ResourceTypes.buildLowerCaseResourceId 04/30/2020 - No longer supported and no equivalent API is available.  Use this instead:
         *
         * resourceId1.toLowerCase()
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceId The resource ID to create the lower-case copy from.
         * @returns The lower-case copy of the resource ID.
         */
        const buildLowerCaseResourceId: (resourceId: string) => string;
        /**
         * Builds a resource manager key from a resource manager ID.
         * NOTE: the result ID should not be used as an ID for the resource manager or in UX, this should be used strictly
         * for indexing and comparisons.
         *
         * @deprecated Services.ResourceTypes.tryBuildResourceManagerKey 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use: ArmId.parse(id) !== ArmId.Kind.Invalid ? id.toLowerCase() : null
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param id The resource manager ID.
         * @returns The resource manager key for the ID if the ID was a valid resource manager ID, otherwise null.
         */
        function tryBuildResourceManagerKey(id: string): string;
        /**
         * Determines if the subscription contains the resource group.
         *
         * @deprecated Services.ResourceTypes.subscriptionContainsResourceGroup 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const subscriptionArmId = ArmId.parse(subscriptionId);
         * if (subscriptionArmId.subscription === ArmId.parse(resourceGroupId).subscription && subscriptionArmId.kind === ArmId.Kind.Subscription) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionId The subscription ID.
         * @param resourceGroupId The resource group ID.
         * @returns Boolean true if the subscription contains the resource group, else boolean false.
         */
        function subscriptionContainsResourceGroup(subscriptionId: string, resourceGroupId: string): boolean;
        /**
         * Determines if the subscription contains the resource.
         *
         * @deprecated Services.ResourceTypes.subscriptionContainsResource 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const subscriptionArmId = ArmId.parse(subscriptionId);
         * if (subscriptionArmId.subscription === ArmId.parse(resourceId).subscription && subscriptionArmId.kind === ArmId.Kind.Subscription) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param subscriptionId The subscription ID.
         * @param resourceId The resource ID.
         * @returns Boolean true if the subscription contains the resource, else boolean false.
         */
        function subscriptionContainsResource(subscriptionId: string, resourceId: string): boolean;
        /**
         * Determines if the resource group contains the resource.
         *
         * @deprecated Services.ResourceTypes.resourceGroupContainsResource 04/30/2020 - No longer supported. There is no clear equivalent to this API, closest is:
         *
         * use:
         * const rgArmId = ArmId.parse(resourceGroupId);
         * const resArmId = ArmId.parse(resourceId);
         * if (rgArmId.subscription === resArmId.subscription && rgArmId.resourceGroup === resArmId.resourceGroup && rgArmId.kind === ArmId.Kind.ResourceGroup) {}
         *
         * Please refer to https://aka.ms/portalfx/breaking for more details.
         * @param resourceGroupId The resource group ID.
         * @param resourceId The resource ID.
         * @returns Boolean true if the resource group contains the resource, else boolean false.
         */
        function resourceGroupContainsResource(resourceGroupId: string, resourceId: string): boolean;
    }
}

// FILE: MsPortalFx\ViewModels\Services\ResourceTypesViewModelExtender.d.ts
declare module MsPortalFx.ViewModels {
    module Services.ResourceTypes {
        /**
         * The resource part extender view model is an extender view model for the resource map and list parts.
         */
        interface ResourcePartExtenderViewModel {
            /**
             * The refresh key is used to signal the part that the cache for it's resource group or resource should be
             * invalidated. When the host changes this value, it signals the part to update.
             */
            refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
        }
        /**
         * The resource part refresh packet is the base refresh packet contract.
         */
        interface ResourcePartRefreshPacketContract {
        }
        /**
         * The resource group refresh packet is the contract for refreshing a resource group part.
         * This is used for the resource group list part and the resource group map part.
         */
        interface ResourceGroupRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The ID of the resource group to refresh.
             */
            resourceGroupId: string;
        }
        /**
         * The resource refresh packet is the contract for refreshing a resource part.
         * This is used for the resource list part.
         */
        interface ResourceRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The ID of the resource.
             */
            resourceId: any;
        }
        /**
         * The asset refresh packet is the contract for refreshing a resource part.
         * This is used for the resource map part.
         */
        interface AssetRefreshPacket extends ResourcePartRefreshPacketContract {
            /**
             * The extension name of the extension that owns the asset.
             */
            assetOwner: string;
            /**
             * The asset type of the asset.
             */
            assetType: string;
            /**
             * The ID of the asset.
             */
            assetId: any;
        }
        /**
         * The resource part extender provides a base class implementation of the resource part extender view model.
         */
        class ResourcePartExtender implements ResourcePartExtenderViewModel {
            refreshPacket: KnockoutObservableBase<ResourcePartRefreshPacketContract>;
            /**
             * Initialize a new instance of the resource part extender class.
             */
            constructor();
            /**
             * Signals a resource group refresh for resource group list part and resource group map part.
             *
             * @param resourceGroupId The ID of the resource group.
             */
            signalResourceGroupRefresh(resourceGroupId: string): void;
            /**
             * Signals a resource refresh for resource list part.
             *
             * @param resourceId The ID of the resource.
             */
            signalResourceRefresh(resourceId: string): void;
            /**
             * Signals an asset refresh for resource map part.
             *
             * @param assetOwner The extension name of the extension that owns the asset.
             * @param assetType The asset type of the asset.
             * @param assetId The ID of the asset.
             */
            signalAssetRefresh(assetOwner: string, assetType: string, assetId: any): void;
        }
    }
}

// FILE: MsPortalFx\ViewModels\Services\Security.d.ts
declare module MsPortalFx.ViewModels.Services.Security {
    /**
     * The security provider contract for a running security check.
     *
     * @deprecated Services.Security.Contract 04/30/2020 - Security provider is no longer supported and no one is using this, it is safe to
     * remove this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    type Contract = Obsolete;
    /**
     * Represents the security service base class.
     *
     * @deprecated Services.Security.Service 04/30/2020 - Security provider is no longer supported and no one is using this, it is safe to
     * remove references to this from your code.
     *
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Service {
        actions: Obsolete;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.d.ts
declare module FxImpl.ViewModels {
    /**
     * Internal interface that the shell uses to manage a selectable instance
     */
    interface SelectableState {
        /**
         * Method invoked by the shell to obtain exclusive access to the selectedValue
         */
        lock(): void;
        /**
         * Method invoked by the shell to internally change the selectedValue
         *
         * @param value New Value to assign selected value too.
         */
        setInternalSelectedValue(value: any): void;
        /**
         * Gets if the selectable is locked
         */
        isLocked(): boolean;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(extensionName: string, assetType: string, inputs: any): MsPortalFx.ViewModels.DynamicAssetSelection;
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(extensionName: string, detailBlade: string, inputs: any): MsPortalFx.ViewModels.DynamicBladeSelection;
}
declare module MsPortalFx.ViewModels {
    module Commands {
        interface Command<T> {
            /**
             * A value indicating whether or not the command can be executed.
             */
            canExecute: KnockoutObservableBase<boolean>;
            /**
             * Executes the specified command.
             *
             * @param context The context under which the command is executed.
             * @returns The promise for execution completion.
             */
            execute(context: T): Promise<any>;
        }
    }
    /**
     * A view model that represents a list of items, each of which can be selected.
     */
    interface SelectableItems<T> {
        /**
         * A list of items, each of which can be selected.
         */
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
    }
    /**
     * A view model representing an item that can be selected.
     */
    interface SelectableItem<T> {
        /**
         * Reflects whether the item is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item is currently in an activated state.
         * Activation is a further level of selection that may invoke
         * additional behavior, such as opening the 'details' view in
         * a master-details scenario.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the item currently has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservableBase<boolean>;
        /**
         * The model data.
         */
        data: T;
    }
    /**
     * A view model that represents an edited, selected item.
     */
    interface EditedItem<U> {
        /**
         * A representation of the edited item.
         */
        item: U;
        /**
         * The EditScope identifier for the edited item.
         */
        editScopeId: string;
    }
    /**
     * A view model that represents a sparse list of currently selected and/or activated items.
     */
    interface SetSelection<U> {
        /**
         * A representation of the items currently selected.
         */
        selectedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items currently activated.
         */
        activatedItems: KnockoutObservableArray<U>;
        /**
         * A representation of the items that currently have journey children that are in edited state.
         */
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
    }
    /**
     * Interface that allows extension authors to provide named parameters to SelectableSet's constructor
     */
    interface SelectableSetOptions<T, U> {
        /**
         * A list of items.
         */
        items: KnockoutObservableArray<T>;
        /**
         * A function that determines if an item matches a selection.
         */
        itemMatchesSelection?: (item: T, selection: U) => boolean;
        /**
         * A factory function that creates a selection object based on an item.
         */
        createSelection?: (item: T) => U;
        /**
         * Initial state of the view model.
         */
        initialState?: SetSelection<U>;
        /**
         * Supplies context menu commands for a data item.
         *
         * @param dataItem The data item.
         * @param commandLifetime The lifetime manager for command related allocations.
         * @returns An array of toolbar items for the data item commands.
         */
        supplyCommands?: (dataItem: T, commandLifetime: MsPortalFx.Base.LifetimeManager) => MsPortalFx.ToolbarItemContract[];
        /**
         * When set SelectableSet will not deactivate an item when it's deselected.
         */
        keepDeselectedItemsActivated?: boolean;
        /**
         * When set SelectableSet will not deselect an item when it is deactivated.
         */
        leaveSelectionOnDeactivation?: boolean;
    }
    /**
     * A view model implementation that captures both a list of selectable items as well as a separate, sparse list of
     * representations of only the currently selected items and only the currently activated items.
     */
    class SelectableSet<T, U> implements SelectableItems<T>, SetSelection<U>, MsPortalFx.Base.Disposable {
        selectableItems: KnockoutObservableArray<SelectableItem<T>>;
        selectedItems: KnockoutObservableArray<U>;
        activatedItems: KnockoutObservableArray<U>;
        itemsWithChildEdits: KnockoutObservableArray<EditedItem<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        createSelection: (item: T) => U;
        /**
         * Enables the data to be pinned in a context menu
         */
        itemsArePinnable: KnockoutObservable<boolean>;
        /**
         * The comparison function that determines how items and their corresponding selection value are related.
         */
        itemMatchesSelection: (item: T, selection: U) => boolean;
        getDefaultSelection: () => Promise<U>;
        /**
         * Utility method used to located the data item given the provided selected item
         *
         * @param selectedItem item to search for
         * @param properties list if properties to compare using deepEquals.  If omitted then itemMatchesSelection is used.
         */
        _msPortalFxFindDataItem: (selectedItem: U, properties?: string[]) => T;
        _msPortalFxHasCreateSelection: boolean;
        /**
         * This is the means by which this SelectableSet communicates a delayed Blade-opening to the Shell.  The Shell
         * proceeds to manage the opening of the delayed Blade and the eventual update to 'activatedItems'.
         */
        _msPortalFxDelayedBladeSelection: KnockoutObservable<FxImpl.ViewModels.DelayedBladeSelectionOptions<U>>;
        /**
         * Allows right-click context menu commands to produce a selection, given an item.
         */
        _msPortalFxCreateSelectionAsync: (item: T) => Promise<U>;
        /**
         * Optional method to supply toolbar items to be displayed in the context menu
         */
        _msPortalFxSupplyCommands: (dataItem: T) => MsPortalFx.ToolbarItemContract[] | Promise<MsPortalFx.ToolbarItemContract[]>;
        /**
         * This member only exists to pin the current toolbar items so the PO layer doesn't release the proxies.
         */
        _msPortalFxCurrentCommands: KnockoutObservable<ToolbarItemContract[]>;
        /**
         * For now, only FX code can plug in an async 'createDelayedBladeSelection' callback that will be preferred over
         * the synchronous 'createSelection'.
         * NOTE: This private member is set by MsPortalFx.ViewModels.Internal.SelectableSet.setCreateDelayedBladeSelection.
         */
        private _createDelayedBladeSelection;
        private _lifetime;
        /**
         * Constructs an instance of this view model.
         *
         * @param options A SelectableSetOptions options object with named properties to configure the SelectableSet.
         */
        constructor(options: SelectableSetOptions<T, U>);
        /**
         * Constructs an instance of this view model.
         *
         * @param items A list of items.
         * @param itemMatchesSelection A function that determines if an item matches a selection.
         * @param createSelection A factory function that creates a selection object based on an item.
         * @param initialState Initial state of the view model.
         * @param supplyCommands Function that supplies commands for a given data item.
         * @param keepDeselectedItemsActivated When set SelectableSet will not deactivate an item when it's deselected.
         * @param leaveSelectionOnDeactivation When set SelectableSet will not deselect an item when it is deactivated.
         */
        constructor(items: KnockoutObservableArray<T>, itemMatchesSelection?: (item: T, selection: U) => boolean, createSelection?: (item: T) => U, initialState?: SetSelection<U>, supplyCommands?: (dataItem: T, commandLifetime: MsPortalFx.Base.LifetimeManager) => MsPortalFx.ToolbarItemContract[], keepDeselectedItemsActivated?: boolean, leaveSelectionOnDeactivation?: boolean);
        /**
         * Makes all items activated if and only if they are selected.
         */
        activateAllSelectedItems(): void;
        dispose(): void;
        protected _setCreateDelayedBladeSelection(createDelayedBladeSelection: FxImpl.ViewModels.SelectableSet.CreateDelayedBladeSelection<T, U>): void;
    }
    /**
     * Options that can be supplied when instantiating Selectable<T>.
     */
    interface SelectableOptions<T> {
        /**
         * Determines whether the click target can be unselected by clicking.  Defaults to 'true'.
         */
        allowUnselect?: boolean;
        /**
         * The initial value of this view model's 'value' property when in its selected state.  Can be supplied
         * dynamically using part binding.
         */
        selectedValue?: T;
        /**
         * Determines whether the click target is initially in its selected state.  Defaults to 'false'.
         */
        isSelected?: boolean;
        /**
         * Determines whether the click target is initially in its command selected state.  Defaults to 'false'.
         */
        isCommandSelected?: boolean;
        /**
         * Determines whether the click target is initially in its activated state.  Defaults to 'false'.
         */
        isActivated?: boolean;
    }
    /**
     * Common interface that selectabe 1 and selectable 2 implementations share
     */
    interface SelectableContract<T> {
        isSelected: KnockoutObservableBase<boolean>;
        onClick: () => void;
        isCommandSelected?: KnockoutObservable<boolean>;
        isClickable(): boolean;
        value: KnockoutObservableBase<T>;
    }
    /**
     * A view model that represents a click target that is selectable.
     */
    class Selectable<T> implements MsPortalFx.Base.Disposable, SelectableContract<T> {
        /**
         * A property that will be set to the value of 'selectedValue' whenever the click target is
         * selected.  The property can be set to 'undefined' via part binding to unselect.
         */
        value: KnockoutObservableBase<T>;
        /**
         * The value to which 'value' will be set when the click target is selected.  The property can be set to
         * via part binding to dynamically change 'value' when the click target is selected.
         */
        selectedValue: KnockoutObservableBase<T>;
        /**
         * Reflects whether the click target can currently be clicked to unselect.
         */
        isClickable: KnockoutObservableBase<boolean>;
        /**
         * Reflects whether the click target is currently in a selected state.
         */
        isSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in a command selected state.
         */
        isCommandSelected: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target is currently in an activated state.
         */
        isActivated: KnockoutObservable<boolean>;
        /**
         * Reflects whether the click target has journey children that are in an edited state.
         */
        hasChildEdits: KnockoutObservable<boolean>;
        getDefaultSelection: () => Promise<T>;
        private readonly _lifetime;
        /**
         * Construct an instance of the view model.
         *
         * @param options Options to configure the instance.
         */
        constructor(options?: SelectableOptions<T>);
        dispose(): void;
        setIsSelected(initialState?: any, selectedByDefault?: boolean): void;
        /**
         * Called from a left-click event handler when the click target is clicked.
         */
        onClick(): void;
    }
}
declare module FxImpl.ViewModels {
    /**
     * Options to configure a delayed blade selection.
     */
    interface DelayedBladeSelectionOptions<TSelection> {
        /**
         * The expected size of the blade.
         */
        bladeWidth: MsPortalFx.Blades.BladeWidth;
        /**
         * Promise that resolves when the selection once it is known.
         */
        selectedValuePromise: Promise<TSelection>;
    }
    /**
     * Internal interface that represents selectable component.
     */
    class ObsoleteSelectable<TSelection> extends MsPortalFx.ViewModels.Selectable<TSelection> {
        /**
         * Informs the shell that a delayed blade selection is going to occur.
         */
        delayedBladeSelection: KnockoutObservable<DelayedBladeSelectionOptions<TSelection>>;
        constructor(options?: MsPortalFx.ViewModels.SelectableOptions<TSelection>);
    }
    module SelectableSet {
        interface CreateDelayedBladeSelection<TItem, TSelection> {
            (item: TItem): FxImpl.ViewModels.DelayedBladeSelectionOptions<TSelection>;
        }
        function setCreateDelayedBladeSelection<TItem, TSelection>(selectableSet: MsPortalFx.ViewModels.SelectableSet<TItem, TSelection>, createDelayedBladeSelection: CreateDelayedBladeSelection<TItem, TSelection>): void;
    }
}
declare module MsPortalFx.ViewModels {
    module Internal {
        /**
         * MsPortalFx.ViewModels.Internal.Selectable is obsolete.
         * Please migrate to the AMD creation pattern using Fx/Controls/OAuthButton.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        const Selectable: Obsolete;
        module SelectableSet {
            /**
             * MsPortalFx.ViewModels.Internal.SelectableSet.setCreateDelayedBladeSelection is obsolete.
             * Please migrate to the AMD creation pattern using Fx/Controls/OAuthButton.
             *
             * @see {@link https://aka.ms/portalfx/breaking} for more details.
             */
            const setCreateDelayedBladeSelection: Obsolete;
        }
    }
    /**
     * Selection that provides information about the detail blade to open dynamically.
     */
    interface DynamicSelection {
        /**
         * Object that maps to the blade inputs of the detail blade.
         */
        detailBladeInputs: Object;
        /**
         * Name of extension that contains the blade. Defaults to same extension as part that uses this selection.
         */
        extension?: string;
        /**
         * If true the blade should be opened in the context pane
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * Selection that provides detail blade name to open.
     */
    interface DynamicBladeSelection extends DynamicSelection {
        /**
         * Name of the detail blade to open.
         */
        detailBlade: string;
    }
    /**
     * Gets a dynamic blade selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param detailBlade The name of the blade.
     * @param inputs The blade inputs.
     * @returns The dynamic blade selection.
     */
    function getBladeSelection(extensionName: string, detailBlade: string, inputs: any): DynamicBladeSelection;
    /**
     * Selection that provides asset type to use to resolve detail blade to open.
     */
    interface DynamicAssetSelection extends DynamicSelection {
        /**
         * Name of asset used to retrieve the detail blade.
         */
        assetType: string;
    }
    /**
     * Gets a dynamic asset selection with an ID in the input.
     *
     * @param extensionName The name of the extension.
     * @param assetType The name of the asset type.
     * @param inputs The blade inputs.
     * @returns The dynamic asset selection.
     */
    function getAssetSelection(extensionName: string, assetType: string, inputs: any): DynamicAssetSelection;
    /**
     * Selection that provides resource ID to use to resolve detail blade to open.
     */
    interface DynamicResourceSelection extends DynamicSelection {
        /**
         * Resource ID for the selection used to retrieve the detail blade.
         */
        resourceId: string;
    }
    /**
     * A helper type pointing to all functional implementation of DynamicSelection interface.
     */
    type DynamicSelectionImpl = DynamicSelection | DynamicBladeSelection | DynamicAssetSelection | DynamicResourceSelection;
    /**
     * Compares DynamicSelection instances.
     *
     * @param selection1 The first selection
     * @param selection2 The second selection
     * @returns A boolean value reflecting whether the two selections are equal.
     */
    function equalDynamicSelections(selection1: DynamicSelection, selection2: DynamicSelection): boolean;
    interface ContextualCommands {
        /**
         * Commands for the item.
         */
        commandGroup: string;
        /**
         * Optional string that specifies the extension that owns the commands. If omitted it is
         * assumed to be the extension that defined the containing part.
         */
        commandGroupOwner?: string;
    }
    /**
     * Represents the set of operations (e.g., loading data) that a Part is currently executing.
     */
    class PartOperationList implements Base.Disposable {
        /**
         * Specifies whether or not there is at least one operation in progress.
         */
        inProgress: KnockoutComputed<boolean>;
        /**
         * Specifies whether or not at least one of the active operations is intended to block the UI.
         */
        blockingUi: KnockoutComputed<boolean>;
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType: KnockoutComputed<ShieldType>;
        private _operations;
        /**
         * Constructs an instance of PartOperationList.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager);
        dispose(): void;
        /**
         * Adds an operation to the list.
         *
         * @param promise A promise representing the operation to be added.
         * @param options Additional options describing how the operation should be visualized.
         */
        add(promise: Promise<any>, options?: PartOperationOptions): void;
        /**
         * Removes an operation from the list.
         *
         * @param promise The promise matching the operation to remove.
         */
        remove(promise: Promise<any>): void;
        /**
         * Updates the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @param options New options for the operation.
         */
        update(promise: Promise<any>, options: PartOperationOptions): void;
        /**
         * Describes the options associated with an operation list entry.
         *
         * @param promise The promise matching the operation to update.
         * @returns Options associated with the operations.
         */
        getOptionsForOperation(promise: Promise<any>): PartOperationOptions;
    }
    const enum ShieldType {
        /**
         * The shield is opaque.
         */
        Opaque = 0,
        /**
         * The shield is translucent.
         */
        Translucent = 1
    }
    interface PartOperationOptions {
        /**
         * The type of blocking shield that will appear if UI is blocked.
         */
        shieldType?: ShieldType;
    }
    /**
     * A set of options describing how an operation should be visualized.
     */
    class PartOperationOptions {
        /**
         * If true, indicates that the Part UI should be blocked (non-interactive) until the operation finishes.
         */
        blockUi: boolean;
    }
    /**
     * A view model for the content displayed in a Part.
     */
    interface PartContent {
        /**
         * Optional. Invoked by the Shell when the Part's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The Part's current set of input property values as a name/value collection.
         * @param partSettings Object with settings loaded for these set of inputs.
         * @returns A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet?(inputs: any, partSettings?: any): Promise<any>;
    }
    /**
     * A view model that is resizable.
     */
    interface Resizable {
        /**
         * Represents the size for a part.
         */
        size: KnockoutObservable<MsPortalFx.Parts.PartSize>;
    }
    /**
     * The fully qualified type name of the resource id.
     */
    const ResourceIdTypeName = "MsPortalFx.ViewModels.ResourceId";
    /**
     * The type of the resource id.
     * It is equivalent to string.
     */
    type ResourceId = string;
}

// FILE: MsPortalFx\ViewModels\ViewModels.ActionBars.d.ts
declare module MsPortalFx.ViewModels.ActionBars {
    module Base {
        /**
         * The style for the secondary link.
         */
        const enum SecondaryLinkStyle {
            /**
             * Leave the secondary link unstyled.
             */
            Unstyled = 0,
            /**
             * Shows the secondary link as a bottom banner.
             */
            BottomBanner = 1
        }
        /**
         * Specifies the status of the operation.
         */
        const enum Status {
            /**
             * Indicates that the operation in the enclosing blade is not started.
             */
            NotStarted = 0,
            /**
             * Indicates that the operation in the enclosing blade is in progress.
             */
            InProgress = 1,
            /**
             * Indicates that the operation in the enclosing blade is in an erroneous state.
             */
            Error = 2,
            /**
             * Indicates that the operation in the enclosing blade is completed.
             */
            Completed = 3
        }
        /**
         * Specifies the action to be taken.
         */
        const enum Action {
            /**
             * No action should be taken.
             */
            None = 0,
            /**
             * Go to the previous step.
             */
            Previous = 1,
            /**
             * Go to the next step.
             */
            Next = 2,
            /**
             * Skip and go to the next step.
             */
            Skip = 3,
            /**
             * Complete the wizard.
             */
            Complete = 4,
            /**
             * Cancel the action.
             */
            Cancel = 5
        }
        interface InputOutputBase {
            /**
             * The status of the operation.
             */
            status: Status;
            /**
             * The ID uniquely identifying the create step.
             */
            stepId?: string;
        }
        /**
         * Specifies the source of the action/click.
         */
        const enum ActionSource {
            /**
             * The primary/default button.
             */
            Default = 0,
            /**
             * The secondary link.
             */
            SecondaryLink = 1
        }
        interface ActionBarInput extends InputOutputBase {
            /**
             * A value indicating whether this is the first step.
             */
            isFirstStep?: boolean;
            /**
             * True if this is the last step in a create flow; else false.
             */
            isLastStep?: boolean;
            /**
             * A value indicating whether the step is optional.
             */
            isOptional?: boolean;
            /**
             * A value indicating whether or not the step is disabled.
             * This value specifies whether or not there are any prerequisite steps that have not been completed.
             */
            disabled?: boolean;
        }
        interface ActionBarOutput extends InputOutputBase {
            /**
             * The action to perform.
             */
            action: Action;
            /**
             * A unique id to track changes.
             */
            commitId?: string;
        }
        interface Contract<TInput = ActionBarInput> extends Controls.Loadable.Contract {
            /**
             * Indicates whether the blade enclosing the action bar is valid.
             */
            valid: KnockoutObservable<boolean>;
            /**
             * The input data for the current step.
             */
            input: KnockoutObservable<TInput>;
            /**
             * The data outputted by the current step.
             */
            output: KnockoutObservable<ActionBarOutput>;
        }
        /**
         * Checks if the specified wizard/form/selector action is completed.
         *
         * @param actionBarOutput The output from the action bar for the wizard/form/selector to verify.
         * @returns True if the action is completed; else false.
         */
        function isCompleted(actionBarOutput: any): boolean;
        /**
         * The view model class for Wizard portal control.
         */
        class ViewModel<TInput = ActionBarInput> extends Controls.Loadable.ViewModel implements Contract<TInput> {
            valid: KnockoutObservable<boolean>;
            input: KnockoutObservable<TInput>;
            output: KnockoutObservable<ActionBarOutput>;
            onInputsSet(inputs: any): Promise<any>;
        }
    }
    module ErrorInfoBoxActionBar {
        interface AsyncValidationResult extends ValidationResult {
            /**
             * Blade to open from the infobox
             */
            blade?: DynamicBladeSelection;
        }
        interface AsyncValidation {
            /**
             * Validation function returning a ValidationResult promise.
             *
             * @param source The source of the click (e.g. default button, secondary link, etc.).
             * @returns A promise resolved with an async validation result object.
             */
            validate: (source: Base.ActionSource) => Promise<AsyncValidationResult>;
        }
        interface GroupValidation extends AsyncValidation {
        }
        interface Contract<TInput = Base.ActionBarInput> extends Base.Contract<TInput> {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox?: KnockoutObservable<boolean>;
            /**
             * If defined, the action bar will run this validation in addition to the form validation before submitting
             */
            groupValidation?: GroupValidation;
            /**
             * The action bar will run these validations (in addition to the form validation) before submitting.
             */
            asyncValidations: AsyncValidation[];
        }
        class ViewModel<TInput = Base.ActionBarInput> extends Base.ViewModel<TInput> implements Contract<TInput> {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox: KnockoutObservable<boolean>;
            /**
             * Hide the infobox when it shows the group validation error message
             */
            clearGroupValidationMessage(): void;
            /**
             * InfoBox selectable
             */
            infoBoxSelectable: MsPortalFx.ViewModels.Selectable<MsPortalFx.ViewModels.DynamicBladeSelection>;
            /**
             * Internal - handle to clear group validation message
             */
            _msPortalFxClearGroupValidationMessage: KnockoutObservable<() => void>;
            /**
             * The action bar will run these validations (in addition to the form validation) before submitting.
             */
            asyncValidations: AsyncValidation[];
            /**
             * If defined, the action bar will run this validation in addition to the form validation before submitting
             */
            groupValidation: GroupValidation;
        }
    }
    module DeleteActionBar {
        /**
         * The actionbar output of the delete asset confirmation blade.
         */
        interface ActionBarOutput extends Base.ActionBarOutput {
            /**
             * The identifier of the user actions on the action bar.
             */
            userActionId: string;
        }
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the save button is clicked.
             */
            deleteButtonClick(): void;
            /**
             * Callback to execute when the save button is clicked.
             */
            cancelButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            deleteButtonClick(): void;
            cancelButtonClick(): void;
            private _onButtonClicked;
        }
    }
    module FormActionBar {
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the save button is clicked.
             */
            saveButtonClick(): void;
            /**
             * Callback to execute when the save button is clicked.
             */
            discardButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            saveButtonClick(): void;
            discardButtonClick(): void;
        }
    }
    module FilterActionBar {
        interface Contract extends Base.Contract {
            /**
             * Callback to execute when the update button is clicked.
             */
            updateButtonClick(): void;
            /**
             * Callback to execute when the reset button is clicked.
             */
            resetButtonClick(): void;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            /**
             * Callback to execute when the update button is clicked.
             */
            updateButtonClick(): void;
            /**
             * Callback to execute when the reset button is clicked.
             */
            resetButtonClick(): void;
        }
    }
    module GenericActionBar {
        import SecondaryLinkStyle = Base.SecondaryLinkStyle;
        interface ActionBarOutput extends Base.ActionBarOutput {
            /**
             * An optional link text used in create action bar scenarios.
             */
            secondaryLinkClicked?: string;
        }
        interface Contract extends ErrorInfoBoxActionBar.Contract {
            /**
             * The display text for the action button.
             */
            actionButtonLabel?: KnockoutObservable<string>;
            /**
             * If defined, clicking the action button will also launch a URI in a new window.
             * NOTE : this feature is not compatible with groupValidation & asyncValidations
             */
            actionButtonUri?: KnockoutObservable<string>;
            /**
             * If defined, specifies the value of the strWindowFeatures parameter to the
             * window.open call used to open the actionButtonUri.
             */
            actionButtonUriWindowFeatures?: KnockoutObservable<string>;
            /**
             * The summary html displayed on top of the action button.
             */
            actionSummaryHtml?: KnockoutObservable<string>;
            /**
             * Callback to execute when the action button is clicked.
             */
            actionButtonClick(): void;
            /**
             * @deprecated Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
             */
            allowToggleProvisioningLocation?: KnockoutObservable<boolean>;
            /**
             * The display text for the link to the right of the create button.
             */
            secondaryLinkDisplayText: KnockoutObservable<string>;
            /**
             * Boolean indicating if clicking on the secondary link should trigger validation.
             */
            secondaryLinkTriggerValidation?: KnockoutObservable<boolean>;
            /**
             * The display style for the link to the right of the create button.
             * The link can also be styled to show at the bottom as a banner, or other value according to the enum.
             */
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
        }
        class ViewModel extends ErrorInfoBoxActionBar.ViewModel implements Contract {
            /**
             * Displays the error info box when the primary button is clicked and the form is invalid.
             */
            enableErrorInfoBox: KnockoutObservable<boolean>;
            actionButtonLabel: KnockoutObservable<string>;
            actionButtonUri: KnockoutObservable<string>;
            actionButtonUriWindowFeatures: KnockoutObservable<string>;
            actionSummaryHtml: KnockoutObservable<string>;
            actionButtonClick(): void;
            allowToggleProvisioningLocation: KnockoutObservable<boolean>;
            secondaryLinkDisplayText: KnockoutObservable<string>;
            secondaryLinkTriggerValidation: KnockoutObservable<boolean>;
            secondaryLinkStyle: KnockoutObservable<SecondaryLinkStyle>;
            onInputsSet(inputs: any): Promise<any>;
        }
    }
    /**
     * Obsolete. Please use `import { DoesProvisioning } from "Fx/Composition/TemplateBlade";` http://aka.ms/portalfx/breaking
     */
    module CreateActionBar {
        type ActionButtonText = Obsolete;
        type SecondaryLinkStyle = Obsolete;
        type ActionBarInput = Obsolete;
        type ActionBarOutput = Obsolete;
        type Options = Obsolete;
        type Contract = Obsolete;
        const ViewModel: Obsolete;
    }
    module PickerActionBar {
        interface Contract extends Base.Contract {
            /**
             * Triggers the select action.
             */
            triggerSelectAction: KnockoutObservable<string>;
            /**
             * The summary and/or link to the EULA.
             */
            eula: KnockoutObservable<string>;
            /**
             * Indicates if the associated picker supports multiselect.
             */
            showSelectButton: KnockoutObservable<boolean>;
            /**
             * Optional. An alternate text to use for the select button label.
             */
            selectButtonText?: KnockoutObservable<string>;
        }
        class ViewModel extends Base.ViewModel implements Contract {
            triggerSelectAction: KnockoutObservable<string>;
            eula: KnockoutObservable<string>;
            showSelectButton: KnockoutObservable<boolean>;
            selectButtonText: KnockoutObservable<string>;
            onInputsSet(inputs: any): Promise<any>;
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.AppBlade.d.ts
declare module MsPortalFx.ViewModels.AppBlade {
    import ViewModels = MsPortalFx.ViewModels;
    import FxContainerContract = ViewModels.ContainerContract;
    /**
     * The options of the app blade.
     */
    interface Options {
        source: string;
    }
    type MessageHandler = (data: any) => void;
    /**
     * The message envelope.
     */
    class Message {
        /**
         * The message signature.
         */
        signature: string;
        /**
         * The message kind.
         */
        kind: string;
        /**
         * The message data.
         */
        data: any;
        constructor(kind: string, data?: any);
    }
    /**
     * The view model of the app blade.
     */
    class ViewModel extends ViewModels.Blade {
        private iFrame;
        private _handlers;
        private _queue;
        constructor(container: FxContainerContract, options: Options);
        postMessage(message: Message): void;
        on(kind: string, callback: MessageHandler): void;
        off(kind: string, callback: MessageHandler): void;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Blade.d.ts
declare module MsPortalFx.ViewModels {
    import FxViewModels = MsPortalFx.ViewModels;
    import FxBase = MsPortalFx.Base;
    /**
     * The status bar of the blade.
     */
    interface BladeStatusBar {
        /**
         * The text to display in the blade's status bar.
         */
        text: string;
        /**
         * The state of the blade.
         */
        state: FxViewModels.ContentState;
        /**
         * The blade selection that blade's status bar can activate.
         */
        selection?: FxViewModels.DynamicSelectionImpl;
        /**
         * The callback executed whenever the status bar is activated.
         */
        onActivated?: (() => void) | ClickableLinkContract;
    }
    /**
     * A view model for a Blade.
     */
    interface BladeContract {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle?: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description?: KnockoutObservableBase<string>;
        /**
         * The help uri of the blade.
         */
        helpUri?: KnockoutObservableBase<string>;
        /**
         * The SVG of the icon to display for the given blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri?: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar?: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState?: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText?: KnockoutObservableBase<string>;
    }
    /**
     * Defines an entity that contains a title and subtitle.
     */
    interface ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
    }
    /**
     * Defines attributes used to configure a blade hosted within a menu blade.
     */
    interface HostedInMenuBlade {
        /**
         * Defines attributes to use when the blade is displayed as the content of a menu blade.
         */
        menuContent: ItemWithTitleAndSubtitle;
    }
    /**
     * A view model class that respresents a Blade.
     */
    class Blade implements BladeContract, ItemWithTitleAndSubtitle {
        /**
         * The displayed title of the blade.
         */
        title: KnockoutObservableBase<string>;
        /**
         * The displayed subtitle of the blade.
         */
        subtitle: KnockoutObservableBase<string>;
        /**
         * The displayed description of the blade.
         */
        description: KnockoutObservableBase<string>;
        /**
         * The learn more link provided in the description of the blade.
         */
        helpUri: KnockoutObservable<string>;
        /**
         * The SVG of the image in the title of the blade.
         */
        icon: KnockoutObservableBase<FxBase.Image>;
        /**
         * The URI of the image in the title of the blade.
         */
        titleImageUri: KnockoutObservableBase<string>;
        /**
         * The status bar of the blade. The default value is null.
         * Once initialized, it will take precedence over contentState and contentStateDisplayText.
         */
        statusBar: KnockoutObservableBase<BladeStatusBar>;
        /**
         * The content state of the blade.
         */
        contentState: KnockoutObservableBase<FxViewModels.ContentState>;
        /**
         * The text to display in the blade's status bar.
         */
        contentStateDisplayText: KnockoutObservableBase<string>;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.BladeCaller.d.ts
declare module MsPortalFx.ViewModels.Internal {
    /**
     * Describes options for constructing a BladeCaller.
     */
    interface BladeCallerOptions<TParams, TResult, TSelectable> {
        /**
         * A selectable that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectableSet'.
         */
        invokeOnSelectable?: MsPortalFx.ViewModels.SelectableContract<TSelectable>;
        /**
         * A selectable set that, when selected, causes the child blade to be invoked.
         *
         * This option is mutually exclusive with 'invokeOnSelectable'.
         */
        invokeOnSelectableSet?: MsPortalFx.ViewModels.SelectableSet<TSelectable, any>;
        /**
         * A callback that supplies parameters for a child blade that is being opened.
         *
         * @param activatedItem The object that has been activated, causing this blade call to begin.
         * @returns The parameters to supply.
         */
        supplyParams(activatedItem: TSelectable): TParams;
        /**
         * A callback that receives result values from the called child blade.
         *
         * @param result The result value sent from the child blade.
         * @param activatedItem The object that was activated when the blade call began. The result refers to that object.
         */
        receiveResult(result: TResult, activatedItem: TSelectable): void;
        /**
         * If true the blade is always invoked regardless of the selectable state.
         * This is for internal shell use.
         */
        forceInvocation?: boolean;
    }
    /**
     * Describes options for constructing a BladeCallable.
     */
    interface BladeCallableOptions<TParams, TResult> {
        "--noUnusedLocals"?: TResult | any;
        /**
         * A callback that receives parameter values from the parent blade.
         *
         * @param params The parameter values received from the parent blade.
         */
        receiveParams(params: TParams): void;
    }
    /**
     * Determines if the given Part/Blade/Command input is one injected by the FX BladeCaller component.
     *
     * @param inputName The name of the input.
     * @returns A boolean reflecting whether this input is an injected BladeCaller input.
     */
    function isBladeCallerInput(propertyName: string): boolean;
    /**
     * A viewmodel that can call a child blade, i.e., supply parameters to it and
     * receive result values.
     */
    class BladeCaller<TParams, TResult, TSelectable> {
        private internal_bladeCallId;
        private internal_bladeCallerParams;
        /**
         * Constructs an instance of BladeCaller.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCaller.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.InputsCallbacksRegistrar, options: BladeCallerOptions<TParams, TResult, TSelectable>);
    }
    /**
     * A viewmodel that can be called by a parent part or other composition item. It
     * can receive parameters from the parent, and send back results to it.
     */
    class BladeCallable<TParams, TResult> {
        private _bladeCallId;
        private internal_bladeCallerResult;
        /**
         * Constructs an instance of BladeCallable.
         *
         * @param container The container instance associated with the part or other composition element hosting this BladeCallable.
         * @param options Options for the instance.
         */
        constructor(container: MsPortalFx.ViewModels.ContainerContract, options: BladeCallableOptions<TParams, TResult>);
        /**
         * Sends a result value back to the associated BladeCaller.
         *
         * @param result The result to send.
         */
        sendResult(result: TResult): void;
    }
    /**
     * Represents binding inputs that a blade callback expects to receive from its caller.
     */
    interface BladeCallableInputs<TParams> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        internal_bladeCallId: number;
        /**
         * Parameters sent from the BladeCaller to its child blade.
         */
        internal_bladeCallerParams: TParams;
    }
    /**
     * A message sent from a child blade to its parent BladeCaller.
     */
    interface BladeCallableResultMessage<TResult> {
        /**
         * The unique ID representing the blade call. This is used to ensure that, later,
         * the child blade's output is directed to the correct BladeCaller, and that the
         * BladeCaller doesn't accept more than one result per call.
         */
        bladeCallId: number;
        /**
         * The result value sent from the child blade to its parent BladeCaller.
         */
        result: TResult;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Command.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxNet = FxBase.Net2;
    import FxImage = FxBase.Image;
    /**
     * Command execution status.
     */
    const enum CommandStatus {
        /**
         * Command is not executing or displaying a message.
         */
        None = 0,
        /**
         * Command is in the process of executing. Command may display dialogs
         * in the blade while in an executing state.
         */
        Executing = 1
    }
    const enum FileDownloadType {
        /**
         * Download file is a text file
         */
        Text = 1,
        /**
         * Download file is a binary file
         */
        Binary = 2
    }
    interface UriCallbackConfirmationDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        uriCallbackProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        uriCallbackProgressText?: string;
        /**
         * MessageBox title string to indicate if file should be downloaded or canceled.
         */
        downloadTitle?: string;
        /**
         * MessageBox description string to indicate if file should be downloaded or canceled.
         */
        downloadText?: string;
        /**
         * MessageBox default button text.
         */
        defaultButtonText?: string;
        /**
         * MessageBox cancel button text.
         */
        cancelButtonText?: string;
    }
    interface DownloadProgressDialogOptions {
        /**
         * ProgressBox title string to indicate uri callback is in progress.
         */
        downloadProgressTitle?: string;
        /**
         * ProgressBox description string to indicate uri callback is in progress.
         */
        downloadProgressText?: string;
    }
    /**
     * Error notification messages for uri callback errors.
     * When uri callback error fails, reject the promise and provide the needed error messages and it will be shown in the hubs notification.
     */
    interface UriCallbackErrorMessage {
        /**
         * Optionally specify the title text for error notification message.
         */
        title?: string;
        /**
         * Optionally specify the description text for error notification message.
         */
        description?: string;
    }
    /**
     * View model
     */
    interface CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon?: KnockoutObservableBase<FxBase.Image>;
        /**
         * Text for the command.
         */
        text?: KnockoutObservableBase<string>;
        /**
         * Optional. Sets a label alternative used by accessibility tools.
         */
        ariaLabel?: KnockoutObservableBase<string>;
        /**
         * Tooltip for the command.
         */
        tooltip?: KnockoutObservableBase<string>;
    }
    /**
     * A view model for the command container.
     */
    interface CommandContainerContract extends MsPortalFx.ViewModels.ContainerContract {
        /**
         * View model reflecting the selection state of the Command. The value is null if the command is not selectable.
         */
        selectable?: Selectable<any>;
    }
    /**
     * A view model for the command container.
     */
    class CommandContainerContract {
    }
    /**
     * A view model that respresents an executable command.
     */
    interface CommandContract extends CommandBaseContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<CommandStatus>;
        /**
         * Function called when command is executed.
         *
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user. Will be cleared if the message box is dismissed without
         * a button being clicked. If a message box button is clicked messageBoxClick() function
         * will be called.
         */
        dialog?: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick?(result: Dialogs.DialogResult): void;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
    }
    /**
     * Interface for a command that launches a URI.
     */
    interface UriCallbackCommandContract extends CommandBaseContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback?: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget?: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
    }
    /**
     * Interface for a command that opens a dropdown menu of items.
     */
    interface ListCommandContract extends CommandBaseContract {
        /**
         * Items that will be displayed when the ListCommand is open.
         */
        listItems: KnockoutObservableArray<string>;
        /**
         * Text of the selected item. We use the text as the key.
         */
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Interface for a command that defines its type and behavior dynamically.
     */
    interface DynamicCommandContract extends CommandBaseContract {
        /**
         * The view model of the nested command.
         */
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * Interface for a command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandContract extends CommandBaseContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * A callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is set, then the targetUri property is not used.
         */
        targetUriCallback?: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Optionally specify GET or POST type for the http request. Default is GET.
         */
        httpMethod?: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType?: KnockoutObservableBase<string>;
        /**
         * Specify set of http headers to be included in the request.
         */
        headers?: KnockoutObservableBase<StringMap<any>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage?: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType?: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions?: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog?: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions?: DownloadProgressDialogOptions;
    }
    /**
     * Interface for a command that opens a blade.
     */
    interface OpenBladeCommandContract extends CommandBaseContract {
    }
    /**
     * Abstract base class for Commands and UriCommands.
     */
    class CommandBase implements CommandBaseContract {
        /**
         * Whether the command is enabled.
         */
        enabled: KnockoutObservableBase<boolean>;
        /**
         * Icon object for the command.
         */
        icon: KnockoutObservableBase<FxImage>;
        /**
         * Text for the command.
         */
        text: KnockoutObservableBase<string>;
        /**
         * Optional. Sets a label alternative used by accessibility tools.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * Tooltip for the command.
         */
        tooltip: KnockoutObservableBase<string>;
    }
    /**
     * Base class for executable commands.
     */
    class Command extends CommandBase implements CommandContract {
        /**
         * Status of the command execution.
         */
        status: KnockoutObservableBase<MsPortalFx.ViewModels.CommandStatus>;
        /**
         * Function called when command is executed.
         *
         * @param formValid Contains the validation status of form elements contained within the command's blade or part.
         */
        execute(formValid?: boolean): void;
        /**
         * Dialog box shown to user.
         *
         * If a message box button is clicked then the 'dialogClick()' function will be called.
         *
         * If the message box is dismissed without a button being clicked, you should ensure to set your
         * CommandStatus to None and also null out this dialog instance.
         */
        dialog: KnockoutObservableBase<Dialogs.Dialog>;
        /**
         * Function called when a message box button is clicked.
         *
         * @param result Contains the result of the user interaction with the dialog.
         */
        dialogClick(result: Dialogs.DialogResult): void;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCommand extends CommandBase implements UriCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
    }
    /**
     * Base class for commands which launch URIs.
     */
    class UriCallbackCommand extends CommandBase implements UriCallbackCommandContract {
        /**
         * URI that will be navigated to when the command is clicked.
         */
        navigateUri: KnockoutObservableBase<string>;
        /**
         * Optional callback to dynamically generate navigate uri when the command is clicked.
         * If this callback is provided, navigateUri will not be used.
         */
        navigateUriCallback: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Optional target for the link. If omitted _blank is used.
         */
        navigateTarget: KnockoutObservableBase<string>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
    }
    /**
     * Base class for a command that opens a dropdown menu of items.
     */
    class ListCommand extends CommandBase implements ListCommandContract {
        listItems: KnockoutObservableArray<string>;
        selectedItem: KnockoutObservable<string>;
    }
    /**
     * Base class for a command that defines its type and behavior dynamically.
     */
    class DynamicCommand extends CommandBase implements DynamicCommandContract {
        viewModel: KnockoutObservableBase<CommandBaseContract>;
    }
    /**
     * File download status with http response codes.
     */
    class FileDownloadStatus {
        /**
         * Indicates the file download status category.
         * Status string will have the AJAX response status ("success", "notmodified", "error", "timeout", "abort", or "parsererror").
         */
        status: string;
        /**
         * Indicates the file download status code which are standard http response code.
         */
        statusCode: number;
        /**
         * Indicates the error message returned by the AJAX call.
         */
        errorMessage: string;
        constructor(status: string, statusCode: number, errorMessage?: string);
    }
    /**
     * Options for command that launches a file download specified by the URI.
     */
    interface FileDownloadCommandOptions {
        authorizationOptions?: FxNet.AuthorizationOptions;
    }
    /**
     * Command class for launching a file download specified by the URI.
     */
    class FileDownloadCommand extends CommandBase implements FileDownloadCommandContract {
        /**
         * URI for the file download.
         */
        targetUri: KnockoutObservableBase<string>;
        /**
         * Optionally specify a callback to set the targetUri of the file download dynamically if the target URI is not known when
         * the command is clicked. This can be used if the target URI needs to be generated only when the user initiates a
         * click on the file download command. If this is defined, then the targetUri property is not used.
         */
        targetUriCallback: KnockoutObservableBase<() => Promise<string>>;
        /**
         * Specify GET or POST type for the http request.
         */
        httpMethod: KnockoutObservableBase<string>;
        /**
         * Optionally specify a JSON request body. Valid only for POST requests.
         */
        httpRequestContent: KnockoutObservable<string>;
        /**
         * Optionally specify the request content type. Valid only when a httpRequestContent is also specified.
         * This should be of the form 'text/plain', 'application/json', etc.
         * If not specified, will default to 'application/json'.
         */
        httpRequestContentType: KnockoutObservable<string>;
        /**
         * Optionally specify set of http headers to be included in the request.
         */
        headers: KnockoutObservableBase<StringMap<string>>;
        /**
         * Optionally specify the authorization token. This token will override any other auth header specified in the headers property.
         */
        authorizationToken: KnockoutObservableBase<string>;
        /**
         * Optionally specify the target filename for the downloaded file.
         * Servers may not add the filename in Content-Disposition header and the targetFileName will be used to save the downloaded file.
         */
        targetFileName: KnockoutObservableBase<string>;
        /**
         * Optionally specify the error message when file download fails.
         * This error message will be used to send notification to the user along with internal http status code.
         * If this error message is not specified, a default file download error message will be used for notification.
         */
        errorMessage: KnockoutObservableBase<string>;
        /**
         * Optionally specify the type of file to download. If no file type is specified, the default file type is 'text'
         */
        downloadType: KnockoutObservableBase<FileDownloadType>;
        /**
         * File download status with standard http response codes will be updated based on the file download ajax call response.
         * When command is executing and downloading the file, the downloadStatus will be set to null.
         */
        downloadStatus: KnockoutObservableBase<FileDownloadStatus>;
        /**
         * Optionally specify if uri callback progress and download confirmation dialog should be shown.
         * If uri callback is specified and if this option is enabled, a progress dialog will be shown till the uri callback returns.
         * A message box dialog is shown to confrim downloading the file or cancel the download.
         */
        showUriCallbackConfirmationDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for uri callback progress and confirmation dialogs.
         */
        uriCallbackConfirmationDialogOptions: UriCallbackConfirmationDialogOptions;
        /**
         * Optionally specify if download progress dialog should be shown.
         * When this option is enabled, a progress box dialog is shown till the file is download is completed.
         */
        showDownloadProgressDialog: KnockoutObservableBase<boolean>;
        /**
         * Optionally specify the resource strings for download progress dialog.
         */
        downloadProgressDialogOptions: DownloadProgressDialogOptions;
        /**
         * FileDownload command constructor.
         *
         * @param container Boolean flag or authorization options to indicate if authorization token needs to be feteched and updated in authorizationToken.
         */
        constructor(addDefaultAuthorizationToken?: FileDownloadCommandOptions | boolean);
    }
    /**
     * Base class for commands that launches detail blades.
     */
    class OpenBladeCommand extends CommandBase implements OpenBladeCommandContract {
        /**
         * Initializes a new instance of a command that can launch new blades.
         *
         * @param container The view model for the UI representation of the command.
         */
        constructor(container: CommandContainerContract);
        /**
         * Creates a Selectable view model optionally initialized with a selectable value.
         *
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @returns A Selectable view model instance.
         */
        static createSelectableViewModel(selectedValue?: any): Selectable<any>;
    }
    module Commands.Dynamic {
        import FxViewModels = MsPortalFx.ViewModels;
        /**
         * Interface for a command that opens a blade and is instantiated by a dynamic command.
         */
        interface OpenBladeCommandContract extends FxViewModels.OpenBladeCommandContract {
            /**
             * Defines a blade name.
             */
            bladeName: string;
            /**
             * Defines blade inputs.
             */
            bladeInputs: Object;
        }
        /**
         * Base class for commands that launches detail blades and is instantiated dynamically.
         */
        class OpenBladeCommand extends FxViewModels.OpenBladeCommand implements OpenBladeCommandContract {
            bladeName: string;
            bladeInputs: Object;
            /**
             * Initializes a new instance of a command that can launch new blades.
             *
             * @param container The view model for the UI representation of the command.
             */
            constructor(container: CommandContainerContract);
        }
        /**
         * Command class for launching a file download specified by the URI that is instantiated dynamically.
         */
        class FileDownloadCommand extends FxViewModels.FileDownloadCommand {
            constructor();
        }
        /**
         * Base class for executable dynamic commands.
         */
        class ExecutableCommand extends FxViewModels.Command {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCallbackCommand extends FxViewModels.UriCallbackCommand {
            constructor();
        }
        /**
         * Base class for commands which launch URIs dynamically.
         */
        class UriCommand extends FxViewModels.UriCommand {
            constructor();
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Container.d.ts
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxCompositionSelectable = FxImpl.Composition.Selectable;
    /**
     * A callback that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallback {
        (inputs: any, settings?: any): Promise<any>;
    }
    /**
     * Details of an error that are displayed to customers along with extra data for support ticket.
     */
    interface ErrorOptions {
        /**
         * A user friendly message for the error that happened, either as a string or HtmlContent.
         * The message only shows on Blade, and expanded error view from Part.
         */
        message: string | HtmlContent;
        /**
         * The HTTP error code most closely associated with the error.
         */
        code?: number;
        /**
         * Free form text to provide in depth details of the error, elaborating upon the content of the friendly
         * error message. This can be things like raw error message, inner errors, etc. Keep content user readable
         * though, this isn't for cryptic system details.
         */
        details?: string | HtmlContent;
        /**
         * Additional key/value pair collection of summary items that will be visible to the portal user.
         * These items will be sent to the support ticket.
         *
         * By default, the following items will be included and populated by the framework:
         *     - Session ID
         *     - Resource ID (if applicable)
         *     - Extension Name
         *     - Part/Blade Name
         *     - Error code (if provided, with default fallback when possible for NotFound/Unauthorized calls)
         *     - Details (if provided)
         */
        summaryItems?: {
            /**
             * The label displayed for summary item.
             */
            label: string;
            /**
             * The value displayed for summary item.
             */
            value: string;
        }[];
        /**
         * Any extra metadata which the extension author wants to include in a support ticket to help investigation.
         * The object will be JSON stringified so it later can be parsed back for readability, log, and data analysis purposes.
         *
         * This metadata isn't visible on screen but is available via other mechanisms, including "copy to clipboard" and "create support ticket".
         * As such, this metadata should not contain personally identifiable information (PII). Caller is responsible to do this treatment.
         */
        metadata?: any;
        /**
         * Optional error associated with the failure.  This is for diagnostics only and is not displayed to the customer.
         */
        error?: Error;
    }
    /**
     * A registry of callbacks that will be invoked when new inputs are available for the composition item.
     */
    interface OnInputsSetCallbacks extends MsPortalFx.Base.Disposable {
        /**
         * Adds a callback to be invoked whenever new inputs are available.
         *
         * @param callback The callback to be invoked whenever new inputs are available.
         * @param invokeIfPreviousInputsPassed  If true and the callback is added after onInputsSet was invoked, then the callback is invoked immediately
         */
        add(callback: OnInputsSetCallback, invokeIfPreviousInputsPassed?: boolean): void;
        /**
         * Removes a callback from the registry, so it will no longer be invoked when new inputs are available.
         *
         * @param callback The callback to be removed.
         */
        remove(callback: OnInputsSetCallback): void;
        /**
         * Invokes any registered onInputsSet callbacks, returning a promise representing the
         * asynchronous completion of all the callbacks.
         *
         * @param inputs Inputs to supply to the callbacks.
         * @param settings Settings values to supply to the callbacks.
         * @returns If any callbacks are registered and return a promise, returns a promise that represents their aggregate completion. Otherwise, returns null.
         */
        triggerCallbacks(inputs: any, settings: any): Promise<any>;
    }
    enum NoticeImageType {
        /**
         * Default image.
         */
        Default = 0,
        /**
         * Image for coming soon.
         */
        ComingSoon = 1,
        /**
         * Image for no subscription.
         */
        NoSubscription = 2,
        /**
         * Image for unauthorized.
         */
        Unauthorized = 3
    }
    /**
     * The options for the notice blade.
     */
    interface NoticeOptions {
        /**
         * The header of the notice.
         */
        noticeHeader?: string;
        /**
         * The title of the notice.
         */
        noticeTitle?: string;
        /**
         * The description of the notice.
         */
        noticeDescription?: string;
        /**
         * The call to action text of the notice.
         */
        noticeCallToActionText?: string;
        /**
         * The call to action uri of the notice.
         */
        noticeCallToActionUri?: string;
        /**
         * The image type of the notice.
         */
        noticeImageType?: NoticeImageType;
    }
    interface InputsCallbacksRegistrar extends FxBase.DisposableLifetimeManager {
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
    }
    /**
     * Methods that can be used for managing a locked blade
     */
    interface LockedBladeManagement {
        /**
         * Closes this blade
         *
         * @param data Optional value to return back to the parent blade
         * @returns a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Promise<boolean>;
    }
    interface OpenBladeOptions {
        /**
         * Closes all open blades and starts a new journey
         */
        asNewJourney?: boolean;
        /**
         * Ensures all ancestoral blades in the journey are hidden
         */
        asSubJourney?: boolean;
        /**
         * Opens the blade in the same frame.  Only applicable for opening child blades in the context pane.
         */
        inPlace?: boolean;
    }
    interface OpenBladeAsyncOptions extends OpenBladeOptions {
        initialWidth?: MsPortalFx.Blades.BladeWidth;
    }
    interface BladeManagement {
        /**
         * Opens a child Blade.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         */
        openBlade(bladeReference: FxCompositionSelectable.BladeReference<any>, options?: OpenBladeOptions): Promise<boolean>;
        /**
         * Opens a child Blade asynchronously.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
         * indicator will be displayed on the new child Blade.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         */
        openBladeAsync(bladeReferencePromise: Promise<FxCompositionSelectable.BladeReference<any>>, options?: OpenBladeAsyncOptions): Promise<boolean>;
        /**
         * Opens a child Blade in the Context Pane.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPane(bladeReference: FxCompositionSelectable.BladeReference<any>): Promise<boolean>;
        /**
         * Opens a child Blade asynchronously in the Context Pane.  While the Blade to be shown is being determined (via
         * 'bladeReferencePromise') a loading indicator will be displayed in the Context Pane.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         * @param options Options used to open the child Blade.
         */
        openContextPaneAsync(bladeReferencePromise: Promise<FxCompositionSelectable.BladeReference<any>>): Promise<boolean>;
    }
    /**
     * containers for parts and template blades expose this optional functional which is enabled
     * for menu blade content
     */
    interface MenuBladeManagement {
        /**
         * This method causes the menu blade to navigate to a different item
         *
         * @param id Identifier of the item to navigate too
         * @param parametersOrOverrideBlade An optional BladeReference that, in most cases, matches the Blade targeted by 'id' and merely supplies custom parameters for the Blade.
         * In less common cases, the supplied BladeReference can specify a different Blade (along with parameters) than the Blade which ordinarily maps from 'id'.
         */
        switchItem(id: string, parametersOrOverrideBlade?: FxCompositionSelectable.BladeReference<any>): void;
        /**
         * Opens a child Blade in place.
         *
         * @param bladeReference A BladeReference describing the Blade to be opened.
         */
        openBlade(bladeReference: FxCompositionSelectable.BladeReference<any>, options?: OpenBladeOptions): Promise<boolean>;
        /**
         * Opens a child Blade asynchronously in place.  While the Blade to be shown is being determined (via 'bladeReferencePromise') a loading
         * indicator will be displayed on the new child Blade.
         *
         * @param bladeReferencePromise A Promise that will be resolved with a BladeReference describing the Blade to be opened.
         */
        openBladeAsync(bladeReferencePromise: Promise<FxCompositionSelectable.BladeReference<any>>, options?: OpenBladeAsyncOptions): Promise<boolean>;
    }
    /**
     * All view models have a associated container view model. The container view model
     * exists to drive the chrome. This is the base interface that all container view models
     * share.
     */
    class ContainerContract {
    }
    /**
     * All view models have a associated container view model. The container view model
     * exists to drive the chrome. This is the base interface that all container view models
     * share.
     */
    interface ContainerContract extends InputsCallbacksRegistrar, MsPortalFx.Data.ErrorNotificationTarget {
        /**
         * The message provided to the container when not found.
         */
        notFoundMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * container.helpContentUri is obsolete.
         *
         * @see {@link https://aka.ms/portalfx/breaking} for more details.
         */
        helpContentUri: Obsolete;
        /**
         * The announce API aims to provide screen reader users knowledge of certain UI updates that are otherwise difficult to advertise.
         * Announcements main purpose is to bring attention to these changes and provide feedback that is only visual otherwise.
         *
         * The message will be published at the 'polite' level, letting the screen reader queue the announcement at an appropriate time without interrupting the current read out queues.
         *
         * The API has these notable documented use cases:
         *   UI changes without focus change: If you add new UI elements through user interaction, and without moving the focus, you should announce.
         *   Confirmations: If you do operations that have completed visually, but not audibly, you should announce. Ex: upon deleting item XYZ, announce "item XYZ deleted"
         *   Loading progression: Announce at reasonable interval loading progression of specific thresholds, and the completion of loading.
         *   Custom search results: If you don't use the SearchBox control, you should announce. Ex: "3 items found".
         *
         * Keep these rules in mind when announcing:
         *   Is this something a control you use should be doing or does already? For example, the search control already has a mechanism to publish search results updates.
         *   Keep announcements short and concise as much as possible. Verbose announcements aren't usually helpful as the UI likely has the information, but the user just didn't know to look for it yet.
         *
         * @param message The message that will be read by the screen reader.
         */
        announce(message: string): void;
        /**
         * Moves the container into an 'error' display mode, allowing for a custom error message.
         *
         * Use this method when encountering an expected error state transition which has been
         * designed as part of the user experience and is not the indication of a product bug.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An custom error message or options customizing the error UI.
         *                As opposed to other error state transition methods, the message is non-optional.
         */
        handledError(message: string | ErrorOptions): void;
        /**
         * Moves the container into a 'not found' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        notFound(message?: string | ErrorOptions): void;
        /**
         * Moves the container into an 'unauthorized' display mode, allowing for an an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        unauthorized(message?: string | ErrorOptions): void;
        /**
         * A registry of callbacks that will be invoked when new inputs are available for the composition item.
         */
        onInputsSetCallbacks: OnInputsSetCallbacks;
        /**
         * Renders notice as content.
         */
        enableNotice(notice: NoticeOptions): void;
    }
    /**
     * A view model for the content displayed in a portal entity (such as Blade, Part, ActionBar, Command).
     */
    interface InputsContract {
        /**
         * Invoked by the Shell when the entity's inputs change to a new,
         * complete set of values. The view model should handle this by
         * loading whatever data corresponds to the input properties.
         *
         * @param inputs The entity's current set of input property values as a name/value collection.
         * @returns A promise representing a data access operation that has been initiated, or null.
         */
        onInputsSet(inputs: any): Promise<any>;
    }
    /**
     * View models which function as a selectable source implement this interface
     */
    interface SelectableSource {
        selectable: MsPortalFx.ViewModels.Selectable<any>;
    }
    module Internal {
        interface OnSourceModifiedContract {
            /**
             * Method executed after the dx source code of the blade has been modified to
             * notify the blade to re-render with updated configuration.
             *
             * @param sourcepath The jpath to the object modified. Can be used for incremental updates to the blade.
             * @param sourceProperty The property of the object modified. Can be used for incremental updates to the blade.
             * @param value The updated runtime configuration of the blade. This represents the entire compiled
             * configuration of the blade not just the portion edited by the user.
             */
            onSourceModified(sourcePath: string, sourceProperty: string, value: string): void;
        }
        interface PreviewContract {
            /**
             * True if the composition is marked as being in preview.
             */
            preview: KnockoutObservableBase<boolean>;
        }
        /**
         * Marks the given container as having content that is in preview.
         *
         * @param container The container to mark as preview.
         * @param isPreview Optional boolean true to mark the contain as in preview (default), false to clear the preview mark.
         */
        function markAsPreview(container: MsPortalFx.ViewModels.ContainerContract, isPreview?: boolean): void;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.ContentState.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * Specifies which content state decoration should be applied to a Part.
     */
    const enum ContentState {
        /**
         * The Part / Blade does not display any content state decoration.
         */
        None = 0,
        /**
         * The Part / Blade displays a "success" content state decoration.
         */
        Success = 1,
        /**
         * The Part / Blade displays a "warning" content state decoration.
         */
        Warning = 2,
        /**
         * The Part / Blade displays an "error" content state decoration.
         */
        Error = 3,
        /**
         * The Part / Blade displays a "dirty" content state decoration.
         */
        Dirty = 4,
        /**
         * The Part / Blade displays an "info" content state decoration.
         */
        Info = 5,
        /**
         * The Part / Blade displays an "upsell" content state decoration.
         */
        Upsell = 6,
        /**
         * The Part / Blade displays an "complete" content state decoration.
         */
        Complete = 7
    }
    module Internal {
        enum InternalContentState {
            None = 0,
            Success = 1,
            Warning = 2,
            Error = 3,
            Dirty = 4,
            Info = 5,
            Upsell = 6,
            Complete = 7
        }
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.DeleteAssetConfirmation.d.ts
declare module MsPortalFx.ViewModels.DeleteAssetConfirmation {
    /**
     * MsPortalFx.ViewModels.DeleteAssetConfirmation.InputData is obsolete. Please use Fx/Controls/ instead of MsPortalFx controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The contract of the binding inputs data to the view model.
     */
    type InputData = Obsolete;
    /**
     * MsPortalFx.ViewModels.DeleteAssetConfirmation.PartViewModelOptions is obsolete. Please use Fx/Controls/ instead of MsPortalFx controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The options of the delete asset confirmation part view model.
     */
    type PartViewModelOptions = Obsolete;
    /**
     * MsPortalFx.ViewModels.DeleteAssetConfirmation.BladeViewModel is obsolete. Please use Fx/Controls/ instead of MsPortalFx controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The view model of the delete asset confirmation blade.
     */
    const BladeViewModel: Obsolete;
    /**
     * MsPortalFx.ViewModels.DeleteAssetConfirmation.CommandViewModel is obsolete. Please use Fx/Controls/ instead of MsPortalFx controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The command view model to open the delete asset confirmation blade.
     */
    const CommandViewModel: Obsolete;
    /**
     * MsPortalFx.ViewModels.DeleteAssetConfirmation.PartViewModel is obsolete. Please use Fx/Controls/ instead of MsPortalFx controls.
     *
     * @see {@link https://aka.ms/portalfx/breaking} for further information.
     * The viewModel of delete asset confirmation part.
     */
    const PartViewModel: Obsolete;
}

// FILE: MsPortalFx\ViewModels\ViewModels.DeleteCommand.d.ts
declare module MsPortalFx.ViewModels {
    import NotificationManager = MsPortalFx.UI.NotificationManager;
    import FxViewModels = MsPortalFx.ViewModels;
    import Dialogs = FxViewModels.Dialogs;
    import DialogResult = Dialogs.DialogResult;
    /**
     * The result of the command execution.
     */
    const enum CommandResult {
        /**
         * The command is not executed.
         */
        None = 0,
        /**
         * The execution of the command has succeeded.
         */
        Success = 1,
        /**
         * The execution of the command has failed.
         */
        Failure = 2
    }
    /**
     * The options of the message box.
     */
    interface DeleteCommandMessageBoxOptions {
        /**
         * The title of the message box.
         */
        title: string;
        /**
         * The message of the message box.
         */
        message: string;
    }
    /**
     * The command to delete an asset.
     */
    abstract class DeleteAssetCommand extends FxViewModels.Command {
        private _assetType;
        private _confirmationDialog;
        private _errorDialog;
        private _data;
        /**
         * The asset data bound to the command.
         */
        data: KnockoutObservable<any>;
        /**
         * The result of the deletion.
         */
        result: KnockoutObservable<CommandResult>;
        /**
         * Instantiates the command.
         */
        constructor(container: FxViewModels.ContainerContract, assetType: string);
        onInputsSet(inputs: any): Promise<any>;
        execute(formValid?: boolean): void;
        dialogClick(result: DialogResult): void;
        /**
         * Deletes the asset.
         * Subclass is required to implement this method to actually delete the identified asset.
         * Based on the result of the deletion, subclass should set the result property accordingly.
         *
         * @param data The data of the asset to be deleted.
         */
        abstract _onDelete(data: any): void;
        /**
         * Gets the id of the asset.
         * Subclass is required to implement this method to let the shell know the asset deleted.
         * For example, if data is a complex object that contains the asset id, subclass should return the asset id from this method.
         *
         * @param data The data of the asset to be deleted.
         * @returns the id of the asset.
         */
        abstract _onGetAssetId(data: any): any;
        /**
         * Sends the error notification when deletion fails.
         * Subclass is required to implement this method to notify the shell the failure of the deletion of the asset.
         * If subclass really does not want to send error notification, it can return null/undefined from this method to cancel it.
         *
         * @param data The data of the asset to be deleted.
         * @returns the error notification.
         */
        abstract _onSendErrorNotification(data: any): NotificationManager.Notification;
        /**
         * Configures the confirmation message box to display.
         * Subclass can override the method to customize the confirmation message box.
         *
         * @param data The data of the asset to be deleted.
         * @returns the options of the confirmation message box.
         */
        _onShowConfirmation(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Configures the error message box to display.
         * Subclass can override the method to customize the error message box.
         *
         * @param data The data of the asset to be deleted.
         * @returns the options of the error message box.
         */
        _onShowError(data: any): DeleteCommandMessageBoxOptions;
        /**
         * Validates if the command should be enabled.
         * Subclass can provide additional logic to decide if the command should be enabled based the data.
         *
         * @param data The data of the asset.
         * @returns true if the command should be enabled, false otherwise.
         */
        _onValidateCommand(data: any): boolean;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Dialogs.d.ts
declare module FxImpl.Dialogs {
    /**
     * The internal contract that allows to control a dialog instance. Used by DialogRef instances to communicate between the extension view model and the framework.
     */
    interface DialogContract {
        /**
         * Controls the internal details of closing an instance of a dialog.
         */
        closeCallback: KnockoutObservable<Action1<{
            button: MsPortalFx.ViewModels.Dialogs.DialogResult;
        }>>;
    }
}
declare module MsPortalFx.ViewModels.Dialogs {
    const enum DialogType {
        /**
         * Invalid value for a dialog type. Used on base class types that are not meant to be passed to the framework.
         * Derived types will assign valid dialog types.
         */
        Invalid = 0,
        /**
         * Dialog is a message box.
         */
        MessageBox = 1,
        /**
         * Dialog is a progress box.
         */
        ProgressBox = 2,
        /**
         * Dialog is a form.
         */
        Form = 3,
        /**
         * Dialog for selecting one item out of a list.
         */
        List = 4
    }
    /**
     * Defines the options to configure dialog.
     */
    interface DialogContract {
        /**
         * The type of dialog to display.
         */
        type: DialogType;
        /**
         * Title shown at the top of the dialog.
         *
         * If hideTitle is set true
         * the title value will only be used for the dialog's aria label (an accessibility requirement).
         */
        title: string;
        /**
         * Indicator to hide the dialog title.
         */
        hideTitle?: boolean;
    }
    class Dialog implements DialogContract {
        type: DialogType;
        title: string;
        hideTitle: boolean;
        /**
         * Do not use. Dialog is an abstract class and should not
         * be instantiated directly.
         */
        constructor(title: string);
    }
    /**
     * Button identifiers.
     */
    const enum DialogResult {
        /**
         * The abort button.
         */
        Abort = 0,
        /**
         * The cancel button.
         */
        Cancel = 1,
        /**
         * The ignore button.
         */
        Ignore = 2,
        /**
         * The no button.
         */
        No = 3,
        /**
         * The ok button.
         */
        Ok = 4,
        /**
         * The retry button.
         */
        Retry = 5,
        /**
         * The yes button.
         */
        Yes = 6,
        /**
         * The delete button.
         */
        Delete = 7,
        /**
         * The Go back button.
         */
        GoBack = 8
    }
    interface DialogResultCallback {
        (result: MsPortalFx.ViewModels.Dialogs.DialogResult): void;
    }
    /**
     * Standard button sets that can be displayed in a dialog.
     */
    const enum MessageBoxButtons {
        /**
         * The message box contains Abort, Retry and Ignore buttons.
         */
        AbortRetryIgnore = 0,
        /**
         * The message box contains an OK button.
         */
        OK = 1,
        /**
         * The message box contains OK and Cancel buttons.
         */
        OKCancel = 2,
        /**
         * The message box contains Retry and Cancel buttons.
         */
        RetryCancel = 3,
        /**
         * The message box contains Yes and No buttons.
         */
        YesNo = 4,
        /**
         * The message box contains Yes, No and Cancel buttons.
         */
        YesNoCancel = 5,
        /**
         * The message box contains Delete and Cancel buttons.
         */
        DeleteCancel = 6,
        /**
         * The message box contains Delete and Go back buttons.
         */
        DeleteGoBack = 7
    }
    /**
     * The options required by a message box.
     */
    class MessageBox extends Dialog {
        text: string;
        buttons: MessageBoxButtons;
        /**
         * Gets or sets if a confirmation is required before users can press default button.
         */
        confirmationRequired: boolean;
        /**
         * The text of the confirmation message.
         */
        confirmationMessage: string;
        /**
         * Creates a new instance of a MessageBox.
         *
         * @param title Title shown at the top of the message box.
         * @param text Text of the message box.
         * @param buttons The button set to be displayed on the message box.
         */
        constructor(title: string, text: string, buttons: MessageBoxButtons);
    }
    /**
     * The options required by a progress box.
     */
    class ProgressBox extends Dialog {
        text: KnockoutObservable<string>;
        /**
         * The completion progress of the command, in percentage.
         * Values range from 0-100 or -1 for indefinite progress.
         * Defaults to indefinite progress if not specified.
         */
        completionPercentage: KnockoutObservable<number>;
        /**
         * Creates a new instance of a ProgressBox.
         *
         * @param title Title shown at the top of the progress dailog.
         * @param text Text of the progress dailog.
         * @param completionPercentage Optional number that initializes the current completion progress of the command.
         */
        constructor(title: string, text: string, completionPercentage?: number);
    }
    /**
     * The options required by the form dialog.
     */
    class FormDialog extends Dialog {
        description: KnockoutObservable<string>;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row1column1: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row1column2: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row2column1: any;
        /**
         * Any object that can be bound to a pcControl binding
         */
        row2column2: any;
        /**
         * Creates the options for a form dialog.
         *
         * @param title The title for the dialog.
         */
        constructor(title: string);
    }
    /**
     * The options required by the list popup.
     */
    class ListPopup extends Dialog {
        listItems: KnockoutObservableBase<string[]>;
        selectedItem: KnockoutObservable<string>;
        /**
         * Creates the options for a list dialog.
         */
        constructor();
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.ExtensibleViewModel.d.ts
declare module MsPortalFx.ViewModels {
    /**
     * A view model whose behavior can be customized or expanded with logic supplied by another extension.
     * The additional logic is supplied by the other extension as an inner view model configured into this view model.
     */
    interface ExtensibleViewModel<T> {
        /**
         * The view model supplied by another extension.
         */
        extenderViewModel: KnockoutObservable<T>;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Part.d.ts
declare module FxImpl.ViewModels {
    const createFrameworkPartViewModel: any;
}
declare module MsPortalFx.ViewModels {
    import FxBase = MsPortalFx.Base;
    import FxCompositionConfiguration = MsPortalFx.Composition.Configuration;
    import Rpc = FxImpl.Rpc;
    /**
     * Interface for an unprovisioned part that uses an edit scope to collect form data.
     */
    interface ProvisioningPartContentContract {
        /**
         * Edit scope id to be used by the unprovisioned part and it's children.
         */
        editScopeId: KnockoutObservable<string>;
    }
    const enum OnClickReason {
        Click = 1,
        FxClick = 2,
        RowClick = 3
    }
    interface MutateInfo {
        /**
         * Part to mutate into. Can be omitted for provisioning parts in which case
         * the new part locator will be looked up from extension definition.
         */
        partName?: string;
        /**
         * Extension that defines the specified part in its parts catalog.
         */
        extensionName?: string;
        /**
         * Input bindings for the new part. Parts in blades must not specify a new
         * container model. Their context will be the blade.
         */
        containerModel?: any;
        /**
         * Whether to prevent activation of the new part.
         */
        preventActivation?: boolean;
    }
    /**
     * Options for the for the registerSelectable API
     */
    interface RegisterSelectableOptions {
        /**
         * parameter collector is optional.
         * provide a parameter collector associated with the selectable here if the blade
         * is a a parameter provider.
         */
        parameterCollector?: ParameterCollector<any>;
        /**
         * If set to true AND the blade is a contextblade, will open in a contextpane.
         */
        openInContextPane?: boolean;
        /**
         * if the blade will be opened in the context pane, true open as context, false open as detail blade
         */
        persistentContextPane?: boolean;
    }
    /**
     * A reference to a DOM element in the portal
     */
    interface FxElement {
        _fxSignature: void;
    }
    /**
     * Information describing a event generated by a mouse action
     */
    interface FxMouseEvent {
        /**
         * A reference to the DOM element that was clicked
         */
        readonly target: FxElement;
    }
    /**
     * Describes an HTML view, defined in terms of an HTML template bound to an accompanying view model object.
     */
    interface HtmlContent {
        /**
         * The HTML template to display
         */
        htmlTemplate: string;
        /**
         * The object to bind to the template.
         */
        viewModel?: any;
    }
    /**
     * Button identifiers
     */
    export import DialogButton = Dialogs.DialogResult;
    /**
     * Standard buttons that can be displayed in a dialog.
     */
    export import DialogButtons = Dialogs.MessageBoxButtons;
    /**
     * Describes a custom button in a dialog.
     */
    interface CustomDialogButton {
        /**
         * Optional display text of the button
         * If not specified, a default display text value will be used.
         */
        displayText?: string;
        /**
         * Button identifier that is programmatically passed back.
         */
        button: DialogButton;
        /**
         * If set to the true the button is disabled.
         */
        disabled?: KnockoutObservableBase<boolean>;
    }
    /**
     * The result returned after a dialog was closed.
     */
    interface DialogResult {
        /**
         * The result returned from the dialog.
         */
        button: DialogButton;
    }
    /**
     * Describes preferred strategies to position a dialog.
     */
    const enum DialogPosition {
        /**
         * The dialog will open above the reference element, aligned to its left edge.
         * The dialog pointer will be located at the bottom left pointing downwards.
         */
        TopLeftEdge = 1,
        /**
         * The dialog will open to the right of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top left pointing leftwards.
         */
        RightTopEdge = 2,
        /**
         * The dialog will open below the reference element, aligned to its left edge.
         * The dialog pointer will be located at the top left pointing upwards.
         */
        BottomLeftEdge = 3,
        /**
         * The dialog will open to the left of the reference element, aligned to its top edge.
         * The dialog pointer will be located at the top right pointing rightwards.
         */
        LeftTopEdge = 4,
        /**
         * The dialog will open above the reference element, aligned to its right edge.
         * The dialog pointer will be located at the bottom right pointing downwards.
         */
        TopRightEdge = 5,
        /**
         * The dialog will open below the reference element, aligned to its right edge.
         * The dialog pointer will be located at the top right pointing upwards.
         */
        BottomRightEdge = 6,
        /**
         * The dialog will open above the reference element, center aligned.
         * The dialog pointer will be located center-bottom pointing downwards.
         */
        TopEdge = 7,
        /**
         * The dialog will open below the reference element, center aligned.
         * The dialog pointer will be located center-top pointing upwards.
         */
        BottomEdge = 8
    }
    /**
     * Options supplied when opening a dialog
     */
    interface BaseDialogOptions {
        /**
         * Name used in telemetry
         */
        telemetryName: string;
        /**
         * Dialog title
         *
         * If hideTitle is set the title value will still be used for the dialog's accessible name.
         */
        title: string;
        /**
         * Dialog content
         *
         * The dialog content can be a string message to display or an HTML template / view model pair.
         */
        content: string | HtmlContent;
        /**
         * Buttons can be either standard buttons provided by the framework or
         * this can be custom buttons with labels provided by the extension
         */
        buttons: DialogButtons | CustomDialogButton[];
        /**
         * Default button is the button which has focus if custom buttons was specified.
         * This property is not applicable when standard buttons are specified.
         */
        defaultButton?: DialogButton;
        /**
         * Optional callback that is invoked when the dialog is closed.
         * Dialogs are closed when the user clicks on one of the buttons or
         * clicks anywhere on the screen outside of the dialog. If the user clicks
         * somewhere else in the portal the cancel button or equivalent is passed to this callback.
         */
        onClosed?: (result: DialogResult) => void;
        /**
         * Hint to hide dialog title.
         */
        hideTitle?: boolean;
        /**
         * Makes the dialog render as modal within its context. When modal, user input is required for dismissal and user interaction is suppressed within the context of the dialog.
         *
         * Only the blade dialog context supports a modal rendering. Modal rendering isn't compatible with DialogOptions target parameter.
         */
        modal?: boolean;
        /**
         * Dialog reference populated by the runtime that offers fine control of the lifetime of the dialog.
         * This is useful for very specific scenarios, mostly where an asynchronous operation is needed before closing the dialog.
         * Doing so requires to build a fully custom dialog content.
         */
        dialogRef?: DialogRef;
    }
    /**
     * Options supplied when opening a dialog that supports targeting
     */
    interface DialogOptions extends BaseDialogOptions {
        /**
         * The target which is used to position the dialog.
         * This is a class name or a reference to a DOM element.
         */
        target?: string | FxElement;
        /**
         * Hint where to position the dialog relative to the target.
         * Defaults to BottomLeftEdge.
         */
        positionHint?: DialogPosition;
    }
    /**
     * Methods for managing dialogs
     */
    interface DialogManagement {
        /**
         * Opens a new dialog.
         *
         * @param options Describes the dialog that is too be opened.
         * @returns Promise that is resolved when the dialog is successfully opened.
         */
        openDialog(options: DialogOptions): Promise<boolean>;
    }
    /**
     * Provides an interface to control a dialog reference.
     */
    interface DialogRef {
        /**
         * The dialog instance.
         */
        value: {
            /**
             * Close the dialog with the provided result.
             *
             * @param result The DialogResult that is passed to the onClosed callback and logged to telemetry.
             */
            close: (result: DialogResult) => void;
        };
    }
    /**
     * Creates a DialogRef instance to be used as a value for the dialogRef parameter in DialogOptions.
     *
     * @returns A DialogRef instance.
     */
    function createDialogRef(): DialogRef;
    /**
     * When to show an alert to a user when the blade closes.
     */
    const enum AlertLevel {
        /**
         * Alerts when the user closes a blade and there are dirty forms on the blade
         */
        Default = 0,
        /**
         * Never alerts
         */
        None = 1
    }
    /**
     * Alert configuration for custom alerting when the blade closes.
     */
    interface AlertConfiguration {
        /**
         * Flag to indicate whether to show the alert or not.
         */
        showAlert: boolean;
        /**
         * Optional custom message for the alert if set.
         */
        message?: string;
        /**
         * Optional flag to indicate that the alert should fire if the form is dirty even if the blade is returning
         * data.
         */
        alertOnDirtyWhenReturningData?: boolean;
    }
    /**
     * Properties to track form validity, dirty state of forms on this tile/blade and methods to trigger validation and modify alert behavior
     */
    interface FormProperties {
        /**
         *  Overall valid state of the controls in this tile/blade.
         */
        validationState: KnockoutReadOnlyObservable<MsPortalFx.ViewModels.Controls.Validators.ValidationState>;
        /**
         * Overall dirty state of the controls in this tile/blade.
         */
        dirty: KnockoutReadOnlyObservable<boolean>;
        /**
         * Triggers validation on all form controls in this tile/blade.
         *
         * @returns a promise for the validation result.
         */
        triggerValidation(focusOnFirstInvalid?: boolean, validateHidden?: boolean): Promise<boolean>;
        /**
         * Configures the behavior of the alert when the blade is closed.
         *
         * @param configuration A computed that returns whether or not to show the alert and what message to show the user
         */
        configureAlertOnClose(configuration: KnockoutObservableBase<AlertConfiguration>): void;
        /**
         * Configures the behavior of the alert when the blade is closed.
         *
         * @param alertLevel when to show the alert.
         */
        configureAlertOnClose(alertLevel: AlertLevel): void;
    }
    /**
     * Interface for managing dashboards.
     */
    interface DashboardManagement {
        /**
         * Navigates to the specified dashboard.
         *
         * @param dashboardId The id of the dashboard to navigate to.
         */
        navigateToDashboard(dashboardId?: string): void;
    }
    interface PartContainerContract extends MsPortalFx.ViewModels.ContainerContract, FxImpl.Composition.Selectable.SelectableViewModel, BladeManagement, DialogManagement {
        /**
         * The title text displayed for this part. Typically this specifies what kind of information
         * appears inside the part, e.g., "Deployment history", or if that is not applicable then the
         * type of the asset that the part relates to, e.g., "Website".
         */
        partTitle: KnockoutObservableBase<string>;
        /**
         * The label read by assistive devices on this part. If not set, will default to the part title set.
         * Override if you desire the label to be more specific than the default title of the part.
         */
        ariaLabel: KnockoutObservableBase<string>;
        /**
         * The asset name text displayed for this part, e.g., "Freezing Fog".
         */
        assetName: KnockoutObservableBase<string>;
        /**
         * If isSelectable is true then the part is selectable.  This value always is true by default.
         * If this setting is false then the state of selectable is ignored and the part is not selectable.
         */
        isSelectable: KnockoutObservableBase<boolean>;
        /**
         * View model reflecting the selection state of the Part. The value is null if the part is not selectable.
         */
        selectable: Selectable<any>;
        /**
         * View model reflecting whether the Part will open a link when clicked. The value is null if the part is not a link.
         */
        clickableLink: ClickableLinkContract;
        /**
         * Tracks the list of asynchronous operations being performed by the Part.
         */
        operations: PartOperationList;
        /**
         * Specifies which content state decoration is applied to the Part.
         */
        contentState: KnockoutObservableBase<MsPortalFx.ViewModels.ContentState>;
        /**
         * Reflects the load state of the Part.
         */
        partState: KnockoutObservableBase<MsPortalFx.Parts.PartState>;
        /**
         * The error message displayed by the Part when it has failed.
         */
        failureMessage: KnockoutObservable<string | ErrorOptions>;
        /**
         * The message displayed by the Part when it has no data to display.
         */
        noDataMessage: KnockoutObservable<string>;
        /**
         * Member used to mutate the part.
         */
        mutate: KnockoutObservable<MutateInfo>;
        /**
         * The height of the part in pixels without padding.
         * Note: The height value will be not useful for part size FullWidthFitHeight, HeroWideFitHeight and FitToContainer.
         */
        height: KnockoutObservableBase<number>;
        /**
         * The width of the part in pixels without padding.
         */
        width: KnockoutObservableBase<number>;
        /**
         * Detailed size information for the Part.
         */
        size: KnockoutObservableBase<PartSizeInfo>;
        /**
         * The width and height of the content area, in pixels.
         */
        contentSize: KnockoutReadOnlyObservableBase<{
            height: number;
            width: number;
        }>;
        /**
         * Moves the container into a 'fail' display mode, allowing for an optional custom error message.
         *
         * @see handledError A method that doesn't log the error to diagnostics. Use for expected error.
         * @see notFound A specialization of 'handledError' that displays standard 'Not Found' error UI.
         * @see unauthorized A specialization of 'handledError' that displays standard 'Unauthorized' error UI.
         * @see fail A method that logs the errors for diagnostics. Use for an unexpected error.
         * @param message An optional custom error message or options customizing the error UI.
         */
        fail(message?: string | ErrorOptions): void;
        /**
         * Indicates the location of this Part (on a Dashboard, on a Blade, etc.).
         */
        location: PartLocation;
        /**
         * Removes any 'failed' error message and brings the part back to 'ready' state.
         * If the part was not already in a 'failed' state, this method does nothing.
         */
        recover(): void;
        /**
         * If allowed by ResizeMode, will adjust the size of the part to the size specified, clamped to the grid constraints.
         *
         * @param width The desired width, in grid steps, valid in range from 1 to 25.
         * @param height The desired height, in grid steps, valid in range from 1 to 25.
         */
        resizeTo(width: number, height: number): void;
        /**
         * Causes the part's content to be revealed immediately, regardless of any onInputsSet promise that
         * might not yet have completed. This removes the opaque 'loading' spinner and makes the part interactive,
         * so you must also disable or hide any UI elements that the user should not be able to see or interact with
         * until data is fully loaded.
         */
        revealContent(): void;
        /**
         * Asynchronously moves the focus to the first focusable element on or within the specified target if the container currently
         * owns the focus. If multiple target elements are found, only the first one will be inspected. If nothing is focusable,
         * the focus will not move and this method will return false.
         *
         * @param targetSelector Any valid CSS selector to elements owned by this container that identifies a target to focus on or within.
         * @returns An object with a success status and an optional error message explaining rejection.
         */
        setFocus(targetSelector: string): Promise<{
            success: boolean;
            errorMsg?: string;
        }>;
        /**
         * Registers a selectable to open blades using dynamic blade selection.
         *
         * @param lifetime Reflects the lifetime of the selectable.  When the lifetime is disposed, the selectable will be implicitly unregistered.
         * @param identity Required, this is used as the key for persisting the selection state
         * @param selectable Required, the selectable that will be used to open blades.   This must be a Selectable or SelectableSet type only.
         * @param options Optional, additional options to configure
         */
        registerSelectable(lifetime: FxBase.LifetimeManager, identity: string, selectable: Selectable<any> | SelectableSet<any, any>, options?: RegisterSelectableOptions): void;
        /**
         * Activates this Part's 'Configuration', which is an API that enables the Part to manage parameter and settings overrides/inheritance via
         * configuration UI (typically via a Context Blade).  See the MsPortalFx.Composition.Configuration.Contract interface for details.
         *
         * @param options Options used to initialize the Configuration API for this Part
         * @returns The Configuration API for this Part
         */
        activateConfiguration<TParameters, TSettings>(options?: FxCompositionConfiguration.Part.Options<TParameters, TSettings>): FxCompositionConfiguration.Part.Contract<TParameters, TSettings>;
        /**
         * Closes the child blade that is currently open
         *
         * @returns a promise that resolves to true if the child blade is successfully closed.
         */
        closeChildBlade(): Promise<boolean>;
        /**
         * Closes the context blade that was opened by this part
         *
         * @returns a promise that resolves to true if the context blade is successfully closed.
         */
        closeContextBlade(): Promise<boolean>;
        /**
         * Closes this blade.
         *
         * @param data This 'data' will be returned to the BladeReference with which this Blade was opened, via the BladeReference's 'onClosed' callback.
         * @returns a promise that resolves to true if the this blade is successfully closed.
         */
        closeCurrentBlade(data?: any): Promise<boolean>;
        /**
         * Optional property that provides functionality for parts that are on locked blades.
         */
        onLockedBlade?: LockedBladeManagement;
        /**
         * Properties to track form validity, dirty state of forms on this tile and methods to trigger validation and modify alert behavior
         */
        form: FormProperties;
        /**
         * This is the interface for managing the host menu blade.  If this part is not hosted in a menu blade this then property is null.
         */
        menu: MenuBladeManagement;
        /**
         * API collection that facilitates dashboard interactions.
         */
        dashboard: DashboardManagement;
        /**
         * Interface for managing part updatable header
         */
        updatableHeader?: UpdatableHeader.UpdatableHeaderContext;
    }
    const PartContainer: any;
    /**
     * Detailed Part size information.
     */
    interface PartSizeInfo {
        /**
         * One of the defined Part sizes, including 'Custom' if the Part is configured to support arbitrary sizing.
         */
        partSize: MsPortalFx.Parts.PartSize;
        /**
         * The width/height of the Part in terms of pixels.
         */
        dimensions: {
            width: number;
            height: number;
        };
    }
    /**
     * The location of a Blade.
     */
    const enum BladeLocation {
        /**
         * Default case. The blade is neither in the content area of a MenuBlade nor in the Context Pane.
         */
        Standalone = 0,
        /**
         * The Blade is in the content area of a Menu Blade.
         */
        MenuContent = 1,
        /**
         * The Blade is in the context pane.
         */
        ContextPane = 2
    }
    /**
     * The location of a Part.
     */
    const enum PartLocation {
        /**
         * For testing purposes only.  The Part is neither on a Dashboard nor on a Blade.
         */
        _Internal_None = 0,
        /**
         * The Part is on a Dashboard.
         */
        Dashboard = 1,
        /**
         * The Part is on a Blade.
         */
        Blade = 2
    }
    module Part {
        /**
         * Creates a Selectable view model that is initialized with the Part's saved state.
         *
         * @param initialState Optional, saved selection state for the Part.
         * @param selectedValue Optional, initial value for the 'selectedValue' property of the Selectable.
         * @returns A Selectable view model instance.
         */
        function createSelectableViewModel(initialState?: any, selectedValue?: any): Selectable<any>;
        function createClickableLinkViewModel(observableUri: KnockoutObservable<string>, observableTarget?: KnockoutObservable<string>): any;
    }
    const navigateToDashboardEndPoint: Rpc.FuncEndPointDefinition<string[], void>;
    /**
     * The part container.
     */
    class PartContainerContract {
    }
    module Parts.Frame {
        /**
         * The contract for the view model of a frame part.
         */
        interface Contract {
        }
    }
    module UpdatableHeader {
        type PartHeader = import("Fx/Composition/PartBase").UpdatableHeader.PartHeader;
        type Options = import("Fx/Composition/PartBase").UpdatableHeader.Options;
        type UpdatableHeaderContext = import("Fx/Composition/PartBase").UpdatableHeader.UpdatableHeaderContext;
    }
}

// FILE: MsPortalFx\ViewModels\ViewModels.Toolbar.d.ts
declare module MsPortalFx {
    /**
     * Toolbar item base that is common to MsPortalFx.ViewModels.Toolbars items and Fx/Toolbar items.
     * This allows older MsPortalFx APIs to use Fx/Toolbar items.
     */
    interface ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: number;
    }
}
declare module MsPortalFx.ViewModels.Toolbars {
    import FxViewModels = MsPortalFx.ViewModels;
    import FileDownload = FxViewModels.FileDownload;
    /**
     * The type of the toolbar item.
     * These must match the corresponding enum in 'FxInternal/Controls/Toolbar'
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    const enum ToolbarItemType {
        /**
         * Not a valid type.
         */
        None = 0,
        /**
         * An items that visually groups other toolbar items.
         */
        Group = 1,
        /**
         * A toolbar button that opens a link.
         */
        OpenLinkButton = 2,
        /**
         * A toolbar button that opens a blade.
         */
        OpenBladeButton = 3,
        /**
         * A toolbar button that is associated to a command.
         */
        CommandButton = 4,
        /**
         * A toolbar button that opens a dialog before executing a command.
         */
        DialogButton = 5,
        /**
         * A toolbar button and can be toggled (between ON and OFF states).
         */
        ToggleButton = 6,
        /**
         * A toolbar button which initiates a file download
         */
        FileDownloadButton = 7,
        /**
         * A toolbar button which initiates a file upload
         */
        FileUploadButton = 8,
        /**
         * A toolbar button which acts like OAuth button
         */
        OAuthButton = 9,
        /**
         * A toolbar button that opens a blade using selectable 2
         */
        OpenBladeButton2 = 10,
        /**
         * A toolbar button that allows moving resources across resource groups/subscriptions
         */
        MoveResourceButton = 11,
        /**
         * A toolbar item separator to add a line UX separator between the toolbar buttons
         */
        Separator = 12,
        /**
         * An adapter for PDL command groups.
         */
        PdlCommandGroup = 13,
        /**
         * A toolbar button type that writes a value to the clipboard.
         */
        CopyButton = 20,
        /**
         * A toolbar button type that reads a value from the clipboard.
         */
        PasteButton = 21
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface BaseToolbarItemContract extends MsPortalFx.ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
    }
    /**
     * Defines a toolbar item separator to add a line UX separator between the toolbar buttons
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarItemSeparatorContract extends MsPortalFx.ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
    }
    /**
     * Defines an item in the toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarItemContract extends MsPortalFx.ToolbarItemContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
        /**
         * A value indicating whether or not the toolbar item is disabled.
         */
        disabled: KnockoutObservableBase<boolean | string>;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage: KnockoutObservable<string>;
        /**
         * Signals the toolbar item is in unauthorized mode and provides an optional custom error message,
         * or an optional boolean value indicating whether or not the toolbar item is unauthorized.
         *
         * @param message A custom error message or value indicating whether or not the toolbar item is unauthorized.
         */
        unauthorized(message?: string | boolean): void;
        /**
         * Optional. The aria label to use instead of the visual text label.
         */
        ariaLabel?: KnockoutObservableBase<string>;
        /**
         * The name of the toolbar item.
         */
        name?: string;
        /**
         * The regular tooltip of the toolbar item
         */
        tooltip?: KnockoutObservableBase<string>;
    }
    /**
     * Options for an item in the toolbar
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarItemOptions {
        /**
         * The type of the toolbar item.
         */
        type?: ToolbarItemType;
        /**
         * A value indicating whether or not the toolbar item is disabled.
         */
        disabled?: KnockoutObservableBase<boolean | string> | boolean | string;
        /**
         * The message provided to the container when unauthorized.
         */
        unauthorizedMessage?: KnockoutObservable<string> | string;
        /**
         * Optional. The aria label to use instead of the default text label.
         */
        ariaLabel?: KnockoutObservableBase<string> | string;
        /**
         * The name of the toolbar item.
         */
        name?: string;
        /**
         * The regular tooltip of the toolbar item
         */
        tooltip?: KnockoutObservableBase<string> | string;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ToolbarItem implements ToolbarItemContract {
        type: ToolbarItemType;
        disabled: KnockoutObservableBase<boolean | string>;
        unauthorizedMessage: KnockoutObservable<string>;
        ariaLabel: KnockoutObservableBase<string>;
        name: string;
        tooltip: KnockoutObservableBase<string>;
        /**
         * Creates a toolbar item.
         *
         * @param type The type of the toolbar item.
         */
        constructor(type: ToolbarItemType, options?: ToolbarItemOptions);
        unauthorized(message?: string | boolean): void;
    }
    /**
     * Defines a toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarContract extends FxViewModels.Controls.Loadable.Contract {
        /**
         * Sets the ordered list of items (buttons, separators, groups) that will be shown in the toolbar
         */
        setItems(items: BaseToolbarItemContract[]): void;
        /**
         * A value indicating whether or not to show item labels.
         */
        showLabels: KnockoutObservable<boolean>;
    }
    /**
     * Options for a Toolbar
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarOptions extends FxViewModels.Controls.Loadable.Options {
        showLabels?: KnockoutObservable<boolean> | boolean;
    }
    /**
     * Defines a button in the toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarButtonContract extends ToolbarItemContract {
        /**
         * The command label.
         */
        label: KnockoutObservableBase<string>;
        /**
         * The icon for the command.
         */
        icon: KnockoutObservableBase<Base.Image>;
    }
    /**
     * Options for a button in toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarButtonOptions extends ToolbarItemOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
    }
    /**
     * Defines a toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Toolbar extends Controls.Loadable.ViewModel implements ToolbarContract {
        /**
         * A value indicating whether or not to show item labels.
         */
        showLabels: KnockoutObservable<boolean>;
        /**
         * The list of items to show in the toolbar.
         * Does not start with '_' so that it gets proxied over to the shell.
         */
        private items;
        /**
         * Sets the ordered list of items (buttons, separators, groups) that will be shown in the toolbar
         */
        setItems(items: (BaseToolbarItemContract)[]): void;
        /**
         * Creates a toolbar.
         *
         * @param lifetimeManager Lifetime manager for this view model.
         */
        constructor(lifetimeManager: MsPortalFx.Base.LifetimeManager, options?: ToolbarOptions);
    }
    /**
     * Toolbar item seprator to add a line UX separator between the toolbar buttons
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class Separator implements ToolbarItemSeparatorContract {
        /**
         * The type of the toolbar item.
         */
        type: ToolbarItemType;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ToolbarButton extends ToolbarItem implements ToolbarButtonContract {
        label: KnockoutObservableBase<string>;
        icon: KnockoutObservableBase<Base.Image>;
        /**
         * Creates a toolbar button.
         *
         * @param type The type of the button.
         * @param options, the options of button, see ToolbarButtonOptions
         */
        constructor(type: ToolbarItemType, options?: ToolbarButtonOptions);
    }
    /**
     * Defines a group in the toolbar.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToolbarGroupContract extends ToolbarItemContract {
        /**
         * The items in the group.
         */
        items: ToolbarItemContract[];
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ToolbarGroup extends ToolbarItem implements ToolbarGroupContract {
        items: ToolbarItemContract[];
        /**
         * Creates a toolbar group.
         *
         * @param items The items in the group.
         */
        constructor(items: ToolbarItemContract[]);
    }
    /**
     * Defines a button that can execute the associated command.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ExecutableButtonBaseContract<T> extends ToolbarButtonContract {
        /**
         * The command associated to the toolbar item.
         */
        command: Commands.Command<T>;
    }
    /**
     * Options for a ExecutableButtonBase
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ExecutableButtonBaseOptions<T> extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<T>;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ExecutableButtonBase<T> extends ToolbarButton implements ExecutableButtonBaseContract<T> {
        command: Commands.Command<T>;
        /**
         * Creates an executable button.
         *
         * @param type The type of the button.
         * @param options The options of the button, see ExecutableButtonBaseOptions
         */
        constructor(type: ToolbarItemType, options?: ExecutableButtonBaseOptions<T>);
    }
    /**
     * Defines a button that can execute the associated command.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface CommandButtonContract<T> extends ExecutableButtonBaseContract<T> {
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservableBase<T>;
    }
    /**
     * Options for a CommandButton
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface CommandButtonOptions<T> extends ExecutableButtonBaseOptions<T> {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<T>;
        /**
         * The context to pass on to the command.
         */
        commandContext?: KnockoutObservableBase<T>;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class CommandButton<T> extends ExecutableButtonBase<T> implements CommandButtonContract<T> {
        type: ToolbarItemType.CommandButton;
        commandContext: KnockoutObservableBase<T>;
        /**
         * Creates an executable button.
         *
         * @param options The options of the button, see CommandButtonOptions
         */
        constructor(options?: CommandButtonOptions<T>);
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToggleButtonContext<T> {
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: boolean;
        /**
         * The context defined by the consumer of the toggle button.
         */
        context: T;
    }
    /**
     * This type of button provides an ON-OFF functionality that allows the user to toggle between
     * the ON and OFF states on every click.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToggleButtonContract<T> extends ExecutableButtonBase<ToggleButtonContext<T>> {
        /**
         * The option group that the toggle button belongs to.
         */
        optionGroupName: string;
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked: KnockoutObservable<boolean>;
        /**
         * The context to pass on to the command.
         */
        commandContext: KnockoutObservableBase<T>;
    }
    /**
     * Options for a ToggleButton
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface ToggleButtonOptions<T> extends ExecutableButtonBaseOptions<ToggleButtonContext<T>> {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<ToggleButtonContext<T>>;
        /**
         * The option group that the toggle button belongs to.
         */
        optionGroupName?: string;
        /**
         * A value indicating whether or not the toggle button is in the checked state.
         */
        checked?: KnockoutObservable<boolean> | boolean;
        /**
         * The context to pass on to the command.
         */
        commandContext?: KnockoutObservableBase<T>;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class ToggleButton<T> extends ExecutableButtonBase<ToggleButtonContext<T>> implements ToggleButtonContract<T> {
        optionGroupName: string;
        checked: KnockoutObservable<boolean>;
        commandContext: KnockoutObservableBase<T>;
        /**
         * Creates a toggle button.
         *
         * @param groupNameOrOptions, implement overloads for both optionGroupName & options. if optionGroupName, The option group that the toggle button belongs to. if options, The options of the button, see ToggleButtonOptions
         */
        constructor(groupNameOrOptions?: string | ToggleButtonOptions<T>);
    }
    /**
     * Defines a button that shows a dialog before executing a command using the dialog result as context.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DialogButtonContract extends ExecutableButtonBaseContract<Dialogs.DialogResult> {
        /**
         * Options required for showing the dialog.
         */
        dialogOptions: Dialogs.DialogContract;
    }
    /**
     * Options for a DialogButton
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface DialogButtonOptions extends ExecutableButtonBaseOptions<Dialogs.DialogResult> {
        /**
         * The tyoe of Dialog Button
         */
        type?: ToolbarItemType;
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Command to execute when button is clicked
         */
        command?: Commands.Command<Dialogs.DialogResult>;
        /**
         * Options required for showing the dialog.
         */
        dialogOptions?: Dialogs.DialogContract;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class DialogButton extends ExecutableButtonBase<Dialogs.DialogResult> implements DialogButtonContract {
        dialogOptions: Dialogs.DialogContract;
        /**
         * Creates a dialog button.
         *
         * @param typeOrOptions, implement overloads for both type & options. if type, The type of the button; if options, The options of the button, see DialogButtonOptions
         */
        constructor(typeOrOptions?: ToolbarItemType | DialogButtonOptions);
    }
    /**
     * Defines a toolbar command button that can upload a file from local disk.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FileUploadButtonContract extends ToolbarButtonContract, FxViewModels.FileUpload.UploadContract {
    }
    /**
     * Options for a FileUploadButton
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FileUploadButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept?: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles?: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext?: KnockoutObservableBase<FxViewModels.FileUpload.UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads?: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection?: KnockoutObservableBase<boolean>;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class FileUploadButton extends ToolbarButton implements FileUploadButtonContract {
        /**
         * A comma-separated list of allowed file mime-types; extension is not included.
         * This maps directly to the HTML accept attribute for file input controls.
         */
        accept: string;
        /**
         * The maximum number of files allowed to be uploaded at once.
         * This limit is applied post-selection.
         */
        maxFiles: number;
        /**
         * The upload context options around how/where to upload and size limits.
         */
        uploadContext: KnockoutObservableBase<FxViewModels.FileUpload.UploadContext>;
        /**
         * Cancel all uploads that are in progress and clears the files list array.
         */
        cancelAllUploads: KnockoutObservableBase<boolean>;
        /**
         * When file input is clicked, if set to true,  the upload command/widget will cancel all uploads that are in progress and clears the uploadTasks array.
         * If set to false, the new file will be added to the uploadTasks and extension author should dispose it off when upload completes.
         * Default is set to true and each time a new file is selected, existing uploadTasks will be canceled and removed from uploadTasks observable array.
         */
        cancelAllUploadsOnFileSelection: KnockoutObservableBase<boolean>;
        /**
         * Observable array holds all the current file upload tasks. Each task represent the file details, status, upload progress and content.
         * FileUploadTask is used to initiate the file upload, resume steaming uploads, cancel and dispose the file upload.
         */
        uploadTasks: KnockoutObservableArray<FxViewModels.FileUpload.UploadTaskContract>;
        /**
         * Creates the file upload toolbar button.
         *
         * @param options, options of the button, see FileUploadButtonOptions
         */
        constructor(options?: FileUploadButtonOptions);
    }
    /**
     * Defines a toolbar command button that can download a file.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FileDownloadButtonContract extends ToolbarButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownload.Context>;
    }
    /**
     * Options for a FileDownload Button
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface FileDownloadButtonOptions extends FileDownload.Options, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class FileDownloadButton extends ToolbarButton implements FileDownloadButtonContract {
        /**
         * The file download context of the button
         */
        context: KnockoutObservableBase<FileDownload.Context>;
        /**
         * Creates the file download toolbar button.
         *
         * @param options, options of the button, see FileDownloadButtonOptions
         */
        constructor(options: FileDownloadButtonOptions);
    }
    /**
     * Options for a OAuthButton Button
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OAuthButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl?: KnockoutObservable<string> | string;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth?: KnockoutObservable<number> | number;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight?: KnockoutObservable<number> | number;
        /**
         * Token
         */
        value?: KnockoutObservable<string> | string;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class OAuthButton extends ToolbarButton implements ToolbarButtonContract {
        /**
         * Request url used to pop up the OAuth window.
         */
        requestUrl: KnockoutObservable<string>;
        /**
         * The width of the popup. Set to half the height of the screen if not specified.
         */
        popupWidth: KnockoutObservable<number>;
        /**
         * The height of the popup. Set to half the height of the screen if not specified.
         */
        popupHeight: KnockoutObservable<number>;
        /**
         * Token
         */
        value: KnockoutObservable<string>;
        /**
         * Creates the OAuth toolbar button.
         *
         * @param options, options of the button, see OAuthButtonOptions
         */
        constructor(options?: OAuthButtonOptions);
    }
    /**
     * Defines a button that can open a blade.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenBladeButtonContract<T> extends ToolbarButtonContract {
        /**
         * The selectable for the command.
         */
        selectable: FxViewModels.Selectable<T>;
    }
    /**
     * Options for a OpenBlade Button
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenBladeButtonOptions<T> extends SelectableOptions<T>, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * The selectable for the command.
         */
        selectable?: FxViewModels.Selectable<T>;
    }
    /**
     * See Interface
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class OpenBladeButton<T> extends ToolbarButton implements OpenBladeButtonContract<T> {
        selectable: FxViewModels.Selectable<T>;
        /**
         * Creates the selectable toolbar button.
         *
         * @param options, options of the button, see OpenBladeButtonOptions
         */
        constructor(options?: OpenBladeButtonOptions<T>);
    }
    /**
     * Defines a button that can open a blade.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenBladeButtonContract2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButtonContract {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        /**
         * The selectable for the command.
         */
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenBladeButton2Options<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends FxImpl.Composition.Selectable.Selectable2Options<T>, ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id?: string;
        /**
         * The selectable for the command.
         */
        selectable?: FxImpl.Composition.Selectable.Selectable2<T>;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class OpenBladeButton2<T extends FxImpl.Composition.Selectable.BladeReference<any>> extends ToolbarButton implements OpenBladeButtonContract2<T> {
        /**
         * command identifier, required to support journey persistance/restoration
         */
        id: string;
        selectable: FxImpl.Composition.Selectable.Selectable2<T>;
        /**
         * Creates the selectable toolbar button.
         *
         * @param options, options of the button, see OpenBladeButton2Options
         */
        constructor(options?: OpenBladeButton2Options<T>);
    }
    /**
     * Defines a button that can open a new link.
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenLinkButtonContract extends ToolbarButtonContract {
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part
         * opens a link when clicked.
         */
        clickableLink: ClickableLinkContract;
    }
    /**
     * Options for a OpenLinkButton
     *
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    interface OpenLinkButtonOptions extends ToolbarButtonOptions {
        /**
         * The command label.
         */
        label?: KnockoutObservableBase<string> | string;
        /**
         * The icon for the command.
         */
        icon?: KnockoutObservableBase<Base.Image> | Base.Image;
        /**
         * An instance of MsPortalFx.ViewModels.ClickableLink which controls whether this Part
         * opens a link when clicked.
         */
        uri: string;
        /**
         * where to open the new link .
         */
        target?: string;
    }
    /**
     * @deprecated MsPortalFx.ViewModels.Toolbars has been deprecated.
     * Please migrate to Fx/Controls/Toolbar.
     * Please refer to https://aka.ms/portalfx/breaking for more details.
     */
    class OpenLinkButton extends ToolbarButton implements OpenLinkButtonContract {
        clickableLink: ClickableLinkContract;
        /**
         * Creates the selectable toolbar button.
         *
         * @param uriOrOptions, if uri, The URI that will be opened when target is clicked; if options, the options of the button, see OpenLinkButtonOptions
         * @param target The target window to open the URI in.
         */
        constructor(uriOrOptions: string | OpenLinkButtonOptions, target?: string);
    }
}

// Compiled with TypeScript 5.0

// FILE: FxInternal.d.ts
declare module "FxInternal" {
    export function isPlainObject(obj: any): boolean;
    export const jqueryExtend: (this: any, ...args: any[]) => any;
    /**
     * For testing only. Use Object.keys.
     */
    export function _objectKeysPolyfill(o: any): string[];
    export function forEachKey<T, U>(obj: StringMap<T>, iterator: (key: string, value: T, context: U) => void, context?: U): U;
    export function forEachKey<T, U>(obj: NumberMap<T>, iterator: (key: number, value: T, context: U) => void, context?: U): U;
    /**
     * call value.dispose() if a value is Disposable.
     *
     * @param value The value to call value.dispose()
     * @returns boolean;
     */
    export const disposeDisposable: (...values: any[]) => void;
    /**
     * Indicates whether the specified object is null or undefined.
     *
     * @param value The value to test.
     * @returns True if the value parameter is null or undefined; otherwise, false.
     */
    export function isNullOrUndefined(value: any): value is null | undefined;
    /**
     * Removes all values that equal the given item and returns them as an array
     *
     * @param itemOrPredicate The value or predicate for the item to be removed.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The removed items.
     */
    export function remove<T>(array: T[], itemOrPredicate: T | ((value: T) => boolean), startIndex?: number): T[];
    /**
     * Coerce an input into an array if it isn't already one.
     */
    export function makeArray<T>(input: T | T[]): T[];
    /**
     * Pushes elements to a target making sure they are unique.
     *
     * @param uniqueTarget The target to push the source elements into.
     * @param source The source elements to push to the target in case they are unique.
     * @param predicate Comparer function to determine if the 2 elements are equal.
     * @param sourceUnique is a flag to optimize the performance, set to true if you know source is unique already.
     */
    export function pushUnique<T>(uniqueTarget: T[], source: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean, sourceUnique?: boolean): T[];
    /**
     * Returns a unique set from this array based on the predicate.
     *
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @returns A new array with the unique values.
     */
    export function unique<T>(array: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param arrays The list of arrays to get union of.
     * @returns A new array with the unique values.
     */
    export function union<T>(...arrays: ReadonlyArray<T>[]): T[];
    /**
     * Returns a unique concatenated set from this array and the given array based on the predicate.
     *
     * @param other The other array to concatenate with this one.
     * @param predicate The predicate function. Added to the result if the predicate returns false.
     * @returns A new array with the unique values.
     */
    export function union<T>(array: ReadonlyArray<T>, other: ReadonlyArray<T>, predicate?: (value1: T, value2: T) => boolean): T[];
    /**
     * Determines if the current string starts with the given string.
     * http://jsperf.com/string-startswith/49
     *
     * @param input The input string.
     * @param searchString The characters to be searched for at the start of this string.
     * @param position Optional. The position in this string at which to begin searching for searchString; defaults to 0.
     * @returns A value indicating whether or not the input string begins with the search string.
     */
    export function startsWith(input: string, searchString: string, position?: number): boolean;
    /**
     * Attempts to execute on fulfill or on reject callbacks immediately if the promise is already resolved or rejected,
     * or waits for the resolution or the rejection otherwise.
     * Currently can only call back synchronously for Q.Promise.
     *
     * @param promise The promise expected to be resovled or rejected.
     * @param onFulfill The callback to be executed if resolved.
     * @param onReject The callback to be executed if rejected.
     * @returns A promise for the result.
     */
    export function tryImmediateResolve<T, TR>(promise: PromiseLike<T>, onFulfill: (value: T) => TR | Promise<TR>, onReject?: (reason?: Error) => any): Promise<TR>;
    /**
     * No-op function.
     */
    export function noop(): void;
    /**
     * Identity function.
     *
     * Note: https://en.wikipedia.org/wiki/Identity_function
     */
    export function identity<T>(e: T): T;
    /**
     * Returns whether code that could have a performance impact but would assist with development should be enabled.
     */
    export const isDiagnosticsEnabled: boolean;
    /**
     * Extends the target object with the properties from source object.
     *
     * @param target The object that is to be extended. This object is modified and returned.
     * @param source The object whose properties are to be copied over.
     * @param deep A flag indicating whether the operation is to be performed recursively.
     * @returns The same target object (after extension).
     */
    export function extend<T, U>(target: T, source: U, deep?: boolean): T & U;
    /**
     * Similar to extend, except does not modify target.
     * Instead returns a clone of target extended with source.
     */
    export function extend2<T, U, V, W>(s1: T, s2: U, s3?: V, s4?: W): T & U & V & W;
    /**
     * Generates the current JavaScript call stack.
     * On IE9 there is no stack so we get empty string.
     *
     * Note that by default, for slower platform, IE11 etc, which error doesn't come with that stack.
     * We will not get the call stack for those slow platform even if you set to force.
     * Since for common problem, you should have enough information just by morden browser (chrome, edge, firefox.)
     * Use feature.includeslowgetcallstack to enable call stack capture for those slow browser
     *
     * @param force If true, the call stack is returned even if it is expensive to compute.
     * @param options optional method options
     * @param options.removeStackLevels If set, remove additional N levels from the top of the stack trace.
     * @returns The call stack.
     */
    export function getCurrentCallStack(force?: boolean, options?: {
        removeStackLevels?: number;
    }): string;
    /**
     * Generates a property that is not serializable.
     *
     * @param The string to use as part of the property name.
     * @returns The non-serializable property name.
     */
    export function generateNonSerializableProperty(str: string): string;
    export const getFunctionName: (func: Function) => string;
    export function getObjectConstructorName(obj: Object): string;
    /**
     * Helper function to get the objectDescriptor string.
     * Initial design is to help capture when we try to serialized a object which contains cyclic.
     * But doesn't have enough informaiton for the live site issue to pass on to the right team.
     * The data is intend for event log, thus by default doesn't prinit out the data since value might contains
     * user information and security object.
     * In addition, since the object is already cyclic, it only capture the first level property.
     *
     * You should be wary about the performance. This is equavlent to runtime reflection.
     * In addition, In the deepRecursive Mode, it mark the visisted object as "visited", if the object is been ask the second time to serialized the object again.
     * it will mark it as [potential circular].  The reason is that the object can be cached in legit way in two different property and ko.observable. It will break it out to avoid forever loop.
     * Do not use [potential circular] as detection mechanism, this is mainly for the logging purpose.
     *
     * @param obj the object to get the ObjectDescriptor on
     * @param deepRecursive:recursively get into the object to get the string.
     * @returns string of object representation.
     *   Here is a dump of StackedAreaChart from the sample.
     *   x = ko.dataFor($0).data
     *   getObjectDescriptor(x)
     *   Here is the return string.
     * {
     *  <ViewModel>: {
     *  disabled: <function>observable,
     *  title: <function>observable,
     *  showTitle: <function>observable,
     *  width: <function>observable,
     *  height: <function>observable,
     *  noDataMessage: <string>,
     *  series: <function>observable,
     *  xAxis: <Axis>,
     *  yAxis: <Axis>,
     *  secondaryXAxes: <function>observable,
     *  secondaryYAxes: <function>observable,
     *  views: <function>observable,
     *  legendPosition: <function>observable,
     *  interactionBehavior: <function>observable,
     *  autogenerateSeriesViews: <function>observable,
     *  events: <Events>,
     *  seriesSelections: <function>observable,
     *  seriesHovers: <function>observable,
     *  hoveredID: <function>observable,
     *  enableTrackXSlider: <function>observable,
     *  disableXSliderMouseout: <function>observable,
     *  xSliderCoordinate: <function>observable,
     *  xSliderFilterHoverThreshold: <function>observable
     *  }
     * }
     * In the dev mode, you can pass in the second argument as deepRecursive
     * getObjectDescriptor(x, enableDebugMode /* true* /);
     * {
     *  <ViewModel>: {
     *    disabled: {
     *      <function>observable: <boolean>
     *    },
     *    title: {
     *      <function>observable: <string>
     *    },
     *    showTitle: {
     *      <function>observable: <boolean>
     *    },
     *    width: {
     *      <function>observable: <number>
     *    },
     *    height: {
     *      <function>observable: <number>
     *    },
     *    noDataMessage: <string>,
     *    series: {
     *      <function>observable: <Array[6]>
     *    },
     *    xAxis: {
     *      <Axis>: {
     *        name: {
     *          <function>observable: <string>
     *        },
     *        scale: {
     *          <function>observable: <number>
     *        },
     *        ticks: {
     *          <function>observable: <number>
     *        },
     *        position: {
     *          <function>observable: <number>
     *        },
     *    .... skip...
     * }
     */
    export function getObjectDescriptor(obj: any, deepRecursive?: boolean, includePrivate?: boolean): string;
    export interface ThrowErrorFunction {
        (...formatArguments: any[]): any;
    }
    /**
     * Helper function to return a general error object
     */
    export const createError: (errorMessage: string, extra?: {
        data?: StringMap<any>;
        innerErrors?: Error | Error[];
    }) => FxError;
    type FxError = import("Fx/Errors").FxError;
    /**
     * Returns a map of functions that throw errors with the provided messages.
     */
    export function getErrorMap(obj: Object): Object;
    /**
     * Boilerplate implementation of deferred for native promises.
     * Deferred does not exist in the native promise spec but this is a universially accepted
     * and widely used implementation.
     */
    export interface Deferred<T> {
        promise: Promise<T>;
        resolve(value?: T | Promise<T>): void;
        reject(reason?: any): void;
    }
    export function defer<T>(): Deferred<T>;
    export function fcall<T, TArgs extends any[]>(method: (...args: TArgs) => T | PromiseLike<T>, ...args: TArgs): Promise<T>;
    /**
     * Returns a native promise
     *
     * @param obj Q promise
     * @returns Returns never to force a compile error.  In the portal a Q.Promise is a native Promise and it can be passed or returned directly without conversion to native Promise.
     */
    export function toPromise<T>(obj: Q.Promise<T>): never;
    /**
     * Returns a native promise
     *
     * @param obj Native Promise
     * @returns returns never to force a compile error
     */
    export function toPromise<T>(obj: Promise<T>): never;
    /**
     * Returns a native promise
     *
     * @param obj Q, JQuery or anything that is promise like
     * @returns A native promise that is a proxy of the promise like object
     */
    export function toPromise<T>(obj: PromiseLike<T>): Promise<T>;
    /**
     * Finds the index of the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The first index that matches the predicate.
     */
    export function findIndex<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: ReadonlyArray<T>) => boolean, startIndex?: number): number;
    /**
     * Finds the first element of an array that matches the predicate.
     *
     * @param predicate The Predicate function.
     * @param startIndex The starting index.  If negative, it find from the end of the array.
     *        If you want to continue the next search from the back you can pass in startIndex as (prevReturn - length -1)
     * @returns The first element that matches the predicate.
     */
    export function find<T>(array: ReadonlyArray<T>, predicate?: (value: T, index: number, array: T[]) => boolean, startIndex?: number): T;
    /**
     * Escapes regular expression special characters -[]/{}()*+?.\^$|
     *
     * @param str The string to escape.
     * @returns The escaped string.
     */
    export function regexEscape(str: string): string;
    /**
     * A function that when invoked returns the milliseconds elapsed since startTimer was called.
     */
    export type Timer = Func<number>;
    /**
     * Returns a timer function.
     */
    export function startTimer(): Timer;
    export {};
}

// FILE: FxInternal\Assets.d.ts
declare module "FxInternal/Assets" {
    import { ResourceKindDefinition, ResourceTypeAssetTypeInformation as FxResourceTypeAssetTypeInformation } from "Fx/Assets";
    /**
     * The asset type information interface which represents an asset type's info like icon and display name.
     */
    export interface ResourceTypeAssetTypeInformation extends FxResourceTypeAssetTypeInformation {
        /**
         * These keys are used for performance improvements.
         */
        lowerCaseResourceType: string;
        lowerCaseAssetType: string;
        lowerCaseExtension: string;
        kindMap?: StringMap<ResourceKindDefinition>;
        defaultKind?: string;
    }
    export interface AssetTypeSearchAssetTypeCriteria {
        lowerCaseExtension: string;
        lowerCaseAssetType: string;
    }
    export interface AssetTypeSearchResourceTypeCriteria {
        lowerCaseResourceType: string;
    }
    export type AssetTypeSearchCriteria = AssetTypeSearchResourceTypeCriteria | AssetTypeSearchAssetTypeCriteria;
}

// FILE: FxInternal\AsyncLoaderCore.d.ts
declare module "FxInternal/AsyncLoaderCore" {
    import * as Di from "Fx/DependencyInjectionCore";
    import * as Rpc from "FxInternal/Rpc";
    export function get<TModule extends keyof ModuleMap, TFuncName extends keyof ModuleMap[TModule]>(moduleName: TModule, funcName: TFuncName): Promise<ModuleMap[TModule][TFuncName]>;
    export interface RpcHandlerArgs<T> {
        readonly messageArg: T;
        readonly diContainer: Di.Container;
        readonly messageContext: Rpc.MessageContext;
    }
    export type RpcHandler<T, R> = (arg: RpcHandlerArgs<T>) => R | Promise<R>;
    export function defineHandler<T, R>(definition: Rpc.FuncEndPointDefinition<T, R>, rpcHandler: RpcHandler<T, R>): RpcHandler<T, R>;
    export type RpcRegistrationMap = {
        [TModuleName in keyof ModuleMap]?: {
            [TExportName in keyof ModuleMap[TModuleName]]?: (diContainer: Di.Container, rpcClient: Rpc.Client, moduleName: TModuleName, exportName: TExportName) => ModuleMap[TModuleName][TExportName];
        };
    };
    export function registerRpc(diContainer: Di.Container, registrationMap: RpcRegistrationMap, rpcClient?: Rpc.Client): void;
    export function makeRegistration<T, R>(definition: Rpc.FuncEndPointDefinition<T, R>, allowedOrigin?: string | string[]): <TModuleName extends keyof ModuleMap, TExportName extends keyof ModuleMap[TModuleName]>(diContainer: Di.Container, rpcClient: Rpc.Client, moduleName: TModuleName, exportName: TExportName) => RpcHandler<T, R>;
}

// FILE: FxInternal\Diagnostics.d.ts
declare module "FxInternal/Diagnostics" {
    import { LogEntryLevel, LogMessage } from "Fx/Diagnostics";
    export function setObjectIdToScrub(objectId: string): void;
    /**
     * This is still internal until we validate it's good to expose more broadly
     * Function that transforms the results as it serialized the data object. This is passed as the replacer parameter to JSON.stringify
     * when serializing the data property, so it must conform to the JSON.stringify replacer rules.
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify#the_replacer_parameter
     */
    export function serializationPrivacyReplacer(key: string, value: any): any;
    /**
     * This is still internal until we validate it's good to expose more broadly
     * Sanitizes the text aggresively, which might mean that if certain patterns are found, the whole string might be replaced.
     * This is used mainly on JSON-encoded strings
     *
     * @param text The string to sanitize
     * @returns The original string with the PII data scrcubbed.
     */
    export function sanitizeMessageFull(text: string): string;
    /**
     * Sanitizes the text, making sure that not to break the JSON encoding of the text.
     * Note that the telemetry infrastructure already automatically uses a version of the sanitization logic that catches these
     * and a few more ocurrences than this utility function.
     *
     * @param text The string to sanitize
     * @returns The original string with the PII data scrcubbed.
     */
    export function sanitizeMessage(text: string): string;
    /**
     * Sanitizes a URI component.
     *
     * @param text The URI component.
     * @returns The sanitized URI component.
     */
    export function sanitizeUriComponent(text: string): string;
    /**
     * Schema of a log entry.
     */
    export interface LogEntry {
        /**
         * Timestamp
         */
        readonly timestamp: number;
        /**
         * Level
         */
        readonly level: LogEntryLevel;
        /**
         * Portal, etc
         */
        readonly area: string;
        /**
         * The message to be logged.
         */
        readonly message: string;
        /**
         * The message code.
         */
        readonly code: number;
        /**
         * Any additional data to be logged.
         */
        readonly args?: ReadonlyArray<any>;
    }
    export interface LogBufferFullCallback {
        (entries: LogEntry[]): LogEntry[];
    }
    export interface WriteEntryHelperFunc {
        (level: LogEntryLevel, area: string, entryType: string, message: LogMessage, code: number, restArgs: any[]): void;
    }
    export const logFunctions: NumberMap<ConsoleLogFunction>;
    interface ConsoleLogFunction {
        (entry: LogEntry): void;
    }
    interface LogHelper {
        empty: () => void;
        flush: () => void;
        entries: (entry: LogEntryLevel) => LogEntry[];
        log: (entry: LogEntry) => void;
        pushLog: (entry: LogEntry) => void;
        init: (remoteLevel: LogEntryLevel) => void;
        setCallback: (callback?: LogBufferFullCallback) => void;
    }
    export const logHelper: LogHelper;
    /**
     * For tests only.
     */
    export interface TestParameters {
        maxBufferSize: number;
        verboseDiagnostics: boolean;
    }
    export var _testParameters: (parameters?: TestParameters) => TestParameters;
    /**
     * Options for getAllPropertyNames
     */
    interface GetAllPropertyNamesOptions {
        /**
         * Excludes properties that are prefixed or suffixed with '__'.
         */
        excludePrivate?: boolean;
        /**
         * Excludes properties that are functions.
         */
        excludeFunction?: boolean;
        /**
         * Excludes the '__proto__' property. Subset of excludePrivate option.
         */
        excludeProto?: boolean;
    }
    /**
     * Gets all of the property names for an object including all inherited and non-enumerable properties.
     *
     * @param obj The object
     * @param options The options to include or exclude certain property names.
     *              excludePrivate excludes properties that are prefixed or suffixed with '__'. Defaults to false.
     *              excludeFunction excludes properties that are functions. Defaults to false.
     *              excludeProto excludes the '__proto__' property. Subset of excludePrivate option. Defaults to true.
     * @returns A set containing the names of all properties.
     */
    export function getAllPropertyNames(obj: any, options?: GetAllPropertyNamesOptions): Set<string>;
    /**
     * Clones object and replaces cyclic references.
     * If obj is null, undefined, a Date, or not an object it is returned as-is.
     *
     * @param obj object to decycle
     * @returns decycled object
     */
    export function decycle(obj: any): any;
    export {};
}

// FILE: FxInternal\EnvironmentInit.d.ts
declare namespace FxImpl {
    /**
     * Establishes environment values utilized by FX AMD modules as they're required.
     * Must be called before require.config and before any initial module-loading.
     *
     * @param env The environment values.
     */
    function setFxCoreNonAmdEnvironment(env: {
        trace: TraceConfig;
        features: FxImpl.Features;
        environment: FxEnvironment;
    }): void;
}

// FILE: FxInternal\ErrorHandling.d.ts
declare module "FxInternal/ErrorHandling" {
    import { Log } from "Fx/Diagnostics";
    import { Features } from "FxInternal/Features";
    type LogErrorType = Log["error"];
    /**
     * Initializes the error handler
     *
     * @param postLogCallback Function to run after error is logged.
     * @param resetCounter Boolean to reset the special message counter..
     */
    export function initialize(postLogCallback?: () => void, forTest?: boolean, additionalInfoCallback?: () => any): void;
    /**
     * Logs the error
     */
    export function handleError(evt: ErrorEvent, lastError?: Error): void;
    /**
     * Get the HTTP status code and message for a given url.
     *
     * @param url
     * @param callback
     */
    export function getStatusCode(url: string, callback: (statusCode: number, message: any, statusText?: string) => any): void;
    /**
     * Called when FX scripts are initially loaded.
     *
     * @param features Features
     * @param bootstrapErrorLogger An error-logger used until 'initialize' is called (after web worker or IFrame boostrap is complete).
     */
    export function preinitialize(features: Features, bootstrapErrorLogger?: LogErrorType): void;
    export {};
}

// FILE: FxInternal\ErrorSerialization.d.ts
declare module "FxInternal/ErrorSerialization" {
    /**
     * Extracted error details schema
     */
    export interface ErrorDetails {
        /**
         * Version of @type {ErrorDetails} schema applied
         */
        schemaVersion: number;
        /**
         * The error extraction method used based on the determined error type.
         */
        extractionType: ErrorExtractionType;
        /**
         * A decription of the error if one is available or has been set.
         */
        message?: string;
        /**
         * An unlocalized error identifier which represents the type of error if one is available or has been set.
         */
        name?: string;
        /**
         * The @type {ErrorDetails} representation of the inner error that caused this error if one is available or has been set.
         */
        innerError?: ErrorDetails;
        /**
         * The stack property of @type {Error} that provides a trace of which functions were called if available.
         */
        stack?: string;
        /**
         * Information associated with the error that can be proxied if available.
         */
        data?: any;
        /**
         * The HTTP status code for errors relating to network calls if one is available.
         */
        httpStatusCode?: number;
        /**
         * The provided logging blade's telemetry context.
         */
        blade?: BladeContext;
    }
    /**
     * Blade telemetry context
     */
    export interface BladeContext {
        /**
         * User defined blade identifier to correlate logical activities through async and component boundaries.
         */
        id: string;
        /**
         * Unique blade instance identifier
         */
        instanceId: string;
    }
    /**
     * Extraction method which was identified and used on an error.
     */
    export const enum ErrorExtractionType {
        ExtractionException = "ExtractionException",
        Unhandled = "Unhandled",
        GenericError = "GenericError",
        GenericErrorWithStack = "GenericErrorWithStack",
        FailedModuleError = "FailedModuleError",
        FxError = "FxError",
        FxErrorWithInnerErrors = "FxErrorWithInnerErrors",
        FxErrorWithJqXhr = "FxErrorWithJqXhr",
        FxErrorWithErrorThrown = "FxErrorWithErrorThrown",
        XMLHttpRequestLike = "XMLHttpRequestLike",
        ArmErrorResponse = "ArmErrorResponse",
        FxErrorWithArmErrorResponse = "FxErrorWithArmErrorResponse",
        FxErrorWithErrorData = "FxErrorWithErrorData"
    }
    /**
     * Extracts a provided error's details into the @type {ErrorDetails} schema.
     *
     * @param error an error to extract details from.
     * @param blade The BladeInstance for the context of the error.
     * @returns @type {ErrorDetails} representation from details of the error.
     */
    export function extractErrorDetails(error: any, bladeContext?: BladeContext): ErrorDetails;
    export interface XMLHttpRequestLike {
        readyState?: number;
        status: number;
        statusText: string;
        responseText?: string;
        uri?: string;
    }
    export interface ArmErrorResponse {
        code?: string;
        message?: string;
        error?: ArmErrorResponse;
        innererror?: ArmErrorResponse;
    }
    export function isError(error: any): error is Error;
    export function isXMLHttpRequestLike(jqXHR: any): jqXHR is XMLHttpRequestLike;
    export function isArmErrorResponse(error: any): error is ArmErrorResponse;
}

// FILE: FxInternal\Errors.d.ts
declare module "FxInternal/Errors" {
    import { ErrorOptions, FxError } from "Fx/Errors";
    /**
     * Represents and cancelation error.
     */
    export class FxCanceledError extends FxError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a CanceledError.
         * Thrown to cancel operations.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
    }
    /**
     * common DisposedCanceledError that share with all dispose pattern.
     */
    export class FxDisposedCanceledError extends FxCanceledError {
        /**
         * The unique type name of this error.
         */
        static TypeName: string;
        /**
         * Constructs a DisposedCanceledError.
         * Thrown to cancel operations upon dispose.
         *
         * @param message The error message.
         */
        constructor(message?: string);
        /**
         * Constructs a DisposedCanceledError.
         * Thrown to cancel operations upon dispose.
         *
         * @param options The error options.
         */
        constructor(options?: ErrorOptions);
    }
}

// FILE: FxInternal\Experimentation.d.ts
declare module "FxInternal/Experimentation" {
    import { Experimentation, VariantAssignments, ExtensionFlights } from "Fx/Experimentation";
    export const enum Constants {
        DefaultExtensionWaitTimeout = 300,
        DefaultShellWaitTimeout = 10000
    }
    export const enum StringConstants {
        ExperimentationFeature = "experimentation",
        FlightsFeature = "experimentationflights"
    }
    /**
     * The variant assignment options as is sent from the Portal server to the client, and then shared between iframes/workers.
     */
    export interface VariantAssignmentsOptions {
        /** The list of flight/experiment names. */
        readonly flights: ReadonlyArray<string>;
        /** The opaque assignment context string used for scorecard generation. */
        readonly assignmentContext: string;
        /** The normalized tratment variable (aka feature gate) map with their corresponding values. */
        readonly variables: ReadonlyStringMap<string | number | boolean>;
    }
    /**
     * A telemetry event to be sent to the server.
     */
    interface TelemetryEvent {
        /**
         * The source of the telemetry data e.g. navigation, blade.
         */
        source: string;
        /**
         * The action being recorded.
         */
        action: string;
        /**
         * A modifier for the action.
         */
        actionModifier?: string;
        /**
         * The elapsed time in milliseconds for the event being recorded (optional).
         */
        duration?: number;
        /**
         * A name associated with the event or item that was the target of the event (optional).
         */
        readonly name?: string;
        /**
         * Any additional information for the event being recorded (optional).
         */
        data?: any;
    }
    interface ExperimentationProviderOptions {
        trace: (entry: TelemetryEvent) => void;
        waitTimeout: number;
        traceFirstAccess?: boolean;
    }
    /**
     * Implements VariantAssignments. Only exported for exposing experimentation to reactviews.
     */
    export class ExperimentationProvider implements VariantAssignments {
        isAvailable: boolean;
        data: VariantAssignmentsOptions;
        constructor(options: ExperimentationProviderOptions);
        whenAvailable(timeoutInMilliseconds?: number): Promise<VariantAssignments>;
        hasFlight(flightName: string): boolean;
        getStringValue(variableName: string, namespace?: string): string;
        getNumberValue(variableName: string, namespace?: string): number;
        getBooleanValue(variableName: string, namespace?: string): boolean;
        /**
         * Internal. This should not be called by any code other than ExperimentationProvider class (or test stubs).
         *
         * @param data The normalized assignment options
         */
        __setAssignments(data: VariantAssignmentsOptions): void;
    }
    export const enum FrameContext {
        Extension = 0,
        Shell = 1,
        ShellWorker = 2
    }
    export interface ExperimentationManagerOptions {
        shellVariants: Promise<VariantAssignmentsOptions> | VariantAssignmentsOptions;
        features: FxImpl.Features;
        trace: (entry: TelemetryEvent) => void;
        onVariantsAssigned?: (variants: VariantAssignmentsOptions) => void;
        frameContext?: FrameContext;
    }
    /**
     * Accesses the experimentation features that use ExP
     */
    export class ExperimentationManager implements Experimentation {
        private readonly _queryStringFlights;
        private readonly _queryStringVariables;
        private readonly _trace;
        private readonly _mergedVariants;
        private _mergedVariantsWhenAvailable;
        private _onVariantsAssigned;
        constructor(options: ExperimentationManagerOptions);
        getExtensionFlights(): Promise<ExtensionFlights>;
        getAssignments(): Promise<VariantAssignments>;
        readonly shellAssignments: ExperimentationProvider;
        readonly extensionAssignments: ExperimentationProvider;
        /**
         * Sets the Variant Assignments to use for this extension.
         *
         * @param value the variant assignment values from the network call.
         * @param timeout Specifies that this is called after the client timed-out waiting for the variants to be returned
         * @returns the actual Variant Assignment values used for this session. This is because once an extension is initialized,
         * then even if it gets re-initialized in the future, the assignments must be identical, honoring whether there was a client
         * timeout for example.
         */
        setExtensionFlights(value: VariantAssignmentsOptions): VariantAssignmentsOptions;
        private _normalizeAssignments;
    }
    export {};
}

// FILE: FxInternal\Features.d.ts
declare module "FxInternal/Features" {
    export type QueryObject = FxImpl.QueryObject;
    export type ShellFeatures = FxImpl.ShellFeatures;
    export import Features = FxImpl.Features;
}

// FILE: FxInternal\FeaturesNonAmd.d.ts
declare module FxImpl {
    interface QueryObject {
        readonly clientoptimizations?: string;
        readonly l?: string;
        readonly sessionid?: string;
        readonly [key: string]: string;
    }
    interface ShellFeatures {
        readonly flights: ReadonlyStringMap<boolean>;
        readonly fromConfig: ReadonlyStringMap<string | boolean>;
        readonly fromQuery: QueryObject;
    }
    class Features {
        readonly value: FeatureConfig;
        readonly shellFeatures: ShellFeatures;
        readonly isEnabled: (feature: string, defaultValue?: boolean) => boolean;
        readonly getValue: (feature: string) => string;
        readonly isNativePerf: boolean;
        constructor(shellFeatures?: ShellFeatures, extensionName?: string, extensionFeatures?: ReadonlyArray<ReadonlyStringMap<string | boolean>>);
    }
}

// FILE: FxInternal\Lifetime.d.ts
declare module "FxInternal/Lifetime" {
    import { ActionOrDisposable, Disposable, DisposableLifetimeManager } from "Fx/Lifetime";
    /**
     * The options passed to the TriggerableLifetimeManager constructor
     */
    export interface TriggerableLifetimeManagerOptions {
        /**
         * The depth of the parent lifetime Managers.
         * For example the lifetime returned from ltm.createChildLifetime().createChildLifetime() would have a depth of 2.
         * This value is tracked to catch bugs were partners may accidently call createChildLifetime() recursively resulting in out of memory errors.
         */
        readonly depth?: number;
        /**
         * The parent lifetime Manager.
         * This value is passed from createChildLifetime().
         */
        readonly parent?: TriggerableLifetimeManager;
    }
    /**
     * An object that tracks and invokes disposal callbacks. This can be used
     * in other classes that wish to implement LifetimeManager.
     */
    export class TriggerableLifetimeManager implements DisposableLifetimeManager {
        /**
         * Gets a value indicating whether or not the lifetime is disposed.
         */
        isDisposed: () => boolean;
        registerForDispose: (disposable: ActionOrDisposable | ReadonlyArray<ActionOrDisposable>) => this;
        createChildLifetime: () => DisposableLifetimeManager;
        _unregisterChildForDispose: (disposable: Disposable) => void;
        /**
         * These properties are only for diagnostics and are only assigned values in dev mode.
         */
        private _createStack;
        private _disposeStack;
        private _dispose;
        constructor(options?: TriggerableLifetimeManagerOptions);
        /**
         * Causes the instance to regard itself as disposed, and to trigger any
         * callbacks that were already registered.
         */
        dispose(): void;
    }
}

// FILE: FxInternal\ResourceManagement\GlobalResourceFiltersCore.d.ts
declare module "FxInternal/ResourceManagement/GlobalResourceFiltersCore" {
    import { FuncEndPointDefinition } from "FxInternal/Rpc";
    import { Filter } from "Fx/ResourceManagement/GlobalResourceFilters";
    /**
     * RPC endpoint used by FX to get the currently-active global resource filter from the Shell worker.
     */
    export const getActiveGlobalResourceFilterEndPoint: FuncEndPointDefinition<void, Filter>;
}

// FILE: FxInternal\ResourceManagement\LocationsCore.d.ts
declare module "FxInternal/ResourceManagement/LocationsCore" {
    import { FuncEndPointDefinition } from "FxInternal/Rpc";
    /**
     * Internal RPC endpoint to get the display names for locations.
     */
    export const getLocationDisplayNamesEndPoint: FuncEndPointDefinition<void, StringMap<string>>;
}

// FILE: FxInternal\ResourceManagement\SubscriptionsCore.d.ts
declare module "FxInternal/ResourceManagement/SubscriptionsCore" {
    import { FuncEndPointDefinition } from "FxInternal/Rpc";
    import { Subscription } from "Fx/ResourceManagement/Subscriptions";
    /**
     * RPC endpoint used by FX to get in-session selected subscriptions from Shell worker.
     */
    export const getInSessionSelectedSubscriptionsEndPoint: FuncEndPointDefinition<void, readonly Subscription[]>;
    /**
     * Internal RPC endpoint to get the detailed info for a subscription.
     */
    export const getSubscriptionInfoEndPoint: FuncEndPointDefinition<string, Subscription>;
}

// FILE: FxInternal\Rpc.d.ts
declare module "FxInternal/Rpc" {
    import { Log, LogEntryLevel, Logging as FxLogging } from "Fx/Diagnostics";
    import { Disposable, LifetimeManager } from "Fx/Lifetime";
    import { TriggerableLifetimeManager } from "FxInternal/Lifetime";
    import * as Errors from "Fx/Errors";
    import { Features } from "FxInternal/Features";
    import * as TelemetryContextInternal from "FxInternal/TelemetryContext";
    export const enum Constants {
        RegistrationTimeoutInMs = 30000,
        RpcCallTimeoutInMs = 300000,
        WindowUnloadTimeoutInMs = 240000
    }
    export const enum RoutedMessageKind {
        TransferPort = 0,
        Reset = 1,
        Shutdown = 2,
        Exception = 3,
        Log = 4,
        RefCount = 5,
        StatelessRpcInvoke = 6,
        StatelessRpcReturn = 7,
        StatelessRpcError = 8,
        PoAcquireObjectRequest = 9,
        PoAcquireObjectResponseError = 10,
        PoConnectionEvent = 11,
        _ = 12
    }
    export interface MessageContext {
        readonly callStack: string;
        readonly srcWindowId: string;
        readonly destWindowId: string;
    }
    export interface HandlerContext<TPort> extends MessageContext {
        readonly srcInstanceIndex: number;
        readonly ltm: LifetimeManager;
        readonly port: TPort;
    }
    export interface MultiplexedMessage<TKind> {
        readonly kind: TKind;
        readonly data: any;
    }
    export interface RoutedMessage extends MessageContext {
        readonly srcInstanceIndex: number;
        readonly data: MultiplexedMessage<RoutedMessageKind>;
    }
    export interface MessagePortLike<T> {
        postMessage(message: T, transferList?: MessagePort[]): void;
        onmessage: (evt: MessageEvent<T>) => void;
        close(): void;
    }
    export function getMessageContext(): MessageContext;
    export function createCallStack(stack: string, context?: MessageContext, endPointName?: string): string;
    /**
     * Helper function to create serializable represention of Error.
     * It's call stack will contain special RPC prefix for unhandled promise to always log as error.
     *
     * @param error Error returned from the server
     * @returns Error object
     */
    export function createRpcError(error: Errors.FxError): RpcError;
    export function getCurrentCallStack(force?: boolean): string;
    export class DisposableValue<T> {
        readonly value: T;
        private _disposeCallbacks;
        private _disposeReason;
        constructor(value: T);
        getValue(): T;
        dispose(reason?: string): void;
        onDispose(callback: Action1<string>): void;
    }
    export class DisposableValueDictionary<TKey, T extends DisposableValue<any>> implements Disposable {
        private readonly _countChangesCallback?;
        private readonly _map;
        constructor(_countChangesCallback?: (key: TKey, isAdd: boolean) => void);
        getValue(key: TKey): T;
        setValue(key: TKey, value: T): T;
        getValues(): T[];
        dispose(): void;
        disposeValues(keys: ReadonlyArray<TKey>): void;
    }
    export class RpcChannel<T> extends DisposableValue<MessagePortLike<T>> {
        readonly onMessage: (onmessage: (evt: MessageEvent<T>) => void) => void;
        readonly postMessage: (message: T, transferList?: MessagePort[]) => void;
        constructor(portOrPromise: MessagePortLike<T> | Promise<MessagePortLike<T>>);
    }
    export type FuncEndPointHandler<T, R, TConnection> = (arg: T, handlerContext: HandlerContext<TConnection>, ltm: LifetimeManager) => PromiseLike<R> | R;
    export type AllowedOrigins = string | string[];
    export interface EndPointRegistrationOptions<T, R, TConnection> {
        /**
         * A list of extension names that can be allowed to invoke this RPC callback. If a falsey value is specific, then all extensions are allowed to invoke this callback.
         */
        readonly allowedOrigin: AllowedOrigins;
        /**
         * The callback function of the RPC callback.
         */
        readonly handler: FuncEndPointHandler<T, R, TConnection>;
    }
    export type LoadChannelFunction = (windowId: string, instanceIndex: number) => RpcChannel<any>;
    export class MessageDispatcher<T, TContext> {
        private readonly _handler;
        private readonly _outerList;
        private readonly _sourceList;
        private _outerListIndex;
        private _innerListIndex;
        constructor(_handler: Action2<T, TContext>);
        private _processInnerList;
        private _processOuterList;
        addItem(item: ReadonlyArray<T>, source: TContext): void;
        isEmpty(): boolean;
    }
    export interface Sender<TData, TDestination> {
        (data: TData, destination: TDestination): void;
    }
    interface MessageRelay<TKind extends number, TContext, TDestination> {
        registerHandler<TData>(kind: TKind, handler: Action2<TData, TContext>): Sender<TData, TDestination>;
    }
    export class MessageMultiplexer<TKind extends number, TContext, TDestination> implements MessageRelay<TKind, TContext, TDestination> {
        private readonly _listener;
        private readonly _handlerMap;
        constructor(_listener: Sender<MultiplexedMessage<TKind>, TDestination>, totalEntries: TKind);
        handleMessage(message: MultiplexedMessage<TKind>, context: TContext): void;
        registerHandler<TData>(kind: TKind, handler: Action2<TData, TContext>): Sender<TData, TDestination>;
    }
    export const enum RefCountKind {
        AcquireWindow = 0,
        OutstandingPoObjects = 1,
        PendingPoObjectRequests = 2,
        Rpc = 3
    }
    export interface RefCount {
        readonly totalCount: number;
        subscribe(cb: (val: number) => void): void;
    }
    interface RefCounter {
        setRefCount(associatedDestination: string, referenceId: number, kind: RefCountKind, isAdd: boolean): void;
    }
    export interface LogMessage {
        readonly level: LogEntryLevel;
        readonly code: number;
        readonly area: string;
        readonly message: string | Error;
    }
    export interface RoutedMessageClientContext extends RefCounter {
        log(message: LogMessage, destination: string): void;
        raiseRemoteException(error: Errors.FxError, destination: string): void;
        readonly routedMessageRelay: MessageRelay<RoutedMessageKind, RoutedMessage, string>;
        readonly localWindowId: string;
    }
    export interface ResetMessage extends RpcErrorMessage {
        readonly instanceIndex: number;
        readonly windowId: string;
        readonly referenceIds: NumberMap<ReadonlyArray<number>>;
    }
    export interface RoutedMessageClient {
        reset(message: ResetMessage): void;
    }
    type Logging = Omit<FxLogging, "createLog"> & {
        createLog: (area: string) => Log;
    };
    class RoutedMessageDispatcher implements RoutedMessageClientContext {
        private readonly _instanceIndex;
        readonly localWindowId: string;
        private readonly _reportError;
        private readonly _log;
        private readonly _logging;
        private readonly _handleMessage;
        private readonly _messageDispatcher;
        private readonly _routedMessageClients;
        private readonly _shellRefCounter;
        private readonly _baseDispatcher;
        readonly routedMessageRelay: MessageMultiplexer<RoutedMessageKind, RoutedMessage, string>;
        private readonly _sendRefCount;
        readonly log: Sender<LogMessage, string>;
        readonly raiseRemoteException: Sender<Errors.FxError, string>;
        constructor(_instanceIndex: number, localWindowId: string, loadChannelFunction: LoadChannelFunction, shellChannel: RpcChannel<ReadonlyArray<RoutedMessage>>, _reportError: ErrorReporter, _log: Log, _logging: Logging);
        getTotalRefCounts(targetId: string): RefCount;
        terminateWindow(windowId: string, reason: string): void;
        createClient<T extends RoutedMessageClient, U>(factory: new (context: RoutedMessageClientContext, endPoints: U, log: Log, features: Features, record: (invocation: InvocationTelemetry) => void) => T, arg: U, log: Log, features: Features, record: (invocation: InvocationTelemetry) => void): T;
        setRefCount(targetWindowId: string, referenceId: number, kind: RefCountKind, isAdd: boolean): void;
        dispose(): void;
    }
    export class EndPointTable<TConnection extends Disposable, TOptions extends EndPointRegistrationOptions<any, any, TConnection>> {
        private readonly _registrationTimeoutInMs;
        private readonly _reportError;
        private readonly _log;
        private readonly _endPoints;
        private readonly _endPointDeferred;
        constructor(_registrationTimeoutInMs: number, _reportError: ErrorReporter, _log: Log);
        registerEndPoint(name: string, options: TOptions): void;
        invokeEndPoint(name: string, arg: any, routedMessage: RoutedMessage, onInvocation: (ltm: TriggerableLifetimeManager, endPointOptions: TOptions) => TConnection, onSuccess: (value: any, connection: TConnection) => void, onFailure: (error: Errors.FxError) => void): void;
    }
    interface TrackedObjectMetadata {
        readonly creationCallStack: string;
        readonly telemetryContext: TelemetryContextInternal.State;
    }
    /**
     * Represention of a Errors.FxError which can be safely serialize and restored
     */
    interface RpcError {
        readonly message: string;
        stack: string;
        readonly data: any;
        readonly errorLevel: Errors.ErrorLevel;
    }
    interface RpcErrorMessage {
        readonly error: RpcError;
    }
    export interface RpcRejectMessage extends RpcErrorMessage {
        readonly connectionId: number;
    }
    export class PendingObjectTable<T> {
        private readonly _destination;
        private readonly _refCounter;
        private readonly _kind;
        private readonly _trackPerformance;
        private readonly _log;
        private readonly _recorder?;
        private readonly _pendingRpcCall;
        private _connectionId;
        constructor(_destination: string, _refCounter: RefCounter, _kind: RefCountKind, _trackPerformance: boolean, _log: Log, _recorder?: (invocation: InvocationTelemetry) => void);
        private _setRefCount;
        getMetadata(id: number): TrackedObjectMetadata;
        create(endPointName: string, onCreate: (pendingObjectId: number) => void, telemetryContext: TelemetryContextInternal.State): Promise<T>;
        resolve(connectionId: number, successValue: T, handlerDuration?: number): void;
        reject(connectionId: number, message: RpcErrorMessage): void;
        handleResetMessage(resetMessage: ResetMessage): void;
        dispose(): void;
        /**
         * Returns an array of pending RPC function invocations.
         *
         * @returns An array of pending RPC function invocations.
         */
        getPendingInvokes(): ReadonlyArray<{
            name: string;
            promise: Promise<unknown>;
        }>;
    }
    export interface StartOptions {
        readonly instanceIndex: number;
        readonly loadChannelFunction: LoadChannelFunction;
        readonly originId: string;
        readonly shellChannel: RpcChannel<ReadonlyArray<RoutedMessage>>;
        readonly windowRedirectMap: ReadonlyStringMap<string>;
    }
    type ErrorReporter = (error: Error) => void;
    /**
     * Telemetry data covering an RPC invocation.
     */
    export interface InvocationTelemetry {
        /**
         * The endpoint name.
         */
        name: string;
        /**
         * The duration of the async invocation.
         */
        callerDuration: number;
        /**
         * The duration of the RPC handler.
         */
        handlerDuration: number;
    }
    export class Client {
        protected readonly _registrationTimeoutInMs: number;
        protected readonly _reportError: ErrorReporter;
        private readonly _logging;
        protected readonly _features: Features;
        protected _dispatcher: RoutedMessageDispatcher;
        private _rpcEndPoints;
        private _rpcClient;
        private _windowAcquirer;
        private _disposed;
        protected _windowRedirectMap: ReadonlyStringMap<string>;
        protected readonly _log: Log;
        protected readonly _recorder: (invocation: InvocationTelemetry) => void;
        private readonly _trackInvocation;
        /**
         * Starts recording RPC invocations, with the purpose of adding this to Blade-opening telemetry.
         *
         * @returns A function that stops recording and returns accumulated telemetry data.
         */
        readonly record: () => () => ReadonlyArray<InvocationTelemetry>;
        /**
         * A count of pending RPC invocations.
         */
        readonly pendingInvocationCount: RefCount;
        constructor(_registrationTimeoutInMs: number, _reportError: ErrorReporter, _logging: Logging, _features: Features);
        /**
         * Registers an RPC callback
         */
        registerRpcEndPoint<T, R>(name: string, options: EndPointRegistrationOptions<T, R, unknown>): void;
        log(destination: string, data: LogMessage): void;
        /**
         * Invokes an RPC callback that does return a value.
         *
         * @param name A string that uniquely identifies the object type.
         * @param destination The extension of where the object is to be acquired.
         * @param arg Arguments passed to the object factory handler.
         */
        invokeRpc<R>(name: string, destination: string, arg: any, telemetryContext?: TelemetryContextInternal.State): Promise<R>;
        getTotalRefCountTo(windowId: string): RefCount;
        detachPort(windowId: string, portId: number): MessagePort;
        /**
         * Acquires window
         *
         * @param windowId The window id.
         * @param durationInSeconds The duration until the worker is disposed. The worker will never be disposed if the value is negative.
         * @param port The MessagePort used to communicate with the worker.
         */
        acquireWindow(windowId: string, durationInSeconds?: number, port?: MessagePort): DisposableValue<number>;
        terminateWindow(windowId: string, reason: string): void;
        start(options: StartOptions): void;
        reset(): void;
        dispose(): void;
        /**
         * Returns an array of pending RPC function invocations.
         *
         * @returns An array of pending RPC function invocations.
         */
        getPendingInvokes(): ReadonlyArray<{
            name: string;
            promise: Promise<unknown>;
        }>;
        protected _assertReady(): void;
    }
    export class EndPointDefinition {
        readonly name: string;
        constructor(name: string);
    }
    export class ActionEndPointDefinitionBase<T> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: FuncEndPointHandler<T, void, unknown>): void;
    }
    export class ActionEndPointDefinition<T> extends ActionEndPointDefinitionBase<T> {
        invoke(client: Client, destination: string, arg: T): Promise<void>;
    }
    export class FuncEndPointDefinitionBase<T, R> extends EndPointDefinition {
        register(client: Client, allowedOrigin: AllowedOrigins, handler: FuncEndPointHandler<T, R, unknown>): void;
    }
    export class FuncEndPointDefinition<T, R> extends FuncEndPointDefinitionBase<T, R> {
        invoke(client: Client, destination: string, arg: T): Promise<R>;
    }
    export {};
}

// FILE: FxInternal\RpcEndPointsCore.d.ts
declare module "FxInternal/RpcEndPointsCore" {
    import { FuncEndPointDefinition } from "FxInternal/Rpc";
    import { UserInfo } from "Fx/Security";
    import type { VariantAssignmentsOptions } from "FxInternal/Experimentation";
    export const setExtensionFlightsEndPoint: FuncEndPointDefinition<VariantAssignmentsOptions, VariantAssignmentsOptions>;
    export const getUserInfoEndPoint: FuncEndPointDefinition<any, UserInfo>;
    /**
     * Internal RPC endpoint to write persistent setting.
     */
    export const writeSettingEndPoint: FuncEndPointDefinition<{
        key: string;
        value: string;
        readers: string[] | "*";
    }, void>;
    /**
     * Internal RPC endpoint to receive previously stored values.
     */
    export const readSettingsEndPoint: FuncEndPointDefinition<{
        extensionName: string;
        keys: string[];
    }, Record<string, string>>;
    /**
     * Internal RPC endpoint to clear all stored keys and values.
     */
    export const removeSettingsEndPoint: FuncEndPointDefinition<{
        keys: string[];
    }, void>;
    /**
     * Internal RPC endpoint to clear all stored keys and values, resetting the storage.
     */
    export const clearEndPoint: FuncEndPointDefinition<{}, void>;
    /**
     * Internal RPC endpoint to return all 'key' identifiers stored.
     */
    export const getAllKeysEndPoint: FuncEndPointDefinition<{}, readonly string[]>;
}

// FILE: FxInternal\TelemetryContext.d.ts
declare module "FxInternal/TelemetryContext" {
    export interface State {
    }
}

// FILE: FxInternal\Units.d.ts
declare module "FxInternal/Units" {
    export const higherByteOffset = 8;
    export const perTimeBit: number;
    export enum UnitType {
        None = 0,
        Bytes = 1,
        Decimal = 2,
        Time = 3,
        BytesPerTime = 4,
        DecimalPerTime = 5,
        Bytes_SI = 6,
        BytesPerTime_SI = 7
    }
}

// FILE: FxInternal\UpdateRequireConfig.d.ts
declare namespace FxImpl {
    /**
     * Adds error logging to the require config.
     *
     * @param requireConfig The require config.
     * @param log The log.
     */
    function addLoggingToRequireConfig(requireConfig: RequireConfig, log: import("Fx/Diagnostics").Log): void;
    /**
     * Shapes the supplied requireJS config.
     *
     * @param requireConfig The requireJS config.
     * @param features Features consulted to control how the config is shaped.
     * @param isExtensionRequireConfig Indicates that this is the require config covering extension-authored modules.
     * @returns The shaped requireJS config.
     */
    function reshapeRequireConfigCore(requireConfig: RequireConfig, features: FxImpl.Features, isExtensionRequireConfig?: true): RequireConfig;
    /**
     * Options used to translate a URI into an absolute URI.
     */
    interface ToAbsoluteUriOptions {
        /**
         * An origin used to translate the URI to an absolution URI.
         */
        origin: string;
        /**
         * An application path used to translate the URI to an absolution URI.
         */
        appPath: string;
        /**
         * The protocol used to translate the URI to an absolution URI.
         */
        protocol: string;
    }
    /**
     * Updates the supplied requireJS config so it contains absolute URIs.
     *
     * @param resultConfig The requireJS config.
     * @param options Options used to make the config's contained URIs absolute.
     */
    function toAbsoluteUrisRequireCore(resultConfig: RequireConfig, options: ToAbsoluteUriOptions & {
        baseDomains?: string[];
    }): void;
    /**
     * Translates the supplied URI into an absolute URI.
     *
     * @param uri The URI
     * @param options Options used to translate the URI to an absolute URI.
     * @returns The absolute URI.
     */
    function ensureAbsoluteUriCore(uri: string, options: ToAbsoluteUriOptions & {
        replacementOrigin?: string;
    }): string;
}

// FILE: FxInternal\WeaveBlade.d.ts
declare namespace FxImpl {
    const enum WeaveBladeFlags {
        UsesPrewarmerScript = 1
    }
}
// diff:ignore:true
declare namespace MsPortalFx {
/**
* The version of the portal framework that extension TypeScript compiles against.
*/
export const enum Version {
/**
* The version of the portal framework that extension TypeScript compiles against.
*/
current = '12.3.0.1'
}
}
// diff:ignore:false